<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="在体系结构中，我们知道：链路层（或数据链路层）包含为共享相同介质的邻居建立连接的协议和方法。该层是在广域网（WAN）中的相邻网络节点之间或同一局域网（LAN）网段上的节点之间传输数据的协议层，除此之外，提供检测物理层中可能发生的错误的手段，但不一定会去尝试纠正。同时，设计链路层的目的是为 IP 模块发送和接受 IP 数据报，链路层可用于携带支持 IP 的辅助性协议，例如 ARP。   The li">
<meta property="og:type" content="article">
<meta property="og:title" content="《TCP&#x2F;IP 详解 卷1：协议》第 3 章：链路层">
<meta property="og:url" content="https://zcplayground.github.io/2017/11/01/tcpip3-Link-Layer/index.html">
<meta property="og:site_name" content="Chang&#39;s Note">
<meta property="og:description" content="在体系结构中，我们知道：链路层（或数据链路层）包含为共享相同介质的邻居建立连接的协议和方法。该层是在广域网（WAN）中的相邻网络节点之间或同一局域网（LAN）网段上的节点之间传输数据的协议层，除此之外，提供检测物理层中可能发生的错误的手段，但不一定会去尝试纠正。同时，设计链路层的目的是为 IP 模块发送和接受 IP 数据报，链路层可用于携带支持 IP 的辅助性协议，例如 ARP。   The li">
<meta property="og:locale">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/Ethernet1.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/frame%20format.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/Ethernet%20Switch.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/switch.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/filteringdatabase.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/STP%20%E6%8B%93%E6%89%91.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/STP%20%E6%8B%93%E6%89%912.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/STP%20state%20machine.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/BPDU.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/STP%20TOPO1.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/STP%20TOPO2.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/PPP%20frame.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/LCP%20state%20machine.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/LCP%20Frame.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/PPPoE.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/Ethernetpacket1.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/stppacket.png">
<meta property="og:image" content="http://osax8w13y.bkt.clouddn.com/stp%20presentation.JPG">
<meta property="article:published_time" content="2017-11-01T08:43:00.000Z">
<meta property="article:modified_time" content="2018-02-03T15:08:44.000Z">
<meta property="article:author" content="Chang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://osax8w13y.bkt.clouddn.com/Ethernet1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zcplayground.github.io/2017/11/01/tcpip3-Link-Layer/"/>





  <title>《TCP/IP 详解 卷1：协议》第 3 章：链路层 | Chang's Note</title>
<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chang's Note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-quotations">
          <a href="/quotations/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-quote-right"></i> <br />
            
            语录
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zcplayground.github.io/2017/11/01/tcpip3-Link-Layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chang's Note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《TCP/IP 详解 卷1：协议》第 3 章：链路层</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T16:43:00+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在体系结构中，我们知道：<strong>链路层（或数据链路层）</strong>包含为共享相同介质的<strong>邻居</strong>建立连接的协议和方法。该层是在广域网（WAN）中的<strong>相邻网络节点之间</strong>或<strong>同一局域网（LAN）网段上的节点</strong>之间传输数据的协议层，除此之外，提供检测物理层中可能发生的错误的手段，但不一定会去尝试纠正。同时，设计链路层的目的是<strong>为 IP 模块发送和接受 IP 数据报</strong>，链路层可用于携带支持 IP 的辅助性协议，例如 ARP。</p>
<blockquote>
<p> The link layer has the networking scope of the <strong>local network connection to which a host is attached</strong>. This regime is called the <strong>link</strong> in TCP/IP literature. It is the <strong>lowest component layer</strong> of the Internet protocols, </p>
<p>The data link layer provides the functional and procedural means to transfer data between network entities and might provide the means to detect and possibly correct errors that may occur in the physical layer.</p>
</blockquote>
<p><strong>TCP/IP 取得成功的的原因之一在于它能工作在几乎任意一种链路之上。</strong>不同的链路层依赖于其使用的网络硬件类型：有限局域网，例如以太网；城域网，例如有线电视、DSL 连接；有线语音网络，例如支持调制解调器的电话线；无线网络，如 WiFi（无线局域网）；基于蜂窝技术的无线数据服务。在本章中，主要讨论以太网，以及如何使用点到点协议 （PPP）。</p>
<blockquote>
<p>… as TCP/IP is designed to be <strong>hardware independent</strong>. As a result, TCP/IP may be implemented on top of virtually any hardware networking technology.</p>
</blockquote>
<p>大多数链路层技术都有一个相关的协议，描述由网络硬件传输的 <strong>PDU</strong>（Protocol Data Unit，协议数据单元） 格式。在描述链路层数据单元时，我们通常使用术语<strong>帧</strong>（frame），来和那些更高层的 PDU 格式区别开来，如网络层和传输层的 PDU <strong>分组</strong>（packet）和<strong>段</strong>（fragment）。帧通常支持<strong>可变帧长度</strong>，但有一个上限——最大传输单元（MTU，Maximum Transmission Unit），这是链路层的一个特点。</p>
<blockquote>
<p>Data-link <strong>frames</strong>, as these protocol data units are called, <strong>do not cross the boundaries of a local network</strong>. Inter-network routing and global addressing are higher-layer functions, allowing data-link protocols to focus on local delivery</p>
</blockquote>
<h1 id="以太网、IEEE-802-局域网标准"><a href="#以太网、IEEE-802-局域网标准" class="headerlink" title="以太网、IEEE 802 局域网标准"></a>以太网、IEEE 802 局域网标准</h1><p><strong>以太网</strong>（Ethernet）这个术语通常指<strong>一套标准</strong>，由 DEC、Intel、Xerox 公司于 1980 年首次发布，在 1982 年加以修订。第一个常见格式的以太网，目前被称为 “10 Mb/s 以太网” 或 “共享以太网”，它被 IEEE 采纳成为 <strong>802.3 标准</strong>。这种网络的结构通常如下所示：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/Ethernet1.png" alt=""></p>
<p>以太网包含如下概念和知识点：</p>
<h2 id="CSMA-CD-or-MAC"><a href="#CSMA-CD-or-MAC" class="headerlink" title="CSMA/CD or MAC"></a>CSMA/CD or MAC</h2><p>基本共享以太网包含一个或<strong>多个站（station）</strong>，它们都被连接到一个<strong>共享的电缆段上</strong>。标准需要每个以太网接口实现一种分布式算法。This common scheme is called <strong>carrier sense, multiple access with collision detection</strong> ，也就是<strong>CSMA/CD：带冲突检测的载波侦听多路访问</strong>。</p>
<ul>
<li><p>CSMA/CD 协调哪些计算机可以访问共享的介质（电缆），不需要其他特殊协议或同步。有助于降低成本、促进以太网技术的普及。</p>
</li>
<li><p>“载波侦听”：一个站在发送自己的数据之前，首先<strong>检测目前网络上发送的信号</strong>，在网络<strong>空闲</strong>时，才发送自己的帧。</p>
</li>
<li><p>“碰撞检测”：如果其他站碰巧在发送，重叠的电信号被视为<strong>碰撞（collision）</strong>。在这种情况下，站可以<strong>检测（detect）</strong>到。如果检测到碰撞，会导致发送方<strong>等待一个随机时间，然后重新发送数据。</strong></p>
</li>
<li><p>等待时间量的选择依据一个的概率分布。<strong>随后，如果再次检测到碰撞，每个碰撞会使等待时间长度加倍</strong>。最终<strong>每个站会得到机会转发</strong>，或者在尝试一定次数之后（传统以太网为 16）后<strong>超时</strong>。</p>
</li>
<li><p>只有当<strong>介质（medium）</strong>被确定为空闲状态时，链路层的 PDU 可以从一个站发送到其他一个或更多站。<strong>任何给定的时间内，网络中同一时刻只能有一个帧在传输</strong>。CSMA/CD 因此有另一个更正式的名字：<strong>介质访问控制协议，Medium Access Control。</strong></p>
</li>
<li><p><strong>以太网是一种广播网络。</strong></p>
</li>
</ul>
<h2 id="以太网帧格式-Frame-Format"><a href="#以太网帧格式-Frame-Format" class="headerlink" title="以太网帧格式 / Frame Format"></a>以太网帧格式 / Frame Format</h2><p>下面介绍交换机如何处理 PDU（Protocol Data Unit，协议数据单元）。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/frame%20format.png" alt=""></p>
<p>所有的以太网帧都基于一个共同的格式。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(byte)</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>前导（Preamble）</td>
<td>7</td>
<td>一般是一种公认的模式，典型值为 0xAA</td>
<td>接收接口电路使用，以确定帧的到达时间并确定编码位之间的时间量（称为时钟恢复）。<strong>简单来说，就是用于同步。</strong></td>
</tr>
<tr>
<td>帧起始分隔符（SFD）</td>
<td>1</td>
<td>固定值：0xAB</td>
<td>以太网帧<strong>开始的标志</strong></td>
</tr>
<tr>
<td>目的MAC地址（DST）</td>
<td>6</td>
<td>一个 MAC 地址</td>
<td>指明帧的接受者。目的地址也支持多个站点，例如广播（ARP协议）、组播（ICMPv6）</td>
</tr>
<tr>
<td>源MAC地址（SRC）</td>
<td>6</td>
<td>一个 MAC 地址</td>
<td>指明帧的发送者</td>
</tr>
<tr>
<td>长度或类型（Length/Type）</td>
<td>2</td>
<td>常见值有 IPv4（0x0800）、IPv6（0x86DD）、ARP（0x0806）</td>
<td>帧的数据字段的长度（长度或类型）</td>
</tr>
<tr>
<td>标签(tag)</td>
<td>最大482字节</td>
<td>如 QoS 指示符（服务质量）</td>
<td>包含由其他 IEEE 标准定义的各种协议字段</td>
</tr>
<tr>
<td><strong>有效载荷</strong>（payload）</td>
<td>46~1500</td>
<td>略</td>
<td>存放高层 PDU 的地方。对于TCP/IP 是 IP 数据包</td>
</tr>
<tr>
<td>填充（女仆长のpad）</td>
<td>可选</td>
<td>一定长度的连续 0</td>
<td>确保帧长度符合<strong>最小长度要求</strong></td>
</tr>
<tr>
<td><strong>循环冗余检验</strong>（FCS）</td>
<td>4</td>
<td>见下文</td>
<td>对接收网卡提供判断是否传输错误的一种方法</td>
</tr>
</tbody>
</table>
<h2 id="帧检验序列-循环冗余检验"><a href="#帧检验序列-循环冗余检验" class="headerlink" title="帧检验序列/循环冗余检验"></a>帧检验序列/循环冗余检验</h2><p>最后一个字段 FCS（Frame Check Sequence）提供了对<strong>帧完整性的检查</strong>。方法是：Cyclic Redundancy Check (CRC) <strong>循环冗余检验</strong>。<a target="_blank" rel="noopener" href="http://blog.csdn.net/liyuanbhu/article/details/7882789">这篇文章</a>介绍的很好，在这里引用一下：</p>
<blockquote>
<p>CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的<strong>余数</strong>作为校验数据附加到原数据后面。（商是抛弃的）…… 为了进行CRC运算，也就是这种特殊的除法运算，<strong>必须要指定个被除数</strong>，在CRC算法中，这个被除数有一个专有名称叫做<strong>“生成多项式”</strong>。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。好在这个问题已经被专家们研究了很长一段时间了，对于我们这些使用者来说，只要把现成的成果拿来用就行了。</p>
<p>多项式的位宽（Width，简记为W），这个位宽不是多项式对应的二进制数的位数，而是位数减 1。按照 CRC 算法的要求，计算前要在原始数据后填上 W 个 0。</p>
</blockquote>
<p>值得注意的是，CRC 使用的是 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A8%A12%E8%BF%90%E7%AE%97/18556715?fr=aladdin">mod 2 二进制除法</a>计算余数。<strong>与四则运算不同的是模2运算不考虑进位和借位，即模2加法是不带进位的二进制加法运算，模2减法是不带借位的二进制减法运算。</strong>该计算结果的反码放置在帧的 CRC 或 FCS 字段中。在接受到数据之后，接收方执行相同的算法，得到结果，判断与存放在 FCS 字段的值是否匹配。如果两者不匹配，帧可能在传输过程中受损，通常被<strong>丢弃</strong>。</p>
<hr>
<h1 id="网桥和交换机"><a href="#网桥和交换机" class="headerlink" title="网桥和交换机"></a>网桥和交换机</h1><p>IEEE 802.1d 标准规定了网桥的操作。 <strong>交换机本质上是高性能的网桥。</strong></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>随着以太网技术的发展，更快的计算机和基础设施使得局域网速度不断提升。（速度从 10Mb/s 增加到 100Mb/s、10Gb/s 甚至更高）。</p>
<p>二十世纪九十年代初，共享电缆已经很大程度被双绞线（类似电话线）替代。随着<strong>快速以太网</strong>的发展（100Mb/s），最初<strong>基于竞争的 MAC 协议已经变得不流行</strong>。</p>
<ul>
<li>局域网中的每个站之间的线路变成<strong>不共享</strong>，而是由<strong>以太网交换机（Ethernet Switch）</strong>实现了一个专用的星形拓扑结构。</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/Ethernet%20Switch.png" alt=""></p>
<ul>
<li>交换机为以太网中的每个站提供<strong>同时</strong>发送和接受数据的能力。</li>
<li>每个站使用一条<strong>专用的线路</strong>连接到一个交换机<strong>端口（port）</strong>，在这种情况下，以太网以<strong>全双工</strong>方式运行，不需要使用 CSMA/CD 算法。</li>
<li>交换机可以通过<strong>交换机端口级联（interconnect）</strong>来形成更大的以太网。这种端口叫做<strong>“上行（uplink）端口”</strong></li>
</ul>
<h2 id="全双工、半双工"><a href="#全双工、半双工" class="headerlink" title="全双工、半双工"></a>全双工、半双工</h2><ul>
<li><p><strong>半双工（half duplex mode）</strong>：使用一条共享的电缆，CSMA/AD，以太网最初被开发出来的时候就工作在半双工模式。</p>
</li>
<li><p><strong>全双工（full duplex mode）</strong>：交换式以太网。网络不再是单一的共享线路，而代之以很多链路的组合。减少了冲突检测电路的使用，增加了以太网的物理长度。</p>
</li>
</ul>
<h2 id="互连、MAC-学习"><a href="#互连、MAC-学习" class="headerlink" title="互连、MAC 学习"></a>互连、MAC 学习</h2><p>图中的交换机 A 和 B 互连，形成一个<strong>扩展的局域网</strong>。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/switch.png" alt=""></p>
<p>下面介绍交换机的 <strong>MAC 学习（learn）</strong>过程：</p>
<ul>
<li>每个网络单元都有自己的 MAC 地址。</li>
<li>每个网桥经过一段时间的<strong>对域外 MAC 地址的学习</strong>后，最终每个交换机会知道<strong>每个站可以由哪个端口到达</strong>。</li>
<li>每个交换机基于每个端口的列表被存储在一张被称为<strong>过滤数据库（filtering database）</strong>的表中。</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/filteringdatabase.png" alt=""></p>
<ul>
<li>当交换机（桥）首次打开时，其数据库为空，因此不知道其他站点的位置。 无论何时收到<strong>目的地为自己以外的站的帧</strong>，它将为此帧目的端口<strong>之外的每个端口创建一个副本，并从每个端口发送帧的副本</strong>。（好像与广播有些许差别</li>
<li>why learn？如果交换机从未学习站的位置，<strong>每个帧都需要被交付到每个网段</strong>，这将导致显著的不必要开销。<strong>学习能力（learning capability）可以显著降低开销，这是交换机和网桥的一个基本功能。</strong></li>
<li>由于站可能出现异动、网卡更换、MAC 地址改变等各种情况，所以过滤数据库中的一个 MAC 地址可以通过某端口访问这条信息也<strong>不能假设是永远正确的。</strong><ul>
<li>为了解决这个问题，过滤数据库使用一个计时器（通常是五分钟）。如果在这个有效期内，没有再次看到某条目的地址，则将这个条目<strong>删除</strong>。</li>
</ul>
</li>
</ul>
<h1 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h1><p>我们知道了交换机的一个很重要的能力——MAC 地址学习能力。但由于可能存在端口交叉连接、交换机级联的可能性，可能会导致某些问题，看下图这个例子：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/STP%20%E6%8B%93%E6%89%91.png" alt=""></p>
<p>假设上图中的多个交换机刚刚被打开，它们的过滤数据库都为空。由于这个扩展以太网包括的 4 台交换机由冗余链路组成，会产生所谓<strong>广播风暴（broadcast storm）</strong></p>
<ul>
<li>当站点 S 发送一个帧时，交换机 B 在端口 7、8、9 复制该帧。</li>
<li>这些帧被交换机 A、D、C 接收，而交换机 A 依然会在 2、3 端口复制该帧，交换机 D、C 会在 20、22、13、14 生成更多副本。</li>
<li>这些副本在交换机之间<strong>来回双向传输</strong>，这导致了转发数据库的<strong>震荡（oscillate，体会与 collision 的区别）</strong>，将会导致多余的流量倍增。</li>
</ul>
<p>这时，需要一种协议来避免这种情况，就是<strong>生成树协议（Spanning Tree Protocol，STP）</strong>。</p>
<ul>
<li>顾名思义，一个网络拓扑就是一个图，生成树就是包含所有节点而边集合没有形成回路。</li>
<li>STP 是通过<strong>在每个网桥禁用某些端口</strong>来避免拓扑环路的。</li>
<li>一张图可能有多个生成树，而 STP 用于<strong>找出其中一个生成树</strong>。</li>
<li>生成树的形成和维护由多个网桥完成，所以是在每个网桥上运行一个<strong>分布式算法</strong>。</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/STP%20%E6%8B%93%E6%89%912.png" alt=""></p>
<p>上面这个例子中，通过 STP，端口6、7、1、2、13、14、20 处于转发状态，其余端口被阻塞，预防了广播风暴。当然，STP 也能处理拓扑变化，会重新计算一个新的生成树。</p>
<h2 id="STP-状态机"><a href="#STP-状态机" class="headerlink" title="STP 状态机"></a>STP 状态机</h2><p><img src="http://osax8w13y.bkt.clouddn.com/STP%20state%20machine.png" alt=""></p>
<p>STP 状态机中，端口可能有五个状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
<th>状态转移</th>
</tr>
</thead>
<tbody>
<tr>
<td>阻塞（blocking）</td>
<td>初始化后，端口会进入阻塞状态。不进行地址学习、数据转发、BPDU 发送。但会<strong>监控、接收BPDU</strong></td>
<td>监视接收到的BPDU，如果需要包含在根桥路径上，在这种情况下，端口转换到侦听状态。或者经过最大时间（MaxA），也会转变到侦听状态</td>
</tr>
<tr>
<td>侦听（listening）</td>
<td>在侦听状态下，该端口现在<strong>允许发送BPDU</strong>，但不学习地址或转发数据。</td>
<td>在15秒的典型<strong>转发延迟</strong>（delay）后，端口进入学习状态。</td>
</tr>
<tr>
<td>学习（learning）</td>
<td>这里允许执行除转发数据之外的所有过程。</td>
<td>等待一个转发延迟就可以进入转发状态。转发延迟内涵见 BPDU 的转发延迟字段。</td>
</tr>
<tr>
<td>转发（forwarding）</td>
<td>活跃的交换机端口承载数据流量的正常状态</td>
<td>上述三个状态都有可能因为拓扑改变，而被阻塞。</td>
</tr>
<tr>
<td>禁用（disabled）</td>
<td>顾名思义</td>
<td>由管理配置引起</td>
</tr>
</tbody>
</table>
<h2 id="端口角色"><a href="#端口角色" class="headerlink" title="端口角色"></a>端口角色</h2><p>每个端口都扮演一个<strong>角色</strong>。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>根端口（root bridge）</td>
<td>在生成树的<strong>边（edge）上</strong>，<strong>朝向根网桥</strong>的端口</td>
</tr>
<tr>
<td>指定端口（designated port）</td>
<td>处于转发状态，作为<strong>从附加网段</strong>（attached segment）<strong>到根的最小路径上的端口</strong></td>
</tr>
<tr>
<td>替代端口（Alternate port）</td>
<td>与指定端口定义类似，但是达到根成本更高的端口。该类端口为当前”根端口”到”根网桥”提供一条替代路径。平时处于阻塞状态，在根端口失效时可以替代它</td>
</tr>
<tr>
<td>备份端口（backup port）</td>
<td>该类端口为”指定端口”到达生成树叶提供一条备份路径，是指定端口的备份端口。仅当两个端口在一个由一个点对点链路组成的环路上连接时，或者当交换机有两个或多个到达共享LAN网段的连接时可以存在。在一个指定端口失效时用来接管。</td>
</tr>
</tbody>
</table>
<p>我们主要需要理解根端口和指定端口。贴出英文，好好揣摩：</p>
<ul>
<li><p>根端口：ports at the end of an edge on the spanning tree headed toward the root.</p>
</li>
<li><p>指定端口：ports in the forwarding state acting as the port on the least-cost path to the root from the attached segment.</p>
</li>
</ul>
<h2 id="BPDU"><a href="#BPDU" class="headerlink" title="BPDU"></a>BPDU</h2><p>下面介绍<strong>网桥协议数据单元（BPDU，Bridge Protocol Data Unit）</strong>，是 STP 形成、维护生成树过程中所使用的帧。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/BPDU.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度（bytes）</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>前导</td>
<td>7</td>
<td>略</td>
<td>略，见 Ethernet，下同</td>
</tr>
<tr>
<td>帧起始标志 SFD</td>
<td>1</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>DST</td>
<td>6</td>
<td><strong>总是被发送至 01:80:C2:00:00:00</strong></td>
<td>链路层组、因特网<strong>组播寻址</strong></td>
</tr>
<tr>
<td>SRC</td>
<td>6</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>长度/类型（L/T）</td>
<td>2</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>LLC/SNAP</td>
<td>3</td>
<td>此头部由 802.1 定义，针对 BPDU 设置为<strong>常数 0x424203</strong></td>
<td>STP <strong>用 LLC（逻辑链路控制）封装</strong>。并非所有 BPDU 都用 LLC/SNAP 封装，但这是很常见的选项</td>
</tr>
<tr>
<td>协议（Protocol identifier）</td>
<td>2</td>
<td>生成树协议设置为 <strong>0x0000</strong></td>
<td>协议 ID 号</td>
</tr>
<tr>
<td>版本（Protocol Version Identifier）</td>
<td>1</td>
<td>0/2/3</td>
<td>STP/RSTP/MSP 用于指出<strong>协议版本</strong></td>
</tr>
<tr>
<td>类型（BPDU Type）</td>
<td>1</td>
<td>与上一个字段，协议版本类似</td>
<td>略</td>
</tr>
<tr>
<td>标志（BPDU flags）</td>
<td>1</td>
<td>见下面详解</td>
<td>略</td>
</tr>
<tr>
<td><strong>根 ID</strong>（Root Identifier）</td>
<td>8</td>
<td>发送发使用的<strong>根网桥标识符</strong>，详情见网桥 ID 字段</td>
<td>生成树以某个特定网桥作为<strong>根</strong></td>
</tr>
<tr>
<td><strong>根路径成本</strong>（Root Path Cost）</td>
<td>4</td>
<td>到达根 ID 字段中指定的网桥的路径计算成本</td>
<td>用于计算生成树算法。 <strong>cost 是与链路传速速度成反比的</strong>。</td>
</tr>
<tr>
<td><strong>网桥 ID</strong>（Bridge Identifier）</td>
<td>8</td>
<td>交换机的 6 字节的 MAC 地址，以及前面一个 2 字节的<strong>优先级字段</strong></td>
<td>优先级的值可以通过管理软件来设置，强制要求生成树以某个特定网桥为根网桥</td>
</tr>
<tr>
<td><strong>端口 ID</strong>（Port identifier）</td>
<td>2</td>
<td>端口标识符，即由发送帧给出的端口号。也有一个可配置的 1 字节的<strong>优先级</strong>字段</td>
<td>作用类似网桥 ID 字段中优先级的作用。</td>
</tr>
<tr>
<td><strong>消息有效期</strong>（MsgA）</td>
<td>2</td>
<td>一开始设置为 0 。任何接收 BPDU 的桥将在其<strong>非根端口上发送帧</strong>，该字段<strong>增加 1</strong></td>
<td>此字段不像其他与时间相关的字段一样是一个固定值。<strong>实质上，该字段用作跳数</strong>，给出在接收BPDU之前已经处理的桥的数量。</td>
</tr>
<tr>
<td><strong>最大有效期</strong>（MaxA）</td>
<td>2</td>
<td>指出 BPDU 超时的期限，默认为 20 秒</td>
<td>在端口上接收到BPDU时，其包含的信息被保存在存储器中，并参与STP算法的执行中，直到被超时，<strong>超时是发生在(MaxA – MsgA)</strong>。如果在<strong>这个时间段内根端口没有接收到另一个 BPDU，根网桥被宣布“死亡”，重新开始根网桥选举过程</strong>。</td>
</tr>
<tr>
<td><strong>欢迎时间</strong>（Hello Time）</td>
<td>2</td>
<td>比如 2 秒</td>
<td>表示 BPDU 帧发送间隔</td>
</tr>
<tr>
<td><strong>转发延迟</strong>（Forward Delay）</td>
<td>2</td>
<td>典型为 15 秒</td>
<td>给出在学习和收听状态下等待所花费的时间。<strong>延迟是为了等待整个生成树的同步、MAC 表的刷新。</strong></td>
</tr>
<tr>
<td>FCS</td>
<td>4</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
<p>1 byte 的 flag 字段的位分别定义为：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bit)</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TC（topology change）</strong></td>
<td>1</td>
<td>拓扑变化</td>
</tr>
<tr>
<td>P</td>
<td>1</td>
<td>建议</td>
</tr>
<tr>
<td>端口角色</td>
<td>2</td>
<td>00 为未知，01 为替代or备份，10 为根端口，11 为指定端口</td>
</tr>
<tr>
<td>L</td>
<td>1</td>
<td>处于学习状态？</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>处于转发状态？</td>
</tr>
<tr>
<td>A</td>
<td>1</td>
<td>协议，agreement</td>
</tr>
<tr>
<td><strong>TCA（topology change acknowledgement）</strong></td>
<td>1</td>
<td>拓扑变化确认</td>
</tr>
</tbody>
</table>
<h2 id="建立生成树"><a href="#建立生成树" class="headerlink" title="建立生成树"></a>建立生成树</h2><p>第一个工作是<strong>选举根网桥</strong>。根网桥是在网络中<strong>网桥 ID 标识符最小</strong>（优先级和 MAC 地址结合）的网桥。具体步骤：</p>
<ul>
<li>当一个网桥初始化时，都假设自己是根网桥。用自己的网桥 ID 字段作为<strong>根 ID</strong>字段，发送 BPDU 消息。</li>
<li>如果某个网桥检测到一个 根 ID 更小的消息，则立即<strong>停止发送自己的帧</strong>，并<strong>基于接受到的那个更小的 ID 构造下一步要发送的 BPDU</strong>。</li>
</ul>
<p>我们可以这么理解：一群猴子要选出一个猴王出来，一开始，所有猴子都觉得自己能当猴王。假设有三只猴子 A、B、C：</p>
<ul>
<li>B 先向 A 发出挑战（交换机 B 用自己的 ID 发送 BPDU 给 A）</li>
<li>然而可惜的是， B 失败了（交换机 A 发送过来的 BPDU 中根 ID 字段比自己的要小），这样 B 就会承认 A 比较厉害，<strong>此后不再会挑战 A 的权威</strong>。（之后是基于 A 的更小的 ID 构造 BPDU，而不是发送自己的网桥 ID 了）</li>
<li>B 不仅向 A 俯首称臣了，还要向隔壁的 C 传达：<strong>A 是目前最厉害的猴子！</strong>（以后发送的 BPDU 中的根 ID 字段是 A 的 mac 地址）</li>
<li><strong>如果“A 是目前最厉害的猴子”这个消息传遍整个了猴群，那么 A 就当选了猴王。</strong></li>
</ul>
<p>下面来看一个例子，这个例子里包括四台交换机，各有两个端口互连，路径成本标在路径上：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/STP%20TOPO1.png" alt=""></p>
<ol>
<li><p>首先选择根网桥。假设这个例子中没有优先级，S1 的 MAC 地址最小，因此 S1 当选根桥（root bridge）。</p>
</li>
<li><p>选取<strong>每个网桥的</strong>根端口，考虑对象：网桥。选取方法：比较<strong>每一台交换机每个端口发出</strong>的 BPDU 的根路径成本，发出更小 BPDU 的那个端口就是根端口。</p>
</li>
</ol>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S2: 端口<span class="number"> 1 </span>收到的 BPDU 的 cost 为 19; 端口<span class="number"> 2 </span>的为<span class="number"> 19 </span>+<span class="number"> 4 </span>+<span class="number"> 19 </span>= 42</span><br><span class="line">    端口<span class="number"> 1 </span>成为根端口</span><br><span class="line">S3: 端口 3:<span class="number"> 19 </span>+<span class="number"> 19 </span>= 38; 端口 4:19 +<span class="number"> 4 </span>= 23</span><br><span class="line">    端口<span class="number"> 4 </span>成为根端口</span><br><span class="line">S4: 端口 5:<span class="number"> 19 </span>+<span class="number"> 19 </span>+<span class="number"> 4 </span>= 42; 端口 6: 19</span><br><span class="line">    端口<span class="number"> 6 </span>成为根端口</span><br></pre></td></tr></table></figure>
<ol>
<li>选<strong>每个网段</strong>的指定端口，考虑对象：每条链路。选取方法：比较<strong>每条链路两端发出的</strong> BPDU 的 cost。</li>
</ol>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">S1-S2 网段: 端口<span class="number"> 8 </span>发出的 BPDU 的 cost 为 0; 端口<span class="number"> 1 </span>发出的 cost 为<span class="number"> 19 </span>+<span class="number"> 4 </span>+<span class="number"> 19 </span>= 42</span><br><span class="line">（这里，BPDU 不会逆着发，联想一下猴王的例子）</span><br><span class="line">            端口<span class="number"> 8 </span>成为指定端口</span><br><span class="line">S1-S3 网段: 端口 7: 0; 端口 6:<span class="number"> 19 </span>+<span class="number"> 19 </span>+<span class="number"> 4 </span>=<span class="number"> 42 </span></span><br><span class="line">            端口<span class="number"> 7 </span>成为指定端口</span><br><span class="line">S2-S3 网段: 端口 2: 19; 端口 3:<span class="number"> 19 </span>+<span class="number"> 4 </span>= 23</span><br><span class="line">            端口<span class="number"> 2 </span>成为指定端口</span><br><span class="line">S3-S4 网段: 端口 5: 19; 端口 4:<span class="number"> 19 </span>+<span class="number"> 19 </span>= 38</span><br><span class="line">            端口<span class="number"> 5 </span>成为指定端口</span><br></pre></td></tr></table></figure>
<p>下图是更新的状态：S1 当选根桥（root bridge）。端口 1、4、6 是根端口（蓝色圆圈）；端口 2、5、7、8 是指定端口（红色正方形）。<strong>既不是根端口，也不是指定端口的，就阻塞</strong>（图中的端口 3）。自然，形成了一棵生成树。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/STP%20TOPO2.png" alt=""></p>
<p>现在再来体会以下根端口和指定端口的定义。</p>
<ul>
<li><p>根端口是在生成树的<strong>边（edge）上</strong>，<strong>朝向根网桥</strong>的端口。我们可以联想 Prim 最小生成树算法，既然根端口是生成树边上朝向根网桥的端口，那么意味着<strong>根端口向整棵树的枝叶发</strong>消息的时候，<strong>往根端口发</strong>就可以了。</p>
</li>
<li><p>指定端口即作为<strong>从附加网段</strong>（attached segment）<strong>到根的最小路径上的端口</strong>。“附加的网段”可以想象成生成树扩张的状态。当<strong>叶节点需要向根网桥发送 BPDU</strong>（例如发送了拓扑改变），则<strong>往指定端口发</strong>就可以了。一句话总结，就是：</p>
</li>
<li><p><strong>根端口就像是树中的 child 指针，指定端口就像是 parent 指针。</strong></p>
</li>
</ul>
<p>此外，还可以得出以下一些性质：</p>
<ul>
<li>每个网络中只有一个根网桥；</li>
<li>每个非根网桥只有一个根端口；</li>
<li>每个网段只能有一个指定端口；</li>
<li>根网桥无根端口；</li>
<li>根网桥端口全为指定端口； </li>
</ul>
<h2 id="处理拓扑变化"><a href="#处理拓扑变化" class="headerlink" title="处理拓扑变化"></a>处理拓扑变化</h2><p>STP 另一项重要的工作就是要<strong>能处理拓扑变化</strong>。虽然前述中提到 filter database 有适应拓扑变化的机制，不过需要五分钟的时间没有接受到某条地址，才会删除这条条目。</p>
<ul>
<li>在 STP 中，当一个端口进入阻塞或转发状态时，意味着拓扑变化。</li>
<li><strong>当网桥检测到一个变化，向根端口之外的端口发送拓扑变化通知 TCN BPDU，并它通知自己在树中的父网桥，直到根为止</strong>。</li>
<li>在到根的路径上的网桥不断转发 TCN BPDU。直到当根网桥接收到拓扑变化通知后，根网桥在后续的周期性配置消息中<strong>设置 TC 位</strong>，这种消息被网络中的所有网桥转发。 </li>
<li>设置了 TC 位的 BPDU，允许网桥<strong>减小 filter database 中的计时器的有效期</strong>（用秒来代替推荐的五分钟）。这样，数据库里的有误条目被<strong>快速清除并重新学习</strong>（有一个术语描述这种操作，叫做<strong>老化</strong>），更新了拓扑视图。</li>
</ul>
<h2 id="快速生成树协议"><a href="#快速生成树协议" class="headerlink" title="快速生成树协议"></a>快速生成树协议</h2><p>传统 STP 的一个问题：</p>
<blockquote>
<p>生成树是一个具有<strong>缓慢收敛时间的旧协议</strong>。如果未正确实施，可能会导致主要的网络中断。 阻止链接的想法是客户现在不能接受的一个适当的高可用解决方案。 </p>
</blockquote>
<p>拓扑变化之后，只能通过一段时间未检测到 BPDU 来检测。<strong>收敛时间</strong>（沿着生成树重新建立数据流的时间）可能很长。</p>
<ul>
<li>为什么 STP 拓扑变化通知必须发回根端口？因为只有根端口能发 TC 置 1 的 BPDU。更新拓扑的机制是收到 TC BPUD 而老化数据库，更新拓扑。</li>
</ul>
<p>IEEE 802.1W 改进了传统 STP，定义了<strong>快速生成树协议（Rapid Spanning Tree Protocol，RSTP）</strong>。</p>
<ul>
<li>端口状态由五个减少到了三个：<strong>丢弃、学习、转发</strong>。</li>
<li>STP 中，BPDU 通常由一个通知网桥或根网桥发送。RSTP 中，为了“保持活跃”，<strong>BPDU由所有网桥来发送。</strong></li>
<li>主要改进是<strong>监视每个端口的状态</strong>。在 RSTP 中，检测到一次拓扑变化的交换机会<strong>发送一个表示拓扑变化的 BPDU</strong>。任何接收到它的交换机<strong>立即清除自己的过滤数据库</strong>。这个改变能<strong>显著影响协议的收敛时间</strong>。<strong>无需等待拓扑变化传递到根网桥再返回，而是立即清理相关条目。</strong></li>
</ul>
<p>说实话，第一次看到 RSTP 之后觉得这才是正常的思路啊？可能需要监控每个端口的状态需要更多的算法开销吧。</p>
<h1 id="点到点协议"><a href="#点到点协议" class="headerlink" title="点到点协议"></a>点到点协议</h1><ul>
<li>PPP，Point-to-Point Protocol，点到点协议【RFC1661】、【RFC1662】、【RFC2153】。</li>
<li>PPP是用于在<strong>两个节点</strong>之间<strong>建立直接连接</strong>的数据链路层通信协议。PPP 操作<strong>只关注一条链路的两端</strong>，不需要像 MAC 协议或者 Wi-Fi 那样处理共享资源访问的问题。</li>
<li><p>PPP用于多种类型的物理网络，包括串口线，电话线，中继线，移动电话，专用无线电链路以及SONET等光纤链路。</p>
</li>
<li><p>互联网服务提供商（ISP）经常使用 <strong>PPPoE（以太网上的点对点协议）</strong>建立<strong>数字用户线（DSL，Digital Subscriber Line）</strong>。可以说是实现互联网与客户的服务连接的“最后一公里”。</p>
</li>
<li><p>PPP 是一种协议集合，而不是一个单一的协议。</p>
<ul>
<li>首先，它有支持建立链接的基本方法：<strong>逻辑链路控制（Link Control Protocol，LCP）</strong>。</li>
<li>一系列的<strong>网络控制协议（Network Control Protocol）</strong>，NCP 用于建立了基本链路之后，为各种协议配置信息，建立链路层网络。</li>
<li>除此之外，它可以提供连接认证，传输加密和压缩。</li>
</ul>
</li>
</ul>
<h2 id="PPP-基本帧格式"><a href="#PPP-基本帧格式" class="headerlink" title="PPP 基本帧格式"></a>PPP 基本帧格式</h2><p>PPP 设计时，是基于<strong>高级数据链路控制（HDLC）</strong>建立的一种良好帧格式。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/PPP%20frame.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bytes)</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>标志（Flag）</td>
<td>1</td>
<td>0x7E</td>
<td>由两个<strong>固定的0x7E包围</strong>，指示帧的开始和结束</td>
</tr>
<tr>
<td>地址（Address）</td>
<td>1</td>
<td>0xFF</td>
<td>在HDLC中，地址字段将指定哪个站正在寻址。但是因为PPP只关心一个目的地，所以这个领域总是定义为值<strong>0xFF，广播地址</strong>。</td>
</tr>
<tr>
<td>控制（Control）</td>
<td>1</td>
<td>0x03</td>
<td>用于指示帧排序和重传行为。但这些<strong>链路层的可靠性功能通常不是通过PPP实现的</strong>，控制字段被设置到固定值0x03</td>
</tr>
<tr>
<td>协议（Protocol）</td>
<td>2</td>
<td>0x0000~0x00FF范围中的值包括大多数流行的<strong>网络层协议</strong>，0x8000~0xBFFF中的值指关联NCP的数据。0xC000~0XEFFF的协议值标识<strong>控制协议，如LCP</strong>。</td>
<td>PPP帧的协议字段指示正在传输的数据的类型</td>
</tr>
<tr>
<td>数据（Data）</td>
<td>不等</td>
<td>帧的有效载荷</td>
<td>PPP控制、网络层数据</td>
</tr>
<tr>
<td>填充（Pad）</td>
<td>不等</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>FCS</td>
<td>2或4</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>标志（Flag）</td>
<td>1</td>
<td>0x7E</td>
<td>由两个<strong>固定的0x7E包围</strong>，指示帧的开始和结束</td>
</tr>
</tbody>
</table>
<h2 id="PPP-状态机"><a href="#PPP-状态机" class="headerlink" title="PPP 状态机"></a>PPP 状态机</h2><p>下面是 PPP 状态机：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/LCP%20state%20machine.png" alt=""></p>
<ul>
<li><strong>链路不可用阶段</strong>。PPP链路都需从这个阶段开始和结束。</li>
<li><strong>链路建立阶段</strong>。是PPP协议最关键和最复杂的阶段。这是在数据链路层进行。该阶段主要是发送一些配置报文来配置数据链路，这些配置的参数不包括网络层协议所需的参数。在这个阶段<strong>主要是通过LCP协议进行链路参数的配置</strong>。</li>
<li><strong>验证阶段</strong>。多数情况下的链路两端设备是需要经过认证后才进入到网络层协议阶段，缺省情况下链路两端的设备是不进行认证的。在该阶段支持<strong>PAP 和 CHAP</strong>两种认证方式，验证方式的选择是依据在链路建立阶段双方进行协商的结果。</li>
<li><strong>网络层协议阶段</strong>。一旦PPP完成了前面几个阶段，每种网络层协议（IP、IPX和AppleTalk）会通过各自相应的网络控制协议进行配置，每个<strong>NCP 协议</strong>可在任何时间打开和关闭。</li>
<li><strong>网络终止阶段</strong>。PPP能在任何时候终止链路。当载波丢失、授权失败、链路质量检测失败和管理员人为关闭链路等情况均会导致链路终止。PPP 的除了不可用阶段，任何一种状态都可以立即进入网络终止阶段。</li>
</ul>
<h2 id="链路控制协议"><a href="#链路控制协议" class="headerlink" title="链路控制协议"></a>链路控制协议</h2><p><strong>链路控制协议（LCP）</strong>构成了互联网协议族中的点对点协议（PPP）的一部分。 在建立PPP通信时，发送和接收设备都<strong>发送LCP分组以确定随后的数据传输的标准。</strong></p>
<p>LCP Frame 是在 PPP Frame 上进行了简单的封装。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/LCP%20Frame.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bytes)</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>协议</td>
<td>2</td>
<td>0xC021</td>
<td>标识 LCP</td>
</tr>
<tr>
<td>代码（Code）</td>
<td>1</td>
<td>见下列</td>
<td>请求或响应的字段操作</td>
</tr>
<tr>
<td>标识（Ident）</td>
<td>1</td>
<td>见下列</td>
<td>见下列</td>
</tr>
</tbody>
</table>
<ul>
<li>代码字段配置的操作类型有：配置请求（按排序从 0x01 递增到 0X0D）、配置ACK、配置NACK 、配置REJECT 、终止请求 、终止ACK 、代码REJECT 、协议REJECT 、回送请求 、回送应答 、放弃请求 、标识 、剩余时间。</li>
<li><strong>ACK</strong> 标识接受一组选项，<strong>NACK</strong> 表明部分拒绝。</li>
<li><strong>REJECT</strong> 完全拒绝一个或多个选项。</li>
<li><strong>配置</strong>消息使得链路两端开始<strong>基本配置过程</strong>，建立商定的选项。</li>
<li><strong>终止</strong>消息可以<strong>清除一条链路</strong></li>
<li><strong>回送</strong>可由 LCP 在一条活跃的链路上随时交换，验证对方的操作。</li>
<li><strong>放弃请求</strong>，用于性能测试，指示对方丢弃没有相应的分组。</li>
<li><strong>标识</strong>、<strong>剩余时间</strong>用于管理目的：了解对方的系统类型，指出链路建立的时间。</li>
</ul>
<h2 id="LCP-状态"><a href="#LCP-状态" class="headerlink" title="LCP 状态"></a>LCP 状态</h2><p>LCP 用于建立 PPP 链路 ，商定各方选项。典型的过程包括：<strong>配置请求、配置确认、认证交换、数据交换、终止交换。</strong>因为 PPP 是一个<strong>包括很多部分的通用协议</strong>，所以一条链路的建立和终止之间可以发生很多其他种类的操作。</p>
<p>（下面引用自<a target="_blank" rel="noopener" href="http://blog.csdn.net/xdsoft365/article/details/6335882">闲谈PPP协议</a>）</p>
<ul>
<li>配置请求：</li>
</ul>
<blockquote>
<p>一般而言在进入<strong>链路建立阶段</strong>时，通信双方无论哪一端都会连续发送几个配置请求报文<strong>（Config-Request报文）</strong>，而这几个请求报文的数据域可能是完全一样的，而仅仅是它们的标识域不同罢了。通常一个配置请求报文的ID是从0x01开始逐步加1的，当对端接收到该配置请求报文后，无论使用何种报文（回应报文可能是Config-Ack、Config-Nak和Config-Reject三种报文中的一种）来回应对方，但必须要求回应报文中的ID（标识域）要与接收报文中的ID一致，当通信设备收到回应后就可以将该回应与发送时的进行比较来决定下一步的操作。</p>
<p>当接收Config-Request报文的一端能识别发送过来的所有配置参数选项且认可所有配置参数选项数据域的内容时，接收端将会给对端回一个Config-Ack报文并将配置请求报文中的配置参数选项原封不动的放置在Config-Ack报文的数据域内（根据协议的规定是不可改变配置参数选项的顺序）。当配置请求报文的发送端收到Config-Ack报后，则会从当前阶段进入到下一个阶段。 </p>
</blockquote>
<ul>
<li>一旦底层协议表明一个关联变成活跃（例如调制解调器检测到载波），则认为这个链路已经被建立。然后，如果链接需要被<strong>认证</strong>（一般来说是要的），例如拨号到一个 ISP 时，需要一些额外的信息交换（用户名、密码），以验证链路上一方 or 双方的身份。</li>
</ul>
<blockquote>
<p>当接收Config-Request报文的一端能识别发送端所发送过来的所有配置参数选项，但<strong>对部分配置参数选项数据域中的内容不认可</strong>时，接收端将会给对端回应一个<strong>Config-Nak</strong>报文，（注意，是能够识别，只是对部分参数内容不认可，所以不是Config-Reject报文）。然而当接收端收到Config-Nak报文后，会重新发送Config-Request报文，而这个Config-Request报文与上一次所发送的Config-Request报文区别在于那些被对端不认可的配置参数选项的内容被填写到刚刚协商完后再次发送的Config-Request报文中。</p>
<p>当接收Config-Request报文的一端<strong>不能识别所有的发送端发送过来的配置参数选项</strong>时，此时接收端将会向对端回一个<strong>Config-Reject</strong>报文，该报文中的数据域只携带那些不能识别的配置参数选项（当配置参数选项的类型域不识别时）。当对端接收到Config-Reject报文后，同样会再次发送一个Config-Request报文，这个配置请求报文与上一次发送的区别在于将不可识别的那些配置参数选项给删除了。 </p>
<ul>
<li>链路终止</li>
</ul>
<p>分为Terminate-Request和Terminate-Reply两种报文。LCP报文中提供了一种机制来关闭一个点对点的连接，<strong>想要关断链路的一端会持续发送Terminate-Request报文，直到收到一个Terminate-Reply为止</strong>。接收端一旦收到了一个Terminate-Request报文后，必须回应一个Terminate-Reply报文，同时等待对端先将链路断开后，再完成本端的所有断开的操作。LCP的链路终止报文的数据域与链路配置报文的数据域不一样，链路终止报文中无需携带各配置参数选项。对于链路终止报文也同样需要ID一致，当接收到Terminate-Reply报文才会做链路终止操作。</p>
</blockquote>
<ul>
<li>当底层协议或硬件表明一个关联停止（例如载波消失），或发生了链路终止请求，并从对方接收到确认终止响应，则这个链路已被终止。</li>
</ul>
<h2 id="魔术数字"><a href="#魔术数字" class="headerlink" title="魔术数字"></a>魔术数字</h2><p>如果一个工作站处于<strong>环回模式</strong>，这时会使点到点链路出现一个常见问题。<strong>魔术字</strong>（发送方选择的任意数字）是在链路建立过程中比较重要的一个参数，这个参数是在Config-Request里面被协商的，主要的作用是防止环路。LCP 通过发送<strong>魔术数字</strong>，<strong>查看是否立即返回相同类型的信息</strong>。如果是的话，视为检测到环回，并可能需要进行维护。</p>
<p>（下面引用自<a target="_blank" rel="noopener" href="http://blog.csdn.net/xdsoft365/article/details/6335882">闲谈PPP协议</a>）</p>
<blockquote>
<p>协议为了避免双方可能产生同样的魔术字，从而导致通信出现不必要的麻烦，因此要求由设备<strong>采用一些随机方法产生一个独一无二的魔术字</strong>。一般来说魔术字的选择会采用设备的系列号、网络硬件地址或时钟。双方产生相同魔术字的可能性不能说是没有的，但应尽量避免…… </p>
<p>我们知道魔术字产生的作用是用来帮助检测链路是否存在环路，当接收端收到一个Config-Request报文时，会将此报文与上一次所接收到的Config-Request进行比较，如果两个报文中所含的魔术字不一致的话，表明链路不存在环路。但如果一致的话，接收端认为链路<strong>可能</strong>存在环路，<strong>但不一定</strong>存在环路，还需进一步确认，方法是： <strong>此时接收端将发送一个Config-Nak报文，并在该报文中携带一个重新产生的魔术字，而且此时在未接收到任何Config-Request或Config-Nak报文之前，接收端也不会发送任何的Config-Request报文。</strong></p>
<ol>
<li><p>链路实际不存在环路，而是由于对方产生了一样的魔术字，但实际这种情况出现的概率是<strong>很小</strong>的。当Config-Nak被原来的发送端接收到后，应该立即重新发送一个Config-Request报文（此报文中的魔术字为之前Nak报文中的，也就是第一次接收端收到的魔术字），当接收端接收到后，与上次比较，由于接收端已经在Nak报文中<strong>产生了一个不同的魔术字</strong>，此时接收端收到的Config-Request报文中的魔术字与上次配置请求报文中不一样，所以接收端可断定链路不存在环路。</p>
</li>
<li><p>链路实际上确实存在环路。在这条链路上就会不断的出现Config-Request、Config-Nak报文，而且魔术字一直是相同的。这样周而复始下去，接收端就会认为PPP链路存在环路的可能性在不断增加，<strong>当达到一定数量级时，就可认为此链路存在环路。</strong>（注意，不是第一次受到相同的魔术字就判断有环路的）</p>
</li>
</ol>
<p>好了，基本上通过PPP闲谈，我们可以比较彻底的了解PPP协议的工作机制和特点，其实，会者不难，协议都是人制订的，只有简单易用的协议才会最终保留下来，就像TCP/IP打败OSI一样。所以，只要静下心来，没有什么高深的。</p>
</blockquote>
<h2 id="PPP-认证"><a href="#PPP-认证" class="headerlink" title="PPP 认证"></a>PPP 认证</h2><p>在一条 PPP 链路处于网络状态前，通常需要使用某种认证机制，识别建立链路的对方身份。</p>
<ul>
<li>最简单、安全性最低的认证方案就是<strong>密码认证协议（PAP）</strong>。非常简单，就是一方请求另一方发送一个明文密码。由于未加密，容易被轻易捕获。</li>
<li><strong>查询 - 握手认证协议（CHAP）</strong></li>
</ul>
<blockquote>
<p>其实CHAP的C代表Chanllenge的意思，即验证方会首先发起挑战：你把密码告诉我，这是第一次握手；然后被验证方才会将密码告知验证方，这是第二次握手；最后验证方反馈验证结果，这是第三次握手。而PAP则只有后两次握手，另外PAP的密码是明文，CHAP的是密文。</p>
</blockquote>
<ul>
<li><p>一个随机值从认证方发送到另一方。通过一种特殊的单向（不可逆）功能，将一个随机值和共享密钥（通常由密码生成）结合形成响应中的一个数字。在接受到这个响应之后，认证方能更可靠地验证对方密钥是否正确。不会以明文方式传输密钥或者密码。每次使用不同的随机值，窃听者即使可能捕捉到这个值，也无法通过重放来欺骗对方。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://network.51cto.com/art/201109/291563.htm">CHAP认证概述</a></p>
</li>
</ul>
<blockquote>
<p>CHAP认证第一步：主认证方发送挑战信息【01(此报文为认证请求）、id(此认证的序列号）、随机数据、主认证方认证用户名】，被认证方接收到挑战信息，根据接收到主认证方的认证用户名到自己本地的数据库中查找对应的密码（如果没有设密码就用默认的密码），查到密码再结合主认证方发来的id和随机数据根据MD5算法算出一个Hash值。</p>
<p>CHAP认证第二步：被认证方回复认证请求，认证请求里面包括【02（此报文为CHAP认证响应报文）、id(与认证请求中的id相同）、Hash值、被认证方的认证用户名】，主认证方处理挑战的响应信息，根据被认证方发来的认证用户名，主认证方在本地数据库中查找被认证方对应的密码（口令）结合id找到先前保存的随机数据和id根据MD5算法算出一个Hash值，与被认证方得到的Hash值做比较，如果一致，则认证通过，如果不一致，则认证不通过。</p>
<p>CHAP认证第三步：认证方告知被认证方认证是否通过。</p>
</blockquote>
<h2 id="网络控制协议"><a href="#网络控制协议" class="headerlink" title="网络控制协议"></a>网络控制协议</h2><p>在 LCP 完成链路建立和确认之后，该链路每端都进入网络状态。然后就可以开始使用<strong>一个或多个的 NCP</strong>（Network Control Protocol，NCP 网络控制协议）来<strong>进行网络层的相关协商。</strong></p>
<p>典型的例如 IPCP（针对 IPv4 的标准 NCP）用于在一条链路上建立 IPv4 链接。包括一系列选项：IP 压缩、移动 IPv4等等。</p>
<h2 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h2><p>对于大多数局域网和一些广域网连接，<a target="_blank" rel="noopener" href="http://www.zcplayground.cc/2017/09/13/tcpip6-DHCP/">DHCP</a> 提供了最基本的客户机系统的自动配置方式。对于广域网连接（常见的 DSL，Digital Subscriber Line 数字用户线路），常用另一种基于 PPP 的方式替代 DHCP。这种方法涉及在以太网中携带 PPP，因此称为 <strong>PPPoE（Point-to-point protocol over Ethernet）</strong>。</p>
<ul>
<li>PPPoE 用于广域网连接设备作为一个交换机或者网桥（DSL Modem，也就是所谓的调制解调器，不支持路由）而不是路由器的情况下。</li>
<li>PPPoE 作为一些 ISP 建立连接的首选，也是建立用户连接到网络的“最后一公里”的首选。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Point-to-point_protocol_over_Ethernet">wiki:</a> 2005年的一本网络书籍指出：“大多数DSL提供商使用PPPoE，它提供认证，加密和压缩。” PPPoE的典型应用包括利用 PPP 设施使用用户名和密码验证用户，主要通过PAP协议而较少通过CHAP。</li>
</ul>
<p>PPPoE是由UUNET，Redback Networks（现爱立信）和RouterWare（现在的风河系统）开发的。【RFC 2516】</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/PPPoE.png" alt=""></p>
<p>上图显示了一个典型的 ISP 使用 DSL 为客户提供服务。</p>
<ul>
<li>用户将一台家用 PC 连接到 DSL 调制解调器，使用一个点到点的以太网络（<strong>使用一根电缆的以太网</strong>）</li>
<li>DSL 提供一条点到点的数字链路。一般是与一条传统的模拟<strong>电话线同时工作</strong>。对物理电话线的同时使用是采取<strong>频分复用</strong>实现的。</li>
<li>DSL 调制解调器有效地向 ISP 的<strong>接入集中器</strong>（access concentrator）上的 <strong>PPP端口</strong>提供桥接服务。将接入集线器将客户的调制解调器线路和 ISP 的网络设备互连。</li>
<li>一旦 DSL 调制解调器已经成功建立了一个低层的链接 ISP，PC 可以开始 PPPoE 交换。【RFC2516】</li>
</ul>
<h1 id="环回"><a href="#环回" class="headerlink" title="环回"></a>环回</h1><p>在魔术数字提到的<strong>环回（loop）</strong>概念，可能一开始看起来很奇怪。不过在很多情况下，<strong>客户机可能希望用 Internet 协议来与同一计算机上的服务器通信</strong>。为了实现这个目标，大多是实现一种工作在网络层的环回能力。</p>
<ul>
<li>使用一个虚拟的还回网络接口来实现。它<strong>像一个真正的网络接口</strong>，但<strong>实际上是</strong>一个由<strong>操作系统提供的专门的软件</strong>。</li>
<li>以 127 开头的 IPv4 地址就是为了这个目的而保留。类 UNIX 系统为环回接口分配的地址是 <code>127.0.0.1</code>（IPv6 为 <code>::1</code>)，分配的名称是 <strong>localhost</strong>。Linux 中，环回接口被称为 <strong>lo</strong>。</li>
<li>发送到环回接口的 IP 数据报<strong>不会出现在任何网络中</strong>。</li>
<li>大多数的实现有经过传输层和网络层对数据的完整处理流程，仅在数据报离开网络层时将其送回给网络层协议栈。</li>
</ul>
<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>以太网帧有最小和最大尺寸。</p>
<ul>
<li><p>最小帧要求有 64 字节，有效载荷长度最小为 48 长度。当有效载荷较短，就需要填充一些字节（都是 0），确保达到最小长度。</p>
</li>
<li><p>最小长度对使用 CSMA/CD 的以太网来说很重要，如果帧太小意味着传输速度过快。当某个站检测到碰撞时，可能会发生这个帧已经传输完的情况，不知道是哪个帧发生了冲突。</p>
</li>
<li><p>传统以太网最大帧长度是 1518 字节。选择这个值也是有折衷的：如果一个帧发生了错误，那么只需要重传 1.5 KB 就好。</p>
</li>
</ul>
<p>因为以太网有最大长度限制，所以<strong>携带高层协议 PDU 的长度是有限制的</strong>。不仅是以太网，在很多链路层网络中都有这个特点。链路层的这种特征叫做<strong>最大传输单元（MTU）</strong>。</p>
<ul>
<li>本地链路的 MTU 对会话期间数据报的大小有直接影响。</li>
<li>当两台主机跨越多种网络通信时，<strong>每种不同的链路可能有不同大小的 MTU</strong>。因此，在包含所有链路的整个网络路径上，最小的 MTU 叫做 <strong>路径 MTU</strong>。</li>
<li>如果 IP 需要发送一个数据报，大小大于链路层 MTU，则 IP 通过<strong>分片（slice）</strong>将数据报分解成较小的部分，使每个分片都小于 MTU。分片会在 IP 协议中详细讨论。</li>
</ul>
<h1 id="隧道基础"><a href="#隧道基础" class="headerlink" title="隧道基础"></a>隧道基础</h1><p>简单来说：隧道就是在高层（或同等层）分组携带底层的数据。</p>
<h1 id="与链路层相关的攻击"><a href="#与链路层相关的攻击" class="headerlink" title="与链路层相关的攻击"></a>与链路层相关的攻击</h1><p>攻击 TCP/IP 以下的层次一直是常见的做法：</p>
<ul>
<li>早期，以太网是名副其实的<strong>共享电缆</strong>，使得任何一台连接到以太网的电脑可以“嗅探”别人的帧并检查其内容。在当时很多高层协议都包含明文密码等敏感信息，通过查看一个分组并解码就可以轻易获得密码。</li>
<li>一个目标是交换机的过滤数据库。如果 filtering database 被快速填充（例如被大量伪装的站快速填充），交换机就有可能被迫放弃合法条目，从而导致中断对合法站的服务。</li>
<li>使用 STP，一个站可以伪装成一个到根网桥最低路径上的站，从而吸引流量导向它。</li>
<li>Wi-Fi 网络的窃听和伪装问题。</li>
<li>如果攻击者可以访问两个端点之间的信道，就有很多方式来攻击 PPP 网络。对于简单的认证机制 PAP，简单的嗅探就可以捕获密码，用于后续的非法访问。</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_protocol_suite">wiki - Internet_protocol_suite</a></li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_link_layer">wiki - Data_link_layer</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A8%A12%E8%BF%90%E7%AE%97/18556715?fr=aladdin">mod 2 运算</a></p>
</li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/liyuanbhu/article/details/7882789">循环冗余校验（CRC）算法入门引导</a></li>
<li><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/huang_shiyang/article/details/50881305">CRC查找表法推导及代码实现比较</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spanning_Tree_Protocol">wiki - Spanning Tree Protocol</a></p>
</li>
<li><a target="_blank" rel="noopener" href="http://m.blog.csdn.net/hong0220/article/details/17448249">STP生成树协议之根端口 指定端口 阻塞端口</a></li>
<li><p><a target="_blank" rel="noopener" href="http://blog.163.com/hlz_2599/blog/static/14237847420101124112234233/">生成树详解</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Link_Control_Protocol">wiki - Link Control Protocol</a></p>
</li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/xdsoft365/article/details/6335882">闲谈PPP协议</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol">wiki - Point-to-Point Protocol</a></li>
<li><p><a target="_blank" rel="noopener" href="http://network.51cto.com/art/201109/291563.htm">CHAP认证概述</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Point-to-point_protocol_over_Ethernet">wiki - Point-to-point protocol over Ethernet</a></p>
</li>
</ul>
<hr>
<h1 id="Wireshark-抓包实例"><a href="#Wireshark-抓包实例" class="headerlink" title="Wireshark 抓包实例"></a>Wireshark 抓包实例</h1><p>附上一个 ARP 包的例子来看看以太网帧：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/Ethernetpacket1.png" alt=""></p>
<p>生成树协议：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/stppacket.png" alt=""></p>
<h1 id="Something-Else"><a href="#Something-Else" class="headerlink" title="Something Else"></a>Something Else</h1><hr>
<p>另：使用 Wireshark 抓以太网包没有前导、SFD、FCS 字段，搜索后得到如下原因：</p>
<ul>
<li>抓 preamble 没有意义。</li>
<li>Wireshark 抓到的数据包是网卡 driver 给上来的，有些网卡 driver 会把帧后面的 4 字节的 FCS 去掉，不上传给 tcp/ip 协议栈，Wireshark 自然就看不到了。</li>
</ul>
<hr>
<p>查看 MAC 地址的方法：在 cmd 中输入</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /<span class="keyword">all</span></span><br></pre></td></tr></table></figure>
<hr>
<p>附上组会上分享的生成树板书：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/stp%20presentation.JPG" alt=""></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/30/tcpip2-IP-address/" rel="next" title="《TCP/IP 详解 卷1：协议》第 2 章：Internet 地址结构">
                <i class="fa fa-chevron-left"></i> 《TCP/IP 详解 卷1：协议》第 2 章：Internet 地址结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/17/OpenFlow-Enabling-Innovation-in-Campus-Networks/" rel="prev" title="OpenFlow-Enabling-Innovation-in-Campus-Networks">
                OpenFlow-Enabling-Innovation-in-Campus-Networks <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">105</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E3%80%81IEEE-802-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%A0%87%E5%87%86"><span class="nav-number">1.</span> <span class="nav-text">以太网、IEEE 802 局域网标准</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CSMA-CD-or-MAC"><span class="nav-number">1.1.</span> <span class="nav-text">CSMA&#x2F;CD or MAC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F-Frame-Format"><span class="nav-number">1.2.</span> <span class="nav-text">以太网帧格式 &#x2F; Frame Format</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A7%E6%A3%80%E9%AA%8C%E5%BA%8F%E5%88%97-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C"><span class="nav-number">1.3.</span> <span class="nav-text">帧检验序列&#x2F;循环冗余检验</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E6%A1%A5%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-number">2.</span> <span class="nav-text">网桥和交换机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-number">2.1.</span> <span class="nav-text">交换机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%8F%8C%E5%B7%A5%E3%80%81%E5%8D%8A%E5%8F%8C%E5%B7%A5"><span class="nav-number">2.2.</span> <span class="nav-text">全双工、半双工</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E8%BF%9E%E3%80%81MAC-%E5%AD%A6%E4%B9%A0"><span class="nav-number">2.3.</span> <span class="nav-text">互连、MAC 学习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.</span> <span class="nav-text">生成树协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STP-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">3.1.</span> <span class="nav-text">STP 状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E8%A7%92%E8%89%B2"><span class="nav-number">3.2.</span> <span class="nav-text">端口角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BPDU"><span class="nav-number">3.3.</span> <span class="nav-text">BPDU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">3.4.</span> <span class="nav-text">建立生成树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%8B%93%E6%89%91%E5%8F%98%E5%8C%96"><span class="nav-number">3.5.</span> <span class="nav-text">处理拓扑变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.6.</span> <span class="nav-text">快速生成树协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%82%B9%E5%88%B0%E7%82%B9%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.</span> <span class="nav-text">点到点协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PPP-%E5%9F%BA%E6%9C%AC%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">PPP 基本帧格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PPP-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">4.2.</span> <span class="nav-text">PPP 状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.3.</span> <span class="nav-text">链路控制协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCP-%E7%8A%B6%E6%80%81"><span class="nav-number">4.4.</span> <span class="nav-text">LCP 状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AD%94%E6%9C%AF%E6%95%B0%E5%AD%97"><span class="nav-number">4.5.</span> <span class="nav-text">魔术数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PPP-%E8%AE%A4%E8%AF%81"><span class="nav-number">4.6.</span> <span class="nav-text">PPP 认证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.7.</span> <span class="nav-text">网络控制协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PPPoE"><span class="nav-number">4.8.</span> <span class="nav-text">PPPoE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%9B%9E"><span class="nav-number">5.</span> <span class="nav-text">环回</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MTU"><span class="nav-number">6.</span> <span class="nav-text">MTU</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%80"><span class="nav-number">7.</span> <span class="nav-text">隧道基础</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8E%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB"><span class="nav-number">8.</span> <span class="nav-text">与链路层相关的攻击</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">9.</span> <span class="nav-text">参考链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Wireshark-%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B"><span class="nav-number">10.</span> <span class="nav-text">Wireshark 抓包实例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Something-Else"><span class="nav-number">11.</span> <span class="nav-text">Something Else</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  
  


  

  

</body>
</html>
