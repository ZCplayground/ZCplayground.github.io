<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2017 Summary</title>
    <url>/2018/02/04/2017-Summary/</url>
    <content><![CDATA[<h1 id="几门课"><a href="#几门课" class="headerlink" title="几门课"></a>几门课</h1><ul>
<li>基础电路与电子学</li>
</ul>
<p>知道了一些二极管三极管的基本基本很基本的那种物理知识吧，但是毕竟我是从电信转专业过来的，所以说我内心就是逃避模电这样的课的。上课基本没听，后面只是死命复习了一周，考的还可以。</p>
<ul>
<li>离散数学</li>
</ul>
<p>像近世代数以及图论这样的知识对于计算机来说肯定还是非常有用的，但是我觉得，学得比较粗浅，而且学习时老师讲的东西也比较纯粹吧，要是能跟计算机关联起来就更好了。</p>
<ul>
<li>大学物理下</li>
</ul>
<p>这主要是掌握一些气体动力学热学，然后电磁学以及量子物理吧这种知识。虽然学的非常肯定是非常非常的浅显，但是毕竟是一种通识教育吗，扩展各方面知识，了解一些物理常识，还有知道物理的思想方式吧。但是我真的没有非常用心去学，也觉得自己可能以后也没有机会再用心的去体会物理吧，觉得可能有点可惜。 </p>
<ul>
<li>算法与数据结构</li>
</ul>
<p>觉得学校发的书本上面的代码和内容都不是很符合我的预期吧（眼光已经比较刁了）。所以说主要靠自学。内容看的是算法导论，MIT 的授课视频。以及国内一些大学的 MOOC。</p>
<ul>
<li>C++</li>
</ul>
<p>看完了 《c++ primer plus》。这本书非常的入门级，介绍的基础概念非常的详细，但是我觉得 c++ 这门语言实在是太庞大了。如果要真的啃的话还需要可能很多书。代码呢，除了示例代码之外，我打的并不是很多。我指的是使用 c++ 特性的代码。我现阶段对于专门学习一门语言的兴趣不是非常大。</p>
<ul>
<li>矩阵分析与应用</li>
</ul>
<p>高级线形代数。我觉得大学的课堂学习方面跟研究差别比较大的就是我们经常去忽略一个知识点的 why 跟 how。就是为什么有这种知识，以及这种知识诞生的时候是为了解决什么问题，为什么能够解决这种问题，怎样才能做到的。在做研究的时候，这是非常重要的，而学习很多课程的时候，并没有关于这方面滴解答，比如算法数据结构，比如线代等等。而我是喜欢构建知识体系的。</p>
<h1 id="读了一些书"><a href="#读了一些书" class="headerlink" title="读了一些书"></a>读了一些书</h1><p>列出细读的，粗略的翻看/参考不在内。</p>
<ul>
<li>深入理解计算机系统 CSAPP </li>
</ul>
<p>这是一本帮我形成计算机大局观的一本好书。豆瓣上有这么一句评论说 csapp 价值超过等重量的黄金，不免有过誉之嫌，但是 9.5 的评分也体现了这本书的价值。这本书我从三月份看到了五六月份，除了第四章的处理器结构以及后面许多的与 unix 系统有关的，系统级IO、网络编程之外呢，我都有仔细的看，也有仔细的做作业题和总结。看这本书的体验非常地赞，不愧是世界上最顶尖的计算机大学之一的cmu。</p>
<p>国内计算机很多课程，比如计算机导论、数电、组成原理，都有提到二进制的计算、数制、以及原码补码反码的知识点。但是我觉得没有上面之中没有哪一本书能够讲得和csapp这样好，只有 csapp 让我知道了，为什么计算机要用二进制。国内的书，很多都是知识点的单纯堆砌。csapp 的英文名字里有“a programmer’s perspective”，整本书的知识点都是从程序员的角度考虑了，这个知识点在实际应用中的作用。这点我真的觉得太赞了。</p>
<p>非常让我印象深刻的是 csapp 的作业题的设计。这是我真正想做的作业题！很多国内的作业题非常的应试教育，他要设计一些非常奇怪的题目来考查你对这个知识点的边边角角到底掌握的如何。但是其实如果你把这种题目做得出来，并不意味着你拥有更强大的逻辑思维能力，或者说是拥有更强的计算机能力。但是 csapp 的作业。确确实实是能够提升你对知识的理解。csapp 是一本好书（我形容词穷了……），是一本阅读体验极佳的书籍，也是一本非常好的入门的书籍，它能培养你对计算机的兴趣（这一点我觉得国内大学做得非常不好）！！最后容我吐槽一句，这只是 CMU 的导论的课本，导论！！导论啊，导论都比我们强这么多。。有的时候我看着谭浩强就很不能理解，为什么不直接拿 csapp 当教材呢？</p>
<ul>
<li>TCP/IP 详解</li>
</ul>
<p>这本书我从五月份购买，看了差不多五六十页就发现自己看不太下去，一直拖到了一七年年底左右终于完结了这本书。总的来说还是一本不错的书，也是我网络知识的开端吧。。我们实验室的网络研究方向是sdn，传统网络还是不能不懂的。说来尴尬，sdn 是一种为了改变传统 tcp/ip 网络架构缺陷的新思想，而我在看传统网络的时候我经常觉得这些设计协议的人非常的聪明，这些协议非常设计的是那么精妙，怎么这些人就能够构建出一个改变世界影响世界这么大的，互联网……每当我在翻动这些书页的时候我就觉得，我在触动这个世界上多少人智慧的结晶。。。</p>
<p>这本书给了我网络很多方面的知识。但一开始啃的时候，毕竟网络对我来说还算是一个当时来说是很新的一块，我卡壳了很久。但是最后我慢慢慢慢的还是把它完成了，所以说心里还是有一点点自豪的。这本书的中文翻译不是特别好，可以说拜他所赐，我又阅读了原版英文的很多段落，并且在写了一些勘误这样的东西。</p>
<ul>
<li>算法导论 CLRS</li>
</ul>
<p>这是暑假的时候准备从新学一学数据结构与算法的时候看的，结合了 MIT 的教学视频一起看的。教学范围之外的很多高级数据结构和高级算法，我并没有看。CLRS，的确是非常不错。它能够给予我一种，数学之美呃。其实一些算法后面的证明啊，或者说一些里面一些更基础的知识都是在课堂上没有涉及到的，但是在这本书中他有讲到，而且用非常美的数学语言去表达了出来。说简单点就是给了我一种新思路吧。而且我非常喜欢这个这本书里面的伪代码实现。读过 clrs 之后就觉得，国内的一些数据结构书，用c语言写的代码，和 clrs 相比其实在我看来是不伦不类的。算法导论更加的着重于算法本身，然后用伪代码的实现了可以更让你注重去研究这个算法而不用去关注编程语言的细节。这本书里我打过最复杂的代码应该是红黑树。当我在编译器里面调试我的代码的时候，当我一步一步执行断点的时候，我好像觉得自己像是一个拿着手术刀的医生一样。当我看到一行行代码运行过去，变量变动了，我感觉这个病人，躺在我面前，我能听到他的呼吸以及心跳。我在触摸计算机，感受算法和数据结构的美。当我找到那个bug改掉那行错误代码，运行结果正确的时候，真叫一个美滋滋啊。</p>
<ul>
<li>计算机程序的构造与解释 SICP</li>
</ul>
<p>只看了前两章，希望新年接着把它看下去。这本书，虽然讲的很多东西，我当时仍然觉得非常难参悟，但是有很多知识点也让我印象非常深刻了，比方说简简单单的基本元素和复合以及抽象所体现的威力让我折服，由此非常佩服那些计算机科学家们的想法。在还有就是。无论多么复杂的编程语言在计算机看来都是一棵棵语法树，背后的实质都是一样的。简单的序对就能够构成很多已知的数据结构，比如说树、还有链表，像类似于什么求链表长度、求树的深度这样子的函数都能够用看上去十分玄幻，但细看十分精妙的几行 scheme 就能写成。光是知道了这几点，我觉得都已经让我觉得非常满足了。</p>
<ul>
<li>构建之法</li>
</ul>
<p>软工是大三的课，所以我并没有上。是因为邹欣老师来福州我才看的。<strong>从书单上面来看前几本书就知道我是比较喜欢追寻那种计算机科学理论细节的，我实践方面做的算是比较少。</strong>读这本书，让我明白了软件工程确实是很有必要，构建大型实用软件，需要多人合作，也确实是需要软件工程的知识点在里面。</p>
<p>我以前有个想法：软件工程的知识点，我进了大公司之后再学也可以。我把这个想法跟栋哥交流之后，他跟我说，那是不是 github 这种也可以进了大公司之后再学呀？我立刻就懂了。</p>
<ul>
<li>C 程序设计语言</li>
</ul>
<p>其实这本书是一六年看的了，但是为什么要在这边提呢，是因为我发现觉得这本书是我看过的c语言书中最好的书，而且我同时发现了这是一本在技术书籍里面写的相当不错的一本书，以至于很多其他别的书里，作者都会夸赞说是 K&amp;R 教会他们写作。例如 csapp 里：感谢 K&amp;R 告诉了我们原来技术书籍也可以写的这么优美。</p>
<h1 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h1><ul>
<li>钢琴</li>
</ul>
<p>业余爱好者，买了一台入门级电钢放在宿舍里（16 年 11 月）。起初是看到网上的弹琴视频非常的喜欢，还有小的时候家里有人弹钢琴，但是因为自己比较调皮，并没有学习下去，于是找个机会重拾了。这一年，弹琴的经历让我有一个切身的体会，如果想要做一件什么事情，这件事是需要比较长的投入，那么最好的时间是十年前，其次是现在。因为需要一段比较长时间的努力才有成果的话，如果你迟迟不开始，那么永远都不会有成果。我最开始弹的是一些东方（自己在玩的游戏）的曲子。后面呢偶然的听到了德彪西的月光觉得非常的优美于是辛苦的把他练了下来。这是我弹的第一首古典音乐曲（话说德彪西已经快算现代了吧）弹下来了之后还是非常有成就感的。但是我距离专业的水准差距肯定非常大，只不过是自娱自乐吧。说实话，怎么说呢，就是其实我发现我干什么事都还比较有信心。确定能把它干好，这是一种不错的生活心态，畏首畏尾的并不是我比较喜欢的。</p>
<p>喜欢什么就去做。</p>
<ul>
<li>麻将</li>
</ul>
<p>社团活动。然后这学期基本上很大部分的休闲活动都是去打日麻。在了解了规则之后，带有竞技性的麻将几乎是立即就把我吸引了。在年末的时候写了一个程序统计这一年的面麻数据，发现自己打了七十多把，觉得打得还是挺多的，明年可以节制一下 233</p>
<ul>
<li>游泳</li>
</ul>
<p>今年夏天到国庆前，锻炼到能够连续自由泳达到一千五百米的水平，时间大概是一个多钟头。</p>
<h1 id="实验室-and-科研"><a href="#实验室-and-科研" class="headerlink" title="实验室 and 科研"></a>实验室 and 科研</h1><p>新学期栋哥也发了一些论文给我看，我觉得我的英语阅读能力有一定的提升。但其实说实话，要是让我做英语卷子，我还是做不来的。应试的话，还得补语法知识，词汇量，做题等。如果你把英语当作一种工具来使用，阅读计算机方面英语书籍或者是论文，其实使用的词汇量是根据你的话题来的，比如说网络书本/论文上面一些特定的名词会翻来覆去的使用，句式也不会非常的复杂，说白了其实就是如果你经常使用的话，那么英语会越来越简单，用的越来越好。如果一直拒绝英语，可能不能真正地学好计算机。</p>
<p>入门了sdn方向之后，跟着小伙伴们到武汉去参加了一次sdn的比赛。其实入门这个方向掌握一些基础知识也不算太难，但是真正的做出科研、做出自己的东西，算是对现在的我来说还是比较难的吧，这也是栋哥对我的要求。</p>
<p>给自己许一个新年愿望，希望新的一年能够在科研的方面进步。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>新疆见闻 2023</title>
    <url>/2023/02/01/2023-Xinjiang/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d9cbff9aef43475da5ee1b9f4042c40201af0f76c94f3595de06e5780aa99610">7fe911b2c901abdf7527cf489804ba2ec9842799a2ef65a508e64d1ad8814ec908836ce82205e4d9478fd05e4f338f28b566a000a5708a17f65118481cefc5e92aaddf0bc4ecedf6f9aaa3be1e3fbbe2ec47611ee812b134c3be9cc953a18d57c153a0a35410f3196262354517efe4cfc1201840b17a497c2d94dc07558c503536a81bfcd5d6d666594fe2ea44a700e8549cd219a4af2ad6580bfad7c9267d37f0c366ad436effab94fcb24a2e7dfdec8024b45a9b0a0d8099903c78b78483b5ad927499ffc08e733a47ab384a06abe2620f4f6f90ab209de624c0cd88e4fbd7a0ace89363c42c23a9866312038ef03a3616ec58ac390d8af87fb7acc955ff2ba351c0a5e610cf71149715f68aaace2f8b110bae9ba185343836bc40ec5c4b1e50fdfd7e0b024007e1972d322d073b7f59bd024f9ceb4eabccd7504422e275d5fdb11fc873596d58f6f5b73d91c4715274be157284d8968b872186c4887b7984ea15aee883d22f32db12b40f92a06fd37b7fbff2103f458fc3fd853446b9fa0559efd857654975b7d8be00175db46602e9063884be068eea1515431a030bda334dd6f0e41a597f3bb86c8913b63a85bef42ed0ed50c4a1e0dbdc02de04a3cd429d995d2fc365371374334bce93c484cee2614e448f30476ad89029503fdb9908c76b74980602e3d1f3650d794ab05293a232306431ccd849a07dbd3913211a15c04c4d02e251a9eb603e2f9aaf514bc79a07b82ca14e031c932e8d17be3c0d1ceed640ac0e9f610a13d7be1ec9ae1079d7d3cab0ad61492807381e46be96df5431059bd143006012dd375d83c99b2f34af009fed138ae8c073ce38ab6ef987466c770422cf600bccc815b87a2dcbd22198ecd7ee02ccc4cfa75e1abeacced6c4b1dfababe9f3a02597bdc5601a9d43dd885433a07028bc4ca3bf665c0587b5994c8e6453484e4163548a47ca94d4578c3ec0654faf1821b6a925a931e5b054eee50e5ac2b67dd5ef7ffe21486160c3d17f0b8381c3401dc86abf9bc87435e02cbeed68c4440acc96cb3c603804bcd1ac84f4f10beb39a2592382c0fa91978e672ea8264421778ecacbed1ff3730968cadb11e7b749fce291d4bb9b6a4e858460339ad74510c2bdbdab8d944b179a8117bbe9bffed57706b222ba1737a6015767ec79b9ea7f51118c2071e2e9e1f2b926bd3e5bcd295811ca89d30932fb8899c88ba8c2d1ffda6e58e7bb541d775801ae20b43fd8327a98013621350cec9e438461ec1813be3518b942cf6f8268d403353000a42bba981d50ed73223dfe8ee43cf218847e5ca488389f07f331ebf72ce2b2ad8ee5ff1bf1bfdf898245f5b0b820533e02c0bac90d3972ac17963b43703e75df366f31251c901e1c5b0a01e1fa402c3cb80b9e6f07c876bb05f543be08d91857ec428748a83bb377ae9bf16e7c271bbc598062a1116d03a50def7f10c9140b414faefc1f1fa84ae49dc32502c301508b491737d7d92b554593df6992864fc8d67113a9997011e17cb71b0e4806d020ca19c22c600f8d8e746e9096a1114bb43428e810da724900d5e2c464c22bdfeef6c0d2f921206e15b67b60473469a0ad02690f396f33af8c78166ab5faa8be7c309e9fd02acf9d1ebda78110128f3a8c546094e1453103ba0067a5f72ad833878cc34c82c512bf23cd34a162529e7ed0fb62860057e700265cff1736c70aefa5ba2ee927ef143b4161f8f1fb8bb59dd3f57e8461d52540fb84d19c634a376bd70a82bc678200434a130bc9139bd8badab97f0302c2a7b6d73880f7df288c935a3eef2afce4dc0a669954198c2448bd1febf9f9e2691c77cc650d7832ef300234188ae0f1909cbbde0ab2f50f464125a34e3151d8b1a9709786bec38ba437466083efb2d5e18aa3f07d2d55f4b4ce3bb74265f76935037f31919a69c03c7b5fcbc240b83482987e699afdfafbcfb2a34a73dcdd55a5505c22bf148113d74833cfd48fb724657728cf98dfb14fa423d185f99b0797e82132a2e5066864073703519e99d48183da2e69a3652b9d9c019dc2e6e3a5b6086337e0f63fc4ecc4dfb5f47b59c15d9abba08731a52085ccfce1ea634a1ffc056cf45ad1d611b8e4106303a53b985a03e86ca9c5099674197b5456050e8546cc4c65c26742bb679b03716ea54dd1f91cf17c8e275fd2d4e14427581338faca531989052ac066609e14b4723f435941a45e061a235fdcbefe1e3cd61bf63180f384abff01277d2fc2eb2274237ad35f3b370bcbfcd22b9bdd5755e53751d0684f06bcc4a23a3284d9eabb4ab8979a9b7d9368240d54b4f61e633aa212da3c6569d245508bbe22b3066f917bf65e0892fb4e8c6f93adfb04e15f241b02c945ec5b10c735474dd9e67a0c8f1cd1e828625ee4e57ad69986e51770059c91b3e235548c65bdffdfe480b44313850977e5dbfa5269b73e5e5a9cd21ab8ef5dec1fc0bf21c6e3d14068c65345a448cba3ed3c8fdec5472a401c9926edbed0d372e020945459a4c4ac8cd4ed3ff6c14f0270b132759b73857bf458af16e6368bd7d5cf64537c9e808ea5741b6ab932457b4413a7de8bb1b4ae3ac87f4ba4f5c0237f971473735484066ad43ac9370136f5e78ca3bbadfcdd95c03a6738a7e0befd68209de68edbb6ffccdc70974aa3fc9fa7b20cfa400f0244a68261f59a74d3e026b3edbc37859f0ab2a64a15fc09f904d82db523487fe74cfe41244917077a347210c62c409b95d54c8ff6eb40a7e28b5825c1719a7cad2813e399d42de12af2456d82edc3466c9852fd51309a8f9f9de064cec01dcaa1851cc763a9ef8d1b6c852a4410b80627ea1d471fd04e7cf4ae31267b86e64d8d336a24664cc4aed0260113587f10c56739e84227b0677130586bceaa04b1622155b9ebef468fa69e1ca0846da63f2ebd3bb83c455a3ae10db9b04c564b22453c0e2220a7ce096a5a4189e6688ad848b0d0114a6575b8f091851ffefe744f0125ff5271bbbfddf60fc511f25ac97e2d8d6c5802b6ee8404e9948dbbfb0628ce9321a95b6edd0504cb92526eeb97f13977e17e0d43e6f6d34da1d1e0181b7458d742580532b32d9994928ef7a271bf19ec6d49cefe200fe7bb0215740227429158cb359bcb2eb94344939c52e6a9ee5df1f550ffb10168bf20a2431008988c474da1f28bb585dce8006cde077c66ad085038251c99239b6cfc6292efb154032e134d3bc7e13f12837ab55cc2ac9e974f7a7fbff727930d4376edb9aa238093d0dccba97b2a52b2fa72e4e4d64ed6ae70c07c0912ea497062db296cacf1e1faab9c5862144f20ab61d24a3a647bf63ec8cdd1b0877277eff5c65967e7bee1f998658e0418c09fef2e80dbfeb787416a95713da8a3d3b3e15c8d813443c4704a0a9e0646d050b45f853f7534f135ccfc9b69f69afb52e14a71be2f464c655f3dc797e3b526b801686de90266f5b114eaf6f64ab5f18cb21dffa36dcb48b2aada62b56d4a521b41b97a9c8c26c1dd7e15a7227ad5d20659ec47e775fa928fc4e56076e351a25719fff18913d030967ee9b1068ab07f12594aa71476dc64af4ce9e4b8907296598db30a1604e46443239b167f14b4e35035d81d8e2dc31a0c6d6d4d8e58722ae2fb5b633ec6944bbcb788b793856fcc66c05e91c36c868bfb99d8c20697d33b417ffca8713a998a0e2e6769658673164d403fc6ab8d1179a0993f9b196914e25220b1e2ecdfa7afd4308d483043a293b42e9aa914d325c74887d87a1b5af274d901014df97491900dcf50f64c79859ec837c89a3d60567176f2ceaebeed2078b7b3781213ff9d683c53ed227ebb922922776e793462000bf56a5be069ec7002779b384d70bcf37497d41cca0c8597a9fb05cb5bfe86d2b98abf5eb05904ea9eec1e415cfcd899a82b3f46a30bc5d012863d870921c3ea99fa27d3e596cd9cbb14b3f16e3b43ba80113ae22254c46857bf80d7d73ca9a25b2047686fe37ff0467dff8b9247d59b4c5799aab98c03cc96409c166b5a2b2f94a487d4be634f4f15af467ddf8e6d149dfa2ba2bfdcf21d0c93a4d2d7a0c20441b1cccb89bf85d105e55e6875ad1791115127eafee91335d088356579ff5a81492c414108e589e13016f0531e91458079a2d0826225f8956386369a1604ec49a4b5d9bef035914fac94e36ecec82ab910ec5d3e1d8d86c5e430a6d36cd2d1e970d0930add667abb95037ecdc9e6dc1be812ca2d8a168157588b1669b01e0f4e9c667c09eee6219475e6fbcf2d278cfab8922cc9fe72abe639071c37f552ca0be73a65c661714049084f543d00c7632acb6441ad46416a7f283ad3b71cce5ddaef5e71fdb962c074d5719c3cb4e0b7fcb29d100e7d9dca90a401507313dd4226bd9936dda0be21c0ec05d453ee551fd898004e1a39ea5a97d08569ea45fc9ac2bbec650c0af86590dedc66af373bc5ebe27ab0d2d8bc9a4dad359cc95d2f177f89d4d364566d35d74dbf88c4c341f489f4a3b86eeacb2cf8b4cfa88f7e4d794722eecd12ef48b356dcdf9f6f7680a5b001409edba2efa8b188017085cd96bb4f73d43c8fd2a1bdd09a53a7df21c87d41b708a5c35963d73277f37fa674096fa53ea0965718f186b332188a1d9804951f0061f19949847afc6f19ab64806e9c79e26a22736de5c01bd3bb6f684c09c06d6154220579108157a8f49f0f003cb044c80431da5e2b5b01ee9cf9729dd9e004fae1149531b22076b57fba3571961f7a7da950d99fa1c13689e6243e66cfbb165aa5d09f8ff3ca94bdfd232cb5c4caff840252d8217f9ff06ea59707542b69ed59cb8766d0acc10e2c1bb180bb090ed07961ac885db9dcf747df0ad900c0b754041e0f4f7d97e726cfa7d6743581cb7de0cd9e49f960ccfc2e4574cee086b18a9b1902ba1a1f17f2e63070c050de7aa926a0ba86618b07c5d19cf1211099a5bc61736cf271957bd169c8ca34b069a4fa0b6e11f181be8f57c0ef446e51675e554868201073a22f07b1721aab3f31670be40ae79877d29b50164ac6c3af7513f38c0e657c0977d4f2ed2afb68b2f99c4ba177d9a9ef8126636a32629720da45cf6947e7bfbcd075d6eed2b9689da47279e2a76e215f9ff86e06d12b46d57733297b32ab56f7e3afd59dcc6b54955932c43f557eb408ff54378b7bffbaeab537df890429ef8fc50ec1bb8ae378b8fd8a03627a93795c2cceee7c33af38b04d0d38549a6c1753ceeaefde3098937798aa7d5b9c08dfd9873ecb879d8e12ee5818faed6173f068d991516953781c6ce825d34df121dff678cd7e687b2cd786bf94ecb29d1a8192dccc1eb60576b00e2654d3816b28a8e033729f3db7eb25c2a596837110005c2291473b702ee8c111afacd4b20a66a074ca80b89041a2a66f1f6f484be88c9d76f4609b8ea6c61617f25abc9c11e6cb7c310c7de7f64a2aef44711a9c69070b81736827f2c43a1c1802e27474673c60f0d118f9d145e3ad5400ebac8835b34276c87ff87619bf9e86fdb649d1673074692f760f4aa9826b85fd690a275e870ca844e8dc406cfa4e14a81f2e77c9a306549675e72002b8ed71a7a61f28bd09b7361b45ba2a26f1eb71954c448abb24ae51a398459c4017e4c907a55958aad35b55a605b3556fb9729c674749f53fa2a04e93be5e495fe8183f336af8e4b2b5fdd567f9bb221d37e2e55ff4b5ff9d4a385ab49707df4eecf630c9518b38365b4eff1a676bd2464034f937ab3c83f1426ac46406f976304ba1ab65404554c314303615d1b253d2a0d81f317f5234d51723dd503000f46fd25c4b55ad07cb54abd4e1f8019a8b12dc3b599071de8c5c70688dff671e26f8caaab7e58ecf29f8316aac52d4dbc2a746c79728b4f80eebf095204fda32ea44755ba5fa7c58c7308f32da1851d302e5d89900d73e0cd0f710fb07c7acc3f60d8646ec55ade362de8db091d9e0e5d5c093410cab9b52bd535887a81cad3dc57f1c53897bd43cdb669922ea8190a19770bde3c2d84556b7765ce235a06227b4c8aed6aa85c82e7fa6033a37a7e7aac44166ab55f495ef36d9e358ab74ae0a87bdf643685291d3d9fe16a08ac79c1580aa5fc9b44f84f68c4cfdf13a79526beab0901622144fe579fe798d5acec6d3b9271d2c7362471a41c0b0d54ea4a926f45fadc57d2bb057b6be720cbb5a1dc2d342bba8cfc2b8c78b56790e38621ea53adc753866d2f14bab39a20af978e7a801da190640231b9816cb23d19ec5a470aa86fd3ee6f15291753d68858ef0e18759363c34b5f8fd2d12ed85e8106d1ee9e04603988202017f97226bdb03cb48fe62415e30a37fbf78566a86f0acf417038ee895b3636206cdaf117d787096bc494126f783c9a86dad945f33659f81b09b70ab8edf8ccefead908e15b769ac040e784049901b0667b302dc257cd334097df1421f6970a3c818a3f225650686b0a354d6b8fd011a07ca59b588dfbc835b7c7b5b451a2517a26787b1617eb61c9f334512f42bc3a6aa39cfb7259fdfa61afe4b31e5afaf9f1a38c39e7494056e749f8833f721a5aed769ccf4f9d65bd9d1572358451387c0e6ad5e8bc6ffc74e796d91d245fe636683ed67eaabb31061e5987040774c8a7ce9521f2e2d3c61c998dad08c28cfb9128877a7b4cf8906e37a827d52ed33fce6cd700bca54460147e944e2f36bfd255f8199e0ab57ec67bbcdb30cbcace3986993483dc698a59b78fdb85d3f2fc5a94d55ce6a6e37d94392fccb77ef030343fbff86d3600533c8d07b3958f8244cf1d4198d3274254ccfa130aaa13d95ec7150dbdf6c4e9e66685058e1a9e105a2475ca2032f4851e8cdb0e8da63f4db9ea7bbc163492b5e18a9872a1c8d74f32de7727fd4a5b2a985c01f310f6a276c1cf374b3bc0aa61552ab3f173458793a0c9a1b0d25c4e776563e9d2d30b9451d2bad5ffb70c20e3a1492a7faa8556617a3e57fdcc3aa99b0a3d77dc461c3f95939a35332e8a73cc41689c661cc134703fd7acd44eda3a4ac1ca90285a53ab3b6303ac326114f1ad6e638347ed1f8511f4c82594339112057a6ed9b683d0495eb9a2ad7921e594e266dec0492f0c2db4555f913bd0958302d72a57392edc0556c8707e3b769f8ab506a6ba9c9aeae4459973045c672eb5532635ee55f54c82f51895d4653cb43424e14a195ccc0fe2259576422170ebbf3a766142686f9418b1926a1c8542178787ed9f8ccb2d0d9cc198f502afa7816aebc9f9d9fc612b8fd25b739b9187b9e408fa3246d9794482044bbfbe4cc919375ed91d567e3a015f3db2a37b34290fa11ef0cd87ac8662b040faeb1dbe78f99520b1e4e03e7f216181a024e126080f18dae1ddcdef356e0f7bcf5503c84527a9a8c5dc77075631e2fa4f35fd7d80dbe64b86c307d63a3d22afad2a6b27b410c5efe0f48fcc5dc66ef4f5e84b2db15c5beecf61b5f3b02dd1995d06a30895163a4ae038cff34b850da3ee3b44a675cb2886b67939e103414a397eae7e84f70e1a2458d05e0a1b79abbc39b7be4fafa5576a68830fa5baf7fc854785a648beea4ff98cd55c76e9ffdcedf3c576480e511e8e299ba10bbe5baad2e89bb8ec4c49d0cfa819d9dd71077db452eae020beebf85d0e96162689be8bede6c593889d4a92fd515306baebbceffd1b1fd830d781f8cb5d7cd9c6619df4e377ae5b6351d05cfa97e66c10ad5b0bb5f36d148d7b5043f095ff3d2f2ab49bc77d825c3cd1929de9e6657359a2cd41f20d923bdb1e67d9828033a91ea0cfe76dca940db1e77f4b44c964d855ebd696974e9fd5c97ec77d900654bd24a9563fdee43b5bebc2d236a21559f7ea6aadd2324262616c460e461d218738b968d539161b7944b60e9c8c00de92289cee5950aab43c2898e985a4d41294c6ab549a9e61c8b5a9c22b79d87e878103cd5127217211418cf7e57a4d94dae9f6dbcb16e8dba603b8d4d3f05cc11bab71788ade38e146a943bb8d5903a18c83e13a67e23d7bae05ecf33207c0f30b4f7edb653a2d6d62cac9844287fa411f620e88ed9eae5623f56937567d57045b92543cff11220d01433deb351ba028aa4d14a509fc83ef0ab38d9709b2b0ffb1c58afada6e46bbad819c02a8273ae0cd4d44c1d1d27d3123b001a12f9d8b3305ee9c8f5d0753635069825c252ce7202acf9dcc5b808e286fc31c37257ac38131f2c77a349e31016320140d4f6cf45690d8bfb85ce1d3033f815d282feea4b9969723ae407b313e695c20f9a8934d3eabadd0a55d4bd5f29f99617b7ef6c803780c96f8df1a4077d51d6f0934504711581e71a88376a6fb89ebf7c6d9019f3133e8792934f75323865ea269b26fbc6d7e487dc1a76b03ba37a3c906bf4f4f9cb3f468acc8f1c6b7cd3c3bc2681c4235497746d7f70e900ea92ebb45074cffa4f00aa22c74c1f8dc74f1358e940ae0d9bc861ffb3fc912407b2052dd231b00a7e0fd3d280db7468a8b292420cb7ad91c2515a020a89cfa7e0e5d1647c8bb2dcdf59bb0f94cf48966ca464845e8344e236394f02c898914878a0b0052fa6a2ac8dcc1b37b88de40623803ad56989ef838ddeaeda4177ddd6e99d9c1ad5cdba0bd3bc0eac9c7f3f627735e6072b594d8e889b72e51649621088dfea22c4d9f39ad7a620dae43454a4d615f461d89932e25bf2b335a0a09091fef0fd7c2417e578431b40a1abc99acfe2250f96dcf4702c317ff207f47b456743a9ab054b5c458334c9017d787d922634543fc6d29b83d9d0fdd04a3b0c9978a6cdde213346473245ffb465fddff178fa0b0affe740ef634afc7015da9403c2b40d5e15272a41ecd66319cf82d25e97159bf33d842758e759c34aebc2860d6265c7b264683242420787d56ecd131cbb9f0093227c0e8dfdbd189fe140acdb23f02ebc19022314abb48b200f97f95ab677af860139c3841a12ee6d1b720912ec2906e6a50405981ab7dda59458ea3760cbd9da792a815b02948808ac7cca5b2ddc035bcc263c701ff00c241e86b7f7097b925e0f1c11adb5ccce47d4f8b1b4565496368fae999793ecef6da77be0f1c10645d72b60facdf35582ef303e50f8d655b681809dc7e253941ccd773067e4b8790405f63eb823142d6e3f345b76df25bd7d9b433e7b0b0c55cc32e81035e8c348d40566a52ae461c1dd328d3b3880eefc1fe5eed9aba54e0946ccfb736f22694344098d16e874ee77c5c32c2e6176633996d7746352e119285f1b86ae381687053923266ccbaac099657f857d2aadb9b5a0e2374c9ed3d1720c008010bf154ae6d0116b8a966e336d23afcc28533822be50d7b93d09cd77265aa1dfa3cf6aa8ebd7b7a64537b11a67e0a56f66a67f96e81bdd1b81300f4f3037ba8f44ffe9ba5a576db9ed09395ce7a368f397749bc53fa7ef7b3268b71416f0011e29850da5a456e3d7f599f495fb7310dbc38d792772da4a6a2218c6c129f56268e6c8c9fbd48b288c932d54839c65cfca37abf6fa2952dda746f6e226a20d2ee7f792afab7e7d10d23ba812f77390dfc9610d20a9670c8bdd00f01782dec9f15976cede277b9642d66dfad69176300d347e5072070ddab69bcdb9946e13a0d89b3b2e2bc7f8e9b4a4aec9601a9f5d26795708934b7af7f1399903721c24118f3333ddd47830f2a6ff62e688f0ca803e15dc5a0fa8e36ac99fbfdfd3f8d94bcee74aa02ea15f702ca6a7e7a08bbef2ec4c1a2d5e2bc3e7dc01edefbed8d24513f3f85f1364697166e12741b3d627dc286e9a0137eadcd59045e121f289c92f0e9ede9d8500dfcc17bb68170d4cbbfb48e452f5b0ac60462f38fed08f27d18b02de1d90636b5336d439985f3e213fee63ca44938a1299b0e7f3bf089785239ccec7860d0a68b2567964e266bda4900aa01d1eafb2099b6e92fa6535694aa5b4a06ad6b463a62bf953c3bee1387229085da9e89085f997ac97860ec54be3d2d4ef1751e30e415eff8b943daa6e3bb8371f0f45c9530b1ce0daad6361e8b8055efea2a42122023f6600a2a0704c63c1224ecf274443cb58a247eb8f60f65718d4d780fba5191869c9f608c8de95e194312a7f605144dda7537f3db8d4cd62d520e530c3a446999eb29c4c35e1143ccda1c96b7efd3322b92533a8496fb805b2d64e3c6d2bac787a7c7ebd59c9bb6f9884745a6265fefde210ceaede4e9920cc153a4e8904b5f484d85f49bbf426c58ddf05558965bee513ee96d1210c19d381d46fef048ad0a059ce7df6247fc186058b70820dfd72c5006cccbcd451f2a8d71c416658a96e1e991a339896f9941a7e2a9a2ed54a170e2c5b22a22d3a65d1442e1e1fa970b4ef2729ca0894974d5b3505d48f8316a145aea6b795dbee1e18c2d9895809a07e5092bb350895997209d1cec35360af0836eefbba3e66452b0e6902c987768bf26776059ea6294cfc0d6f61a476cfa385fdb7de78fe14fad8e2f39f0ec036cdeb25f4bd343d488a23652a76acd0d2c31d85e03203ef07a94b8488ae2bfe664461f832f6cec59d69e5069267e8ebce0088a146a377993f4bf56d0d06287bb31c08cf415da18988381968df5cccab4a082faff85e2ca42f60160c70ebfe7fed1cc3f90b194634e04cb6b8995d2d526f1e27b381104f4c3a0d93829ac51e7bcf1181b7e5efe1765c4c7cb13fad809222405f4a15e2c5b4dc6814581f1f25aa291ff06f1c26aa6661336d6471c02fc31765f122a1be29b7f08f48f76fabd8bd8b69b5e917aac72611944855e62b269075725acb0a0c74ba8442d2cbe478ce139279d86210473f511dbdaacbe73fb899afa83dcfaa851c75a9d740def07ad70da3f25393aa81abcef32340892646b7cc2397a06bc9277b55b811b58032ae53350164b601a07c2d14be37a4519d20578209392d2c71653374e23fcaf7022e73e41e9ad1a3ae3a5d5ace1fb930d2381a6661f7c1de6d6af66f363161e61a56125ac87bb0a11e899ddc813637083c2fe561f3c6340d79748728288659d62ff07a7060689d589e2e5a62144d725878234a31a40ed642e61225e76b347b01ab2008ee5b3bf89c719694f448dd2243c9851b7d282d5aef18ddf9a11fbb36aceaeb8e64d1c946200308ed3a9bdc8c4569bda2de7fd580e4090d2cee919bbb9985a40f6a7c45dc83655e9157d7420ebac4ddda687d61b5532854081b857ed88dff5be4afb4d02c16327ee9512dbbf417cffb2c567d6c5930e8308c17aec64f9709105f51dd543be92e1bd7c828a5cf318a2ef3fdd2ac6b660442c75b05a602f989fbb2406cce4ad39b452709e9fefccd0ec51feb56e6b97f144d8981a6f43865b17d130efe264df6eaaa3263b53808fe23456339630c995ea8225a32169b450ac2c369d7b665b33849561cacef9377dbb475a1536732b57d20385809931c3e43f5066fd947f19ca4efcfdb4d8eeccda395373715d6cadff2f5dd49e118d664259b2a9264771993baeee59a38d19d3e11440245b43753c4d953969158a6a4c64640727d44f554ab60977e9e412bdd47e37729a75f4203b4deca71eac54fda4317835ead505f978c1328d8c0155ea870d4523915d746f59d7c89422776b85823c22906c76c7e48e5c28e2e437aece18e5ad25520a0322e787442099246cd10b611eea625cbd3490e5fbbcd83c04e2c197a7fe926a60c39a27647ab0ca28af6daabb043de57a713ade31141b50ab97efc2ceaa51ba9ca3fdec9fd77fa46e74d34d17c5724174619c5761ac76c513943165cce81198b4eb2c39920147087a25a0e1f3474936fc288ec953bbd06c7720d04ecc90999aef0d7b2fc61238d9283a506327bb04d64cb0709f1b5bf2f85b316880f80afe9b6787b4bb5b68d187e57d6dce62941eeba0bb52f47927d0e852990ad6bca9daae2f9b33799f581cc93a5e260b1c9965ed101864d58550ec98a2e6fec33246d32a5cd62de2cdd50d99ed1238bb64921c306e945f88eb186bbd98b6e5af1c393a8475cbadea45da29427dea43995a14271ec5d65eb36b3c3251a7e107d2a2560ae638b08a2a057b26fb402a42afdcb365372ac3265c215d16e4ffe147043b8a414ea8d28c1eb42ca2bbe9695d8ad3af3ea28ebd932042f237b31e477b4ca23eaa8e689d7809d5e97a01dcac51faadc805e66e8fcf4d61c46331b3cdf35f02cfea9d34aab55348d19943c71b020293f7295e6d360f486b2dca61d31af2e4253254f39dee5c7419d54e609738a3b8863fbaccc12f1f51422d28e5b20d2a42a425f138e0ac881bc3c201340d18d7c8e58f7ec92c7010434894ce989194f7d89d4f99c63b1cc016d9b4660ec1eec4f402f9a246a5cbe497f546d8a1a79de28b4358c5ce56c29b4d718321fd417a6e2a6b043e3bd4325b6def62adfe1741a9075c6e225e08ddd8b0e7106bcebfd632a5084cd1c729b29e4fe38c63847c1b00d9c0cd9f579122fb2896ec0db6f163cee103e8416211d7e8856a191b03a81a95a88948ec7a28814638330309c12a215e3f928d3e99f2ce165b966c2302f21683f6986e4aa0ccd7b48c7c889a72652f694259eee4346258ecbf43135b8a7c4cf2c2a50846cf906cfebc174dbda3e08be35a7f431685e83c5a7f1537672dcb7f246dfbe25f95d7220875b963b85fd3443e35972830407ff912c823d7e67e3f071fa9305b167ae5cb831ac303f8cdc5d0e196b987b35606bf9ee7895e15ef2a240c1457ae44f891247a8ef8709f91d5a336dac6cb98088830be9f8717027a93f4b18922124504f978fde03ad1bb112ae49a07d93c7c093f001f8ae27c8e4afd25cbdd8f3656092583c0217e43cc30c1172372b25ff3cb902a3d81a7439443b62611bad9ce10d38c9e077199cfdeb924083882bd782fce358b40501d83618a76bfdca3c7f33c5f65b5277848473eb7d20876473efe18c19761b7cc661cc746828bfc2147d94d8849280a17dad0c8227eb4909c4193802c6e6696f7567c5012a94b6f7c869d3c2ab12d375cf5a0022d19a1c8a198fd2d458f33725d99a947412a010ace011d652a7960b62d2751fdd1e4df06e489b2fe397b2c6e47146af3d8f25f17557665a596a4ff7f12c6c20249a6df976a23e9f6476aa9b873e1e1c134e62df16f3b2187347c0957955bc888549ce9b496cbb321a621b0a056a4ea52cb3356389d7ffa0d203360461f14472c3aeea950e613f12369bac1d63344557ad1f5e5c42a359d42feba0f9fbdb887abe07276bd047fd2ec56651d5e1a80781b7f65b70498cbf2f599096e303043d1d70a4c205d66a917e0fa8e1b115d33697944ee3ecd4f267773581cdb312dfc01c827432222aa86fefb18b00f58bd64ef2e31a2da665a2459cb40bbc19a5d1cb9389ca5a8b4dbb4a22f8dec069f2ba42bf6f372e2ed17a1ec846f52dfdc9f65e7309299d2a95f29d420cd56df81c4ad13ebe23d9822430329b0b5170b5694928497f1bf5792d2eb594330adf763dbf9377ed0d4ca95b0c94d28edfb2a0d7f1b971a3b670ffe7b5e2073c48def646389815d1e16009e06225d6f16c2d6feea6bcb805905ee12ca758ab5842f94e609e2257cb7a75f40206e54274efb2df8d724ff3dcd0af7f24b670122f579e08bb08895c1a8b4e0c77addc2c0c659c4773bbf5c96ffe83a7002595ce870f7b41421ec12396f73398c6f8e90ad705cb2703312e97154401302cb154a49f16148226c9893fc2d4fa7fb0190fd0011fbb5d7e51ccf70d337973a3dc94035f000b0cd42a866ebaf62472804c871d14ae2a9bc22cec26a070b95cfa2b9f61308059b7c12d6fa10f5a48fee6db97ca5deb1f7ed89d8ebeca209ee02db6755fe4efb33dbf11bd67b72c429a6fa5e4e55af806f3da24ef0d6e75d136eae32ed4caba4aed95166ebfddbf7ef458b9efee3734c8477c8c866297918e51783aa366adf6e247ec1a78865066d87ad657c9e920fafe16bca356730287d6d2be1354c2edf698ebec02210df85a67d8ad591613c96b7c45c6dee28bff726ecacfd7cad2ba6ba04145b2b6db5c2a0edb1f26a63b028fd5df663d17b855c305916be87274d8cbbf9705be81c230cd4e379a0ca3b9f175a88c4f20d593c0a9dbe1c6962f2bd881b81a37b46e9866e4408a0cbf05a23baa851edaec65f1ae71d7cf2b1adc07539963c0bee8e67fc85af332f6a1a6d7c42dc2a1273e03399592beceaf577dcbadcebe73465db31ac706017115acf0a3e4c92ecfd5572c7c77b1593afe2dabcf1b07c96b790c2671155790c3c7b067208699ce7af06483037d63c592e7c48d80ba3f9d0f8b4e8cbf3e96f13fdc087a7c3c2d30130114f2e407b26135e0cf4140f07da38972d2e19129ee9c0c6437650f04c9b45535d1ded84c9f48e9909129a0573eec2ce84e9154952b7f13f49b77588eff932bc9dd5537ac29a708a1c06f5a0dbfab8fa345928b0ddd20038b6ec8a962b09d6d308625a2df708b835bd3c653377ee5387b26463217ff5261b86a131ffdba5809933cf97171066d7021b21f6ce1fba88848e08d297effd290199eaf62efcd022121d3e302102b86705dee2d0a011ff2cd81692122ebf654df8c1256b1a05ee9a6d0894dc011e76f1a165d2bb020be95f1dba259f36addee5c5c0dc6de4b8bbe2462c4c1db72ad4888adf080b7f7f145018fd3484d36012d5bbb4e1c486d384cc7946add689fbaa909ab6c9de2b281df5d8d254bfe4e797d248bde3ddfa8bae56fa793b07ccce010e003773292034c6385de047d125e4a828eb84a469ad4a82c8fb4cf3f49f87bb2cfb996c10b4fe3535d51c29275cc2c22bd1685441dc4177826fcb6c7bd6f1c5cb761b7d97c88c68d74c9dada905f7571b5e680c857d59ea5535c62ebbf4e2da827d4e30a0b43a44f8a4e7948e5c0e023dbcfb3e262fe323981a9154b0b0fcb0a81855700483cee474ad6f0b451fc30d82d529b85473918f71612e7d180b59c77ec1b7d1312a77a71cd18d0af27dc1d30d9e441d551a24b5d3083445580b4ede3095afe488fd7503766579235ed1d88d519884a0ec87919ea2086904623cfb048a5021d7a7f5fec9bd605a56e724ea446238b817bec4559fc11998c0d11773bcdcd73d9947667c810b9bade8fe905c2b29ea339cace5faa18f055276d7ae38b91948881252fc9504b3e189023bd2ac194972202f4228e7db4988b08717aa396b34f7d45a8cc38ef9dbf84ecda08d9df0381586dfadd5b81802f07e1df4b83dc3b5d48e8263e79d263a73af0286f7939343cb5824ff3abe36ffa73eab8c36841a42194382f8ff3d296b089ff316a7c37ffbd1e46bed3a86f146287309158590cb58e9a12b98d803da2539a12c8b9462dab8f3dae1c784b567ea9b9f82b32a5b15ed5f5c6c20c1ab952efd3ffbed6bc813c4a1fd162773370fe725c4ca8b2da6d4ab6f5ce4cb4a71d5ed05f3a420c7d7e4d41679101f474808dd42b6075be08d9307d820e8bfc3a7069a2c349639abb8a7a3bfd8dc7f77fc0fcde1c5b0f9aac0e0bae5cd18d045bef879ce36dd20f2a749381923677d4caa0664b820824be67f00fca280d1b97a688858703e4234caee6e24212b6ee5319a7d774f2c9519073ac872fb54c747016be6fc37922b72afcf7e0be60053eaf1c89578eca0bab4041cd745c594e751902a2a409f5eae50539551c6bbf607569d0b35ae039d071249f163d5221b5e4ffa2af47fc2a4441d3f66dbcef9ac3082632e4bfebae485b0daba101951c6c24866245b739b925eaf7628b3256466233e3f93cbe6321c82f1b5a1d9db01f8cb7d4ba21df5360ec4ed3bffa281eb25e26ec3c4eb36c016e62ef2070f6d4ebd5ac9b7773fa96e76293185200d13d971a39ecd020ab39f1171499945e2a8351e195320b0c423884a4895e9e2e685d5fdaf75d5e16c246e3722d6ef385b28ad289955c2e056af68f59adbb71a9674883638a281b864fdbaf6db11ec69d8cbf176c07bf0b2c771dff3c2779bdb8bf8327261dce30006c33aac75d64e1cd8347e6eb520d1fc220f0e3c407759551c0a5a9905c0608475c14e5613563570b50b468ea156e0361684c72e5f0efc07f5b75eedf49be11cf75032d41d8e2e4c220532f103c6952ec108635e2597252edad5d02ecdfa89d8421160786358a3bbffc6d06168762fb8a54b9f71e24121a9a47378712cfa88cafc2a53cbd392f0cc50d18babdd15815bdb21076f05a44357ab2b2409443514820daf72ae9890ba5c9ad6c10b7854fcd69ad7a7c0a9bf56b924a11036345e5619a45564316b94e4d0ae4e41179820dfff1d5bbe5c86d39b6e83f70afc28f7632fa35e60da9196d3ce500b27d975f97bfa02fa6094ecc7f64e71042ef981241e24df2d26bfb9bcc83128b4cf7853f41dfeb724dcf67a6b55e35fcf17fbab0258307ea96b5f7a2f69041d9196161e8a443005d6373cee662c71be6277d709fde88ce9dc6e22889801a85de3dd120f550392bcff50f1b659a26b63eb695f692d244321e4ac4cb3ab35b4b9ceab867694a72a5bf90ba963220b1c746507a6d385de079061c97eb3099d6020a781dc96a246e47b8402ceb4d9b86731ea5f0e54ffae24920551b57a84e38da8d9670cd6be063e5ee2b1356198c12735c934cfb3ceb9acb1167be2df0ecb51aa7ce2f50ac7bf79c92bfb2b9d06049dcb1fd8528487be913f0a2983741c669d6994cd704a8f92f9928abb151cbe24a6f8cb190f4b604aa6978ca659f7eaeddb2da56d94edd6fadd67e1fa9070690a574538ddc20049f3e62b94d3f343bb58dac64af7ea04f0bc8da5e2fdc56569823f9f941fcf2e27fc72077962bc7f4f67a9504e0fb26742bc8c5f2a798387515bd9cc37737b4c832fb5b1bfea4442d6a25af6ce16d867d23ce43d89fbdcf33b2d36309df93e538038c9286af9fcb5cec8f558f331d60edfd8bd60e13a6aad515927f6d97448458dd2f4c503211e401eb51bf04d39de941f3ad283666e58385e3eab2519e30a4fee846dd0bef25a9ef926964e1760158f0729ed65f2362dfa8c3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>FD.io 社区中国行暨未来网络技术沙龙 南京站 会议记录</title>
    <url>/2018/03/19/2018-3-17-Nanjing-FD-io-DPDK-Conference/</url>
    <content><![CDATA[<p>FD.io 社区中国行暨未来网络技术沙龙 南京站，2018 年 3 月 17 日。</p>
<h1 id="开场致辞"><a href="#开场致辞" class="headerlink" title="开场致辞"></a>开场致辞</h1><p>Ray 介绍了一些有的没的</p>
<p>⁃    (Future Event)DPDK summit, FD.io summit<br>⁃    Ecosystem<br>⁃    VPP milestone</p>
<h1 id="FD-io-101／102-FD-io-通用数据平面（Intel-倪红军、Ray-Kinsella）"><a href="#FD-io-101／102-FD-io-通用数据平面（Intel-倪红军、Ray-Kinsella）" class="headerlink" title="FD.io 101／102 -FD.io 通用数据平面（Intel 倪红军、Ray Kinsella）"></a>FD.io 101／102 -FD.io 通用数据平面（Intel 倪红军、Ray Kinsella）</h1><p>内容概要：FD.io VPP 工作机制介绍。</p>
<h2 id="FD-io-和-VPP-架构图"><a href="#FD-io-和-VPP-架构图" class="headerlink" title="FD.io 和 VPP 架构图"></a>FD.io 和 VPP 架构图</h2><p>图</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>⁃    DataPlane<br>⁃    NFV（LB，FW等），OpenStack<br>⁃    CloudNative，云生网络</p>
<h2 id="介绍-VPP-工作机制"><a href="#介绍-VPP-工作机制" class="headerlink" title="介绍 VPP 工作机制"></a>介绍 VPP 工作机制</h2><p>多提供商的数据报处理技术，引领新一代网络技术转变。（leading transformation）</p>
<p>（先吹）<br>性能：</p>
<p>优化：</p>
<p>实现了如下功能：</p>
<p>可用性：</p>
<p>（再讲讲干货）</p>
<p><strong>GraphNode</strong></p>
<p><strong>Vector Packet Process</strong></p>
<p>伪代码</p>
<h2 id="Related-Project"><a href="#Related-Project" class="headerlink" title="Related Project"></a>Related Project</h2><p>⁃    OPNFV，Fast DataStacks（FDS），集成OpenStack／ODL／FD.io／DPDK的功能性测试平台<br>⁃    CSIT，Continuous System Integration and Testing。也是项目测试平台</p>
<h2 id="What’s-new-in-FD-io"><a href="#What’s-new-in-FD-io" class="headerlink" title="What’s new in FD.io?"></a>What’s new in FD.io?</h2><p>介绍几个关键技术的时间节点。新版本DPDK 等等。</p>
<p>优化的 new direction：</p>
<h2 id="Asymmetrical-Pipeline"><a href="#Asymmetrical-Pipeline" class="headerlink" title="Asymmetrical Pipeline"></a>Asymmetrical Pipeline</h2><p>没听太清楚，需要重听</p>
<p>一个 path／pipeline到一个core，合理利用 multiple cores</p>
<h2 id="Container-优化"><a href="#Container-优化" class="headerlink" title="Container 优化"></a>Container 优化</h2><h2 id="TCP-优化加速"><a href="#TCP-优化加速" class="headerlink" title="TCP 优化加速"></a>TCP 优化加速</h2><p>利用 DMM framework（下文华为就是讲这个），Socket API 保持不变，数据平面引入 FD.io和DPDK。使用 DMM 构造抽象，不同网络栈合理管理编排，合理利用。</p>
<h2 id="IPSEC-优化加速"><a href="#IPSEC-优化加速" class="headerlink" title="IPSEC 优化加速"></a>IPSEC 优化加速</h2><p>Accelerating IPSEC with FD.io/VPP/DPDK, Cryptodev API</p>
<h2 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h2><p>Q1：报文乱序如何处理</p>
<p>A：无锁队列以及按树层次遍历保证了包按什么顺序进来就怎样出去</p>
<p>Q2：TCP HOST Stack 的细节？</p>
<p>A：是一套不像 Kernel的协议栈，for different use cases, less but faster</p>
<p>Q3：VPP 能否替换 Linux Kernel 的大部分功能？</p>
<p>A：这是愿景。</p>
<p>Q4：容器 container 现状？</p>
<p>A：VPP可以跑在容器内了，容器可以实现router等功能。</p>
<p>Q5：容器失去了轻量化的特征？</p>
<p>A：很多机制都是放在容器操作系统内。应用层角度上确实失去一点。</p>
<h1 id="中兴-FD-io-构建-MEC-和-IoT-的基础网络架构（ZTE-王辉）"><a href="#中兴-FD-io-构建-MEC-和-IoT-的基础网络架构（ZTE-王辉）" class="headerlink" title="中兴 FD.io 构建 MEC 和 IoT 的基础网络架构（ZTE 王辉）"></a>中兴 FD.io 构建 MEC 和 IoT 的基础网络架构（ZTE 王辉）</h1><p>内容概要：MEC IoT的网络架构和一些技术细节，本地流卸载和物联网网关的 use case，中兴技术贡献。</p>
<p>中兴 FD.io VPP 网络架构</p>
<p>⁃    MEC IoT 服务框架（Mobile Edge Computing），“边缘很重要”，在移动网络边缘提供服务。<br>⁃    use case1，本地流卸载（Traffic Offload）<br>⁃    use case2，Gateway<br>⁃    ZTE contribution to VPP</p>
<h2 id="MEC-amp-IoT的使用场景"><a href="#MEC-amp-IoT的使用场景" class="headerlink" title="MEC&amp;IoT的使用场景"></a>MEC&amp;IoT的使用场景</h2><p>⁃    视频流加速<br>⁃    视频流分析<br>⁃    AR<br>⁃    Assistance for intensive compute<br>⁃    企业网配置<br>⁃    互联交通工具（connected vehicle)<br>⁃    IoT gateway</p>
<p>VPP 技术迎合了他们的需求：</p>
<p>⁃    高吞吐，低时延（DPDK、VPP）<br>⁃    链接数量大（高性能的hast table）<br>⁃    Services Localized（plugin as a node）database:Redis, 自定义<br>⁃    Services Flexible（VM／Container 灵活部署）<br>⁃    流量卸载（L2／L3 转发高性能）</p>
<h2 id="ZTE-NOFaas-框架"><a href="#ZTE-NOFaas-框架" class="headerlink" title="ZTE NOFaas 框架"></a>ZTE NOFaas 框架</h2><p>Network Output Forwarding as a service</p>
<h2 id="use-case1：本底流卸载"><a href="#use-case1：本底流卸载" class="headerlink" title="use case1：本底流卸载"></a>use case1：本底流卸载</h2><p>视频流截取分析，信息分析放在 MEC 侧，减轻主干网负担。传统的方式，在一个节点要处理上行下行、转发流量，是性能瓶颈所在，引入 VPP 性能提高明显。</p>
<p>（展示了相关topo图和架构图，架构图内详细讲了视频流量、控制信息流量、信号流怎么走的，怎么优化的）</p>
<h2 id="use-case2：IoT-Gateway"><a href="#use-case2：IoT-Gateway" class="headerlink" title="use case2：IoT Gateway"></a>use case2：IoT Gateway</h2><p>物联网的架构图</p>
<p>重点介绍网关的实现，这份架构图中网关分布在两个地方。1、MEC侧。2、Service 侧。</p>
<h2 id="Node-Graph-Rearrange"><a href="#Node-Graph-Rearrange" class="headerlink" title="Node Graph Rearrange"></a>Node Graph Rearrange</h2><p>介绍了 Node Graph Rearrange，讲解如何 plugin node 使用VPP、实现 TLS，TCP 代理，实现报文加解密和传输。实现 LB、NAT。L7的协议也是 plugin 进 VPP 的</p>
<h2 id="对-VPP-开源社区贡献了："><a href="#对-VPP-开源社区贡献了：" class="headerlink" title="对 VPP 开源社区贡献了："></a>对 VPP 开源社区贡献了：</h2><p>⁃    classfier table<br>⁃    ARP table<br>⁃    IP Fragment／Reassembly - Pseudo Reassembl<br>⁃    Full NAT</p>
<h2 id="问答环节-1"><a href="#问答环节-1" class="headerlink" title="问答环节"></a>问答环节</h2><p>Q1：中兴的框架中 VNF 解耦了吗？</p>
<p>A：中兴的 VNF 框架可以独立，粒度是控制／数据解耦。基于中兴开发的隧道，底层走UDP 协议，VPN。</p>
<p>Q2：port、service 交互的通道是怎么做的，性能量级怎样？是基于packet还是stream？</p>
<p>A：保密。</p>
<p>Q3：MEC节点布置的位置考虑。（基站／终端？）<br>A：目前是布置在基站</p>
<p>Q4：use case 的视频流来自？<br>A：就是路边摄像头，在基站的 MEC 处理。（这位提问者提到一种可以处理视频的高级摄像头，直接在终端处理，减轻基站负担）<br>A：具体最终怎么布置不一定，但这种高性能摄像头带来的开销也显然很大。</p>
<p>Q5：MEC采用 VPP，是采取一条pipleline，一个核呢，还是Graph Node。。<br>A：采用简单策略（例如简单的查表转发，就是独立、比较complete的机制）</p>
<h1 id="通过-DMM-使能“协议路由”（Huawei-曹水）"><a href="#通过-DMM-使能“协议路由”（Huawei-曹水）" class="headerlink" title="通过 DMM 使能“协议路由”（Huawei 曹水）"></a>通过 DMM 使能“协议路由”（Huawei 曹水）</h1><p>内容概要：传统 TCP、Linux kernel 的缺点和未来的需求点；华为 DMM 架构介绍：framwork、workflow、usecase、takeaways。</p>
<h2 id="目前我们面临着什么？"><a href="#目前我们面临着什么？" class="headerlink" title="目前我们面临着什么？"></a>目前我们面临着什么？</h2><p>TCP 的缺点</p>
<p>⁃    考虑的不是性能，而是稳定性，因为当时的网络质量是很不好的。面向丢包设计的协议，对丢包太敏感。<br>⁃    随着网络规模的up，性能是down的。（BDP，Bandwidth-Delay Product ，BDP）即链路上的最大比特数。<br>⁃    reliable，但对于 latency 没有<br>⁃    TCP是端到端的，调整相当难。端一侧优化了，但网络路径中间节点相当难进行优化，仍旧性能差。</p>
<p>Linux Kernel Stack 的缺点</p>
<p>⁃    用户态、内核态（上下文切换、复制）<br>⁃    紧耦合。<br>⁃    不好定制化，不经济划算。<br>⁃    协议 release 到 kernel 时间很长。</p>
<p>目前对于 Internet L4 的需求，未来面临的挑战</p>
<p>⁃    ultimate performance requirement。吞吐+延时=复杂。VR、AR、HD Video。<br>⁃    diversified QoS 。拥塞算法研究的特别多，但对所有人都是统一的，这不好。<br>⁃    complicated network environment。目前各个平台的协同不太好，多环境、多硬件、多协议</p>
<h2 id="Trend"><a href="#Trend" class="headerlink" title="Trend"></a>Trend</h2><p>⁃    kernel space –&gt; user space 避免上下文切换，进出内核。<br>⁃    Apps have different flavor 不同的服务应该使用不同的协议，多种协议同时跑，存在协议部署，协议选择的问题。<br>⁃    Hardware 协议开发者通常忽略底层硬件，实际上硬件能力不同，应充分发挥其作用。</p>
<h2 id="华为-DMM-project-Framework"><a href="#华为-DMM-project-Framework" class="headerlink" title="华为 DMM project Framework"></a>华为 DMM project Framework</h2><p>DMM：Dual Mode，双态支持。Multiple protocols pulgin，支持多协议run。Multiple instances , 多实例跑不同的协议。贡献给了开源社区。</p>
<p>图</p>
<p>应用层的接口仍是 Posix Socket。有一个 Socket Layer 连接到华为的 DMM 配置。Socket Bridge 支持 Linux kernel 的，也支持用户自己定义的 stack。L2～L4就采用了 DPDK、VPP。</p>
<p>协议编排机制（orchestrator），资源发现、主机配置、主机协议能力。实现 App 与 stack的映射，stack 选择可以通过 SDN 控制器下发。也可以是bypass。</p>
<p>华为的业务跨度大，需求广，各种不同的应用就要开发各种协议栈，就搞得很烦。所以搞了这么一个协议栈框架，部署方便。</p>
<h2 id="routing-workflow"><a href="#routing-workflow" class="headerlink" title="routing workflow"></a>routing workflow</h2><p>图</p>
<p>⁃    Client 和 Server 还是使用 Socket bind、listen 等等。<br>⁃    preload 拦截，进 DMM<br>⁃    系统资源配置<br>⁃    协议mapping达成选择 stack<br>⁃    进行通讯。（多种app，多种实例，多种协议，用户友好，接口标准，编排清晰）</p>
<h2 id="use-case"><a href="#use-case" class="headerlink" title="use case"></a>use case</h2><p>例如公安局的camara 也有不同的要求。很多业务就是复杂。但协议都是写死的，没有灵活性。DMM就是实现了一个框架，就好像抽屉柜，如果你业务变了，把抽屉抽出来放进新的协议配置就可以了。</p>
<h2 id="takeaways"><a href="#takeaways" class="headerlink" title="takeaways"></a>takeaways</h2><p>⁃    协议开发者更聚焦xxx<br>⁃    用户态／kernel 二选一<br>⁃    APP自由选择 stack</p>
<h2 id="问答环节-2"><a href="#问答环节-2" class="headerlink" title="问答环节"></a>问答环节</h2><p>Q1：怎么保障C／S配置一致<br>A：DMM是配置库，有对企业的高级版本。</p>
<p>Q2：DMM的存在意味着处理过程中增长了交互过程，对于像HTTP这样的通信会带来延迟？<br>A：配置能构成default配置，直接快速走。</p>
<p>Q3：Google Reserach … they developed their app and stack…balabala…how to 整合？<br>A：DMM就是有同样的愿景，为TCP／IP减冗余。</p>
<p>Q4：配置复杂？用户并不知道自己的服务该用什么协议。<br>A：DMM适用单个DataCenter，若跨越多个的话比较麻烦，丧失一定灵活性。</p>
<h1 id="FD-io／VPP下的云原生网络（Cisco-Frank-Brockners）"><a href="#FD-io／VPP下的云原生网络（Cisco-Frank-Brockners）" class="headerlink" title="FD.io／VPP下的云原生网络（Cisco Frank Brockners）"></a>FD.io／VPP下的云原生网络（Cisco Frank Brockners）</h1><p>todo</p>
<p>可能是英语雅思听力</p>
<hr>
<h1 id="SW-算法下的-Hyperscan-及-Turbo-网络安全（Intel-王翔）"><a href="#SW-算法下的-Hyperscan-及-Turbo-网络安全（Intel-王翔）" class="headerlink" title="SW 算法下的 Hyperscan 及 Turbo 网络安全（Intel 王翔）"></a>SW 算法下的 Hyperscan 及 Turbo 网络安全（Intel 王翔）</h1><p>hyperscan：正则表达式匹配库</p>
<p>内容概要：正则表达式简单介绍；hyperscan内部实现：模式、runtime、一个算法跑的例子、压缩和模糊匹配；性能分析工具Hsbench；正在开发的feature。</p>
<h1 id="基于DPDK实现高性能L4技术实践（京东-鲍永成）"><a href="#基于DPDK实现高性能L4技术实践（京东-鲍永成）" class="headerlink" title="基于DPDK实现高性能L4技术实践（京东 鲍永成）"></a>基于DPDK实现高性能L4技术实践（京东 鲍永成）</h1><p>内容概要：京东基于 DPDK 的负载均衡实现：背景、目标、功能；集群架构、组网架构；性能分析、问题解决。</p>
<h1 id="vBRAS的过去、现在和未来（北京派软件CEO孙朝晖）"><a href="#vBRAS的过去、现在和未来（北京派软件CEO孙朝晖）" class="headerlink" title="vBRAS的过去、现在和未来（北京派软件CEO孙朝晖）"></a>vBRAS的过去、现在和未来（北京派软件CEO孙朝晖）</h1><p>内容概要：商业角度介绍SDN、NFV、vBRAS行业。提到了非常多的方面：SDN 和 NFV 的冲突，BRAS的优缺点，Performance 四象限，vBRAS 的未来，SDN 和 NFV 对运营商的影响，SDWAN，Google，中国特色互联网，vBRAS Scheduling Capabilities，DDOS Defense等等。</p>
<h1 id="NFV中的DPDK应用（新华三赵丽娜）"><a href="#NFV中的DPDK应用（新华三赵丽娜）" class="headerlink" title="NFV中的DPDK应用（新华三赵丽娜）"></a>NFV中的DPDK应用（新华三赵丽娜）</h1><p>内容概要：介绍了下 DPDK 和 NFV ，讲了自己的 DPDK + NFV 架构图，带来的性能提升和优点等。</p>
<h1 id="圆桌会议和py交易"><a href="#圆桌会议和py交易" class="headerlink" title="圆桌会议和py交易"></a>圆桌会议和py交易</h1><p>··············</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>美国大学给我发邮件提醒我不要乱说话</title>
    <url>/2020/10/09/A-Sad-Email-About-Freedom-of-Academics/</url>
    <content><![CDATA[<p><img src="/2020/10/09/A-Sad-Email-About-Freedom-of-Academics/email.jpg" alt="email"></p>
<p>邮件翻译：</p>
<blockquote>
<p>美国的大学的教职人员享有学术自由的权利，这包括在课题上展示和探讨某些在其他政府看来可能是非法的话题和内容，因此，这些政府可能会审查这些内容。这些话题可能包括：宗教、性、人权、民主、代议制政府、历史事件。</p>
<p>作为一名华盛顿大学的学生，如果你居住在美国以外并远程参加这些课程，你会受到当地管辖区的法律管辖。当地的政府机构可能会限制你对课程材料的互联网访问，并对你采取惩罚性的措施。不幸的是，华盛顿大学无法改变你所在的管辖区的法律，或影响当地的执法机构如何施行这些法律。</p>
<p>所以，如果你在美国以外学习华盛顿大学的课程，尤其是参加某些会涉及到某些在你所在的司法管辖区被审查的话题的课程，你有理由谨慎行事。若你对这方面有疑问，你可以咨询您的学术顾问……</p>
</blockquote>
<p>感想：这真是一则“温馨提示”呢！令人感到心酸的温馨提示。读完这份邮件，我下意识地想象，这则温馨提示的背后，是不是有什么沉甸甸的故事了……是不是有人因此在监狱里？我仔细想了想，全球也没有几个国家需要收到这种“温馨提示”吧，朝鲜、伊朗、越南…… 等国家！全世界没有几个地方还没有确立学术自由的原则。所以，收到这封邮件，可以理解为是一种悲哀。</p>
<p>我在本科期间，上过一门外教的英语课。这位老师是英国人，他的课是让同学通过分享时事新闻来锻炼口语。第一节课他开头宣布 syllabus 的时候最后有一个要求，我还记得很清楚，<strong>“We are not going to talk about politics and religion, because the university requires me to do so.”</strong> 当时的我还很天真，并没有认识到这其中有什么不对，现在回想起来，这简直是在向我们宣读“你们和奴隶没两样”的“奴隶宣言”。同学们一时没有听清楚老师禁止讨论什么，于是交头接耳地问。我似乎有一种感觉，觉得大家在知道是被禁止讨论的东西是 politics 和 religion 之后，还表示非常宽慰和理解——“我们才不想讨论那玩意呢！” 如果我能坐时光机回到那天的课堂上，或者说以后我还能有机会见到这位老师的话，我一定会挂着无奈的笑容，并且耸耸肩跟他说：”Yeah, we are not allowed to talk about this, we are not allowed to talk about that. No freedom of academics, isn’t it? This is the case in China, we all know it.”</p>
<p>I have already known that I live in a much darker world.</p>
<p>因为没有自由，所以向往有自由的地方啊。</p>
]]></content>
  </entry>
  <entry>
    <title>我的大学提供的质量低下、毫无意义的职业规划课程</title>
    <url>/2019/04/21/A-disgusting-colloge-student-employment-guidance-lesson/</url>
    <content><![CDATA[<p>（这封博客当时写成了信件递给了老师）</p>
<p>我觉得这课上的“面试”非常无聊、没用、没有意义。老师您找了两个《非你莫属》的视频来放了一节课。不知道老师您有没有基本的判断力，这种视频有任何的真实性可言吗？我相信越优秀的人，越是懂得人外有人天外有天这句话。那个清华的硕士，百分之一万是导演安排的剧本让他演，正常人根本不会说我实习要几十万工资，也不会PPT就做两页完全无关的内容，我相信清华里的人不会这么差，（如果您有机会）您会跟清华的人放这种视频吗？无非就是让一些没有学历的大叔大妈看了这个节目后咋舌：“切，其实清华毕业的也不过如此，太自大了”。然后下面再来一个北大的女生，瞬间卑微到泥土，导演企图制造一个反差，那些支持读书无用论的人就是这款节目的受众：“呵呵，北大毕业，还不是只能拿6000块一个月的工资”。这种视频适合放到大学生职业规划课堂上吗？老师你没有基本的判断能力吗？现在这个时代，你作为一个讲师，在课堂上没有能够传递有用信息，那我过来上课干什么？你直接发这个视频的连接给我们，我们不是也一样在宿舍就能看？还要费辛苦过来上你的课？</p>
<p>再说第二节课，无领导小组面试。我不想吐槽了，我不清楚你们机械学院是不是找工作大多数都是按照这个模式。这个模式不就是嘴炮撕逼么？能体现什么能力？这东西，你说你讲给大一的同学，那也许还合适，也就是那些什么校级部门、组织面试人会出这种无聊的题目。拜托，老师您教的这个班级，大多数人是数计学院大三的学生，老师您能不能结合一下实际？虽然您是一个机械学院的辅导员，但当你站到讲台上时我希望您以讲师的身份要求自己。我想我们学院不会有特别多的人应聘什么“管培生”之类的岗位。您应该去了解一下应聘软件工程师或者项目经理在面试时需要经历的模式，是不是分析一些这样的内容更适合本课堂的学生？而不是这种“无领导小组讨论”？无领导小组面试的形式适不适合，看行业的，银行啊什么的合适，技术岗就扯淡了。更可笑的是，您最后还放了一个视频，在我看来跟弱智一样，不知道您是真的认为这个视频很有教育意义还是只是随便点开让我们看好糊弄到下课。我就是那名说了一句“还没当上公务员就学会使坏”的同学。虽然可能这门课，十几年几十年都是这么水下来的，可我觉得您作为老师，您如果有心，应该会去提高这个教学质量。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>《UNIX环境高级编程》Advanced Programming in UNIX Environment 摘抄</title>
    <url>/2019/04/02/APUE/</url>
    <content><![CDATA[<p>图书馆里借了一本《UNIX环境高级编程》花了约一周时间粗读完，通篇都是极其精确的定义和讲解，不愧圣经之名。下面对一些学习过程中比较觉得有心得的地方进行记录。</p>
<h1 id="文件I-O-amp-标准I-O库"><a href="#文件I-O-amp-标准I-O库" class="headerlink" title="文件I/O &amp; 标准I/O库"></a>文件I/O &amp; 标准I/O库</h1><h2 id="文件描述符（file-descriptor）与文件指针（FILE-）有什么区别？"><a href="#文件描述符（file-descriptor）与文件指针（FILE-）有什么区别？" class="headerlink" title="文件描述符（file descriptor）与文件指针（FILE *）有什么区别？"></a>文件描述符（file descriptor）与文件指针（FILE *）有什么区别？</h2><p>// chapter 1.5，3.2，5</p>
<p><strong>文件描述符（file descriptor）</strong>通常是一个小的非负整数，内核用其来<strong>标识一个特定进程正在访问的文件。</strong> </p>
<p>当打开一个现有文件或者创建一个新文件时（open），内核向进程返回这个文件描述符。</p>
<p>对于每一个新运行的程序，所有shell都会为其打开三个文件描述符：标准输入、标准输出、标准错误（stdin、stdout、stderr）。其对应的file descriptor分别是0、1、2。</p>
<p>// chapter 3，5</p>
<p>第三章中的I/O接口，如<code>open</code>、<code>write</code>、<code>read</code>、<code>lseek</code>都是针对文件描述符进行的。</p>
<p>对于标准I/O库，其操作是针对<strong>流（stream）</strong>来进行的。用标准I/O库打开一个文件，是使一个流和一个文件相关联，即打开一个流，fopen 返回一个 <code>FILE *</code>，该对象使一个结构，包含标准I/O库为了管理流所需要的所有信息，<strong>包括：实际I/O文件的文件描述符</strong>，缓冲区指针、长度、字符数，出错标志等。</p>
<h2 id="标准I-O库缓冲"><a href="#标准I-O库缓冲" class="headerlink" title="标准I/O库缓冲"></a>标准I/O库缓冲</h2><p>在一个流上执行第一次I/O操作时，通常会调用<code>malloc</code>来获得缓冲区。</p>
<ol>
<li>全缓冲：<strong>填满缓冲区后</strong>才实际进行I/O操作。例如对于写到磁盘上的文件通常使用全缓冲。术语flush（清洗）在标准I/O库中意味着将缓冲区的内容写到磁盘上。</li>
<li>行缓冲：<strong>输入和输出遇到换行符时</strong>执行实际I/O操作。由于每一行缓冲区长度固定有限，只要填满了缓冲区，即使还没有换行符，也会执行I/O（类似全缓冲）</li>
<li>不带缓冲。标准I/O库也有不带缓冲的流。例如，如果使用标准I/O函数<code>fputs</code>写15个字符到不带缓冲的流上，很可能就是直接用<code>write</code>系统调用立即写入。</li>
</ol>
<p>ISO C有如下要求：</p>
<ol>
<li>当且仅当标准输入和标准输出<strong>不涉及交互式设备时，才是全缓冲</strong>的。（若涉及<strong>终端</strong>设备，则他们是<strong>行缓冲</strong>的，否则是全缓冲的。）</li>
<li>标准出错绝不是全缓冲的。（<strong>出错信息不带缓冲</strong>）</li>
</ol>
<h2 id="标准I-O库与I-O函数有什么区别？"><a href="#标准I-O库与I-O函数有什么区别？" class="headerlink" title="标准I/O库与I/O函数有什么区别？"></a>标准I/O库与I/O函数有什么区别？</h2><p>使用标准I/O库的一个优点是无需考虑缓冲和最佳bufsize的选择。</p>
<p>标准I/O库与直接调用<code>read</code>和<code>write</code>函数相比并不慢很多。</p>
<h1 id="标准文件I-O函数的效率与bufsize的关系"><a href="#标准文件I-O函数的效率与bufsize的关系" class="headerlink" title="标准文件I/O函数的效率与bufsize的关系"></a>标准文件I/O函数的效率与bufsize的关系</h1><p>// chapter 3.9</p>
<p>选取bufsize值会影响读文件操作的时间。</p>
<p>从书中看到，如果缓冲区太小会严重影响效率。当bufsize达到4096 bytes时CPU时间就约达到最小值，继续增加bufsize不会有太多改善。</p>
<h1 id="内核表示文件的数据结构-amp-文件的共享结构"><a href="#内核表示文件的数据结构-amp-文件的共享结构" class="headerlink" title="内核表示文件的数据结构 &amp; 文件的共享结构"></a>内核表示文件的数据结构 &amp; 文件的共享结构</h1><p>两个图，讲解的很清晰</p>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>// chapter 3.11</p>
<p>用一段历史问题来说明这个概念。</p>
<p>早期的UNIX不支持open的append选项，所以要用如下代码来append：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">lseek</span><span class="params">(fd, <span class="number">0</span>, <span class="number">2</span>)</span></span> <span class="comment">// 第二个参数是offset，第三个参数为2代表的意思是将当前文件偏移量设置为 offset+文件长度</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(fd, buf, <span class="number">100</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>对于单个进程而言这段程序是没问题的。但假设有两个进程A和B对同一文件（长度1500 bytes）进行这种操作，假定进程A调用了<code>lssek</code>，A的当前文件偏移量设置到了1500 bytes。假设此时内核调度B开始执行，B也执行了<code>lseek</code>把B进程的文件偏移量设置到了1500 bytes。然后B继续调用<code>write</code>写入100字节，这时文件总长度变为1600 bytes。然后内核又切换到进程A开始运行，A调用<code>write</code>时，就会写覆盖B写的数据。</p>
<p>问题就在于“定位到文件尾端，然后写”这个操作的两个步骤分成了两个函数。结局问题的方法就是<strong>让这两个操作成为一个原子操作</strong>。也就是O_APPEND标志。或者<code>pread</code>和<code>pwrite</code>函数。</p>
<p>原子操作（atomic operation）就是由多步组成的操作，要么全部都执行，要么一步都不执行。</p>
<h1 id="文件类型-amp-所谓“一切皆文件”"><a href="#文件类型-amp-所谓“一切皆文件”" class="headerlink" title="文件类型 &amp; 所谓“一切皆文件”"></a>文件类型 &amp; 所谓“一切皆文件”</h1><ol>
<li>普通文件（regular file）</li>
<li>目录文件（directory file）。“目录”也是文件！！这种文件里保持<strong>其他文件（也就是“该目录下的文件”）</strong>的名字和指向这些文件的指针。</li>
<li>块文件（block special file），提供对块设备<strong>带缓冲</strong>的访问。例如磁盘</li>
<li>字符文件（character special file），提供对设备<strong>不带缓冲</strong>的访问。例如终端。系统中的所有<strong>设备</strong>要么是块文件要么是字符文件。</li>
<li>FIFO，命名管道</li>
<li>socket</li>
<li>符号链接（symbolic link）</li>
</ol>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>// chapter 1.6 P10</p>
<p><strong>程序（program）是存放在磁盘上，处于某个目录中的一个可执行文件</strong>。使用6个exec函数之一，由内核读入存储器，执行。</p>
<p><strong>程序的执行实例被称为进程（process）</strong>。</p>
<h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p>// chapter 8</p>
<ul>
<li>每个进程都有一个非负整形表示的唯一进程ID。</li>
<li>PID是唯一的，但可以复用（已经终止的PID会赋给新的进程）。大多数UNIX系统有<strong>延迟重用算法</strong>，让新进程的PID不同于最近终止的PID。这是为了防止将新进程误认为是同一个PID的先前已经终止的那个进程。</li>
</ul>
<h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><ul>
<li>fork 创建一个新进程，是父进程（调用进程）的复制品。</li>
<li><strong>调用一次，返回两次。</strong> 子进程的返回值是0，父进程的返回值是子进程的PID。</li>
<li>子进程和父进程继续执行fork之后的指令。</li>
<li><strong>子进程是父进程的副本</strong>。例如，子进程获得父进程数据空间、堆、栈的<strong>副本</strong>。注意：是<strong>副本</strong>，而不是共享这些存储空间部分。</li>
<li><strong>写时复制技术（copy-on-write）</strong>，fork时并不执行一个实际的父进程数据段、堆、栈完全复制，而是由内核执行写时复制，先让这些区域由父子进程共享。如果父子进程有一个试图修改这些区域，内核为那个要被修改的区域（页）制作一个副本。</li>
<li>一般来说<strong>fork之后先执行父进程还是先执行子进程是不确定的</strong>。</li>
</ul>
<p>文件共享：</p>
<ul>
<li>fork的一个特性是父进程的所有打开的文件描述符都复制到子进程中。所以父子进程会对同一个文件使用相同的文件偏移量。</li>
<li><strong>如果父子进程写到同一文件描述符，但没有任何形式的同步。那么他们的输出会互相混合</strong>。所以常用的处理方式有如下两种：<ul>
<li>父进程等待子进程完成。这种情况下，父进程无需对描述符做处理。子进程终止后，子进程读写的文件描述符的偏移量是更新的。</li>
<li>父子进程执行不同的程序段。在这种情况下，<strong>fork之后父子进程应各自关闭他们不需要的文件描述符，这样就不会干扰对方使用的文件描述符</strong>，这是网络通信中常见的。</li>
</ul>
</li>
</ul>
<p>fork的用法：</p>
<ol>
<li><strong>一个父进程希望复制自己，然后父子进程同时执行不同的代码段。</strong>例如：网络服务进程——父进程等待客户端的连接请求，当请求到达，调用fork建立一个子进程来处理这个请求，父进程则继续等待下一个连接的到达。</li>
<li><strong>一个进程要执行一个不同的程序。</strong>例如：shell。这种情况下，是<strong>fork一个子进程，子进程执行exec</strong>。</li>
</ol>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>进程有如下五种正常的终止方式：</p>
<ol>
<li>main函数中执行<code>return</code>语句。等于调用<code>exit</code>。</li>
<li>调用<code>exit</code>函数。</li>
<li>调用_exit或_Exit</li>
<li>进程的最后一个线程在其启动例程中执行返回语句。</li>
<li>进程的最后一个线程调用<code>pthread_exit</code></li>
</ol>
<p>有如下三种异常终止方式：</p>
<ol>
<li>调用<code>abort()</code>。产生SIGABRT信号，异常终止。</li>
<li>当进程接收到某些信号时。</li>
<li>最后一个线程对“取消”（cancellation）请求做出响应。</li>
</ol>
<p>不管进程如何终止，都会执行内核中的同一段代码，关闭所有打开的描述符，释放所占用的存储器等。</p>
<p><strong>我们都希望终止进程能够通知其父进程它是如何终止的。</strong>所以对于终止函数exit，有一个<strong>退出状态（exit status）会作为参数传递给函数。</strong>内核为每个终止的子进程保存了一定量的信息，<strong>父进程可以使用wait或waitpid函数取得这些信息</strong>，至少有PID、终止状态、该进程使用的CPU时间总量等。</p>
<p>在UNIX术语中，一个已经终止但未被父进程善后（获取有关信息，释放所占用资源）的进程称为<strong>僵死进程（zombie）</strong></p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>当一个进程正常终止或异常终止时，内核都会向其父进程发SIGCHLD信号。因为子进程的终止是<strong>异步事件（asynchronous</strong>，指在父进程运行中，任何时侯都可能发生），信号就是异步通知。父进程可以选择忽略，也可以提供一个该信号出现时要调用的函数（术语叫做信号处理程序，<strong>handler</strong>）。</p>
<p>调用<code>wait</code>或<code>waitpid</code>的进程可能会发生什么情况：</p>
<ul>
<li>如果其子进程还在运行，则阻塞。</li>
<li>如果一个子进程已经终止，则取得该子进程的终止状态并立即返回。</li>
<li>如果没有任何子进程，出错返回。</li>
</ul>
<p><code>wait</code>和<code>waitpid</code>的区别如下：</p>
<ul>
<li>在一个子进程终止前，<code>wait</code>会让调用者阻塞，<code>waitpid</code>有一个选项可以让调用者不阻塞。例如：有时候用户希望取得一个子进程的状态但不想阻塞或等待子进程结束。</li>
<li><code>wait</code>是等待调用后第一个终止子进程。<code>waitpid</code>有若干选项，可以控制它等待的进程。</li>
<li><code>waitpid</code>可以等待一个特定的进程，而<code>wait</code>时返回任一终止的子进程的状态。</li>
</ul>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><ul>
<li>当进程调用一种<code>exec</code>函数时，<strong>该进程的程序完全替换为新程序</strong>，新程序从其main函数开始执行。</li>
<li>调用<code>exec</code>不创建新进程，所以<strong>前后PID不会改变</strong>。<strong>exec只是用一个全新的程序替换了当前进程的正文、数据段、堆栈。</strong></li>
</ul>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>信号是<strong>软件中断</strong>，提供<strong>一种处理异步事件的方法</strong>。</p>
<p>信号都有名字，以SIG开头。</p>
<p>很多条件可以触发信号：</p>
<ul>
<li>用户按某些终端按键时</li>
<li>硬件异常产生信号，例如除数为0</li>
<li>进程调用<code>kill(2)</code>函数可以将信号发送给另一个进程或进程组。</li>
<li>用户可以用<code>kill(1)</code>命令发送信号给其他进程。常用此命令来禁止一个失效的后台进程。</li>
</ul>
<p>信号是<strong>异步事件的经典实例</strong>，产生信号的事件是随机出现的，进程不能简单地测试一个变量来判断是否出现了一个信号，而是必须<strong>告诉内核“若该信号出现，则执行下列操作”</strong>。某个信号出现的时候按照下列方式之一处理：</p>
<ol>
<li><strong>忽略</strong>此信号。有两种信号是不能被忽略的，是SIGKILL和SIGSTOP，这两个信号向超级用户提供了终止进程的可靠方法。</li>
<li><strong>捕捉信号</strong>。为了做到这一点，要实现通知内核在某种信号出现时，调用一个用户函数。注意，不能捕捉SIGKILL和SIGSTOP</li>
<li>执行系统的<strong>默认动作</strong>。大多数的信号系统默认动作时终止进程。</li>
</ol>
<h2 id="一些典型的信号"><a href="#一些典型的信号" class="headerlink" title="一些典型的信号"></a>一些典型的信号</h2><table>
<thead>
<tr>
<th>信号</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGINT</td>
<td>当用户按下中断键（一般是Ctrl+C），终端驱动程序产生此信号被送至前台进程组的每一个进程。常用此信号来终止一个运行不正常，或者正在屏幕上产生大量不必要的输出的进程。</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>两个不能被捕捉或忽略的信号之一。</td>
</tr>
</tbody>
</table>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>用于指定忽略某信号，或对某信号执行系统默认动作，或注册收到某个信号后调用什么函数。这个函数称为信号处理程序（signal handler）。</p>
<h3 id="kill-raise"><a href="#kill-raise" class="headerlink" title="kill / raise"></a>kill / raise</h3><p><code>kill</code> 函数发送信号给进程或进程组，<code>raise</code> 函数允许进程向自身发送信号。</p>
<h3 id="alarm-pause"><a href="#alarm-pause" class="headerlink" title="alarm / pause"></a>alarm / pause</h3><p>使用 <code>alarm</code>函数可以设置一个计时器，在未来某个指定时间该计算器会超时，产生SIGALRM信号，如果不忽略或不设置handler，默认动作时终止调用 <code>alarm</code>  函数的进程。</p>
<p>pause 函数时调用进程挂起，直到捕捉到一个信号。</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><p>让程序异常终止。</p>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>让调用进程挂起，直到满足下列条件之一：</p>
<ol>
<li>经过了指定的秒数</li>
<li>捕捉到一个信号并从信号处理程序中返回。</li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>进程可以看作只有一个控制线程</strong>：一个进程在同一时刻只做一件事情。有了多个控制线程后，在程序设计时，可以把进程设计成在同一个时刻做不止一件事。这种方式有很多好处：</p>
<ol>
<li><strong>简化异步事件的代码</strong>，每个线程对于独自要处理的事件可以采用同步编程模式，比异步编程模式简单得多。</li>
<li>不同的进程必须使用操作系统提供的复杂机制才可以实现内存和文件描述符的共享。而<strong>多个线程可以自动共享相同的地址空间和文件描述符。</strong></li>
<li>可以<strong>改善整个程序的吞吐量</strong>。有了多个控制线程，独立的任务处理可以交叉运行。</li>
<li>即使运行在单处理器上，也可以获得多线程编程模式的好处，<strong>处理器的数量并不影响程序结构</strong>。</li>
</ol>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>像进程有PID一样，进程也有一个线程I。PID在整个系统中是唯一的，线程ID不是，<strong>线程ID只在其所在的进程环境内有效</strong>。</p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>传统的进程模型中，每个进程只有一个控制线程。这其实与基于线程的模型中每个进程只包含一个线程是相同的。程序开始运行时，它就是以单进程中单个控制线程启动的。在创建线程以前，程序和传统的进程没什么区别。创建线程通过调用pthread_create函数。这个函数的参数可以指定线程ID，指定线程的属性，指定线程要执行的函数的函数指针和参数列表。</p>
<p>线程的创建并不能保证哪一个线程会先运行，是新创建的线程还是调用线程，不能保证。</p>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>单个线程可以通过以下三种方式之一退出，在不终止整个进程的情况下停止该线程的控制流：</p>
<ol>
<li><strong>该线程从启动例程中返回，返回值是退出码。</strong></li>
<li>线程可以<strong>被同一进程的其他线程取消</strong>。函数是 <code>pthread_cancel</code>。</li>
<li>线程调用<code>pthread_exit</code>。</li>
</ol>
<p>线程中的其他线程可以调用 <code>pthread_join</code> ，作用是：调用线程会一直阻塞，直到指定的线程调用<code>pthread_exit</code>或从启动例程中返回或被取消。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>如果每个线程使用的变量都是其他线程不会读写的，那么久不存在不一致问题，否则需要对线程进行同步设计，确保它们在访问时不会访问到无效的内容。为了解决这个问题，线程不得不使用锁，使得同一时间只允许一个线程访问某变量。</p>
<p>函数是 <code>pthread_mutex_init/destroy/lock/trylock/unlock</code></p>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>如果<strong>一个函数可以在同一时刻被多个线程安全地调用，就可以说该函数是线程安全</strong>的。</p>
<h2 id="线程私有数据"><a href="#线程私有数据" class="headerlink" title="线程私有数据"></a>线程私有数据</h2><p>线程特定数据，是存储和查询与某个线程相关的数据的一种机制。常见于，希望每个线程可以独立访问数据的副本而不用担心同步问题。</p>
<p>进程中的所有线程可以访问整个进程的整个地址空间。线程没有办法阻止其他线程访问它的数据，即使是私有数据也不例外。虽然底层实现并不能阻止这一切，但依然可以通过这种方法引入一定的数据独立性。</p>
<p>在分配私有数据前，需要创建一个与该数据关联的key，用这个key获得对私有数据的访问权。<code>pthread_key_create</code>，创建键之后，调用<code>pthread_setspecific</code>函数可以把键和私有数据关联起来，通过<code>pthread_getspecific</code>可以获得私有数据的地址。</p>
<h2 id="线程与信号"><a href="#线程与信号" class="headerlink" title="线程与信号"></a>线程与信号</h2><p>信号的处理是进程中所有线程共享的。一个线程修改了对某个信号的处理方式后，所有的线程都必须共享这个行为的改变。</p>
<p>进程的信号是被传递到单个线程的。</p>
<p>要把信号发送到线程，用<code>pthread_kill</code></p>
<h2 id="线程I-O"><a href="#线程I-O" class="headerlink" title="线程I/O"></a>线程I/O</h2><p>用<code>pread</code>函数和<code>pwrite</code>函数。</p>
<h1 id="高级I-O"><a href="#高级I-O" class="headerlink" title="高级I/O"></a>高级I/O</h1><p>to be done</p>
<h1 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h1>]]></content>
      <categories>
        <category>ReadingNote</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之抽象基类</title>
    <url>/2017/06/07/Abstract-Base-Class/</url>
    <content><![CDATA[<h1 id="抽象基类和纯虚函数"><a href="#抽象基类和纯虚函数" class="headerlink" title="抽象基类和纯虚函数"></a>抽象基类和纯虚函数</h1><p>至此，已经介绍了简单继承和较为复杂的多态继承。接下来介绍<strong>抽象基类</strong>（Abstract base class, ABC）</p>
<p>有些时候，继承关系并不是<code>is-a</code>那样简单。例如在开发图形程序时，可能会涉及到椭圆和圆，会有<code>Ellipse</code>类和<code>Circle</code>类。因为所有的圆都是特殊的椭圆，所以考虑从<code>Ellipse</code>类派生出<code>Circle</code>类。但涉及到细节时，会有很多问题。椭圆Ellipse类包含的内容有：椭圆中心的横纵坐标(x,y)、长半轴长(a)、短半轴长(b)、方向角(angle)。方法包括：移动椭圆、求椭圆面积、旋转椭圆(Rotate)、缩短或放长长短半轴。</p>
<p>虽然圆是一种椭圆，但如果直接用<code>Ellipse</code>类派生<code>Circle</code>类是笨拙的。首先，圆只需要一个值——半径——就可以描述大小和形状，不需要长半轴长和短半轴长，也不需要方向角<code>angle</code>和方法<code>Rotate()</code>，因为这些东西对圆来说完全没有意义。所以与其派生，不如直接定义<code>Circle</code>类更简单。但是这种解决方式也不是最好的，忽略了<code>Circle</code>和<code>Ellipse</code>实际上有很多共同点的事实。分别定义忽略了这一事实。</p>
<p>因此，还有一种解决方法：从<code>Ellipse</code>和<code>Circle</code>类中抽象出它们的共性，将这些特效放到一个<code>抽象基类，Abstract base class, ABC</code>里头，再由<code>ABC</code>派生出<code>Ellips</code>e和<code>Circle</code>类。这样就可以实现用基类指针数组同时管理<code>Ellipse</code>类和<code>Circle</code>类。C++通过<strong>纯虚函数</strong>（pure virtual function）来提供未实现的函数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BaseEllipse</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">double</span> x;</span><br><span class="line">	<span class="built_in">double</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BaseEllipse(<span class="built_in">double</span> x0 = <span class="number">0</span>, <span class="built_in">double</span> y0 = <span class="number">0</span>):x(x0),y(y0) &#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~BaseEllipse() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> nx, <span class="built_in">int</span> ny</span>)</span> &#123; x = nx; y = ny; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="built_in">double</span> <span class="title">Area</span>()<span class="keyword">const</span></span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意Area方法。在函数原型的末尾加上<code>=0</code>使虚函数成为<strong>纯虚函数</strong>。这里的Area方法<strong>没有定义</strong>。这里的概念是：包含纯虚函数的类<strong>只用作基类</strong>。当类声明中包含纯虚函数时，<strong>不能创建该类对象</strong>。</p>
<p>现在，可以用<code>BaseEllipse</code>类派生<code>Ellipse</code>类和<code>Circle</code>类。使用这些类的程序能够创建<code>Ellipse</code>类对象和<code>Circle</code>类对象，但不能创建<code>BaseEllipse</code>对象。由于<code>Ellipse</code>类和<code>Circle</code>类有共同的基类，所以可以用<code>BaseEllipse</code>指针数组同时管理这两种对象。所以说：ABC描述的是至少使用一个纯虚函数的接口。</p>
<p>在处理继承的问题上，抽象基类的方法更具有系统性和规范性。可以将抽象基类设计人员能够制定“接口约定”，确保从抽象基类派生的所有组件都至少支持抽象基类所制定的功能。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>一本十七世纪出版的书是如何说明审查制度的荒谬——《论出版自由》弥尔顿 Areopagitica by John Milton</title>
    <url>/2023/04/28/Areopagitica-by-John-Milton/</url>
    <content><![CDATA[<p><em>Milton’s Areopagitica</em>, A Speech for the Liberty of Unlicensed Printing</p>
<p>《出版管制法》，该法规定，凡书籍、小册子或论文必须经过主管机关或至少经主管者一人批准，否则不得印刷发行。……我要痛切陈词，这法令的订立者是诸位不屑于承认的。其次要说明，不论哪类书籍，我们对阅读问题一般应持有的看法。同时也要说明，这法令虽然主张想要禁止诽谤和煽动性的书籍，但却达不到目的。最后，我还要说明这一法令非但使我们的才能在已知的事物中无法发挥，因而使我们日趋驽钝；同时宗教和世俗界的学术中本来可以进一步求得的发展，也会因此收到妨碍。这样一来，它的主要作用便是破坏学术、窒息真理了。</p>
<h1 id="杀人是破坏了一个上帝的像；禁书则是破坏了人瞳孔里的上帝，扼杀了人的思想和理性本身"><a href="#杀人是破坏了一个上帝的像；禁书则是破坏了人瞳孔里的上帝，扼杀了人的思想和理性本身" class="headerlink" title="杀人是破坏了一个上帝的像；禁书则是破坏了人瞳孔里的上帝，扼杀了人的思想和理性本身"></a>杀人是破坏了一个上帝的像；禁书则是破坏了人瞳孔里的上帝，扼杀了人的思想和理性本身</h1><p>书籍并不是死的东西，它包藏一种生命的潜力，和作者一样活跃。不仅如此，它还像一个宝瓶，把创作者活生生的智慧中最纯净的精华保存起来。我们知道它是非常活跃的，而且繁殖力也是极强的，就像诸神的龙齿一样。当它们被撒到各处以后，就可能长出武士来。</p>
<p><strong>杀人如果只是杀死了一个理性的动物，破坏了一个上帝的像；而禁止好书则是扼杀了理性本身，破坏了瞳仁里的上帝圣像。</strong>任何时代，都不能使死者复生，这种损失并不太大。而各个时代的革命，也往往不能使得已经失去的真理恢复，这使整个世界都受到影响。因此我们就必须万分小心，看看自己对于公正人物富有生命力的事务是不是进行了什么破害。看看自己是怎样把保存在书籍里的生命糟蹋了。我们看到，这样像是犯下了杀人罪，甚至杀死的是一个殉道士；如果涉及到整个出版界，就会形成一场大屠杀。这场大屠杀中，杀死的不是凡尘的生命，而是伤及了理智本身的生气。</p>
<h1 id="审查法令的历史"><a href="#审查法令的历史" class="headerlink" title="审查法令的历史"></a>审查法令的历史</h1><p>雅典的长官只注意两种文字，一种是渎神和无神论的文字，另一种是诽谤中伤的文字。普罗塔哥拉由于在一篇文章的开头坦白说他不知道“有没有神存在”，于是他的书被下令焚烧了，人也被驱逐出境了。还有律令规定不能指名诽谤任何人。后来西塞罗写道，事实证明这种方法很快就禁绝了其他无神论铤而走险的思想和公开的诽谤。</p>
<p>但除开这两点，书中到底说些什么，长官从不过问。虽然西塞罗在自己的著作中曾反对伊比鸠鲁的看法，但也没有任何命令禁止他们。</p>
<p><strong>如果我们看到坏书被禁的少，而好书被禁的多，那是一点也不稀奇的。</strong></p>
<p>早期宗教会议和主教们只是宣传某些书不值得推荐或流传，读不读全凭各人的良心决定，一切直到公元800年以后才发生改变。罗马教皇尽情垄断政治权利，想象从前控制人们的判断一样，把自己的统治之手伸出来遮住人们的眼睛。凡属不合他们口味的东西都禁止阅读，并且付之一炬。从那时以后，罗马帝国除了暴政以外就很少有其他的东西了。</p>
<p>到了特令托宗教会议与西班牙宗教法庭举行时，产生了禁书数目和删节索引，把许多优秀的古代作家的五脏六腑翻了个遍。对他们来说，这种侵害比任何人在他们坟上能做出的破坏还要严重。他们不仅限于绝禁异端邪说，任何不合他们口味的东西他们要么是直接下禁令，要么直接列入新的情况目录。他们最后还创制一项办法，规定所有的书籍、小册子和论文，不经两三个如狼似虎的修士批准，就不许印行。<strong>好像圣·彼得把天堂里管印刷的钥匙也交给了他们似的</strong>。</p>
<p>一篇标题页上可以发现五条出版许可令，一唱一和地写在上面，好像几个秃头僧侣在互相恭维一样，而作者只能莫名其妙地站在旁边。</p>
<p>说英语的民族在自由方面的成绩是独步古今的。以上我把这书籍出版许可令的来龙去脉向诸位做了清楚的阐述，这种命令在任何古代的国家、政府或教会中都从未听过，我们自己远近的祖先遗给我们的法律中也都没有这种规定。以往，书籍和生灵一样，可以自由地进入这个世界。心灵受到的扼杀并不比身孕的生育受到的多。但一本书出生到这个世界上来以前，就要比一个有罪的灵魂更可怜地站在法官面前受审。这种事是从未听说过的。</p>
<p>事实上，古往今来一切法度清明的共和国都不采用它，只有那些极端虚伪的煽动者和压迫者，才急于向它乞灵。我只要求诸位在我没有一一分析它的性质之前，应当把它当作一种危险和可疑的果实看待。</p>
<h1 id="即使书中有错误，对读者也是有好处的；审查制度不允许读者自己去判断书中的错误，这是对所有人的人格矮化"><a href="#即使书中有错误，对读者也是有好处的；审查制度不允许读者自己去判断书中的错误，这是对所有人的人格矮化" class="headerlink" title="即使书中有错误，对读者也是有好处的；审查制度不允许读者自己去判断书中的错误，这是对所有人的人格矮化"></a>即使书中有错误，对读者也是有好处的；审查制度不允许读者自己去判断书中的错误，这是对所有人的人格矮化</h1><p>“你不论拿到什么书都可以念，因为你有充足的能力做正确的判断和探讨每一件事物。”只要心灵纯洁，知识是不可能使人腐化的，书籍当然也不可能使人腐化。</p>
<p>书籍就像酒和肉一样，有些是好的有些是坏的，至于选择问题就随个人判断了。固然坏肉纵是使用最合卫生的烹调，也不能产生什么好的营养，但是坏的书籍在这一点上却有所不同；它对一个谨慎而明智的人来说，在很多方面都是可以帮助他善于发现、驳斥、预防跟解释。<strong>一切看法，包括一切错误在内，不论是听到的、念到的、还是在勘误中发现的，对于迅速取得最真诚的知识来说都有极大帮助。</strong></p>
<p>关于我们心灵的粮食跟消化问题，上帝任人选择。这样，每一个成熟的人便都要在这样一方面使用他最高的智能，这在人的一生中是多么的重要啊！上帝把这样大的事情交给了每个成年人，让他们凭自己的品行做决定，此外，并没有提出任何法律或规定。<strong>上帝不会把人们永远限制在一切规定好了的幼稚状态之下，而是使他们自己拥有理智来做选择</strong>。</p>
<h1 id="不能通过禁绝恶来达到善；对恶的观察和理解，能够获取各种理论和理解是非常必要的"><a href="#不能通过禁绝恶来达到善；对恶的观察和理解，能够获取各种理论和理解是非常必要的" class="headerlink" title="不能通过禁绝恶来达到善；对恶的观察和理解，能够获取各种理论和理解是非常必要的"></a>不能通过禁绝恶来达到善；对恶的观察和理解，能够获取各种理论和理解是非常必要的</h1><p><strong>我们知道在这个世界中，善与恶几乎是无法分开的</strong>。关于善的知识和关于恶的知识之间，有着千丝万缕的联系和千万种难以识别的相似之处。在亚当尝那个苹果的皮上，善于恶的知识就像连在一起的一对孪生子一样，跳进世界里来。我们又有什么智慧可作选择，有什么节制的规矩可以规范自己呢？如果善是一种隐秘的，而不能见人的；没有活动，也没有气息，从来不敢大胆地站在站出来跟对手见面，而是只是在一场赛跑中偷偷地溜掉；这种善我是不敢恭维的。</p>
<p>我们带来到世界上的不是纯洁，而是污秽。使我们纯化的是考验，考验则是通过对立物达到的。因此，善在恶面前，如果只是一个出世未久的幼童，只是因为不知道恶与诱惑堕落者所允诺的好处而抛弃了恶，那便是一种无知的善，而不是一种真诚的善。它的洁白无瑕只是外加的一层白色而已。</p>
<p>因此，<strong>在我们这个世界中关于恶的认识与观察，对人类的美德的构成，是十分必要的</strong>。对于辨别错误和肯定真理，也是非常必要的。既然如此，如果我们想要探索恶和虚伪的领域，又有什么办法能比读各种论文，听各种理论更安全呢？这是兼容并包的读书法的好处。</p>
<h1 id="不实施审查制度有坏处？"><a href="#不实施审查制度有坏处？" class="headerlink" title="不实施审查制度有坏处？"></a>不实施审查制度有坏处？</h1><p>这种阅读法的害处一般认为有三种。第一，兼容并包的读法，可能使毒素流传，但照这样说，人类关于一切世俗学术跟宗教问题的争论便应当完全取消，甚至连圣经本身也不应该存在。邪恶的风俗完全能够不通过书籍找到上千条其他的途径传播，这些途径是没法完全堵塞的。我不难指出，这危害多端的书籍出版许可制应作为无用，而不可能实现的事情立即予以撤除。如果有学问的人将首先从书籍中接受并散布邪恶与错误的说法，那么专管许可制度的人，如果不是我们认为或他们自以为比国内任何人都更可靠，更不容易受到腐蚀，别人又如何能信任他们呢？如果说一个聪明人就像一个优秀的冶金者一样，能够从一堆矿渣中提取出金子来；那这一个笨人拿着一本最好的书跟不拿书，同样是一个笨蛋。也就是说，纵使限制笨人读书，也无益于他们的愚笨，那么我们就没有理由因为要限制笨人而剥夺聪明人在增加智慧方面的任何便利。</p>
<p>第二，有人反对说，我们不应当让自己受到引诱。关于这种反对意见，对于所有成熟的人来说，这些书籍并不是引诱或无用之物，而是有用的药材和炼制特定特效药的材料。这些药品都是人生不可缺少的。像小孩或幼稚的人，他们没有技术来炼制这些药品，就应当劝告他们自行节制，但是要用强力来限制他们，则是宗教法庭中一切许可制办不到的。</p>
<h1 id="为什么审查制度是一项无法达到目的的法令？Useless-law"><a href="#为什么审查制度是一项无法达到目的的法令？Useless-law" class="headerlink" title="为什么审查制度是一项无法达到目的的法令？Useless law"></a>为什么审查制度是一项无法达到目的的法令？Useless law</h1><h2 id="恶是无法通过审查来完全绝禁的"><a href="#恶是无法通过审查来完全绝禁的" class="headerlink" title="恶是无法通过审查来完全绝禁的"></a>恶是无法通过审查来完全绝禁的</h2><p>第三要说明的是，这种法令许可绝对达不到他自身的目的。<strong>如果采取一种严格的方法来管制书籍，就需要不需不分青红皂白地也管制一切其他同样易于腐蚀心灵的事物，否则单独在一方面下功夫是徒劳无益的</strong>，这就等于把一道门封起来防止腐蚀，而又不得不把其他的大门大大敞开一样。<strong>如果我们想要通过管制印刷事业来移风易俗，那么我们就必须同样管制其他所有快意人性的娱乐活动</strong>。除了庄严的音乐以外，我们就不能听任何其他的音乐或写或唱其他的歌曲。同时对舞蹈，也必须使表演者经过备案。任何姿态动作和风格，要不经过他们批准认为是纯洁的，就不能教给我们的青年人。如果对每一家的琵琶、提琴、吉他都加以监督，这种工作就不是二十个检察员所可以胜任的了。人们的闲谈也不能任其自流说话，内容也是必须事先经过许可。有许多教会的书籍，外面包着一个包藏祸心的书皮来发售，这又有谁来禁止呢？是不是也由那二十个许可制检查员来管呢？此外，乡村也必须派访查员去检查一下那些短笛跟三弦琴里到底演奏那些什么，甚至连民歌和每一个提琴演奏家所奏的全部乐曲也得管管。谁又来管制我们日常的狂欢夜饮呢？民众尝到沽酒买醉的酒家去闲荡，又有谁来禁止？男女青年互相交谈，是我国固有的习惯，那时候我们也必须加以管制。此外，又有谁去制定应当讨论什么、提出什么问题，而不至于超越范围呢？娱乐场所又有谁去制止？宵小之徒有谁去驱散呢？</p>
<p><strong>这一切都将存在，而且必然存在。</strong>如果我们从现实世界中退到绝对无法实现的乌托邦政体中去，那么对于我们目前的情况是毫无裨益的。<strong>我们必须在这个罪恶的世界中，也就是上帝指定而无法逃避的世界中，制定清明的法律</strong>，这一点是禁止书籍的许可证制度所不能办到的。这种许可证必须会牵连到许多其他的许可制那样，<strong>我们将会变得荒唐绝伦，疲惫不堪而又束手无策。</strong></p>
<h2 id="用强力来限制恶，会让美德失去意义"><a href="#用强力来限制恶，会让美德失去意义" class="headerlink" title="用强力来限制恶，会让美德失去意义"></a>用强力来限制恶，会让美德失去意义</h2><p><strong>如果对成年人的每一种行为的善恶问题都加以规定、限制跟强迫，那么美德将徒具空名，善行也无需再赞扬了，严肃、公正和节制也就没有好处了。</strong>上帝赋予亚当理智，就是要他有选择的自由，因为理智就是选择，不然的话，他就会变成一个做作的亚当，木偶戏中的亚当。上帝要在我们身上产生情欲，在我们周围设置享乐的事物，如果这些东西不是经过适当的调节，就能成为美德的构成成分，上帝又何以要这样做呢？<strong>如果有人要借助消除罪恶的事物来消灭罪，那么他就是个不通事理的人</strong>。像书籍这样普遍存在的东西，没办法把罪恶从其中消除。纵使你做到了这一点，罪恶也还是原封未动的存在。你虽然夺走了一个贪婪之徒的全部财务，他却还是留下了一颗宝石——因为你无法剥夺他的贪婪之心。你纵使把一切贪欲的对象都消除掉，把一切青年都幽闭起来，用最严格的纪律加以管理，但你却不能使原来不纯洁的人变得纯洁。因此在处理这些问题是必当极端审慎而明智，<strong>纵然我们可以用这种审查制度消除罪恶，但应当注意的是我们这样消除了多少罪恶，就会破坏同样多的美德，因为德与恶本是一体</strong>，消除其中之一，便会把另一个也一起消除了。上帝的至高天意是你有理由的。他一方面命令我们节制公正跟制止，但又在我们周围撒下大量令人贪恋的东西，同时又赐给我们一个漫无限制而无法满足的心灵。试问我们为什么要制定出一套严格的制度，忤逆上帝和自然的旨意，取消那些考验美德和体现真理的东西呢？我们最好能意识到允许书籍自由出版就是这样的东西。如果让我来选择的话，我就宁愿要一点一滴的善，而不要大量的强力来限制恶的东西。<strong>上帝对于一个贤德之人的成长和完善，比限制十个恶人的问题要关心得多。</strong>其实我们的视听言行都可以说是我们写出的书，其效果跟写作是一样的，如果被禁止的仅仅是书籍，那么这一条法令，似乎从根本上就不能达到本身的目的。</p>
<h2 id="审查人员的品质不足以担当这种任务"><a href="#审查人员的品质不足以担当这种任务" class="headerlink" title="审查人员的品质不足以担当这种任务"></a>审查人员的品质不足以担当这种任务</h2><p>还有另一条理由可以说明这条法令达不到自己的目的，我们只需要看一看许可制检查员所应具有的品质便明白了。</p>
<p>作为审判者，拥有书籍生杀大权的人，那些决定书籍应不应该进入这个世界的人，他们的勤恳、学识跟公正，都必须在一般人之上。否则在审核一本书可不可以通过的时候就将发生极大的错误，危害不浅。假如他的品质足以胜任这样的工作，那么叫他不断的毫无选择的阅读那些书籍便是一桩极其枯燥而又无聊的工作，在实际上是一个巨大的浪费。任何书籍不在一定的时候是看不下去的，而他们的工作却是不论在什么时候都要阅读一切的书籍。像这样的工作，对于任何珍惜时间跟学术或稍微有品评能力的人，我万难相信他们能忍受得了。担任这种工作的人已经有清晰的迹象表明自己希望摆脱，而珍惜自己时间又有才干的人，似乎没有人十分愿意接替他们。只有那些希望挣一个校对的薪水的人才愿意去干，那么我们就能很容易的预测出将来的许可制检查员究竟是什么样的人了：他们不是骄傲、专横，就是疏忽，怠惰，便是卑鄙的贪图金钱。这便是我要提出来说明为何这条法令何以达不到预期目的的理由。</p>
<h1 id="审查制度是对学术的打击，对学者的侮辱"><a href="#审查制度是对学术的打击，对学者的侮辱" class="headerlink" title="审查制度是对学术的打击，对学者的侮辱"></a>审查制度是对学术的打击，对学者的侮辱</h1><p>最后，我要说明这项法令，对于学术跟学者是一个最大的打击跟侮辱。它不但没有明显的好处，还有十分明显的坏处。</p>
<p>这世间有一种是浑身铜臭的冒牌学者，另一种人则是富有自由精神跟天才的人，如果诸位不想让第二种人完全感到灰心，那就必须明了，一个学术名望不高，然而从不触犯法律的人，他们的观点跟忠诚，如果得不到信任，以至于被人认为没有人检查跟指导，就不能发表自己的思想，不加管制就会是散步毒素，那他作为一个明白事理的人，就将认为这是一种最大的不快跟侮辱。</p>
<p>如果我们从老师的教鞭底下逃出来，又落到了出版许可制的管辖底下，不经过草率从事的检查员胡乱检查一下就不能发表，那么作为一个成年人，又比一个学童能好到多少呢？如果一个人从来没有作奸犯科之名，而他自己的行为又不能自主，那么他只能认为自己在自己的国家里是一个傻瓜或者外来人。</p>
<p>当一个人准备向外界发表作品时，他必然会运用自己全部的聪明智慧才智。他辛勤地探讨、思索，甚至还征求贤明友人的意见。经过这一切之后，他才认为自己对于行将写出来的东西的了解已经不下任何以往的作家。这是他忠诚的写作，运用他的成熟的智慧得出最完美的结果。这些作品却必须送给一个终日忙碌的检察员匆匆看上一眼。这个检察员很可能是比他小很多的晚辈。在判断上远不如他；在写作上可能一无所知；纵使他可能有幸而没有被驳回，在出版时也必须像一个晚辈让自己的保护人领着一样，让检查人在他的标题后签署以保证他不是白痴。这种做法，对书籍、对作者、对学术的庄园，都是一个莫大的侮辱。</p>
<p>要是一个作者想象力特别丰富，在没有印刷之前可能会想到许多值得增补的东西，因此作者必须不辞劳苦地跑到检查者那边去审阅他新增的内容，他就不得不跑许多趟才能够完成出版，因而造成很大的劳力浪费。要不然作者就得放弃他最精确的思想，而把书籍以较差的水平印刷出来。这对一个辛勤的作者来说，是一种最大的烦恼跟伤心的事情。如果一个人要写书，他就必须成为一个学者，否则就不如什么也不写。但如果她所写的一切都只能有一个家长式的检查员完全按照他们的判断加以修改跟指导，那么他又如何能有威信地作为一个学者而写书呢？</p>
<h1 id="国家的当政者可以做我的统治者，但不能作我的批评家"><a href="#国家的当政者可以做我的统治者，但不能作我的批评家" class="headerlink" title="国家的当政者可以做我的统治者，但不能作我的批评家"></a>国家的当政者可以做我的统治者，但不能作我的批评家</h1><p>其实这些检查员所谓的判断，只不过是他们自己狭隘的胃口。每一个敏锐的读者一看到这种迂腐不堪的批示，就会退避三舍。我最痛恨学究，我不能容忍一个学究披着检查者的外衣来接近我。检查者是谁，我并不知道，但只要看到他在这儿亲笔写下的字，我就知道他骄傲不可一世。</p>
<p><strong>试问，谁能保证他的判断是正确的呢？</strong>“国家可以保证，先生。”但是我会马上说，<strong>国家的当政者可以做我的统治者，但不能作为的批评家</strong>。他们在选择检查员的时候可能发生错误，检查员在审核作家的时候也同样容易发生错误，这是人尽皆知的事情。被批准的书，里面只不过都是一些流行的话而已。检查员的质量是不可想象而不可求的，然而他的职务跟工作却规定，他除了一般庸人能接受的东西以外，不能放过任何到其他东西。</p>
<p>假如一个已故的作者的作品，在生前跟死后都享有盛名，还要经过他的许可而重新复印的话，事情就更糟糕了。假设如果他在书中由于热情高涨而写下了一句言辞犀利的话，但这句话不符合检查员那低级老朽的趣味，就免不了要被他们划上一道。这位伟人的思想就会因为有一种马马虎虎的检查员害怕出事或者粗心大意而不能流传后世了。这种情形下，人们就不需要让任何人去钻研学术，大家也只需要做到人情达练就够了。这种事情对于现在的明达之士来说，也是一个莫大的侮辱，对于已故的贤者流传后世的著作，也是一个莫大的损害。所以在我看来，这对整个国家都是一种诬蔑跟损害。</p>
<h1 id="审查制度把国家置于窒息真理的境地"><a href="#审查制度把国家置于窒息真理的境地" class="headerlink" title="审查制度把国家置于窒息真理的境地"></a>审查制度把国家置于窒息真理的境地</h1><p>英国的发明艺术和智慧，以及庄严而又卓越的见解，绝对不是一二十个检察员能所能包容无遗的。真理和悟性绝不能像商品一样被加以垄断。</p>
<p>如果把全国未触犯法律的人都包括在这一个疑神疑鬼的禁令之内，就不难想象，这是一个多大的侮辱。</p>
<p>一本温良恭顺的书发行之前，标题后面必须在众目睽睽之下挂上一个看管者的名字，就尤其感到侮辱的严重。这对一般人来说都是一种责骂。<strong>那就是因为我们把他们当成了糊涂恶劣，没有原则和没有人格的人民看待，并认为他们在信念跟判断力方面都病入膏肓的，不由检查员亲手喂到嘴里他们就吃不下任何东西了</strong>。我不能说这是对他们的爱顾，我们也不能说这是一种明智的制度，因为在极端仇恨跟鄙视俗人的教皇统治区中，就是用这样严厉的手段来进行统治的。</p>
<p>我有幸跟博学之士来往，他们都认为在英国哲学理论是可以自由抒发的。别人认为我能生长在这样一个国家着实是很大的幸运，他们却不住地抱怨自己的学术陷入了一种奴役的状态，近年来除了阿谀谄媚就没有写出任何其他的东西了。如果我们又像宗教法庭那样实行许可制，那么我们自己就会胆小如鼠，而且对于他人疑神疑鬼，以至于还没明白书中的内容便感到草木皆兵，对每一本书都感到害怕。这简直不是推翻主教制，还是换了另一种主教制。在某一个时刻对未经许可的小册子变感到惊恐，过几天会对每一个秘密集会感到恐惧，再过一段时间就会把每一个基督徒的集会当成秘密集会了。</p>
<p>我相信如果一个国家的法度公正宽宏，一个教会的基础是信仰跟真正的知识，就绝对不会这样胆小如鼠的。如果诸位一定要让我们受到检查员的管制，那就会使一切学术界跟宗教界的人士感到疑虑和丧气。人民的特权会被取消，更糟糕的是学术自由又必须在古老的桎梏下发出呻吟，而这一切又是在堂堂议会中发生的。圣阿尔巴斯子爵曾说过 <strong>“惩罚一种智慧将增加它的威信。禁止一种写作，就会让人们认为它是一种真理的火花，正好飞到每一个想要熄灭这种这里的人的脸上。”</strong> 只要肯动脑筋，就可以清楚的知道，我们的信仰跟知识如我们的的身体和面容一样，愈运动愈健康。真理在圣经中被化作一泓泉水，如果不经常流动，就会干涸成一个传统与形式的泥沼。如果仅仅因为牧师对某种事情做了某种解说，或者宗教裁判法庭做了某种决定，就不由分说地相信一个事物，那么纵使他相信的是真理，这个真理也会成为他自己的异端。</p>
<p>如果我们相信自己是正确的，对待真理也没有虚伪的地方，那么如果有一个人贤明渊博而有良心，他公开写作发表他的意见，提出他的理由，说明现在宣教的东西为什么不正确，那岂不是非常公正的事情吗？何况写作比说教更公开，既然有许多人把为真理而战当作自己的职责，像这样公开写作就更容易驳斥了，如果这些人疏忽了没有驳斥，那也只能怪自己他们的懒惰和无能。这个许可制的阴谋给我们带来难以置信的损失，还有许多没有提出来。<strong>它比海上的一个堵塞了我们港口的敌人更厉害，因为它阻挠了最有价值的商品——真理的输入。</strong></p>
<h1 id="审查制度压制人民，使其习惯于自我审查，逐渐走向堕落和腐化。"><a href="#审查制度压制人民，使其习惯于自我审查，逐渐走向堕落和腐化。" class="headerlink" title="审查制度压制人民，使其习惯于自我审查，逐渐走向堕落和腐化。"></a>审查制度压制人民，使其习惯于自我审查，逐渐走向堕落和腐化。</h1><p>英国的上下议员们，请你们想想是你们所处和你们管辖的民族究竟是什么民族。这不是一个迟钝愚笨的民族，而是一个敏捷聪慧、眼光犀利的民族。他们勇于创造精通辩论，其程度绝不下于全人类的禀赋可能达到的最高度。我国学术研究的历史已经是如此的悠久而杰出。请看这个广大的城市、这个避难所、这个自由之家，周围都有上帝的保护。我们没有那么多武器铸造厂，却有执笔为文和善于思索的人。我们虽然不能制造盔甲跟枪矛来武装正义，却能够彻夜守伴孤灯；沉思、探讨、创立出新的观念作为献礼，忠诚而崇敬地送给即将到来的宗教改革。对于这样一个服从真理而喜好追求真理的民族，还能要求什么呢？</p>
<p>哪里有学习的要求，哪儿就必然有争论。善良的人们的意见就是正在形成的知识。由于人们这样荒唐的害怕，我们才贻误了上帝在这个城中激发起的追求知识与领悟的热情。某些人感到可悲的事，我们应当感到高兴就好。<strong>像我们给上帝建造圣殿时，有一些人在采石材，另一些人把石材开凿，还有一些人砍树，而这批没有理智的人却跑来说在上帝的圣殿盖好以前根本就不应该有这么多派别的人分别在采石场跟伐木场里工作</strong>。</p>
<p>当人们情绪高涨，不但能保卫自己的自由跟安全，还有余力参加最神圣最纯真的问题的讨论和提出新的意见时，这就说明我们没有退化进入致命的腐化堕落的深渊，这也说明我们走上光辉的真理，跟蒸蒸日上的美德的道路注定要在未来的时代中变得伟大和光荣，难道要加以压制吗？</p>
<p>上议员和下议员们，你们自己应用而指挥如意的谋划给我们带来了这种自由啊，这种自由是一切伟大智慧的开端。<strong>让我有自由来认识、抒发己见、并根据良心做自由的讨论，这才是一切自由中最重要的自由。</strong>究竟最好的方法是什么，我想我无需发表己见了。</p>
<p>虽然各种学说各种流派可以随便的传播，然而真理却已经亲自上阵。如果我们怀疑她的力量而实施许可制跟审查，那就是伤害了她。让她和虚伪交手吧！有谁看得见真理在交手时吃过败仗呢？他的驳斥就是最好的可靠的压制。谁都知道除开全能的主以外就要数真理最强了，她根本不需要许可制来取得胜利。如果把它捆起来，他就不会再说真话，而只说顺情的话。我恐怕这种外表一致的枷锁已经在我们的脖子上留下了奴隶的烙印。繁文缛节，还在纠缠着我们的心灵。我们很快会在陷入一种强暴的信奉国教的呆滞状态。</p>
<p>当先贤们告诉我们日夜辛勤地向探寻宝藏一样去寻求智慧，竟然有人跳出来命令我们除开法律所规定的以外，什么也不许知道，这是多大的一个阴谋啊？</p>
<p>假如大家不可能全都一条心，那么让许多人都可以得到宽容，而不是所有人都受到压迫，无疑是更健康、更谨慎、更符合基督精神的。<strong>如果我们竟然采用审查制度，那么非常可能是查禁了真理本身</strong>，因为我们的眼睛已经被偏见跟流俗所蒙蔽，一看到真理是很可能认为她比许多错误更不堪入目，更不受人欢迎。这就是真理远离我们的主要原因。<strong>这条法律除了压制人以外，没有其他用处</strong>。</p>
<p>一个好政府跟一个坏政府同样容易发生错误。试问哪一个官员能保证不听错消息？尤其当出版自由被少数人操控时，就更容易如此了。尊敬的上议员和下议员如果能迅速纠正这个错误，如果处在最高地位的人能对一个人的平易的忠谏比其他人对他的一笔大贿赂更受重视，这就是最符合诸位的高尚美德的行为。只有最伟大跟最鲜明的人才具有这种美德。</p>
]]></content>
  </entry>
  <entry>
    <title>《常识》托马斯·潘恩 Common Sense - Thomas Paine 摘抄与读后感</title>
    <url>/2020/05/10/Common-Sense/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="07448352362eb62506ce2fdd21429da15a0e97342d43b3e8a9642b831704f5c2">7fe911b2c901abdf7527cf489804ba2e9968dc585c166c23d9aaaa5a9bb581d0f25ce4ac02280b89f6ef75f2312a5c4acf4cd6f81b9d44125e2d58dcf345d7de5d2568c13a008a1216c761662ea8a53e2daa29546beb12ea65e57beca1d3b394535b5dcbde5b9db9203aee772a28d6aef38ace9da31de0234980b101e5f02785b0da2558752855d9413656fca045458d67b4c66ba432a2425022bd043f283709966861839f69cbbb9d4b8cc17afc2aa4a65f765a9a64940060fd1d54f1e98497634432504383d21a95be8b6765d787bf9c752de28b052c18e4916744881cc58d7107c22533ed753ac0e88cc7f98cde4bc80dada3841f56c8df8a65b50a0a6b5b6840766e85fda04271a7adf6b385c54156f64e9b8a5996ad8eaad973a6f1b2e7202f6e50f422355a52a7f1333f38162e0f162cbf99f6dfa4fdaca2c57bdbe9a975ee54c8bf5bce0edd9a9cc6c196c64894f5ce05cb532cac58ddb08df5c19213e2924ad9483d1d6dcf698b3d13d84405cef41a20134b02a1c6fd1e6f53a0eb7ad7d72d7a59e952bb82613dfbad70ccd7c04c77e887e581dd959e427e1e0211cd9a207e1f087ee6b6c8621b5d686c043281bdecf41fea24d72ca603879a5fa5f03984a434104eb63bc4cee15c9de8d69d6dc5eddab6bb083a98271a12ec840412c9a56ee8edd468786d1785a5b973d5e626d232ab59fcd01c2b80fef2f4183384dae3b1e6a5f460cca4806e5eafce5417f9c41483ef0d3df32eeed1ff446ee466e3b3f8a7705c56c7e2f6c4db16d2368ed5c0231e3c6db0f2af0810b1185a2d109cab511cea946ce03ddedefbb1b6bc04e7f82a7f00292d6914c749283c5d164d8e1684525e1d69aa61775c8ce064b06f3fc0dfcdc2915c1ed913f1a506ac4754db6ddab10d2e94cc48153a08f2ddd1f5af601c0f7fcc9521a7b3b161b1b5279c4c64bdcc6f8ff5bfde3d71bd35186fdd8fd782d6f9ff32964925c8b611b696bf990759418828e69f0ac721ee0c6fac613427fc0f1b8ff27d7ea3dfd9b17dcb30cc91158a2d72b38cd3337d1dcea9f302cb3b83b9954b555b7db7099ebe7d83b3d084d50a0b16160266148690449560421b0385eed85e59e8e33692707d7b4ceb2edfd692a87224670626b0d237b76b9eec82fb7b4d1bdfe8e39e82f8584042b73c4188c96aff85a7cb1b4184003bf86ecdf9038b655e950cc53c2f68d2d6da8c73ac1b0b287c5fe39c16a22c88c8564304fb7c43824fcbd44b6335de025f2bcd0cada1cee2acae42ab4c084fb0df3984ea4fd2d45a84b7af4ac1f5e236e9137bc68858a5a967384ad4a2b07e23320895c2d06f79abe192dee6cfe6538abcec8870e5a14ff634056e13aaf2571a99a1042cac4662df845adabefde6ea5da606d647a29c8f3c4db07f68517ef08b18f116dc0734ae3140defb6521b6dafabd99453cf3cc2b5b3e8c7baa4fa883ffd650bfb858eb175f1117617da018e25fe45793856369b0aa3a3d1c21ff2632422c6b987398e2e00ea9058ce3fb26271759f9225ecbe7c5adc3a2153a9a8434d71d73322bfabf1a63002808c7c144a2866ae6998c7f8a161e0ce5fe107919697276047ba0d8ad90c4baa97008b654505b3c0905c3cd6455eb31cf41afe2296c88765af8581fad3d9b557a46c2201c283b4097722f65e223fa950e21a2809e946e8e8bc61a3f00a270ff9faf09a94108e6829562462051e468ebe3c34d9a48678e167c3c6af0de6e059eb48bd3c92509447bd9477900f0fa2a888f60587e98d2a6d233e68e8275f4082688b3a7622abc5d5283275391aa80ace964c9e6ca266c23a0ee05009d8a8b1f9a2725a7a20af5bb3007c34217b000e85d6e313aed7ce8563128f28cf6cd99270dd3678a321f7b24e793137eda1d7c7a1277993bf231c94373c23469d8ffeed2c5c8c1e2f6f8d7c37d8661e7b2cb598180eaf65117882f5323d041eb5bcd7ed6e9fe04548692843471e99a9b1cb237eb21519169ac94894263d4966c468fc51873e5ad3f0893e7d782919931234af51b151b943a8e754dfd9c8a914157e999ef03f7a0ca8a46f78bc88f890ca689d9d4aa95e31ac6552e6f1b9cbf1c695eaf004f65bbe5c1070ca268e4dc6d77fb4bc9e7fdba8d2d01969b1a5c85e0c556a1b957895d4e0380fdc2e8b1c559793310002ab3eb744573630ddbbc06c0b04c8b696d44ccf42229fdf108a019aea79fdc37b45f154d04c4552d878184c62826e10d2534e66662dafcdfe63bb520241376d1e1a9bee1e46c27735b346cfbff81a8f1f74b5996f957d690cdc48e71de89896ba9b87edaa0d0702d93a71a09c6bf475068cea70654f7be4ef04549fbe5477416dd0dc99e6bb4437002c47803ee74e2ead2b56e9919afdb71e9064f1893a3de4457e9df11ba53f3b3b881082e9bac752138190a625a1a1b0038c654d4516cb9386e4b6e949d3866684be618021b535fdce94fa941eeb29c25c59dc0076ca6fcb4161ee2f747483db193aede1f0498815dbdc1201fade90ad93833ff6c8c161a74e9510f2a255b8a25365b5019840ddaf6802126824a5cb8940d1d92a0adc30e257343e23cebe7fdf62f6ff47580a147884febcf131dfb40c51385cde8b8141687e769df370fef0a6bb564e5b74479589fa9f80e3db0ea6805ac09998dfa9cbd9b7aacddfc5aedaa489fcf73c4bf2a655489bde6b6397437481a71e74ccc1f3004bdbe0170d870312846eca5fa6193331c90f38594a3e75f36330d3333843cfc64ed6122461a9531602543434b1ce2cb44306479a4d192605e7c87c3d63908941bea852ab92e08744e5158bd47dfbceb931617fcd1317d141d23aed84750b0531e56bf30f44e8f21203b78cc54e9b04dcba1985db3702db8b297d1dd8f551681ba5ea2b1b8199db1accfb4af6b1aba997d60579154300047f1d10ce2b3d9d00fda8b94b0287f651d99f717de3fc1bed487ec9ee68bdaff02ebff033d1933074a635b92b62560452a247e7bcfe59d1143bbd90877c09c9eb54eadfe1affc65b1c292adc8d3d311caecea35b96270f967e16308d232696030e41472a1485b5ae4db4e069b25204a226ead8118086166ec8e337e7e48d890c7e4d5c9d4a876bf7b23734e5c34fd8c0afb6c511ab23bbcbf6cc3ce21da18aca00e453a33137c3f8a68ef5b2fee4142011ea15b26fd0640fcff9a508658976ba2c45e48b666d25b28d8010e0157a2fb547a45548977dd0499cdfb3877318aa99111efdb363a49ebdbe4b229c32e18e211db7eb6c03f0d4870a06e40902ed0647f5317e3bc4e950ffa63f5568267937ff23f7e6a07940a00b9e2470ee69065f231e8246bdb717c47849d1ac05102870897116306553742cb68abeb5c29a3b999f6f728c4a679a1df737d684d58bc1874ebcb68577cb856280853b9be40b6be2f6890882b144aec0ab6e5be13ae1606b92b5e234a4af30af0571a10e0837a0c4db0b6793e69d6c3f1d05eac46a7198555184c87c379f8fc5158aa32a8c0d3ef2f61648970e5d066fafa42305cc9cc29057c4d16d4c9fd5cb1dfe934f2909406c8eb12bb993b4f31a0edc4163724432b264e59925f3f4daffc22b0cee8438427102723c896c76e8beb0c8e702944d3565a213b69f4f50a60e7ae815934e8a4f1c705983f906cb6c293a077e798fdebe188df94b74e5f63a2d00a3a643e922efd1b43ecf930062153f30d94fa5d12829f08e542f382b547cd6d7f3c80fc395cd41a9e1fe6b0f893f170eb3bf0ce916555e75b34386e20d44a5dce2609867392140c73e6b76f2beadd4435064c34fb0b4de50b71ef43877e22715e6d02eded0fc87dd0ee3e23bcbb4cb382981c753532efad437def548dec6eb626c5f7be3448ea095f71264ee9f57fb21bd796e150f90cd27c8b7d73c151e42c59e3e222305db1995921e36ecc815fcc756938d217c4a359626077603bb2833f05af9900aa1cf329a2a3ed26e11a52f3bac60eedaadb2f03e82b255dd2475ffb4372e637ef4295b47084c8f6468d238931293b463815c6c0218038d896084a147c792fbc290c9fcd7bfa747a905783fd15fc977bcc89023e069440caa8551abdef93ada788ef917081f74d3dc2cee91b5050c290a546e1b6a1dfff47f659e6978890214515f517b510f970345191aa28da1154daab71088114797043bac181e3421cd69cf51706a8eee4902241908b86c6bc1ae9e452f0b30bffdf0e3083d4f121a6729fc71e72426f4715e21e137d53df6890ae25e3eda8cb73238e8c3e030c47f89248719bbeab1a1aa500965a7ebf1ad5ab6e8c1ec58a2e4396851883927214e8f3efac4cdf3e474eac786f53c3a81d8cfa399032e10b550ac00458f4787d0ce040d383c7ccff4274c965281e91ab17b585cd98205f234535d1decbc9ff4bd90eb4cf105c7f2473a5b56c2873efccef3ba933e2f0f29c2b3a87cfdb67b5349d2dd344cbacf4a441bf322bb28fa227cb4f81411152aadf1fc9cf5ab094d98165692082483693d9d70da2619f4eaef93d016c4c6c282e2ab8522185c15e335ed46ef07d5259165131a5b10bb67f7bc280359129a492a6655edfb3fca8f51ad014ea44b61d75d290bfb50fc2d3fe73311a1b1eaa52023ec0e291a5a6ed9a2ece003bca5f89e9d7d975f14f49991cb63de001e5671b2748a69ebf7c7956b72f146423724cdf47e616c0c5a78c634496fec5487bad85ec6f151419937b05cc7fa1e029445b59b5a4d000260361b7beb41feb363c5e4b38199da90d4446e80a3e0ed1e3fe4988e4dc4a3a4133c486bda5988dc8e0e6ca05c912018c1f66d9a4e6071f5a983a588d5365e9f5440ee6d5b49570447aca88ff8aa286e716b900ae1e7bb9d4595ff09b31b4d0ed6ec2b40db00bd882165c3cddd36de9b11257c45efc11db78c558a9e52ba2cf0e3a544babb37db9731bacb019ffee5f7142d51977b5ff8b516ef43e34069de8ca6ce3ee4eae9fe2ffaa6ce928536a38a4e5d9e9806a864405559052314f34c70f944953e9a0d70015a3f7d56ef280f5669087e7371e6c711e30c4af727ed3364c685789bafab941188006aeb163cf490cb359303a6e51601b120702bd44a4c6fbfb30f80ab5609d29f046f103f9d5e440e31b77238d39a5d8e99caa453e6760ceed7e75e28c04367713052474e03341c83cba91afd060b5335b2e2597f5a405edd228028aa320803fa0b0083046aaf06a4bc682e24601aa5cc80c536c228875902ff847fe25442cfc00e20305231d22216a4fcf8133e4cf32f6478a1e6f085d0ffda33b802a2e7013fac744d04df3830ff97117fec0d721f8637adaf289432f17a5e4bcd3535f2448ed87e97df2f18d2aef28ab64a3d5779fc56ebbdc8c704cff0537d39c863fd3ff34a459d48eb5793d4d5b45ef1738808bba62a342bf19734ebaf9bf2ca7f016c337a11f95698a3205cd8f8a192745865f6530d1bc1730a1eb58012e1f7f07f33f9bb404a8f658854fd55a8e55c9679ba522fd98b8094ea4b6de99c9911a227b23394020fd031ec9f75b0c6314b9aae491746837f4fbf52ff8e7dd0726883ae94b3d942e8bd28c0773d6869bc5b15847b414f0c9cb298bfd41bab41d35a64b0afa39c823433f92e5733542e4297fec2a0c21b60dc79890a9ddb0130afa961f45a8e2c7c624058e4dbc17d7b80b0283a719f4011487a07ff40fdaca87f5912ff8fdd86ccf12b27348d9222bf8fa5fb1e5e97158969e09c8180cd3ebdfbb573a1ac9c116244cd3ed981ad3e9b95c4fec92275a5910a970cad04d1d87d9d66b0c302c93f08e9d2b4f856dc0fc9eaee232e88074693a9718182611bb53c8716c212e2fe335993d04da519c7203a18a5250ddf4718593a5b3fe295d6e84e91505b91ce63d8a54469b3ca53d53eb99b726043f1bd0772ed7883d833913e882393f2e8f75f7f740762baf938fadfcc5c2c7db5c95c0c30108531d4a7232592c815916b48242ccd9e9da9a73808be8e4f054d2186a8811fdec6810e94276a9bfca0e6bf1aad4427df00301ebbc5ee0a85739877d001279a4f6a837b9240ce3c9c342c7658e567943fe4eaafb33f99e652beaf3fc4f3e0052aef8933bba69e4821f2cf6705622c7d8823e79342d880cbca6e415e8d21e5a699dc11823281055d1ce8f12df9690d58ae62b4bc807291ec843f3969fcfc21268f0bae2481b82cb641be426ba2b400f91545804082538fc96aea432b76660da4a8967873231fbe53627571767ec78370ae8bf543e5e1ffc2c7b49a5656583126310bbd2dd3a4761170fbd4a491a484654c6e0eb9711490adfa14003c3ca00958686741a2d4967de1d8f6e775565b616ed19989e9b702653a89d62548793cff8b1a3976ccb4769b01a4675a4416fbca1edb70aff9cf5a82db161f9dd18a6c20bfffc3959c6faa4b47a36e344ec68035019cad1b5eccf282b8b8696241d8d25a46ca017361ce114292799baf2752fc743f32bf6b493c8ec3a8a1f9539089072397bdf21925af1c1ef4493a6bb10774677ed0150184e87fdd1fc91a76cb4e8828817c6ffe9736f4267805b5af9b9da5c4657efb0f1c7af2aba14ec4b996117164c2cfdd4b0fb263144d8714f27f4927d76ece7df857813d6b95b0e1327791b5a365947870495a337f7c9d4af3b8f4a038c06bf3cb9f0d6c71592e3a73d7b88e38d7ffe2a7d678afc66d0888422dc5583180a7ae2ddc4ed519e281c31ef83563c07f5af7678bb6cfdc346b77d865706f4ce4f5f56fac2bbae90eeb709f6f83a9d3c8b0fce879ba2bf1746c0e4b30d2d8fe21416ddfe473e35a9d22d6946d07321f784a598bb3a948d0419bb0f81a686548524358b15fd853a6f7ec92ac6ebe3f45867bcbdee073129654bd269ae9918ee48462197ed5ce703cd1c58f46f7a03f7c0da6bdeb5728ff890bf03ace0b6b086a727ce145fb9d094139a6036fa364da605e36ee6d2c3cbb2f494c86835776ce4aa130d549be24e385029d844ecdd923ca16cb23872e92b4fbb63be753440598fc7868328f26b75d5e9a6ad3549d573afd9bcba7357a157ec36b3d8a6a12add7db20bd3811de84854fbb285ddbc4c2414c6ea5776c5579b914025e7bc1079c7d68e7397e25d26ad8aba1113bfd8b5c16e6cabee25a407a6ee2c08386e4b406b07ed6ba9846397ea17362b8d320d63d8e355ebd9ac79fc55203a86e08a842afb3c9d3f8af80a428800d9b79acda36d4550b01887fa623cdb85e372731fa40ce5df2a892ba2a46b357b9213bf89a69ac5fd6ba8e45bdae943e59e6f8921f3db9dec30dcf93cb48f0f1fc6d0894c417972b1f76a52891ae983000c1d295b645b93e67db25f90746fac04e25eb82823c9e6a490c50476b38c4d8d6ef431e3e23080d64d5127b87e8fc8f4cffa0b9431fb5e204609a1dbdaf238a09c131a667e3286c36a854207eba3b2e462227bfc77eb65cc8a1800cfacc89498817d8d0a9429fe836c1a6f4be30d50d7eab78b0b6a6b42d7b796a9e6fb4c036b07e88ce2497c8383b6242b29dd4813e67a0d1f9ae33bc83e63e7e472177fdcaaf8291c1d37f88557b95b085e34ebba5c5174600d9db1ab29a17aa2e5d42547d0d109036ac9aa43586d9fa9fca430af01301c6db5bd7c9e88079838296299583fb24a1db015674f9a862350251c5acddf4ea8b2e3e898fdba380006c1a8a6a95edd3351b59ec4ba316d1441d12e33fb61fd7ca40864e290e94c681ee1b29be71eff96f3ca12a077dce7fde21c6d23f66fc4bf8eeade0728ded4564103a558d65ab097652f3263ef35f4b65c9b4180ac5e10c3142dec709159838fe523528d3b31855ab32128b5eadcfc015d3fe9388fa5206398cefdc0206238b26a8cf2016a306e5d3de1959dc1ab8524b54df9bd39b7c45b1ba6dd5e310ea4a2ab44f12f473337d382048984ea87aa2b0347c3568a3726b46bd01a54574a016a0e4de2cb7609c065c605c0ce81b5c1af026015bc10cd7ffacf2d7ef28cc5e8f18e52d597154ba829d1c5115e8fa9f72cca84e17e3fdce0b36cda2942e6a7153ae986ad3eac2ab65965a02edaf7d08f50774087d0f0935cf241ce99838741e68e5e21826608694538b1fd7178ce822da76dff79356c853f1028bc1877821a6ed7b41424327ff1552647ad3cabd4eacb5e83157f8298774c2b39f764dea03394466a630e88e51414dfe5dd815aac849bb5b3b100e72b4e73908b5fa52e4d29a6c05cf20217eeea92d4ce3d14406c4a5d898f542f5796c0fd1f4309d2aa96559471adf81c8b188bad3e1d5f5b2a24a16869b8d2463d05e26dba017cf2d85337bf2d1a16a7656e76a80b3ef0d1541f2f3b6017ef0a60724a677d56f1947219daaa1525c128ce4af4d00fca3ccedd0565a852a6b7e30b86e375a3222eae973be4b8e3be19ebbcee2fd270d79e3b856fab386dcd1d8b075dc303d0330191e7486837bb45397abad8563aa533712a566f1db8f79b0b8dced7efd48f015a3ca20c44947ddd1abfd87e0770fa68eab6fb82a0a28f627af48bfabf285eeafd9c807091bc5148a3c2d52c42abae17f7e0df719b97706a1f3e5c0c9930f75bec2e85417f2c652f65b9077a544f69a9e2631af798cb5a4deccf4d0a2e9173dc02cb2cec939b133bc5e14978af1ed1d49ef2716d48df7dad482930f456727d6dedc35679d9ad8e4e74d24c770a3776baa66039b146c90b47eeccfd8e4ddef9072df8dac850474d309c7032835664f8b47f8ee7e3dbebc30083f6260649cceb977b93fbb5a700b8349f619019fe4e09b5aa5e3a61b3efea85231e16c91752d720a40ab2df56ed463a95ee060433f4e855b5ac232e1ad17c2fb58f8660e6a76c9f156d00a940010242a20fdf639f48249f190f637196cc58481f38b8b3f58f348000e980655477a0fc341092b51a26c009e5863a019b2b199283e52de7513b1b515bb064dc7036c54e22a2e769575cd1dc987aacd0a15b9b75a4a263116b87b1f4ebba1852a8998fa96d704b0f791b40025e1d995a740fcaae7f12dfee1756412c66dd7ff6733c90aeab46adaa43a9a75f00f62f061a75feb0f2cccd6a383bb9a8fff2533daf670b54643f24e78824359e74b72a3eb471a58e14df9ebc63d60911ee8bea7ec3ad3514c640718528867fd34688ac99525403cbcdc288e86aa0b0fd6b126a11cba15ecbf0e39d35d84f3710cbe3b2cca63e0d9d77afa3de83c84dabb34fb30be4f8f197bdf26d8b3749ea9b23a49b32f200112479f9e2be7562e08936f98f7879c5aa9d7d488aec867e372c7a11788777a9060a685397a0bf1cffd12f88a0b138d83768befe36dc72e9a9f71a104bd945bbf428543fd22b85f64524268f7cd912b4fd1387cee33a8f0b4ce15f3d07ee49518e053e9f54265c1fb8e3e10b881643d0638beccc331da8d249882e5eb8c6ec834a1301fa65e1b43b4e9f2b2ab0110c319790ec1f0853dcb06e0d71380c5cd9c48d7f518595512873d9c72db368467ea56e9cc8f74ecc1691982b1c27e579233d98a4142d5ee449345b7a604ce6b1424fb39a061d918cf780fc8c682f501d960a1e252f295aac8bd445f7a99795442d2b3d53ff6f9b260c71d973627a9c7af4163901861206dbaf95b7e78c0b74f348f1201bf9674c3206f2be2c60d45b492c8e216fcc8c2aba4004d3019f2a2cbd780b648097212642fd63e5ca992fad8b273525d1d4104a32f78eeb4b71dc0ff496bd1e728eb51f7694afcfc98f8d2dae657c587163edc8d68eb531879214ef45dcb3f401637dcbbd506dee38597849aeb54b6a0a3b4a4f1c3d0f13793932af584b0390f380b243482ffdff0c68c9403adfb97d9241a0d53484ef2d170051b52b18fc35025f4c37b398921e45cfc74f668bd6c90f8e203627731497585a80875455720368551364616eeb7faea5e3ce852fc5a370a77b1aaf89a2683094a7550ddcbcda878f625e0e69f00dafb4a2117340f579ccc89fd49c589edb27d4f9827d9c317a0865cece2c71d815ded8fb1fb9d9c4237dc1f8e070dd72c2cb5da468da6611dc92c218505c60702636920655c45083cd4a722028949e71269ca2756be05cc644330650f17bfdd1583b888cee00a7ababf0a0af256e5bfc283eb72f5c17374a66c10fc9fef7077a00fef528f61871514dfd5da19e7018ee8aafce2a389f4144ae7d70f6713cf3f506d7b6176ea34c1eaeffefe8c7d4fc887d6a8bf672eb717820053584053241d76b194f4bdbcfbff9dafe90f488d31f1a7a5bb7ba3a11b2bfdff854d018f66362d37433caadcf290a46fac89335212ad247175207f4156abd394c7d7ae1d849a56337d0f75fe254af41cd8ad4f8970890b46aa202d3f194a9285938deba507a89fae14204f63afe7a40e5d3f27e9539794933d13b31dc28d0426edcd705caff3fe366a1902b9f783a81eee6da173d8dffaf8d3169836cc8d6ad65b3d0619c7c300da6e8b57e3c409e963f1c105abf4f6b3259f1072291f6fbf166638ef67bb568fcbc7cc78365da67fd4b2803d21fd4e39aeb68d58ba086f438647bc3f9a54deb198aad9137bdac4593eaa937117ef866e7e1b74223f371b8c5053513c7bf266da76d04a8d79cdc37b4fab6a7bd60923b1649f3074aa6da4e3d1dc889147d499ef74f64c4be9eed8d681aa669c7baed69c604832df968a7e09ec6f0978cebc8a086ebfa6cc89783160597c4be6395f69edb7449f0eb97f968a594a158410f780e2e8ba5ddee5bbb358d2230c0f2d39e55156503d889e7ef900598a2f7e75b5719ffdc96b9de6ee4ff428196e381432a4c50d7b0d2110e5d7a60d353a0f89650fff7c0a95ce74f3e76678d45b7edbb012b37ee5bdb63c955777604ff637686da3980599c0b0624175bc8b9f99252b4daee62cbdc5bfc0f3f7253cd5e2baa237f1bf6c6aa359d636d1c5c579ae32c8bf9a240cb9e48aa8cc030770673bf3892fecebc5e34fcded541528874d7a90024786df20eeb14495a89162b6525c68bddae03b4ad579f50d1f280783eaac6a7197680d23750bfe65e3b9384ed8803bca41e2a39568d690895bbf0d31fd96879de446bd3d5bb354558bedf85be050937184f0cd9166f0cc0d97827cc191a78b77199965731a71f6d8608f730b3747fee75f25eb5ed08c8918431d2aaa8ef2641b76b4ecdc1dc7178109cb4c925c5d8c7ed677016cd6d4e6048bd7013e73d01b02d826bc4e868dc7cc31704399c8be3d4f00129398cc736a8d69af4b9d64088f8c9edb2f84f1959c0087028a81c6dc1094a16ec3e72871cdb7aad7d906a969e206a309bad9533d817615704f444db904c3c4caa49cc968212d0e2ceba5fe0c5f66862b05827570319a80f52ec88431d8e2a3a0f4a89f903a004a98d7b7a97ddfda635a4d7ce554dbde417d102cb324ce61446ea98710d9a8940ca264938872eca54eea71028c332a055d6f4aa07c72f4b646ae0a34492130e2a244731ffdbd84e9a61ef52d3b57fe36ea388d4d04d76cd1727945f88499d78b59b50ee6bf57048d66edac3c13369c4f78922ca36a27678b4dd6c978e341e79e0cbbf9b44daf8df9b510a22cac4689c689fdea52833c17f1ba33d5dba3d4147a1ef0449b4462a1239e0824a266d7249ec282b3d6cb53f3146d51b5827bd038a0f2744da1817990dea96e9a09396c618b2efc87afa3c60969b73dcd9a586c1fd7000dc26263af466db915174be4d72ce2ed7e62b4c2330019ac6242ec9cfe4fb8e91b6ccdb8d790bfe179cdc9d270de01040586f8f68df33795e8a8824a1353b77865676791ff14cbd86ad61ef9d556e7ba4abcca9563761366e9e1405ad9dd08f9549fd32b1af3269a79159fb9506ee3a29cfbfd2eda3bc6cf9784234d08cbca400a36fe85eced4c3c748aba1a185017370dd53d0ecad4240475f9eeab507cee4eeb93b6e9b52163b4f8bb65f892a2d7a57794fa2ff8add80984896c9be760460a144a8296113d2c99d41a63a8774e87660165d22c943adef81d751f26d098a70bb4e93a0ef948b6fafa89437f103e1f11519a7f4bd976b282001d45dda0757cdee70fbf7bda0e92069da6478a63626a1b91e4e995974c7f378a4997fbfd4cfe33c1c5ef3e5da3321517e0bdce46a5585e33c02715c27e666f955a5650826a6743dab9115e8ac8e9001647b1f3579a6678279467323edae7a7246e05e2eef46749b7fcbc95126165a3bdbddaae4dafa9b31436cd964fca9052545a4a135c1ddc10942c3c7759d9036ba3cf5b3f3457614373f5e0d3a3b573b447b6dec142f07aac2e2c0105dd952cbfad1708310c117b7b9a33511aa4516f6c5289aa0a2d7c1ca059b0734e65aae85ca8d9023f3daed4aa8d92115bbec0e7dbb980786462fc4d95a128d026eb8f75ae8af38932beb2c40c802ee50317b5a31ac497313f0524e94945013c9c10e6ea17e766d2dbf4a4f5c6872bf0a8102aa3e8501b2a83dd3d67a82f9d58726a96d8bc97f7151e4d26790457f470b0d34c090019f1bc2a5d094e69a7257f9c6a18a5d6c643e12a8c53d7c0ad52f377a90d15c443bd8c236075498668c2e9579044bfa589344fda108c4514f3ec6405770b535942438a047dc123f672196e3c09c450ac02c1b3376361e83cd6fa412f9180e10ab9949dbedb43a668e52b2f8c8dfc990e04156a9006c986abbe6f7252b1ff61d483eb4f82c80af8508c731ac563410be2d3dd7ff91348ba9a92b9c1e389fa8943332db9387931b3b02ea60bbf5df7a89d4b480cc9b8811d47b3f6a923f0ad6503e333feba8b870f04999f3821fa3470593e17fd99702f71b6076bf82cfc4b2cbc5da9f9a303d99ffeb5fd7d756a8a30fe1ec288a55c3a6dabda4dac11be724f9d051e05615f661a92140678cb160ebe7d8740f9300f2517577b7680d01f78abe9d8130c2901321a9f38ef740d44cf8e7e4e70237341868625cd93aee13f675c77d8397a28ddc1419f75f450f6a6b649e91028918314f3865842404e5b7ea46408083486f55c45677c3f7ad6d77d09d5e5b6476618df76dfa990ae17de24fdb5a35af63455bb332b5bcd907b11b3240b29c3a0e910cc0ff9d3df673e6ef2732f8caa2c3530a53c39039104d86f56fb2161f2f6b8b6ff3f4731be4d490009b520c5d417b930a6c5c06801f988ccd49075e73f7a3a5c8172960a48154ebb51b5c985dc53efb7f3dbcaa81546ba3a08fbf017c4cc19900b6d8c5ae03ba8bc9d68f5e24070c6708d2377711ef17a52d576a08d04458773c00d3333366d06c91f98373a69053bd7d08cb3cd5704ca29a5fc0275c50689e7c32091b90bffc1cb3bb7eec26620b037648d371587089c87d1d0eb2dc1d5c2a2c0b1be13530b4242e22801b18156d9a2321a4b4c59d8b79bca68d62aae86b0d12f0851ba490c93c597ce825b30d6f0fe00b7b4abf01a091435fd0eed9131fd62724bc3471a55f0d3afe5f3cdef4ea53212a910333a40e03b2ae87da94f2270f6b8b9c5d63255621101964c91872ac4302ae63cb6997a7310becddd26288d9461fdf534d03b83638e6851124972ebfcd5d7866ae712adfff268f1b127bca979957243c489c52fa95a667fb8244aa7d0b538a6874c63edbeb77c8d893d2c9ef7b8f0558c6cf3982dcc7bb5aac6d6314b002717d7295d5d69f58b3f8f78326d0494a83610480353d1c66933816c17d0aed017e04914931ec056a904c4c4f9b02ef60c55654e15a86ff34e55385b5fd4a6ed035e64605b890946363be74bc58f6d317fe2069c88488f52893aece3e61cfa56dc6df8aaf48fd0761ee135925872b3b629e2b1a06387d4a6aa6d955205970a2ccdc47addd7eb7d368b7fdc8029aebf0303719e8606eddc25a1d640bcaf0e0cc47e86ec4cf37459eb52804e4a50378e1067aeb02c61c5433dd36cd8b8ab291c78c494a217ac93875d789f0f684b8d1f73fc43a70ee1dc0316c482970e87dea27b407e80d4a82f3d9577f133b6e3799eb31d7a1b2446dfb59283b1976d4e44856716682e9b5dbf2e9f332394de4e1c9bb98b10c58c026febe8a752a56211f92192ff9fa6daeae3e78eec3cfbca108d05fb09e567024305076e5731db7d53a93affdb41fb7efd29a9486fa714b917aceab74661780270f5629d8a35d0514c2e4a94a0641677c271c478f623b201d21608f2e96c98c923cc0292b138b29190c3d90ead86835086bef29b49a3cf24cd3e972bdebc172cf6840ff4d3b69f1e1d799c6391bd6ef136eb61b5bae1a46001f945fffddc452a04e887e1bab69a415511184021aa14fa724dc2ce80bdf0c376f3b09edefec6cce5c3f562420fefdb1b37ce5fd79d09ee1b19ac27eac450c7549eb95826f61820c503f5cbc30130b65feb33730d7d2b73f26b27fc1c4523befd996453a57bd75d64e679b96937f2e9e3fd122955af8064ae549ad6df8e64ce2fce37edc260c0164bfd37c9dee6e349d033e6afda073574e9b7d3cf277a61144bed2179e1bece48272f403bbd0d87b6fbb711b5e0459f71bbe71b18fc62dfbe0c62acba2e903031a4242510665d316530097d51b0f8a112e8f573fe088c13cc09f6b5c617293ff6fac6c839d44ced83dd1760d0fdee4626f02d83fce64300daa33c62ede208c62c78c5ad79f82aab99de8b3b14ca91ce1cc129cc409685571b18b94f28eeb3dd8f26c486ab65d2ca79587f316e5ad07ecfbaadb7fe9660f6c925622b5977efcfd7e4ab42094c13a5443da9e966c2f153781e4da2e1bda5c10ff9576266509c83c55190a00c7954eab09b52fb40fa95228ff9d6406bf13d8a5bb251d433b4430eae025cdd9142f22570ce0ac4f2d4a121ad3bcde879d23b23b6e0981b821e70511fdfc30b5d3f88db1e553e0d6ae6d1f74cac63894b02788673afe39e9f3306ef615ad72478be67af283e91fd6c9c538223ff1709650920eb7e8d15024a725ecbe57342d0d525d402d5a70440b26c705c776cc518fcc55068c99939dafd1f25b4880392d4a25dc06e4f9657efac57a823563083db399d8b11e1f6cd279d615704e96d5d67324e90f1fda84030b4988f9b2e705753e01e20647ad86ee6a3fb3b5c4ee744825b4997efa01bd7b6ea494fa3bf14f6be252a41df51d40feada45295ceea633472348aa6e42dab81783d24e37762ca81cc3571cdf57b4e8639ee800552c15f5e1deffaebdffb588650493608632b74e07d6779acab335404a085ffb34639b93ecdfed843b0a6e77e71aee74ed357a5e508d6961c2a2955a2ee0353502a7e09574f9b1f1ff361f9ae442dd0044a73e1516b690263175fa51ffc282629901dac7eedc5059421e61f35bdccc87602915593b11768ea551bf95dc7a602e24e34f2e8c9267b7b3a963f562ae8108fd4277fe646ae1f9b3973800b3c3b86989b9b6dc364ff69d5aec1eaaebe5bb32c0caf144b243ea31b9074b4bb78576d9ec351c8faa42faa02ffef47b1c9a06cee2070a8d54f10bbca2dfa5fd0b909502404d39db366a3ca4461446b425d7bcbde3b19beade3c29b299ec73732fb1df8eb21f6488169bd6f7b8167ad4797b77484d84176f2e79602d388bb13d3397070165b7ff90cbc47ff8a3906594315a0155f774e7f9cb409a7bcb31f083d18e640243ca741c90efba07ef6c2104146b356a2b598e5da5a578fe172c9eada1da495d87a5eac4fa30a5a81c71f9867033c2f1f81405f9a5b3d8fb2f330895cfd17cabfca88b6d07ce23d645f1c315c87b3430484ccf10bc28ecb11b71e5a5a6f81ea3368cc1d57f2d132a92d2881c178e86e5b716f2bc7ed668f2b883ea41d911bf96f3ae760cb6c00e285a3bbf72dd656876c104af80c7e94797d64edacbd5a0c5ec05cdd22d1ffaf62de2c8cce5d85837099929d0ffc32abe88697c47fc590c1773d8b9bbf15b8c5269d999cfe5b11dfbf25a966b13540a3b40ea6a4366a11ee0664ec7131cfdb3e83c51fd4d6fc0ab978d0d14ccee95dbd2b10d6f095ba07bc1aa67fab593e3ff8d3070d547e1a146301f710eba1572173d46b9b1471f8efd939573876773c8d4d789eb3caae665634fcaa966d3b4d68d805aad19d0e6e452daea171fbbfeab7af5ce13c9acf3aa90e238bcb525a7bf0807f211551b273cc24a50424feae40be8590268bb896d7ba18fa9477a11a9e84fcbb4663ddd3241a6c29b2de1fa7a372dbbc1614ec62effa5fbc49cfd0214494ec6d517a76551e4738751be4cdd3e28066e1f086da3d61fb949682006d336de3884b909c959501de28e7f8b85f8359ab012ffabec438d443f6a8db1d7e5ac77cd93749201c0aeb637d10cebc4097f146285dca9d5cdc0bcc6523b1dd0ed0eaa589139c7d0136871c07a7f440ac6311d1ba3fb8b7f4eee04fc5fc5dba00d6e4a76d7f16e851b64e732fcd3dc4cc1812549bb8665e43bf9ca6191521d483098a1f9e5c7b5f8c93afa46c8535f3cfa71b59bc00891324956d4e0a383ea3c2aa0415e5ecd9563d8aed397222516777a8ece1275f4a886fd392c3de5304413c40eae895712ff9700db853a6607ea44d04cfb51a51ae92db9fac9d2cfb5fa41acb003687be1592352bee13dc93bd4188fc0f9dbffae438317d295eb191f5c1671b808a2cb847cce1c617cde2d2d44f1733ccf5c21afa8de8140503dc49a7f1ae809f1df0874831430bf93c2abfb2605349961c26f9f0db5427b3e518e9c56dc0fe30f6600a2a91f1da39f5dd7f3b12bea9b85c9a500708f292437182379b27218e685affc2b96b4b9b51602253fb13ce4866ae973f45e753a4a8819c5c5fdfed7612a906e006fbefdb4bca3d3de80ddcefe40dda9b60ffa394622aabf9d9711d5bce28d99c66966088b3a058f95f376c0d3a0a63409b35ca2faeaa405ae9782aca8903878e77b628f3ad221fb52c2cb5e92dccd7dfae8017bc8f0bc8b75f3c9cb26ba5a15aec50db5ebeacb5cd09acc7d800928556fa41119ca06c0c7afd5e4cc5ddb158a87a08f3befc2f116b6e6a8f1a8b12661df6d472146cf7c64996f7cb2581c38024cd79cb1ec07cde6a30ed7f508cd646ee30d6342ecf2db8ed7212f34aecc0fae70eb309754cea121a985f99d13120eb78fe53d1d211e2aa36b7332606ac6a86f78e12e70e2015162698a31f27c7e5cccc923a4837b367b2dfc41097cf0ad151a39c3078760bb4bb1ac48e6d98d83a8813e9fde7020f2d9a521d985d4174e843aec86c29f8b7c6e000216cc0ff0cfc005a4648a9074c3be0c58a85470ea206d5c217f3bc1ad94ef7cf542e6dffe85b267227ecbcb67ac16f1ca77174eb1c0f5dac9ee00e374455bd9850454b006865012a251b0493ec5c591eb01865c94e94e62c2a76d006a621d88931c3414fd266a1ef623d92784b57f243d9d67d8a87401ceaebea10e30f860988e9b3171038ba4ba0aa9631d81610949ac236016394d19b159bb39b096a7a89e9e08f176fe036e654c7949c5ffe352f964029d6eb3985b47e9ac5030bc98a26215917894c241bf6f70a5465b67d7a1a1449123aeaf90a9501fa34202e93e70a37fac751c612691832a5e9087acae1c3af65bc23161417ffb0c4b2335635b2e0bc7bf55b5a201fd99cdb42c1abfbaf9dca745082ccf9da881e729f3c1d2fc51e6ef36d14cc4462df93b00050e1c42834e8b9006e9d0d22f7783b6bd25808bd1d674b9cdaa85a7d49cbb28d953b3949a8535de7b37362ecd18acc0d52599f25bc091f6cfc7c677c6388b9cec143652c16aaad85a525b11499b8821b6c7fb8ea030b52c77b5362eff91125da7df3461f3f1d5ecb39dea85b89d1f325f2b16edd502daee35c1a0568ca5138f919f08d960fcb7c617a725b0bfa67508e6ed84e556c7e3c2da9db549a63fe3e5824b55822144240077002ea5f4947c0f77cc84fcc19fd45d615345ea246ce78dca3d72f000354c99d35d71a2f26dc12d3fe62a841850ca6d5b37c97278eb0ba5b512b0dc2625dddf7f9068c59a242289881a41b433701a72bc1aa2d8a3e2c9deb455c408d8f0d95b1c4999ed19109716e199ad3e118df45747a9a4405e70cf91594ace579ae7c735165eb72444290888055923f26236f0cc32fa3ff4f071ed38a45fc7adecae296679f3f6d95001dfc81b722e194b48439178b05a219b267d2e58e2b6afbe249a683c43f577b4c8c407126b982f97075992fe834b1beacaa5cdd45864c94e04e5542d4bb3102e9c30a25793b3b0c97e6b4bd51e89ba82054743bd300cd6edee1334bf6a8c83c052ae4c5bea0b5a5ba9f32b904944a6d9a135d259e80e1a4570ba5ba36552c54b265cf8cd96cd1a2d0ea98a33735685ee1abd4697317bbf91b81def5c222709dcb87d55728e7ec301c8130c305c2531144dc07c270bec77debe0990aeab5990884d16e80094ed94c4f0b1d80bb38e620f0f65104fc83329c36ab38d490f30d6269004aa6bcfc1f9c846132ae1f5e29fdef2a9492d077d01042fb7020a5505e42f4739407b6bfc9f9608363b3e519019eca43f86d52fcbd8388f30470251a419c9c78dfab755ab416b78ffeb69de69e175aa26bb9bddcaf99c31915c7594246769974a7a9ed11b24deaa7973c245831edb94d7f6131b14ed25d91d8cdfa9f01de7225c1c9308e075a44cc63e37d4b8c139e019007429e2c10f4a42c06b9160a37660ef9f291161349860601a27f4c8d53647e7a6acf7e821b59d00ecd45e52246bb72bd9e5cdc281dcad07192b3906d310d1ef88283c1a7ed17151acb02cfcca2afad35c6fc0abccb1856085f43ce2d974eb16c350dd24632d6adf6212a418a59979295ca85dbfc6e48c6f6563422add9f55543a843852e2d68ba7df036c7e9a25a93bfc75d1aaeed7a621c0b33b65feeacce320b481797e1bf1e52b88e9c2cabaabe6885dd9fd1c035ff8a288add7e4113a450d0a2c2e365cc8b25c616869e7ccf08504ce0322f9121e7c3bb78bc908ef92037999541279363cf709cd5249f80ec0ce33483fb49735d40a7d831291a8bc78128ab5ebf2e946695e80fada55c0a85166a6d5b5c52f6720c91b23f91f4fd01a6168e9e3e20e30d1348e607af2b494db53f5d320138cb0a5409171e487c1aca25487007701ac3452413888fd095f4170ce7e324aad7b1b323c55d5a1d2d078d9b8b0858cead52b38461ed57ad77016f0824e9362c6e9b3a16644542c8a9dbd1c047d3ea4fc532696d9edf2136d799ac7a8b463f6ea84a27a9c4a4bfff63d2d4d09edca58c4ccd976fdffad70dcb959a50a8e1f94a408161bed22b618b3d6b218f949f2170bc8a490932e1300b526f38fa31d4da452aec4990a41d5cdffc9c5d2ed883336d275023285b7b612976161b772fcb309aadcf272d4e5074c6c70e343ca4439970e12dba8342e62fb65d27a377600d113eb0130b85cecd408a830ecb828cc919807af580b5973f2f8d8f351d1633b3428b43c81ab2cbf7ab5ad91a354dd4a6fd9605529a693259fd28fd3e11e03a39245de817ae255a09887011a08564f3b979aa4f120b21900e4e83c779922b3df1c5d474ebf5a5865f4db12f40a03457d67f2f49385fc8e03665ae82abb20f1cd1c306a92c689479ef1a836ae9916cc8fd52028caef4755bad343296fbb6dedc4f4cc31d21d89a85e2c99ec4f79d5e927d0b64209d2faf05aace8ef1e1ab1108a44e40cd382779e5118a93c9c01ff8268a79112bb9c46c8862da44f86878bcac4a43ebca21eddd8b29d71ba019da7a3003754ec4019b01987e54b0edeb889a3146b3271ec8b9638901041008cf223341a98ca22dabee730949c8a9f1e0029c55f4eec1503c0c730c335d6f544dd20f1f9a31c6abbad1e78ad9bf6f18e61e2d6536df9fc7b036832d8c401c92a34a46d6a6a9f15fa3302332ede098c877c39fdeb69b41c3538bbdf0310ce631193cdc937f834f398dcf77ccc29a3eed75cb19f302d67cf1d740c34165f91e3a4af04db7eccb985e327cf3bd7b018d8cf419e6a53ced5a45207d8a3e5f02560747d78d97c2f9831e90cb7de7f900f3398a830fdb7c08dd64f041ade0e4f8c9a7e77cbe8800c14c4e015d91b1db060335cf919518ec2a8565d47dc7dd0fe47e67076f29d6a2be33cbda4d4dd98929141c4fc3a375033a75e89c16723f4c41ddd26a2164688c6c3c3c1af495075d0974ce1a423a3336c277952ce952582eb247e1920582656e1a33d94afb3c84227887c7c9ebfe2f5bdfdcef963c40d37287c9bdfa765b6e8458b33444eb19b89323b89a1d30043cbcdb51615bbd76eb55c16b4e1c55c44ca1613e7e554dd9068336d8f4791e05b1d26246a9130019203bcc6792d69cb709d145477397715b98439466f784451be93feb6fe37a4b4e951bfcc0b913451b68e83888c146b722fee5c5afa663f93335c405d3fb2ce54e34077bf2f60b3681357933d186af64b22229ced0e5afc184b67b1ff564d5afcfdc9d4d7dcad7c8f95713a579220b0348db8698affb04d4a1ddc98c5760cb1689ca877f090e0ca031fce8d4048d5bb4af6bacc5a253376eed49317dca6648f0b3851583e8dd75a82dd572640e47e9062097ddca1650bd8fa6203acee7c7ba605c435e9878743806f2a4263f59be730d034fb7f36004f19b870747bc2b8c2a419d4287a54811ed688920c15c6c0d1670296613e9483b89eaa4e9d7a63c53be04d1affa67a4b7c82c387b38c2a93e246ff974f6f326ca0a0ef2f79dd2c3d4063a07da2b45dc40afea02ca7ecaf6b78e2a1a4c9fb2e6ebf7e44cbb9753dcda58980810551cb7b68f8802bab73c52327fb88f1b34cc1316ed6780192c40c1c22517d21873cb77e9da2c38bcbabbf93f5657009cbfa25876f220305d8f461d53d59976e1d17cc54199b35ebec35b17105aa518a47aa4f3ddde3c2969cb98a364d5f05a5bf46ed697b7266c9781f2cd96cba15dd1feee6b9b45cc6643c042321c714c51a3648375c6cc9b8596396d0bb58f8fdc7085914f9b0d7be0b09303719ae5d8a700bb3fe8ceac1926c57a8980231448470b95f47d660f17b8564af8705df38a75b525dbd0f3ef32adefdbb865f7fd08d97a203403b5838831f9497034c759418d4d06efe136c113c16a4cb78b3b331cb4e58be80091f5a68fe7664e5f03c87605157b3cf4963d479e063d91cdcce765d84e49ade36c712e4a5f77d01a47ae320aaa6369c7c2c80de9a3f7f245185638a48655a0da51173d5e39f9538bca371a8c4f61c33bc05200c2057b20d572c6f44e86f85d40dddec917f033e51a848921a48fe7cbf6ba5906c89e994eadcbf80eb5e7a17f036179ed01d0163f86be419ab3cefb10f729935741fd9f1b87be6cede5066d7a9e60f6953fb381e08ed2712ebd6fb04e0125fec02ef34a5b5e10ea0a1f6375ba54d43683988a3d5310bf88d7ba70f020a5701fb95456bd1002dfb3cd62d81d13a8a0eebd0c9fd54f3971ab1a7b9d9cdddf5ea6519522a495b5323e6275505df15e91a421af2eb8c3c6a63f42222377758302a13699c546d178d6e6cd541786283c31e525f61d0fa510af086c602be9d973ad610b15c4128e6b6702cf96e46efb52f451248bf88e4643ad66d79844280858a6c9942e58cb156d9e62523589395ea8ef16add12986b9bac8e7d7d63e601a1482a75f615779975923aacdacc44c2a6afa278739a41675863a36d401648a15c8ddb51cbd5f5768ad44c44c4a8b2547f2f115082397956f31eb8ad706ac85208f60b18481786a7e60971dde86ad29293d7616186cb5b16f1c768a32431085d27ac2120ac3990101f437b93c1485f20c51dfc3030ead654699d5a950e113cd943d1dc9e647bb8d169ca52bd1aa948cd9a12e28da2688ff97e39606182cb7b2f17fd450f817bf392d1e572e4696788ec59dc5cae76d084b780e4ddb3c7365c86d30d0e93be64732808602fb858a876892515e6cc1e421ddc7a6b11efa659536de70f99dc1a51096b1601a67f7393bb5011c603570f7e142ac22bb27058c00ae8bc44ac6008a3f2ff71faade3dbb07d0f9f574ef0ce7a3a5e98c8cf9216279312718483fb16b8cb2ba7c142a23b625c27284aa18c5e054f6134eb23d7dc4f4099380ba2abe611097cefb3bdc7aee4f0846c7de63d81b167217510457c450a467d2db7b435639a9a9fb807fbe423f9904e8a1761b1d7fedf512877396f3fd1eb86aa26630eeb17360d6838951aaeedb9880e1ae6754e927c099ea0b2bc0ee35d03ff10096d702a8d9930e1243e742fe1c0f70fff1545eb49f2864847606493c574cc1a06453f0f55b63ccfbb5e256cd70d19d1dc0b3fa36f2d9402ba423580d10b0df1306c318edad22df8e5936606648ccfb7491a4335c4b1cfce79746d58c951a043e048aa520e61bac9c4ff79b818dc3b0b990e9c16e728d36938979d67ba649ae2fc235b08598a976d420df0b6bf3abc6e95a8279aa58adb5b73e45af1bcc12cfdcb1eae63e3fe783a02f2355e9d4ab1d429349e3d9dd4c84cfb89463d172e8fbef72d7759336936d825ad62be643aef307585e256604edd725921efc50d96838fec5874f0bbad72ce5503cf0554d1f0b3a4fd95cc8a9e05f46a2ef2d81c614240fb146129e56050fb060b764af2ce88d11cbaa37d09e40b8e9c8699e1d5924f1ca58acc582b789ec1ccdcd248178c24cdcb69372e538358e15ed412f0c166ca052ecf78db08c8266045663fbe2fda0281d1e7346722560a61b80c1f5704ca42c21889483e8494166391cd09805b0c41061215cec5e640bdceef055bfec9f9573d0577d11b505209ca868f9457f18cf664e51a453071e0ab0c0b5d9815edeb82c673866a26cbf0cf230b68b5393120860986e630c007eeb522b80f328ecd1468eee44b5b5c8199ee1c495ab5e691837dae8e2aa3cebb4be87a2188f4ba86f9a7a64eed8cc3c5a665a580234351c7dc39b24f205fda6586b257ffaba7e7874050c33760d3d6f0b07b0eedd7a4f97b49a4dbcbd377ca713364bf9de369ca7761a58172b3fccd18930bde79e7a7b0b4a03871ab452fe1a81b70294dde573dbcabc1827fc89a6581279908093dff5bbfb7799f205e9bb6717d1336b7610527295b4a12cce0695b0a1e529466d3d330fb1c65d73fbf5c919e42d1ae73ef5ea2efca67e90e4b43a623872c1787107e133ddf1df0977e3afe45480e05bdb215f4586ab76ac821084172a417fe516e5b01aa6a0045d7fa963041631cc4770bc3b627986d2d3f1cc256ed84dcc2ff0b68bcb1a69a015415bdac6ad96c2f9b9e0a4330dc0419bc4b4415b6546fdec0bc900f8f566b4cfa8f4ed77cdc4b196815f5d1c2667577b327f1dcf6c9a3a380221b0de61543a59df516c4f31e039caea42680b65a829f47786cee180ecbe2deca1155fc065e949b8281b6ae520fde0554cce3e462709354eaca88efd1792504726abeca966b22f06fe90cfcb67a169ac224e869ef4765b581d436360fdfc6494c4f3a8ccc64a17320a798f16df8c3e92de9e925850d95da56e286bdc18b9a546c2132053739889efc88cd8c2672b502ea197c91e0faf81dd7da3130c4adb1edf354c7d459d44290efbf6766f55607d9f21ab3a65d80fbe796dad013bc71558932df5ff013a28b1a9a09a1910b835add08c4ad9e3ca0c8eec437766ab40acea87f31a7f552292a34a7b27647b724cdc77168a292de45f14c7b61fdbe9741e6eb3ab26101312d89d81f2d37cae275882905c6be98f5eaa413f9e217d0bfc4665f485e351f779aa69d50bee63d7e6ec6298ad76a85582c629b68218e47be45b3969b8dcb776a9a7c730d5718c3b6bf0fdabb70e201b10aecf84918de040c3dfb2bf8871c1c474878f5a1d8b378d396c5f32a9ddc7de2b8fdd4813efe0371ec161297126795345a2d511c15b6c1ac94d175510487cdaba5551d1f9e5fb61b33d1a6ea20ecdae444333dbf1b6aab23d72dbcaa9d85028645cf2a92773abbca6e455ccf1b377cfa4236afabad8bcca19d9e607d898e28cee3d26f61a6336520d75e0653716bfe1aac6765a43aad4d0295c586306f23babd68608a6b598ebcdd4e1d20124ad1809e47e12ad7d65688c9c95dd8a95a268086f9b90fdab4b9b6a792e0d84af23adce0220b9f1161a672d53f18ea98690fbf7ec52d074c4b6e385df34cfc8c51aaf69c7ed7c70929451be1a3ef1462f5c460beacac002c672f2863ae39744bcef93881df6330b80fdff8494db12f54cd00ee5f3d67ebd9e8d366a7dbfc379cb4bd1bdaa07f6280bae71aac92a9d2775f46faa2944a75302fc4886a098f074e6ee835a8e34f818a4bcf181735c878dda9e260f1eab2703b1b619b7109f36a3029ceff94c89fef35e76017f215adbc1c2f424119348acc9705fad4d9e077a70c07812c34d637a7d998a32f4225ee7e83d579a13632cdc93d8e894eec6aad554e436c004e4f5e40f2ce192a9e83e291076bbee4b359abd8c95156ece28b6eb0bd38f45c31e90498f8e5c35865c70aabb9cdbce35ab54a8cf2aab2beb95728642bfb660c18499d740e4c068930f56fc242c66dd6ce3e607c90d35e903c17382727457a3f597bfe8a952d116192164ff7e300a9aac877810d290dac7132eeafecf5028eecbf3f282de278d67dcdf4137625dce49a3c5dcaddd1cebbb404bf6bad8743be3c842deb1e5b3bab3ad5e60095418c577230b4814dcfa1a5aac2df68e2c3a38cd74ddc495f9d999efc12e73f174000e80ddcf32252aa6ff30c7059851f8d3a9805a75b60f5e057eb4d28079cdfde5a4fa869dfbafdfd11db04f2fe30f054f9ed287fe0ce65f975689ec4de5b2958a9a427447c78cfe4ecfb2bb840d0db376f9679dc8a465c16726b17c9854f9495b2568d8ccde3a844fc0750dd1c8519550a599bfccea31844e656e3c78e799dd9f21d9c5eab765aa3fd76dce60c696cf1e64605232eed62dc68c497e720efe1bd11cf377d9837b3875f849d2c836efd8720f6f18585b304c7c89a0e61910d63efdd25655a5e4149afd1977aaa0a6528a790d69bc033c33fe1ffbb9abfbbf05001a6f3f632203a8dd5de6cb23eed906390e6a24d415b9a18734375ae5d9f14fde2b2b2e4fcb915842448f2fa1cc6aeb4e4c2322e66cf80893f99f66f8dd8fd4a34018e827a3871fbfee29058b4632f72d17b57273cd66e89dd2935cbbfa900fe9b8073817cb4bc383123bdb52c6643b14689bb97f3779000ec6a5c9d41486820e7330462228e128a63fabe7b4d378f87981b5c66104f130a1dadc628947742a974b0f652275e59cf1374dcf32c5b456598b245a5f77d491957cf610f3b5bfeb0814b5f05597a3bcc7f019b86bbc704a285aedefd9ca2e24836f44792fa166bfa49e1c867d9629b0ad3dfd654dbadcfeed3cea472e1c0787a20033b78eadcc95d1a7e3ac984bd5239ffbaf94d34c14d3709a0eb5373e356a75312b50031ac21a2fc973547321d7cf1fcb2d70a03da21fce3e989835f265b78fbba12bdf20ec6fd1debc34d723308e3d6ad3dc7254fc2d21d6e22030893ec03e92f0d2f3df439585fc1868cdead6c38483d4c5b63145ea01c720c671842773cef29c7ae1766002b44e5181e758ca470c6d43bb8ccff830ebd9e41d647d1359e7a38239502d28cdae81c185f0207c28902c5d02077b0ff04132c94daee90ea81f6c62177a70d392852e7792d216d6155c70b100b2dc4cac9c5ffe8a51ec5d96419236512a58aae2f2bca83922a6b6f82e8591e5c2c4a30e77eba2ef47fa92bd7001847b1312527574c2f08507abdc8b6d0ddb6ebd40db422016a75efc93683fe5139ccc90fdf34d7fd88dfd53dd854c7697f6c76ed61b20726a804b00d49370e62b97fe64673b8ec7f275aafd4bcbf6779fe0b6e8291b2b7f28c55a2289fda9f6627b9cd672589c4e94735d0a40730aa23a552f70abf404535819e34b53f432c110444c43d15c8ba06e1af42600f883e4cf9acb452bb803413c4e4ca431c6a8c7c6f0538844677f30ad825f5c7c637e9fe51252e2c3007de4400e405623ee3857655f8c800cce3fb564c0f8cf5b666cf495150b30f3f1cdb785a31c183c347bacf93b95f5b6820dad61713fa24a8315ae13554bd1acbcd0c2443c4cfcceaec5f1cb1c029c58cf65cd5406da3af84d80d7da3788955461f7335dc2587450870f682a792f4fc70653365ca5b9436481ff92d2ffaa58f2ad844e7e76b2dfe75b15065cdd45eae399fb45a3f90b05b2c324f4ca49efba685eb9cf1209e568b2bcc1c715aaa9000e517f50e97f2f50d23b046e6b9215aee6613cc012445a05b2c53325d5fbcac8084183522a2b466ca3d2360bd3a92d9c49a1fcca5e6a40fc28977fcd3dc0392464adb9bc007e34870559467430d60ccd38d74642347ee5f24ac0f2ad310396e0a07978f77f6ba986788bc22c57c76a00cef58129c65fe50ef2639b646e0727df793879a51a951091fb2108c21664a6faeee921a6b71966fdc58774aa9bf8f1a8d0b2ac0f0e2fa7bf0b0c8ea8bf9dd7b4434a99e6f20af8a05c3bc168922e92d129b7e01e341d63159a7f247c87caaa08451a6f161f8992040c69ac8cc25f170f9d474c52da8096d7524ba9647c773eec9a51d42b73d7dad5e1ded450b8b337df3e2656b22406184e95e2d5205242c295c3932cb3c880d1c3e3e006b293ebc105c204410b5f85a5b9c5520288f04ff334c36e4a6bd08717dae03607959065bbdcc78e3db57f97afa5a40c2940c22c3c69a4596418d01fddfefe5760d97209a71415d63762e3913d3c1d5d1e8813e7cfa09c08855060b1df125250754301cf7073a26ca329413c0c35b169f170a63c36a9637f1db8df893ff1e5659ade1f70a974362163ccdd6700ce7791e6c6f350d83671c1b5b9f31df55beed681dbf44b69c6ae8316151181fe522fdcdf395796bf7c43508560e19bbd09959c125f6f36a668d8a1453418f4bd09230604633d35c4822596929632063b08cf88a6c3256bf707adc60102f2e4bf195b704f44be6825dbfaaaf1d55ea4c2b6d53b28d8b994dea534b6d5e81cb07f97875f527a83984feb797fa4cb33663f84ef81a3eef3ab6f2b0ef75ed047d020946165953bef713debac29d350b2c82cdbf84c2510b2a69e6b700dbb75be21b7d18f7963007d7aa868b4219417e251cd42ef3f9357bbfe3fcaa31d48575cf6684aa80bcdeb0a62f4110efeedb26a6214f0a0ba047e30f7c849e4ef42649c2d74c3e650b18be43a42bb2e21540222a936b014e559f74dc89cf847877120c8ef5136ab2eb37a126eae388b0918533cf7e8a854da3617a0e740c54cfbcdf540d98fa95966e018686b9674e85b241e4d9242c38604af3c9b5f794f55994960e626c5b9aed324548cff51308770ef9279f614377cb7bedd9bad32c54376b9320b07df307e9fa16b434f766f4420073c9eb8bc3265b1d6447c27eb019acfa5a5babf7672c690457dd9fa6ad29dcbde5439990060a166d78a3fb586c738e968a03da413efa344f35d555ee32e1578abee74f481594ff7768e688b8393b39058d1daf641765f288c726a4d70aa928b08293759fd31cae21d053667fddb24d8586839a1c30ba38c8fa6b9c799decf0ecd77cad678838078218a65b4c0291e7072a4fe4ece6056b517c19a7b5318efcb0ff8cd630f9f8bb6f168e35047fac19c9b90a73e7b6bd23d444b1960fab323c1df92667ff4406446ca877436444336976e323952a689a6726ac806bcaf15373c78da7eff16424a73d7981442c6933ca4549ef88c1bd1d4972e7af63438fd4d252815e00dde5fe1b73d22d39f853e30f41c14e7041632839b226bb1465d887a6f1b5b2c5137314282e84743dad06e2cca9823b281ce2c49d86e3491c64568ed040b5666d0c00978048ee7f20f495804c2b92590b0957ebf48d497acb0a4dd24da11337272c967febdc9d0fc3dc179539227bfc683a5de7674fc31c626c604c73d2854095b928779ce8a70de65ae8c6465141a1d16e486a843f2c1ca24c71299878f1bc41ad446eef1d01b2f1a1c5d148ed9fe6163bad50681ec2488aea5a3ab06474b40be4cfd65c4fb634631bf19a49e08536fca18091f7ad0ad1ad937e1f2c9060f7b013bf316bed8ab98e5cb7ca0fff69c9de492574d541840e60b22d18b8f1fc3015a14b072f3077ca3683bd57166f2b61e78956277a234bd09f7bd893ac1d1ce752e8315b008118fb15f3ce9fd1b0caaeef42144a3da5c71e36b9ad2db780a8f8624e09184cb11bd04f9a173495cde04a32bea5df063d4c22bd31cc6b63fb7487ad6fa83d8343971d09ed39a5f25dd8e523aa3a0fdfaac497e72e32dd23280d08d55eee9a983ed6a8591f5671cf101c0a3ebe06f8df82611cbd9f567476b034ab3a7f879a52ee14327cb9d73f2c90455570bd451eeb547d23ccff932ec98ee6dc37e82eef6e22320f1be85226a9e476245dfdc50ed97b20fd08172b1a5bada7c0f6465e2f06f3c3b9a94a5f6c2724d6710bb280d4dd79a9bd55e74077a6865bd13b18448ee60460ad55ac4f3b2c8c01eed54306f9785cfff55c4ba3d6cf5f0a8213d4c56469d21836d9d09124ba7de9e4ebf22c46afd6026ff6b4903f8b3ea006adad436a45ec486ecc2a612e2ea98021cdeafddfd50f0598e762248a67f60f55f30b8985fd4e7fb616d564f6c4a262076622d26b8be249b108f37c4d722e134797c183a4f3ffcf79c54d4c61fa57c150f64bdc8027d758ccda2f3352cc04e238f25bfe66fa3af5dbaa4409b17a3192bc9b488f758b55227e024db6c02f41368a5b055bae970290c068f84512f185e9cde2014484a1f28c1f15ad1a9cd27dba4d22149e2e03a663bd7a664e669c7a505c5b56405f3c0276154ad4d18f6b59df373e53393594a478ab24ce3c3ffd460a816fa9d535d4a76b4985a3b55bb42a2b38268c3f2184dae1ce73c2aa0c3175ac93c918b4b49cb0d30783449bb0a3f393da5c2f72af060e14e8b0eb8fed7ef2c098fee1f90addedd41015074775b1dcbe8bf143a779ac2a12b86e6ae83d7ccfc42f1665ac2faed41a8c4f5ea27dc2b19f3ec96a42fc45cfda8559e8dd9007f8d948a6d3ed19334366e78a6aef819cebf1227173c4964fbc773706c40da185dbb44e66b5b28c8c28c1260cab49d5d95b8d09beaa663e65e670f6f5fa33dd6718018e4f2c3d0dfbd950597981df47fa8930801f25ee920580ff9b1d3e3c9e661075f55d134a67cb5e874d272a8bfd6759482575cdb9280f409bd2e6a9805486083ff886c0de7e585dde71fff2960c388ba702f1bde26703e5bbde399e97d19bc8b411049db58009fa717d532ad115b22878d30c2e376aa84a81e4af169397d93accc93eaa0e97103e4e2cbefbbb319e2ce4829039a4cf754ebf58532774581e072bb8b9022adafcc4d98263f92e4bf45c9ffde46329d713d50e32031947aa34f79eda676e7a4538e74a9c8681a0d289938bc912d6d6689c6d15811d32c54ecec201c68f956ffcb208d38a1193b14b65dd373887f71ab5dba2aa1e47f940ad81e51d1af21b953e4a72f408e2042d82a392b74c159d7e7966e6a0a4999a77c0c7729f0fd12c635902b221c1287a7b33137c3af21276c60afd9517482a8c13fb662f22b3c0ac1ea5bd3d8867da2adb3f24371730fc330a701712c85c0b3c4a35b167842c4295f8cfed0fab11fbb165be8599f7519d0bdd7b617fec7b56b5f8aff4db722ae249ec50c1a29efa7e3ebf939929733bf604fe874b7b4352723c52956806a658ee7ced321f32c6c3b21befb846c5fff0d86e778f7e32e47baa10bba3614643851c5258c57691cf5e69c10805b7a74de2324fbd8307cb4f4e6039aaa06c12d4463e8236705ced5ff64d9a35b0346a8b01728c55f36189f8b4a94617d35104d25a9a5dea2ed262ca9b0bd23cd3e60c99e7016c4a06e20027ee0117f14cf10a9ba08c311973e7bd0f1e47b2199ea853ec840aa57aedd5561684aab2d9396e21abe93789a1fbf47739da418bd565eba70daf592e3ba8a54b39d955ad42b0b41e50f7f73dd07bedc835b19ecff71b0df9dec8dadc5695baea9265f22780eff52ff72834185442cf493cd677d43ba7864c37a5877a13d8d876d6bac6bf85634bea108f62578d3cc14ce28f85e2f9d8f03999be88edea07492c98e92cc0ed916b51abf2dfd9dbbb25ec05688555925bec425ed3bdc19e14396d86bb7ce18239ae6cf944e3dc0d6d56428221b695f26cffa9f6e4f546a34a551c5365ae86cddf0486ec24284a56089e7e7f5ef15e226547c58f5a037f799c243cfc1401687473f67c504c59797c4127a07617f3f2bc9bb7ac73f0fc36d565c4aa811aeccae8a4ce6c885f4e75827c388f17f058093cc7d3cac918d824dccf0b1ecbfe9f667aa8f1a054c85ca2eedf9d598049c0b2669c5fc57b91a5f552f42225e9508e41b0543af46230a7cd0b99893854a63db6ce0effa88396324ac2096a2e1e1d2ddd31037cefa05950e43fd743800558198c2f6770360b37b49f8980e062d1b844e0bc7c27f5c9a6856e69f62c88d4bc3c0a0a5008caa3609cdfb7e9d397ac6d91bb956e1c73d20c7d6af3b6f771154408f2819176340c293a90156e3e64e9a83b27c0dc34f32c81279f23a63b8bad7ee3647f83fce96c56220af2795715a2389db7583853c3143c23454da83c0ddc55bc34a02aa93ab925ed80b406329bd541eae9b6604ce4dc1da2caa599a48f3a8520bc09ed31dda97066d0a94d9244becb55fcd7c9552feabd37d854c4fa038f5520fab454da25bb614b9a8a95c882f62c88e9c1e92d28fff03a2b4aa1f01255b8c48c4b2dc5341186bc3bb4bcdae517c852b6557ae65bca8193602e4a5e62cebf1e566c1f319959276077989e2560f29613335b56cb52dead11dbb3918cf81ab552d5693e6e11cfce91653f008482d325c5be88152d3635129d607b86ea823ca16431b661704fbd80201a7b0294ed67926dc5b7c06923e0d7b998897d4f1f7bd88e0e2cac901a6960b244d38180e5f5538e904ebf34a9bfed08086be77d48ab296b512e714d9e1cfd94e30cde57ed198854120aa5ece4c2bd3bfee6f35b0369290db79e7da64fa4be19e90d9a4af7c86046bce270970e0b9876b37e02f97ff8f2ef0ac73f48a59f3ea97571e2ea8d42ce238ff14828255890446060abae0aa17a4074bc350700d87d5834c2edb5d2b84a80a737aca139a4804d70fc811d1c8b24708ae32700f2f5058730602c39e723121a722db0cc1c9c889f523aa7fe5f2da3e6b635938edce15f67caacb12ad3d3553adeb152136019bf28c8ef9e30397613e79ae17c146d4260ae5b133d97f67a5240852b05c5a98cb3d9afba70e8ce81165cc991353957ea2fba83c74eff15a735a2e2586e0d58e0b2a4f190bc12ada3ea036d81f67c1d99c0e00044bd2b7cb4dc6dadd30159e5b231ddff8e09b352ddfecc6a7854f32a824723780414d3e532a40fb9ed79a3defc3e2011e06bfd390cd9d3375a60ed777dc6c775bf241fa88b26dd1c4111404e274676d00ab5f567778848fb0af64d14f2b602f1f2f95cd8ab770ff7e309f67da6b4f5191df05e4d06c1f0301f4893aafb1c4344b4538469bbfccac4098805d4970487e5af65d44f986095c00a3cdfa254071ec1fdbeec1722a7d6d491917382a519f1399f2420987cc33ab7a6f5f9f6f213b6739008724280746bd57a86c522f5e40635a95913fea13fd55f524a82cad652e56b60981348478a36928c00ffa92db01ae6a4e337bf75bcb1deb15e69f51047ec8f5b2ea27dffb9c4a5bb45d566bd0e7ef71ef88e101a3fb74fb7e499f3f533d6dab8396697819a4fa81a5a4b095464613d56cfa0970e4973a9d2aaffddb2c951397e355d49268c1b26245ec9d3788492c758455e0c4d94e297b510cafa36001f666f6105b0c759f2646d20fc96c9c3caf4ece60c44db51f64f3325a13eadc46d87ad364a2004c6a3792c0e43dcf691f93a243c144097c9d8acda5089ea8f16efe18a529985c04e038171103e4d7ff44d26ed9388526c5c277b8bab6ae8ce4ba4a56a59bed6ceb6c0617fa098ebb95f378335fcd0d50a636c7942bd917c9bdb6f9afb59e8cec2ccab98f459491e68a70b56cc4f0bb2c9e3e70d24390383e249fb53f2b3b5938ace9840f471b9a91ebf5fe196756de1a87acf7d6efca5d88b558703c318e4cb80cd540f45efb004ef550d57700b58658f61558a422508b81364ca33cfc8e1eee17e1d052285e79c25eeedb2c4a682faacb896fff1b4a2a37cc9786bd3ffff5679b342472b2a72f84c82e09b37db0abf15f1604195c2b7ce103dda74485542d6e26855f13affac61030de9821cf0462af7535ef2b672f477af78f82407893619155394c56db7bf34c647d75de0bff0cbb6d9fa951fc7f606ac8f4f9d90325d2e70b40b0f851c1eb58e4de9cc7121921d4ad73f2311b6e0cd39ef1a3fe503027a82c2d74ad1914d7d0549b5d9866d40bee80cf0b1156e0bcfcf0a8dab2940565b387629a54716e3cd3d10c731a9749a5bb01e9967ecd8914c0a7517746127ded9b77d1d7184906808acd15527e90393398882c523c8ead716cc43428bb8cc807820d1e71fc9ed37417df24e38abc2a03eccac183e7d4da2d86c1cae40fdb4f94f88d9e208154b33c9a80393f1253017b4bb2f76540b6d984188d10ffa2ac8bb6a5fcea02355bdff1c5d605f008175214a44646ffe7426cc41fa353954d406f6282f56c5313c5372c2b335be21e3487820724387e8604ad982b21a2604810cc09192fc1645cbc8b9611e1c7fa7a836db8d9f9cee1ad5967572294b40f261b3633b077dcbaacab1617e41cd20805a5678d3927cc87b0d10ffefd33d57f82bab07667d871eeb246806b5b9ac2ee05a8537a8ad8131ffa0ff2a6e0517743c5c6c2125f86c1ab555db9189a4d1482f9f4b52b26ae30b14eb5734f04ac646aae4436e34dacab694b61ee5e3ce242abca09dc4cefbf6bb471526c1f6ffa6d35d3cf4267216b146daf2b2abacf2973caf44c79b588153496e36233b796034cb309ab53fcfb5f3e6d6cd86134fb0f3d92d90fb353ddf5ea7500a089c1a18dca85fbacf166a16ed0225a13d1aa445e6f00070d128e54b1252aa5e69bfd868f2e566788e6f66d70666a1e8a07a3c1cdb0327672dd4fbde4f1506da0dd428a78ee4af5598a12c28cb0b3bb4818d7d0e6b7ed91aea6d8fbc2a4bf47262aa88953e89f466a4a766f47337b8f17ac2ba9321e36a97b81db4f3559876a923fb344d8ed4a6e2ebee15a401727460e71783796b73c76151e4b60b9dabee7b93fd8edd92324de595506da023306f9f1b499c1afe7f4f24a98be422831c8f0c5a8e05a20aaf7ce18b56b4c2f49458de41afe241cb1e8b85c26d0903f8ad21a579eeb4909366c70cab59960d27a9eecc7f4c1f6302255a14ea290bcf073010d13320dbcbc94059c79c4a8cec7cdfb5685154b5094e1a424330b435046894276c65d7660eef7d071817abdbc251dd464211a2c79b8f192cfba260feb7892c361e8b3088b7d0c52eb762a743185b554a8cf0c016a3f8d70dbeaf3103ae9baf638211232c5ef3f5f4e891355f5648467c53021211effe36d7e954b9bd47a45b5b3372edbfc970cfebf3e92cb10d03f66861694b7a0008ba6aff6b16362e12f192deec97b45f28e368c3923ad4e1db4e0e987b54a8434796ebe6fc35a83a15f9674eef3b488dee2ce5a546d76b018a820a55c0c0c8152f322b404698509676decea9b34af0fa24051ca244917fc8b469aa402c5f22e4e2458b7d071d5d229ca84360e2ff73e8aed067f5cc32b118069a84ee0533e90aff083b01713f42377c3f8d3788775f821a2c971049dff2249cf79fde5d3dbb6b82314ce29909f4dc288a6a34094ddc5e35dee68ca0e591c042036fbb03d2eecaea7ff5b29ba8cc10948285d933774966d57d85c30785d8d3f792db57c36328dc353b60eca10fda6bc8156770ef34afc17e515fa56d32ec613e1d144b1473bc2f519b57fad24448331d221a9ae43c3bfed093046ad9f4ce51f717e47b8fba1300a23e02e4659cebcccaf4a2871f8e4c0b457c0f8c6a79696260a472abb487d9ea513e03ca6f52eab21a1bc769ba9987532de36ba58e280adf154038aa88e6d83e9ae4f4489cd2bef115b22d8e67da629ec2272dc0c0876937c6d1142cd7a8d795f6aeb1b669f140072a2dac106f9d3a169c5abde47a59ceed8808447e923b847a7125f6919896a16048d15aa1bc4477f0650e7b13b1110020fe5dbb70adee0d545bc5f73b5847216a51d48b819bc6f202c1cddc6d4df7bb5f9e21ae6322b78c4af2bb85ad921a78aa8621305b6adb1250a92541dd189cdb85a04410ef334c626b2ec6f983057ace5f5b47bdbb29ebd49b72f6fa7f82df6fb8bcfd4671b070b24b10bf98b9d4d0285f12d562a4b06ea26f9ced1d866d13eba249b15b7d998955fe75695b16275f2529f1c63c0b7d4bef87c281da506606b2864df38d86205066b695872ddbcf10a8f9b65cbb52e690f7d76162d2d96a0f1b6f7f9ffa662fadd10d701f342004024b8cfd1794bef5288a4c3d33f7b23cde6966a342c606807fa529b55155fcb30c4c914f320d3912a7de03f028470f2d969e7acc9abf38a896a0b713a4c9b68ed515a7eba5d5ac78bc3c3bfe4114df53c4471f0c775441f983346d00d08a64f3ec21f39b0159f4e20449801e5a9392f8ab42877aeea4a189c4b8adc1c44f96dfd960142833d196d579b6f5eb43d009b561ba5cd6a672d09f82c9a2f152710f23a4c0f8df77f264abb16261e3ac2378df2f086b4ca9efec56b92cc29e608ac90c81555583ef26a45e5e167edff6f35a65b4aefda5897f8ed16eec775809af4e5c928977a8ab1271f5399edd249eb024457ffbdc9ea00d06db82342e4edc1bffbc96547f2359eb7401c74a8e0de4c748f06437c0e2934f1d809e7bd8683c1033d4d91c7af43336cc67ba583ec33f8929b7e202495465350d9a46ec6fdd2d1f352a749dfb9e599d0cc1f6af9b0cdab6e2c6363686f3f677c576cc025b61815b039abb16cd2c873fd349de99af7fdf64d0b90fcc829880cec8c729d78fd0bd6df56f30a02411f90126a72c3cad03d7ec91db5c5d3e7ad5553a51a8a0b28e278f004d8dbe8beaf2911efb75c23f368dfe30f09da709707d7f12ad2ff13a9227429d2825fe080e75f75a5bfbe30f54ed3a8dee5cf67c3e563f3d64de1f75b3906c3e7f8b8cb4f9a3fd124b0b2a9ef0634fd4d31c995cb9f835a7792f5f372db84b036d4d4103aaf4f73ec268cb5af61837f5044ab92f459f4ab2800f1f3c48cd92059bb3c7f9423bdb153e08e294d4c8a11a8251ebb7a354a42eaacdd41d5f71cc31cab4e10c61a52f010f1477222655fb55655f4c7acc92aaec37af45a8b88ddc95caf97b8de9c221364dd95a5ed04572f6e38b3463c0cdb115e1b5569656a808ace240774d6ae88aef57e01ae8d5e3f55cd21c3eec664157a5d235455c71515f0c3d207793da52e5cfc6b250b7563ee9442da022dda4d3aaa1f529218039c1a9f780f9870b8d47641773a164fefd05940807530653c7c6fae3089cf55bc00b91c1849c3d367e1fff7fa96b0fe99f8defeb2143a83074aa0e9b126fd0c883e916b4d411ef931a7c828075fdb4172ce6a7c02b0b72a796db89f71fb85cf77d22ec3f8ab8669e5bc581c6c24988b66f4f06e6b1e8ae51087e24e39ae12f95f9e706cbbd9ee7d98ac07cbe2c7efc0066869b90f3cd666bb1596091b16b52976efc7524c5a7c2e0ed04cc266c25722a26b2ad41953cd03eb1e503b023bf8e5885ef62653d3f6f41139991d36b9d3c8050f1929a6d132cf3e764308f0f360583ab72a527a8d1b9935afc142f4c4f5b527aba4f16e22b95057c017676c84119778b43427b281e20a3f5f6f9456ef1c761a3f6180adc2ed1c91ed71a8f9b2878fd0534d36f00512df486edc164c090f71113c8c4962e91485a5aefaf9335fe80b8be2d3341b06b61d97de75afa762e02a73b1f64bb237acaff4428c5d62bdfb8efdd9ec82642626ec26fab5b1ffa57f684ac68bbf53770cb793bc4c925aeced7d1416276d70fd60ed73af81854c060a653725451d33278317a95ab23e2133fb2bfd26918007466eb3ca5faa134699cd57135d127d8d877c6cfe9626fd7c7c667b0ee6cc0f281b0c8cf528147731d78c8bb7f3d73f8b1739b6ae957a8d908362fb8538dc37add174c74dc9aea6da1d8a06fc6d548d8ea0e2c32480e0101a3fa3e14c067826df985510165cd953c316784fc9009dc2b8a990b2820bfc065999d30f60b8f048c88ffb70347556501a86bd6ce90bcabb0b81a574fd9c521810f5c879a8ee4b72d4db85d6162da6b24f24af408141b48ea21b8b8d528e9c8283329a89d71b2eeb6b3a9a02533a16ffb95797c8c8d0df35e3cbb562aea6388c228244a6f6fdb28bdcf8c1bb41db5a08f928a7d37b625d0b2de84ad21aa7b46db14934cc25e428f8f9699280d5e625cbd5bcc92436f86893efaba7086ce624437aac7f4ce26fcd9956d066838454569df3b4138f248c91fbbde6b8582bdb8a72d28fb7d8df22186b1fe5ef50c85e1739cf9a97622940ff37edbd15ac842807795bad74ee7de47a306bb0c568bef12fd77ce426fc963c7c3fd2ed3e71d8c95cf20a1fc93cd661e3d6bfefddc7a6991ec1304697a4e28e9250304657d86bbb1f002122e5d26bbcfb6e1068ced535a6d93555dd4804740eb4fccfb673c7898341d50754558eb4d51b0d112aec9354b6984da2ab6b6e7fa49c11b47a12560594116afbe9cea91eca74554c192a96368f8035614bbcbd06133672ce525954a52ebd627de96df3b16de226635119dd6e726b07e7a05e7044ac6d278d18b3b33afe2a2becbf1aa4b71ddc7cebb9c932d725b0256ff978f51a602b4b11f73ec28a89f40c333ae044294468044bc71489967384fde79bf2c86e31bd90964476fa5af2fa070e4ca340b1027283c4e8d0d781cb697f45c5c0882c782b06e3817949a190cb391545410844d152dc188a30b462e1ff79d4245f2bcee863190b104c89bc24209074ac8b05391a3f16fdc576903d68826e09f1a55b8fffe670bb5df310d1e44edc036cec71ae5287098fdb11e570c9fc539a59aa909deaab0806513f66e5ac33d27fa0e9ccd2b258a252aa700420e05abcec578e602d7627377b6fd45e4e72054095cabe30e4a58b30788ca763b16d410e0afab43b3873e91bde6025428c54a66cec6421b5022576054abdd1610244765d1b88ec61e8733464bc047a76f2177912a067e42784c55e22932c4e7cc54d0394fe1dcd7a26d23d532873a3d66f14eb4380d420ebe57dbef9460dd44c55eede7fbbffe9fbc4949ae4b328aa74aefa5caea38f7d7b7aa7b23c44aefa44d5fd35a5e28e621bd7368f45f9e2569f4e754f64a40fa38dd494c4a6744f62bf3c6f6a5edfd1efd85a46a4193e85e079fbe2cdf3613c15bae830d515b1bdd134bf47f9cb7f4b8daa0f51bed02df75aa96d3a7f37f389eef3429809818d2e0767e44751529c257bdc914b9f32c32f9fc698ee1cb90fe2a9b660b64c060b6823c3766b2ac89e5faa5909460a68881bc632b6871d519765a64ae836b5f9fd42ef9fc040df7daa2ad13092ff3f350321d06d67f1d00fcd8a28f722d1deb30ad6986462b7be81d0b8dce1c71c95249c6e6846f5ab47383e6fd21fb4059ff7e4349667522db3cf6f45c2960c2bf5649f5555bee19568cdc3a60d217cc5fd844588a9a28643f971be82ae4226777d2f7a8cc5291f785f0c9ba1c3d0bec36531526972a5979820f896d9bbb936fd9ae6948bd17415091960e537561badfababac98b3330bf5b70514897930f5088d75e5ef195814dc7c871f61f7623d3ae99d784618e0d0ad840bcb2c1a619464ac2471674c650cc73b4348fd1ae1944abf3d85c105bf5ce55f47db5a59cacc194f2311728211a1fb08a7de42badbc652acd2bfde09400c6fa289fefb65c77eadb214ae5bdb82cf208c2c03f4697a4603b2f0851276847e2de70677e97c74a6e93dfe098de7331847c9aebe6272fdbfded3af48076e7791a2d9e3514070b7f75e2999a624bf851caff097bcc783e3f1e0737401dea17eb662a055e838570134565f8c44dc874e0141f2a212f9d1c7c69675ab7835d68659480c2931e286939899f8ec91efe773ac21d9ad10118155c49d015693b080b9a5c7b89b827f56b6d85a1b0572812742d386af368ccb56b5223f6fe3ffaba8bf5f4e1f5b68aedadb94e239631b5db4c1cbaa98be35cacbd7be69af85900494cde88d0d67fe082bb3641523e97e6c7eee97e68438970603c018bbfc8e0cd11c99cfc77cd4ab32e331eb1b03968d51d4d8125d6c0e95b9aab5d97bae8241b27e6b78afe988fd67daff84f5cb2201a431cdba4b9328d9d5702e929dd7111761358dd143e3ddb4dc16d23201ee55121eb1d1c4c495ac5761bc58b1a19de8dd79bf49b0867a21f952d51acc33d84c3e3bfef7f21f0c046302d05232fae7e34789bcdbf982cbea01f1afc7eac2440edf759e9ff72449cd0566ca1441e135560b8c7d709e177e287f7a762bbc83bbffcd67c48dcac442cbdb438f718d0801ce1f9ddb28be046d30d660b28502854df4092eb0503fe426dcbda73d82a900d350a34ffeaa04897a9b25089ac7b674bc468fd80dad1a3093f62063b5f20608cb0b67544b0b91f40021f6d189cebae87b9f6dc1938ae80c1c1e6d60360ac5ce1a5891ad7b1f4f12b481ac1308749f6cff9348cfceec28a93b613a10065ea9b84e8bce6dc996c1991771b0255fec5114419e12aa56999809a5438a5c307603c8518c3447ca44e933051a207ae27455986c4faf263c5f33f69397e77c774642776acb2e523ee59ff12a7805a7d021c3fc029d289e460250f83a4950a648221ca5a5deee2feb5655ecf67729fe12a3aa839025d8bdb8be0b768f1f597662f89d1c7d6d52fecabbc6336b17db6d275a591d56cfcf5340d73342b8245fbaa1b85ca37c8279e3379cc8a9e40c7c5aae2a581a5668c5509d4a5d0e711f6b5399b406908f44a940853955576dad4465b83be3127dbd21695f0226dbf810e4277c7c133161c3789eb54811cabf91013ea37f3e8970c9642bfa1807adb5f3f7ab5b4aaf5e5a4e3d08a47de8af1ad3651739207ea016b12c29972a07d529b334bae5c52d86148ffe085fcf6e3e4c4a7dedd0f4961cc1e83230bf165ad95d51745dccb7e03832bfd9e514c07d1460075ca213e1304c298ede40e64fbed827f4202bf1af0640dde61d6035158895e59466531268d5102673b364061f7a661ef551bcb50557907ec14e41652b8eb18d21f61846bfcc1fecfefcb57962cd299273897e1a101383ad782344d02dfa0db023b44ed62e6f18863ba4ca146e2561ec29ea95c9af48aec5cbead0bd4045131020f293832be0754cf095e1bbd88d4fc7921d2423ee238516723afaa80deb7c4e80da8b22feab2630f3ce18d02a3c6cbd97204d355972cddbb6428f70aed2f298ccad624c2ee5134a2c627bbc651dfe56d5d345f2e8b193ba5ad45ca0b981a2c7173e1810632d5522e9a9edfe66182ac0e161c7491f166a8bb02ce23200d83c35a9a3b007b9ceb316f8615d9c77c57040e41a18d39089bc5d782661886b85b2ce03ac07a68d9ee1aaa655522a38ee08723716aa8af4f73df570943a124152308b99330516461062197115c51cf4a12cccf0b063fe34413dde4a09d7d164876b9c28b4ad3221a3eff752087bec53ac9d5f5bbaa0e04d72682782809fc59f1add529914e6feb4c1e8399fe197dba9366258f43fd0def744aa02478bbf8155e1839d4bda1d80e03fb5c25403631aa6f100f98f64d695c15032f5c7f71e22c2cec6710cac2fc4bedd6544711cb75c2e2d98c194aa1fecde33697ea959d062927964c916b3a459119edc2d540fa0a2391207f5d6c4787930cb7882fec78d622ab83a0ed11811856fbb1c20398f5ffed48ef1b2475a71014c443ab37f2dc49b85121894e9664ac3ec8d650f3fb367e37db5d8a44f8dc52ec4d0923a0131e25146befc0fb371f5ee98ec376304b48f2f8766e5f3955c9309d0b9a0c6684afb1a4d76b915353ecfcfb9a695bc488f5ade05b07a83a645923b8165ff1e76c780ff3644a717207d0b98f2785ff53983bd076b6a10e0dd7e3edfe423f5a4859d1c639f027521eea96360bdccb10e1ed33cb99a770ab61e250f9136d7285a470624d1ae2d3ba20d4adfb0f6e317adec6873adca4078d9789bb9057a580c0c94a036c2076185d0bb057fe1c45918fb4faf378b664b3cac1df1fdbab50ea4ccf4556231a931a5ef7785bd5962622fa831566f6ef4447586ee141de0ca6f1bd41eec63f3d055eba294adebf4ede4cc4aebc7a4effb44b893eb4562f048739a438e730fbc51e3474f73900ef81456a4aabf4215008a6dac472d13a64b73451320b2ec82fe5f8c01d9c1f1ddbf3f4311768f0dcf691c6f108258b5e6aaea2e743cdff3e081596eed1b9ec024ca435e46d147a85229d170219b786885ea5906d0ba5f73c0c17cc364d3ff612f6039bcc7b3ef5b1b8e437e50c8db9b59d83d861e32c68a7a33d1c0f13446c0ecd538b6161616a2c5475eda8bbed3b12723d3db0ad6f2f33d3115024851bbbf14786d136f54a79d77c080a02228556ece3e4f185cd5035c8f6e8eebd012199b9c7b498a614e8e6a102911fc7c8e6abe5ce51f5073b7eb11ad2d206d6e8c4d85cb0c5148f9c288ec1f812948b280391f33e08069edc891cce88e9927a0250867494c3df41c16941fe3f0214908ef639beaedd414bdfa0bcf22c3f594b8f4e4494be7603f49129462350db8290a81aeb45edf12d9f5886079a656361936e0fe6b06f6b9c7a8c78d608907dfbaa8fc490b1f587612b631172c974b23260a1c74fce49d8d9169e82b9a052684a8d878d72d223ac7eceebb945b974a274bf07514519cf279d3eb6e0914cc9cb5ca7dc838d78a025e4febff99f3ed5ff46bfea0db9e6ef4efb5b610b70ff09c2e7ce33db74b6763431d6e6ad6d1fa701ba46b84eaa84dec06405999903dcb12784611e63c34a4b18eb325f64dff3f4e73dcec65178691a078cba66a9198bc1746ed144367a9e9d69fd9a276a2ceed05a8e16e07f1cbbc9bf2135c8e1700eb6be0ce38aeb4ed00f46e2494ee3b6adf63e4f3fe4ede0f06348facc35fcdfa94c1804675307b4dadad787578a5d3e4014bf207ada0b17744843a1ce6af88f03495b685618f2dbfd2e7d13f08f1396d62c3c07a4036805dc589a91ee8c245e9e8f5cbe980292df1c79340912f51303be56aeeb54bc556d12ae800864aa62a9ad72c2e51f37dc4d5773b54f988dfa983e95a840e2cbd2a65dec840648c308a5769abeaffd39a33b36c2b555c86bc292e498a80f2a4e414d03fc62c0976ea6fdade4ac9b9a60834d362ebec925589bf860ca04925980350b614ad5fe1cd692a445df9a1b7608ca2af06926bd78e13e9e519f70d28cbb80c5aab1b9703451868edfd706a48a361edc0cad24165b112f37b83bf6fb8685f4dd0e89375e5f438ac2e0f481fa387951c2998282721b7dac4f4f2fa356651f7caabad031d5547919744ab1b8f691412bd10152aa743dfc86bb5570f820530d8bcc464eee759984d159ce28b8eb222ec253139186499858374348b6bc4f2056c959998e9fda529c3c26eb2f995d9c921c0ab96bc52abf425c4b8ae63ba6000493863706bc5688017ab99ced27bc68f1592ff9359dfba1eb89601e19f4564d04293c0b3372afdf90139b91f308c733895644bb35802f6988192f71691fa2a86efb774cf43baf4113cf466f4b41252a2db9c5c48f34019cd4e6a4abcf381ed82f1a4bf7f3b7f5ea7b59d75549c3ca67135205979ad52b1ca49f9cd541b343beba8ce91d7e404b19e4d1b66d2a1846d9778bd81489a4a9dbe5d74007526a658ffab693641ba733a63c5a38e66f0f752fbd6195f7c2f32b4dd1ab4250b7989fd590c5cae89d8a1fde243b047a9399e37df8d2e4ab4bf70356760ff415ebc0afe631a57aa9cfe0aefefb655b185d8daca07fa50fda39e0a8e75b58e3260ecaa46dd53d6ae1f684362c88c8fabce971e5c0a637a785a9e2c50119cecdee304a3dc3763e20e53fafbf17cbcb08e2374d614b067932349e656e666cc274cf23ae8226c09ed650a1d96047a3c6619fcf24c4367d0b69b7494afedf14337a0ba24203774830ccf16d838691f75f993afa7571a6f45fcab0aba14c770af9779d4ac1f6115ac0c5db8686d5b3a636619aeb8ae49af22fd21346584e67793b996ae05567565d112095899b020ff7afac457859016511f35fbacd4990a999f11b3170312a870624b8de2c77b877b567408f2906ee1072431088922a3555c07ee48d832cae2d78fc921e71e74a0ea4e9017682549056028c1e80aa40933713860811a3f592e1babb2b279a40b22cee6985c26d181bb8326262a195a50ef1d5794a9b119cbe25fa2115fe01a02d002c9b5f174a0382fc6b13e62e8f35ff5d196ad2dd76edd00dcd8f0336252e3fd2b41ca201e7d32779b6da55f82e814b0180777154433cfd85609544540d7a4edb33655ffc7e7d341b668c5256c0c9b73b1e44fe97a07050baba42d50d2a46fd0087e960eb343b6ee530246050c12690965bdc66ff2f84824e42e500a81c177b583dceb04a313f556387b8d3a171d51394c9340570542877664f1b7e9259a147e47d83ccddfacf1227139fafb468da56e023ef93de130f6fcc6f9f1c1c9cc35ef25557d8686f47ba632cbf7a8af83d0b50e6dcaeca36e282203db558cc181c6a4d07d0704853b8174baaaa6b77cfe7f27ab0bc2026c2932705ed112be05d6a5247dc38ba2d4829b8f076b3003ad6ee49f2598841b48e9e64cee89d2c99f2a768d1363db70c9f51fccade5ea96e1fe66374240bfd43452bd55d3e4b2e656507ecdc34a24ac59b81ec2afe01ca581e572bcb4334e999775448229c445d9f029454d5f8ba57bd8cac8661156c9973257605957678e8d034f70b2acefd353d6be7ed09c80d9904b578e8f9ffa5f3c244ff2e333c4f6002327c3d62bb4844be35b4ba2e9783c018234bbf0ec826f98ee0a9c8379d1ef9299cdfc433122f9269c02301047b92a921e6f3f9982879a7195d460c4938dd34c37c3324a0edb1e07cf8a63a25032a9e8691421174aa582c637cb2023d24fb6365b5ab623d8f5e1eb8cc623020b30270dd86407e9e43b5ab2a485e088dc7567ff5a742017e2d870f55d1ce7a02f69702b835a40ae907286b35acb8b156cc35a339231b334d7a283e91079876bbf1a1b1fabfe2ba95e4a008758fd7f62ae53a3a21c18e52e14e9a39ae9b69d029e3efa8e62da5561d4f45bad0fcfdcf9d6079c3beba1d97a949e6ccb816802fac5c0bd23630b0dfcc0193fd4bc2c2d6bd2e217545f6bea9a380811ba5d2ce53ea6ba8fca6e940ef365fa642ec7ed753fc3c6164212a71f303db7dbf0b56d6057726df4505f0dfd58374239215260215f3d0fc1a4f184825bc5e1833d6d3db6028e26ea4aae33e2f9de6324c21809912c820af61ca59823a3ad69a28066c1b164863232ba1abce5609dfbfc1d887e96db1d9ec6956d9758fca6b6de8efccc434e7fb9679be299f3af9d335fb4d84cfdad99fc25b5e08a3edafcad09418a6c892efca502bf02c4fcd71c9896f6490c405c6f11aee17c9b05c2ecde7659cad9c45524a48815751400f80cdc36bd13d8c4a73be382cb66a7c87ede27ac727f2500f324542f725b6b822f7bb74558ef5992ad01f9852c79fd43c9a600d9565a55493eb869cfdb6d586efdd44379ec101bcdcac5a7da347d269b2a8e550191b2a2694fe2991f365fb9fc62785853eabe48efb1ebcbfc54cb89c28cda0fd2d3130d480893936153d5e5e2623395d49caefdd0b6f5f5941c55135ab0ab2800a6f4356d6db9feb3a5f988177cb87055f45b875c541c4d59190c496f1758a6184be8dd71f3892a4f94c372785958b3f975f213064cf8da494ed8f63d2fc76b2a02f6a131cb036acf6fa9b553a57bf4df2e394abd2f06a75e31ee9868a404e0b2f4b535c392fc4d819577283d640f1a0041eaf2312a5289b4825557117701cb1803c628e3e96c390b0c6cbb0d93ef1d554dc4f170d021e83fd3d22fce1e1f4030e9883aba87e538f86ce91834249a283832ab0635f8676aefe16fdbcc21d65153d388a1ae758009a9cd3b763aa0500d7b40a9d4e2f3244f9f66ee8be00d1e17278b204516bc2ec181fad5ca474f6ccc36cd6136c2d91cec5937e75fc9bec55beb87c279dc07ff5ccb8582cf1c6c3a6249ea4a65430b5a93a7b0196412294921883a5f7e71ac14685af7bf3653c7fe5f1b028d6253632e76328ad562e2aa16f09badfe5cf8acea8e571481a7087fdbd1165557e04d77b1008c565f2ef82ae5a74adbbdf701a7fb7cdf8736ab8b87bd3bd441a63fd34a09afe924c72e2721d30e39c4d3b0a025fd5b8258aabb4b1062d69cbfd857c3aa74fa24c96a743fe334fbb2a58295e55716ab9e8f56b1ce1257ce9ca4e81a42801521b701f5959a369ed5179005a96982c1f4d62a22968a57cfd6e8012efe00e53def652995a27e6fe0924bf00b32b1c377e87114f36d26130859f46fba9dee4ea8ca6eb95792ec27dcebb2f1b5c6f86ad30abd53311915c42b5cc99167ea094c0c174742c3eb8ddda3ecfbd4ead85488c7332aea3efc63191403db2e89170ce68572fbd00d94b43de28fe85dde3161d9f047eeb1ea8d8877c61c8f8bcd672b9195441ed85f6b9c8c236c950d0071b3223f4685980e34ff06a66f7370fbce1d23b27fceb4c1fb3611b23d99f34da1408df30bc109834965f79309ef64e74ca86969bf46010019d0df24abb54c8d03a1e8cfb97e90ac8012316ad363851b8f7f3ff03089e6d7b7dae15ea00ba9d45ea7402059b29b8ea58c6cd47cb51d84dca7c5cfa7bdd41fa849206c2ad641c9590e3f754087bfe94af0684d6afba56832e100c8dea9f97796043d2ccce3a86209d83fa7c10a504b1ec8409a102f11b81d318ba468620c895bd8665e035f45c3fff3a6e8c73183eaf74cfb7a9bd5383e3645a5d2ada188ef2acd18d5b54b3a7f01041bf9b52ee51bd524caf92e348a57d6616f6ee63ba1015b7d79fdc4cb4edb2d02ebe8ce3c4c95e82b0e8fdb1aec54c84af432d9afa1e587ad52325e3c5d4f14c1dd3760d69a841febb586fc681dcc37e2ff89f4172e9f64fec89d4a5b4f8d0946f61fe1e27c3956af5334c94b482c9e6fbff5330a235fb8ecd7ff3db516fd91eb03b3ba3e8b2120c32a8744a8113c5d8f64e935441d31551e1a9ac0d6e38f758447e8672b1bd5228bea7be22001f2b15e77ec7554a908740c0e826f70c6dd2e2e53182cd681ff56c33d2aa7a4eb885a2d4c0eb07dc70a5b3ca1cbdc9254143334c68c3d8c3fb9a51f6f47ed04e257605ed1f936b7c37aaa4b49ae957347f589d44ab7d193c59eb4ed8818c43acba758ba4f59caede13e0a95ce17bf48172018df5ee9922b2011f66045822a99f617146c7c3d7a04592d7a7a498dc4a2cbd59881acb2baba825395a5164d151fd09ccf00e11cdaabc1e6ee27a33d9bd7ac0c24076512df6af55c391c9a3f5571a879c1e2cb49df060a97a938b04b68884dfff5f3368aedaadeca7e651fcaefb35d19e729607822f6bbdb3a1dc423b958b5839fd091ca72d12e31d119ce5caaa41b9d9cca7d813e3aa78f308f51e04ff38eca83d8d605b015f26bcfe85d8760fbaa4abf4e925235f6cf264597fb737b1b66cc295fa300982c6bdb6693f397eff3ac3d0b4513ed671843bd0e67de22138e778211786b820b6a99e05abddf30da3aa262bff7cd3f3847d8254a17bcbac86d7bb20e8ddd</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>百度和谷歌的对比</title>
    <url>/2019/08/31/Baidu-vs-Google/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7fbc57b4c452787e0f3d5b7ebfafc0d8f8184e5a266186996c1e672658bb01a4">7fe911b2c901abdf7527cf489804ba2e437563510181535dc65d9d0e253e55d223940683156c4700af1fe92fc9afb62f4cbedf875bd5cb1ea0ad803f5b2135ecf531b61e557e7cfa7e13908a7f6c7fff6d8dde20dedbffc8c0e3f73f6bdda3e173117ddb1e08e179d8368cc2789224b1a20609d4708cc39d822f475e6e86a784de9e4b514559b0f85e6c4b4235824c8033578322d95683425cab9251a3fcd5b6d65f5205df98b0ff230f7b2640e2712ffb66a7a2dc1b92768c0c6a555f1f17cadf10934903cbc90164bf7f257d093530150680f991ba038a1f0d6b1529d77d8d58ea2d49fbaac94ced4d9dc978b4c78ffcd73e5b0f7df71bad675c3640745c6e949bcc850830c33a14c881dd5961399c8201679af03941643e91cbadbf9d1005809b7ebc60877fbd01bbcaa8d97b6869be3fed1aece10795be7da0fa16a11727bf544bc9651cc9e4d551362f26e8acb87d3ba1286b92f13dea4674cd0b1cfca78dd65c2ffe1a2dce35a6ef4fea32c2f0d4f43bd73bc0719dc0c57c46f03e869884f6b482ee443cf433ff4f4f84f70f03547eabf260270774e15bd1e78f53d8713c82173964baf162aab841bff1b0c654fb8221bfb7a92e9c217b8398a39d5c87fea2821a328353995fdff3e0521a9ec75459f69e5eeccd7b2ee75e6cd95b39ab37a1405a86ac9d8651554c12d5e28357daac2ec2181a39b2aec25434055424aa58408e881249099d7aa9bbab427ddd5a2dde092f62c7a202c35ea5732a29a4c632792fef12ae728ee1bf855e31f05bd91531348fb2707e904319a076cca68f93a1eb52e7459ae444b3c0615ed502d309a3c2f833b19548fa0d2c67152fec699da9d077c4a7b718d48a3c4c68216d6b0ab644748afd2c40bc8d614664a9798bfb4dad08a2ac7599105b94996944b4619c47c0b3bb7cc80f8c4c874fcc10be6ec3a125823c1d690e662f934f0d0ec575d08d729674eb7bc3b69f58f3c1900f2f7ad5676eb7db23908ed75b183b3fce6cf3fcd84a85d3a02d12fa756f262f352f75473cd6b736835a5e29ad6ab522e803494c0918b202d97bab0f962ff3595c372f7e1fac6fd88ba05ad37087126483f569e1c7db985ed764a3cd183ad5b40aa212d1a928f58bfde8327f491a097c6b769cad0337431469d4052cd2464aba0a8fe94708676ee083c31d9e583ea3ea218de184a259e7d0b5a3b3602af472eed7ba926bbd103c6e6df8dbdc3338f2b236c2d31104e41a3cacfb69055879e14f1a1b0181ea2bb23d79a507b2126f9e089e44ea15da95feb721bc57bf7daf168fe10fc3a829e48d8924388b58a130ba8e47d9fb10389483412630e9f6ea7ef222665f9842552782fc4dd800c9e3c0461bf6864ea846694fd5712028195a64c5ee046ac7fb505321dd8dfe65a75f9dcf2ba0a30cee70def26af83350e5ad11e1ba56f1fc4880f7c7a40465817a80d9b207d4b6e347196f0da6caa20abae4f73831e215d8d2377ba898a78b504360062d0143c00bf328537967b9cd2c5cb348cbe42fecbd7280a2680ff7ab9d83ec67c72cbc418f4849819b7e73da75ea54d0bb831980a3dafb60c079938b3a36642b3407b0e8393b90976e16de23c84bb8ba2044685f1fc23700179d488a1d1d11ca1b417099e65c2d29db3c1acc889c418bec511e7a4f39eeaa79bd750589dd4875a9828730258f1dead6d933509f610b92169ce6a32b7d13c9f5ccad582017768f1af9d4ba8fc1be65a7f4b76f3aa2e916d9c76a9438556beda15e3e9512c477e168a621d3a5334b44bb9b7e398de4e4a861b13603e2abd1dfccb4fc3072a3528ed999b1e9be0dcb90acc2607ab33fa696085d952d4b6b2e4e120cc2fec952f72b36b04c3675c466bc35be1a7e35f7dda72af5d0a03a058aebbfc94a2f879daaf60bbc7aa6003c09299cf466257fbc8c02eda37c57f0ff8c988d80404e012b22ee716e2afc8d9145b4d241e08e4b9711d1c3dfaf44efc1911c8aee478a8622e2239bae05a733ec44d96484dc625704ff6b098f6a5250085536bf315ad23cac9e3400a1eb6e60a5e6d8958ab5750a93a977c9690084efe79e145e7d1a8b5376bbef080cde250727147678b000fed658413760c9c49448cf5d738a1961ffca39965e42acab0200f30426601190eacddb609e22f7528223bf64b51d6da0d9ea450b076d62b620607ad62be26a7ffcbb71c7f682877f172398e4c52c1985e26a676e8d1930b37744699ec45debcf60e952737c59487aea5fd4835e5b1373a35d2227d603353a93bafdd0c2d2c3ca29d7bd36de5631850813c67c12bd7ddbb2c94e69812421edf9c3b4159c97f798531d96c1420b343acefc9c7d64322dd9fc7eed05b4bf187db431f5cfa45ad2fb35f33d58ca57d1c1137f9a8f2d87d11b9a5f142af3711ab8b4d3b2c5ce3a0a59ea334f7b339167b7c82c97985cb3c1c4a49f7a2114ee75287cf24f6ed46f9f6126e77ad6f9c05b64079bc1402225cfaee4614d1a99a2c9e6a6a0ad1f335a69e2616e379a1c869801aa6040cbb6f259c2a3ffe87981c3334bb3bf856ddb6b6b146cda250c18695895ba4264a22e00b7d0a3788c55fed4eaca8978e846a330310d21555f58990853ea7f5bc13cf24948e97c59376b20b1c205b6b354cbee25394629ef8e34c1c887464ca2019ecf8d2b516d24bc23906011d029541a6d3ca8c8bd5b1cb927e78d8209c446c126dca2ce441c74a56f02ba2ccfe33c89f1c480cc892f8faeba1c74c640bac44210a18f91b280906e5373ba0784406cb4f11ffd57ce6d276ebfbac2506e9a01cd587a6304fe9648fdff0c615baebce46f3f709f9188d978714dff41ce96d0c8cdb1e816b85ae32fdaa445bc432b48237c0c11213ca123d155110fb99d2334d0af0ab87fb3cb731f42824b17e7c3594d893b02305adaba46e396efa6987b861210110037f2e0f7860d835bb1e27c0b648067e59fd681f59785f234c4d770ba1664da4762cd0f5acc520c4cb0198b81569b1cf2d7420115686c4f8dbe98d0c66df1c51e743e29181d5405eaa4d9277ec24fb23c4fd32120c1a0f3f48df5e0bf059d1419492ef3456a2b541bfd2885956cb6054ad4daa954f5a81e26f3334bcb02a587333d4090fcd94f1662fb822ade470ec37e8dfbe0b50a5b850d775057c750da3cf5da2d28bf676138207461b0ac58756bbab47e95a424eb9f162026c23cbcf966eef53b19dbf1ddb6ef662ca793dc3eeb3f37cc195352fff87fbf70de6505162a09a2780833c15bc9f5636a8268cb8d51a48fdc8f8d97994b7d9e2e4690206b2ac863e75d98c646daeb5fb136864411e2fa3b53d965d655432442d09c59fe6cc2f5e3203a0c763dafe7efb8ae175bf3396584ae6e5bcf27b0b594bcdeef3053ca15cad70d34d3184359001e365d8744238accee1515da7dec6e2b8c6f7e065dc99c71e211327270b0d831de348e3d7ec3cb2ed8d32a6a18a597fe876aa968c05fb9511ddd7e5c56b62bd35d59cee5aba8eff7ab275d1b13ce464966c4a89f3b825eba7a495f298a31d3c6fa9a64d922a760832bdb8b16c07da51d0f4696909458e049efadc6924da18584f0d8bbf44c1cbf13067cd9f4799e6570edd1291ef46462614d0400714c4da64df18c8c5c251088a0ebe6beb77021882b79954126bc7027e8fea542c3459d2d0ff53c1a1dec1cbf9eb3393aedcc7ea64ec32ea677695cef52c5a93da3d1fa3c627330afa2bce6669c06d01104b8f5410816ef690536dc4a0a967ea66220c6be0096f27e1be6f9ef12162ddb4a98bc34f72e9a402f086561e31209af7d2bea72433874ac822ae23f79937e7867de6dd656e5f2ab5e5d4827798c4d8f911cfa72ab7c30bcdf1ceffcfcc49372ddac9184dae92f79c39fa57ef722643f42835b9544c644db11df16859c9deb74364af157a8eb13fb38f9e67e29d38c19d10da107ed79023713e45c4896fa472bc486678a47792a51d3bee713f291efcb70887f89cb49d7a892a2c049c0516174f3424477ae7f8cea52fdcbf6035af93bada7edd6108b3cab92389bbdf77bce87341d21ee77418aa134ca5ef65ce6ed395ce2bc3e070bf9f081974b4585157243a3ac58dae8422eb93847cf88865945c1cb6ce8e35260adb1456bf901513fdd589c4ef55198684f50afea1ee86ecaa4047de369c58af4d4cc454a9c8c4c9660b9cdfa1acc782a2030202c6589a30e314921df8ac3b54fb92e79cb888605d357b3f8e44bedc02f92511ad06cc6672d5c35827a8cdde34f816890cb5df22bd4d475908ca9d7fe411d9c289c2ef505e9093669b93ba817e831c1f7ed01e3ad73ec45850ecd7be890587d105932bd43a14356bdebded820a30a7b6b977289ee4e0a3e95d83846ea29e2c7d198f06426a46b74f2a42ad8c712b07a1c7c2975ac5a539093953fff2d939cb13137961bb7a0b4dcd55170da429b1a3682c46ba6ac64cea4cc929cb13efbc3b7a0d05c3963f6c77ba1d31ac679d35227076f0e298fb0a9cd2e9c9e7f9722f9246b444508046e0d19a24e27a995f938a94c831c7364a5162a7203e3005ab342f37445157e38d9ee8b7f621a0c7760541295a6bf0493c122dd36bd10ca136ffb0a29e2ba99728f119cb8b83d2b0f4bfc6c2e81c4ea4be967fd531878398f0af85d6094994a9423ff4b106376a6c3025ed283e4bddd486b8961f17b1062083862ca7595f943b446655e3e67ab899a38caf664129b00de82571a138003ae4a4e8e07eec687667857fa75042bec0916a0602bae8233cce24b565b6c9d84cba25b4a6f390f7a93f5381071e213890e4d7843291516476f7945cc4b3637b06f70c074f2f190669351cc456d65b4c990083a0c75db9e4c969c57aa91fb35eaa837668b50e511ac8c43e9be8bd016b4b0b2bcf9db5534b4a96553e1c8c40817ed1687e9c82d625c75c0b6addcbb437102854a5930e8029ffe42a7a3ad21d3d0f0ffaf204223756a5678dd51a5cc123a6eca584b955fe52ba6727bbb8535e567cf13c627724039f7ae2d8f66a99c077c5bacf563d2a6f90744e89c6c75c484feae8dc47ab1dca3cd41e7f5582bbfcdddd344516ba30bbeec518af3f22cade9e31e5965de4d9401f0666b00fdd12bf75ad423fac9085fce874bd8af7f2a81541b71cdc38c39aab63faf5bdebbf6af3264e78dab65a58f4ac0bb0d3f2c56be0977845ef5b8f7acabeafedd399785771d123d71e77d67819d90c2be731a147252b95abb8895d239c71e12872bf8182576e31b6895b72be1c4cd04a77d6a6c2456dc2c97eb3e9c2716e5b6fc8295011a75c02a96e889395ee65e812d85be359c78d850439b298779c5e7baaf4a93647affa2c784757be9635b9b577ee80ccd7b8dcaf34497757a769b739b5bb738ca0c55405d4d68242973122631fb000f28e85a37a66443eef934b45de94832d91176542cc4fc6c085bf60c2a25d053a423bd7cc226c7c6066d6b3eddba0b7505b134719270249d3d97275dddd22208798af794e1a33b0774ceb244df6d523da1b21b7a0438a15ccc758129e68592a9d44baf32e77795615cb3db35d3265f462c09c68bbcbbb304eaa28f5d7a4d24dd9d16406b5fa70d5dfb675c4aa35b08b85b89088cbe4507651ddfedb7404072d49e8812c46e262e172f26d3a4e9552b00f8639fcd1ddc9d91c70cc6ced2c7c9248af164e3e7b21588fb72d4d16dc1d5ac32ccf80f80ca83dd67f484ce1e2d730434f4aa59d2c115c31fe71f9409a7c106899c6d59eb7fd961b28c461829e3dfaac22809fb5ed8062a5133519270dfb86d870f8a61adf2c0d160fb48a837957ce91f19cfc1324a4959c4a0a6320a1187d9d021ba2570a10c470b01bd01407ef0b00ef787c4724a62a9a7ae538e16473a8a45ef1757ebaa7299e06947c37cf3e5caa2e2826aae93d37a0afb6b36dc41b264c3afa8548840457defaa3f9d6cd6ec6537fb73aecfd2363a1bc3329f0d9aa4b0cbb5ef6741351820fc75f71b52bbf994116a87837eca618ae849737e698ff1f16ef95e35a98ee41c9f0265cd2d67ef041029f0f5db87e91400f93af7e1838379d8282046c87529af22d9348c4ada2d5863636cbfd02c6dfe63299c059c2eef35172044724e18c15b5ccb2650bb3af403e498581bd3fb52cf22a8c18e7de0033cf0f29b19d9fe42997330470ca166086aa78b4b9bd87583ee3750400f14ee4a780c5ba1ae230b526e7b9ede81f6354125413a973b6bedb36197de8431144caaa95290e507fd974b16976a64241e16630b7fe4a967e68eaf7e71f3b692502d5409a609a96c91f320488049a31eda29ca6cd84a2f13ac5fa429b782243fb7334e883f9e7e64206c31f7c992a0fd175ac53945822168816d5a89a2b8bffe50193c1627b53d0818b5ab5e1e558bdbd4651a643a4aa9ba85791da62f4ed8c20334a7263cf3b831744e74c5d1b4324ed9cb763a07c9fcff1c2982e1d2c2517970b3115d31dd58a2e861979069dc24347094cef7575a86d6208416816cda0e4e81df98b675ab2594c8b4c0b3496b27fc5fb64d633c928c19426dbcb1c255ce94b9a9919e696bf68a35452456f4108bb824c04ff8a3ab5ffe5a8f1b62c99fe06c89a615916c3d68e5c068117511cea08ba75247f4ad79032095d7bb5e1db6a6f4d735d41a2349cacf15cb0889540baca3b1808ffb4b2165018a33e266ae7dea9ef50a8bc5f5fcf7212572a529d588b1ba68c424bef0785e2d8569f68fd4fb5850d3f93e34508299f4f76aa0341a2f01d66be09fb681c0efae63c6b5f20af54eeead2c960e3154e7768e1fc3cb2bfe2b93bbaeda99cfc96006077d75aeae14d7c2c1bde3bc0920b2b539b53ed6e4b8400b48720dee699bbb349050e051ccb71df1267753728bcc015caf7fcb8e9ec3772c59b62a16049ee9947a341b5fd94eae6456c3d3202539f89a0e780c5688b25481c9c0c01657cd843871a7603f023f68a07065f6b097879114e78e5e14803f76c85214d989ca9b762ce599a4194b236cc03cd3dc387c2a7ae5daded326e541d9be29191cf0af82279fbc07a4d292a0c82518b08e40a0e21cda941b5dae3c6456448e832da71ed8822f2aebb8be632778048deead43938b9f414b4d1fe59d2dadec5b96c1743c91291f974308f1d47d99b77c702bfb4fb1ae0da1b00ba3dcf86fae60badc255a902b50dc7e081c81c2a28e7b334ae599dbc0931679c538856604d7787d7e0476886e9d1461290b6e4c387eeface9fa86695478d4205d4d02946ceaeddc71557c9f2831e49a9bff6dc05e925288bd0ce283bff94a6719ebecfec8e937556efd26ae7715fa83e2ac1fc20e5b8ac5f57498a6538fc28a1a309168d7bb56f6a98e20f6de4a1c8680179f58d32f9c48de3568cc159b70ab9fd4d57c44608d5e59cdfca51ce479ea5297d672b93583723ce3503c76b6a0ac592f9782521f72a3c1289e1530ad28d73c6ee8727a0d381f563abc8c9ad04fb2c578592f890cde2d721b9ff7f39a754ab01c4fe2640c48922dce5f6e41beadc5b3b5e35ce4702075dae0499ef80f2b677f3511ec0bc76bfe266317eeefe55f05f26b58c3e84838ccc92fbb4b4d64aa6ba8847e7da3d59cac789c2ade6f98ecd03b83893da5bf92a58766ef2fad379c02a234f5911ec4092ba1177907b2b6ccc424d642c2f10b0e3bf4207928872ebbd7dfdbd933f6208c0d04c466d82ac29ee7b46255cc082aebf9ddb2d7234b6cc99af001b10581a6bc23e32f1c0e3b4f524fb61962b378dbec3f855f95944d11381e76aceb9da1ef259b864b8393b16d08a11c0dc13d6dd99dc53e87d2330f045d43b6a22044e8ab2ac84b2d7b64fb4a7627e591f5e5b94ab47806680e77242da38f64c96fb421847392d34cd9e19576e0836500bd998b50313b0172f96494364ba2362ca807917215af578eeb066f08e016bea718f68cb3541ab43fe034074970d7ff749b8da6d0a822b84276e31618925c18f8be5cf01e82a89e904deea0db61a2d5e806e4fa2e0c6ca4b012eca2bbc766da2390fe8d483fb15ad894729635b8a0c509fe34155a17f538e45d97b03e884f198ec4a4fa489bc8c424a61efb84d415ebb35179d3ac151639ed8833b3f9621224758ff09b9a5b5c3837b841f06e1c5ec477f5ca57e06f04bb337fcd5da7137ec4125460cb1e3a9cb17afdcc0864dcb6fd5a7739cb58b770b54c1a7ed1d2fd3129251d83c4d2a55de3092d0bc8513207bf52b6eec2d68b317abff44a550f2331590082c3453be53493a117789774cad730c9dc3e7fee30e70d2375259bc57b0af5898a6787436588828bfbee4c0b01a99140dfa2cf4695c532271653f87e480a4ea87877b965a29df1dfa53b6c04b193b54e4dd4f5e7972778a5ae8c4e37b7b6549d4f9b5865fce791da32d54ff5821a60a7c1b087c27e59f3216f173e8091790df20f84e6b5bfa50cebe2330f28a601fff1e4d69a17cc5fe2974b462868df4ea3fee1cb91924fc465719d4416e45a1bd735e6697db0e8f0063c48a14b7d86d96d14baf39e24d75976810e10a0dc9c8905838ce342a9ee931f69eda311587867a25f4ae2de813c07fa80fff0bdb9b4b0d564a01a637d1b100b0418d7b4dd5890658d791e7e7d75ae5ed014700f4574e07435976379911a5a43a1d02c07f479ba793c835cf9859aa3b0001657a581a7405b59ffcd0fa38fd20239457235ceb319efb3b26451eb83ed4d70fca658eff38458894f60dc5683dfcfc110b6e487a8e3f20e5de6f343e820ab8359b96a28f2086ec15a6ee0bf0c6eefb56f472291f9f9a3cc1e5a7c021f1de2bd33f27b1af010236b2dde15a5dd0b4fc1ee925d04670b11d8d5b8189d4843a8c454817a3c7f2ef486d71b603f13cdda870e8c185215ce10c356775c22d8964e44bc98428ee5e9a6a3033a0a42aeef05a462d26f5f725d906cfd2bfbc7c2738f2233a5b77ba899fafbc7888e02edb92fd1dad8a1598d7e935765cc424d56a376cbcc00697762af7d8942e994af69f51722f6ab7509399785149cfea9e0bd7947c002f22ba871b3f214903bb7ab1b97df045f6e2a76b2859f128c431e918f878a58badfb6e6bcfe5f99f47bf713b38e5ca594d5337329c1c6d5d93fa7b5d04949027e85981cd8ba0c1d169cb81f98603bfa0293ab37440952e6e0515cfd1cadaabe95eeeee1aef65696a2b1d39e5114a3511ff3eca178f65e9616922a5d655c5bdd434e386230594164d4e830c19298cda66d4ad5d7483074adc1444bc247bc0765d1329e61448babdf1a38dedc8219fde98a742624df32f159b8a026e1483b27c3bf5be954af2acde857866b6bc5924bc7daf71b9003997d14d2fa75ddf2f7395703f11608bf1712f2fb9aa1162a77a038db4bcccc2ce17b7968a5aec22b90aae9ddc7b780911f58216c75236d7913c2d69abf8dab70f75e3b5276e7f6cbb80eaada3c4b641ecf58918529e28c24af94e04b601eecb2d03bbbe8a0b5c16d465626c5f478ec5d6f8064ea92684de68bb1a07ec05979772377c1a2dc8870caa25beb0883b101f6cf5d3d61adb604e4e72665a64b28c2c68ef46cde2ba89c347c1417aa384285a3ae9d24021340a3ad5f57dade7a619f385d47457cffc521f8bfe97fffa59aa13dc31235787cb1b011fd6b11aede41edac2ad1ca078b34b1f67f17df1455de2150efba340ab093ec3479c25f0fb68b8101bab5cf4382f182edc88d85d914e95d2cd0088cab24a67e7380b961386a742752bcb40ec1d869f65491ac07fd7fe0ec26ad39d88ad39d9193bfb98398f0e95ee7aa3b4dffe1832038201e83fea29451c0932c99fbafcac98a449769c690dcfb9f8d2c0fee450ba9d44c5435b1eba61f63f7d631655405d1807d2350a54105e5662c4f38a65654cc6c6dcaadaf8d7d555b10504cc998e9bb25f49f4a10612ee999572bffe91584f3ab82d0af3c83727c6381526fae23f73b6044b99c9654446ab9e4bee5423d186c56765a60228a4c94194372df6d6800d11ddedbc1cee0407608d242236ea5571c56ca1e70dbfb51f4e87563aac88ac8aa6cd06e909a2488eb8ec5022f02fa8b5139aa531144b91d0b3d2b15e4cc66e0790c4096b756411100dc9104963f50bfccda4719def82327962d58be9f36d244009a8b2d18a47e1d7fe5b1e3d3aeadbca215fa000b0a04db43ffaf0d1216c6154f9eb44e1d2783883ff887caf34aa4b81836e0255ca601ce518a60d0755c0b334a6384a0da61eb49f1c16388f022f55f77275ccd5a786bcc880a317a7672f9206ec670edf6e0131a8727f1a11aa2eec0cf657fa82bb36a3fcb4211729142587d207bb8c8848bb3f57dc8fd6b13beac7b9ecda0b7c3be8fbd0923a50dde5b658ee1918130513710048269f68fdbe5d41c83bb63964cd9aa62e4fb1d38eef89019e571c9d3c200844c50ff9f50cc783d48719406649b5565e4cbd58e7916558bfb9f9fa89c0474c48916d9e57ecc31fa1a529769b221e0856b989af8f6ac0981d5ef6daa38a92dd6404089f471fbb895b8de6dfa2a16ead6a967c911cc611fe5fd0e06c1acc492279ddea44caadf680f8bc7fe570fa779db314affed8d853006d16ca16e010da9c1da371a2a158b4cb220f617f82545fa8f9df1b21d9efe763ba79aefa0f8a164df2d33eabf2fe0f75e888108598e3c034cbd66fbce2a8600401e4a9988a56874cbee5bc417976a4de77a794daa49b5ce98c3b2fc103daecea134ad9cb9ca4d1437da6454c5b397eb197d4ed2472a677c367073fb7e02794f7bafc06743ca85a402a8a57190624af2624a3738dbc558a76596a6e86cafe9aecae68277f7c4b11ebf5fa69c7ba3d003a5950a65e7d356157b27c45c1d288fd129ff3d13f6c0916489f6defd4d405f51efee7b34d5f222f2f7be7ef9ac3eae7f2f628a1ed77c466cc65dce230dcd80323dc6cbddbf38d69f7da98803335d20ad98579a91812b59ccdd6c6f027065c8fcc6e64eb24007e4df4fa149d2b72a5a6cd22b30a0e513a8abda37951750fc7040e8d123962a3893a61a2ae783bfbdc75b6adc7a3a0019c260fd03ff81251e4d85a8e666134461a295147a4ee0d3ad16179b132749f7301f4ee8508dd61f6ffd598cc6cca2800c89f21dcc0c78f1134d878e8a35f0af03e6f698af19fa5747f7dea6258e67e1d5acc80056bfc1e3ade570042a674e59c1def4f60b379162ac9ef1760b0a125e3ffab41be98dc4672983d460794606d103f941fff11255b16eb33be206b85f0f86c3d27c57741d9a44c393c1dab3680dc831345a21d018d12f6c6fd50e960ac7dbae3a672b754e6d4855443f1ed071c4b4c8617899432a6151ef18896484d5ac4151e8106ff170cd6125f6ae701f32bea58227343fc74c7d0e3d77349be352d20988b8aab7ce72d9257c5fa3f3e3442dc43ff90f6ef9a35ef85b11bc86c82c894d4f1b98e4ddc627bbc6498157b09225d8488069bfb9f5369c7c40afa28e9954fdb97f44d15a420f5812b8e850e51c9a78a165eeba638e5440911bc23d2f69e10205e82ab0c976be9e92a7c1105dcf1a5a92fada06cdce066a2bd71c9ba1ee33a657abd80f6e78f972dd455b7496249516b4736de7cd83a2bda867622828f515afa29edae76ac8249e55806929213f24a3707e3248219349fffc6766697b707d9018436da1c4fea78badd6de41c8e1f8e4f04f3459b9c9d2d6712d55cb42340a78ecf957d698b2619a84d69d2a676ae622366b31c2ac7b6716d84603bccb6b971648efb8129a1442d44dbceefc1bd74c588735c2f493c61298ef9b7e5376d3fa5f8ac49b84e960794d6b5d9056cff7b9da7b6c483a9c6ac8d05d3622d30c35b78290f9e69c4121d21a7ffd95b173d0ead46087ad42c0edc198a7ac5745c2eb5e8d0f7a5dae96ae4f2ee968b366d751ab0ce2941f88d9214a62ff043ca509554e25e8e2e7addbaadefc89f27157f76aebed00f07760c28f1ae8f27d343e3b1f58dbb55e272bdf41e3ba56315b44d6687fa91d7e367f089a9b5b84be63d0b7b5205c9cca7938806b6fbee5cf7898c87b677d99868611f7e04e47197e52fd</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>西塞罗《论老年》摘抄</title>
    <url>/2023/08/20/Cicero-On-Old-Age/</url>
    <content><![CDATA[<p>“尤其令我钦佩的是，老年对你来说好像从来都不是一种负担，绝大多数人却非常讨厌老年。”</p>
<p><strong>本身不懂得如何过一种愉快而幸福的生活的人，无论什么年纪都会觉得活得很累。</strong>那些从内部寻求一切愉悦的人绝不会认为那些<strong>因自然规律而不可避免的事情</strong>是邪恶的。这类事物中首当其冲就是老年：人人都希望活到老年，然而到了老年又都抱怨。人就是这样愚蠢，这样矛盾和不合情理！他们抱怨说，自己不知不觉地到了老年，真没想到它来得这么快。首先，谁让他们抱有这样一种错觉呢，有什么理由说成年人不知不觉地步人老年要比儿童不知不觉地长大成人更快呢？其次，假如他们活到八百岁而不是八十岁，对于他们来说老年的烦恼又会少多少呢？</p>
<p>我认识许多老年人，他们从来也没有抱怨过老年一句，因为他们非常乐意摆脱情欲的奴役，而且根本没有被他们的朋友所轻视。<strong>事实上，对于所有这种抱怨来说，应当指责的是性格，而不是人生的某个时期。因为通情达理、性格随和、胸怀开朗的老人都会觉得晚年很好过；而性情乖戾、脾气不好的人，无论什么年纪，都会觉得日子不好过。</strong></p>
<p>“你说的不错。不过，也许有人会说，你有大量的钱财，又有很高的地位，当然觉得晚年好过了；而像你这样幸运的只是极少数。”</p>
<p>这话有些道理，但并不全面。例如，我们知道有这样一个故事：有一次，地米斯托克利和一个塞里弗斯人吵架，后者说，地米斯托克利的显赫地位不是凭他自己的本事，而是借助于他国家的声誉获得的。地米斯托克利回答说：“不错，如果我是一个塞里弗斯人，我可能永远不会出名；但即使你是一个雅典人，你也永远不会出名的。”对于老年，我们也可以说诸如此类的话。<strong>如果一个人非常贫穷，他虽然很达观，可能也不会觉得老年是安逸的；但愚蠢的人，即使他是个百万富翁，也肯定会觉得老年是一个负担</strong>。亲爱的西庇阿和莱利乌斯，你们可以相信，最适宜于老年的武器就是美德的培养和修炼。如果一生中各个时期都坚持不懈地培养和修炼美德一如果一个人不但长寿而且还活得很有意义一那么老年时就会有惊人的收获，这不仅是因为它们必然能使我们安度晚年(尽管那是最重要的)，而且还因为意识到自己的一生并未虚度，并回想起自己的许多善行，就会感到无比欣慰。</p>
<hr>
<p>事实上，只要好好想一想就可以发现，老年之所以被认为不幸福有四个理由：</p>
<ul>
<li>第一是，它使我们不能从事积极的工作；</li>
<li>第二是，它使身体衰弱；</li>
<li>第三是，它几乎剥夺了我们所有感官上的快乐；</li>
<li>第四是，它的下一步就是死亡。<br>如果你们同意的话，让我们对这些理由逐一作一番考察，看它们究竟有无道理。</li>
</ul>
<h1 id="1-老年使我们不能从事积极的工作"><a href="#1-老年使我们不能从事积极的工作" class="headerlink" title="1 老年使我们不能从事积极的工作"></a>1 老年使我们不能从事积极的工作</h1><p>说老年使我们不能从事积极的工作。究竟不能从事哪些工作呢？你是指那些非得年轻力壮才能干的工作吗？那么即使老年人身体很虚弱，难道他们连从事脑力劳动也不行吗？要是果真如此，那些历史上有名的人物就都是废物了！</p>
<p>说老年不能参与公众事务是没有道理的。这就等于说：舵手对船的航行没有用处，因为有的水手在爬桅杆，有的水手在舷梯上跑上跑下紧张地工作，有的水手在抽舱底污水，而他却静静地坐在船尾掌舵。他虽然不干年轻人所干的那些事情，但他的作用却要比年轻人大得多，重要得多。完成人生伟大的事业靠的不是体力、活动，或身体的灵活性，而是深思熟虑、性格、意见的表达。关于这些品质和能力，老年人不但没有丧失，而且益发增强了。我参加过各种战争，曾当过士兵、军官、将军和执政官，现在我不再打仗了，所以，你们很可能以为我就无事可做了。但是我现在仍在指导元老院的工作，告诉他们该做什么，以及如何去做。</p>
<p>安度晚年的普通百姓也是如此。索福克勒斯直到耄耋之年仍孜孜不倦地写作悲剧。他专心致志于悲剧创作，以至于被认为不善理财，于是他的儿子就把他带到法庭，说他年老智衰，要求法庭剥夺其管理家产的权力希腊的法律也跟我们的法律一样，要是家长挥霍家产，通常就剥夺其管理家产的权力。据说，这位年迈的诗人当场把他刚刚写完且正在修改的剧本(《俄狄浦斯在科罗诺斯》)读给法官们听，并且问他们：这个剧本像是一个弱智的人写的吗？陪审团听了他朗读的剧本后，判他胜诉。可见，索福克勒斯并没因为年迈而放弃自己的事业。荷马、赫西奥德、西摩尼得斯，或我在前面提到过的伊索克拉底和戈尔加斯，或哲学学派的创立者，如毕达哥拉斯、德谟克利特、柏拉图、色诺克拉底，或后来的芝诺和克莱安西斯，或你们也在罗马见过的斯多葛学派的第欧根尼，也是如此。所有这些人都从未停止过创作或研究，一直到他们去世为止。</p>
<p>即使撇开这些崇高的事业不谈，我也能举出一些萨宾地区的罗马农夫，他们是我的邻居和朋友，凡是重要的农事，不管是播种、收割或屯粮，他们几乎是没有不参加的。然而在其他事情上这也没有什么好令人惊奇的，因为任何人不管怎么老，也不会认为自己已经活不了一年。但是这些人辛辛苦苦所干的事情他们知道对于他们自己是没有任何好处的。正如我们的诗人凯基利乌斯·斯塔提乌斯在其《青年伙伴》中所说：他是为后人种树。的确，假如有人问一位农夫，他是为谁而种的，不管他的年纪有多大，他会毫不犹豫地回答：“为了不朽的神灵，他们不但希望我接受祖先的这些东西，而且还希望我把它们传给子孙后代。”</p>
<p>凯基利乌斯还提到一种更糟的观点：</p>
<blockquote>
<p>据说，老年最大的痛苦是：老年人觉得年轻人讨厌自己。</p>
</blockquote>
<p>一般说来，年轻人并不讨厌老年人。而是比较喜欢老年人。因为，正如明智的老年人喜欢同有出息的年轻人交往，年轻人的亲近和爱戴可以减除老年的孤寂，年轻人也乐于聆听老年人的教诲，这些教诲有助于他们去寻求美好的人生。我觉得，你们从与我交往中所得到的愉悦也并不亚于我从与你们交往中所得到的愉悦。<strong>但这足以向你们表明：老年非但不是萎靡和懶怠的，而且甚至是一个忙碌的时期</strong>，总是在做或试图做某件事情，当然，每个人老年时所做的事情与其年轻时所干的工作在性质上是相同的。不仅如此，有些老人甚至还在不停地学习呢！譬如说，我们知道，梭伦在他的诗中就夸耀自己虽然老了却“每天都在学习新的东西”。或者拿我来说也是一样，我只是到了晚年才开始学习希腊文学，的确，我曾贪婪地——而且也可以说是如饥似渴地阅读希腊的文学著作，所以你们可以看到，我现在已能自如地引用希腊文学典故了。我听说苏格拉底在晚年还学会了弹七弦琴，我也很想学，因为古人往往都会弹这种乐器；但是，不管我学不学得会，我在文学方面总是下过功夫的。</p>
<h1 id="2-老年使身体衰弱"><a href="#2-老年使身体衰弱" class="headerlink" title="2 老年使身体衰弱"></a>2 老年使身体衰弱</h1><p>我现在也不像年轻时那样想往有牛的力量那样想往有青年人的体力。<strong>一个人应当量力而行，而且，无论做什么事情，都应该全力以赴。</strong></p>
<p>对于我来说，我宁愿老年时期短一点，也不愿意提前进入老年时代。</p>
<p>每个人最好是适当地节用体力，量力而行，何以当然就不会因自己体力衰弱而感到遗憾了。<strong>当你身强力壮时，你就享受那份幸福；当你身体衰老时，你就别指望再恢复昔日强健的体魄——除非我们认为，年轻人应当希望自己再回到童年时代，中年人应当希望自己再回到青年时代。生命的历程时固定不变的，“自然”只安排了一条道路，而且每个人只能走一趟；我们生命的每一阶段都各有特色；童年的稚弱、青年的激情、中年的稳健、老年的睿智——都有某种自然优势，人们应当适合时宜地享用这种优势。</strong></p>
<p>一个人甚至到了老年，只要他坚持锻炼身体和有节制的生活，仍能在某种程度上保持其青年时代的强健体魄。</p>
<p>老年人时缺乏体力的，不过人们也并不要求老年人有体力。人们不但不强迫我们去做那些力所不能及的事情，而且甚至也不要求我们去做那些力所能及的事情。</p>
<p>也许有的人说，许多老年人很孱弱，甚至连生活都不能自理。孱弱不是老年所特有的，身体不健康者也同样会孱弱。既然连年轻人也难免会孱弱，老年人有时体弱又有什么可奇怪的呢？我们应当抵御老年的侵袭，尽量使它晚一点到来。正如我们应当同疾病作斗争一样，我们也必须同老年作斗争。我们应该注意自己的身体，进行适当的锻炼，每天所摄取的食物要正好能补充体力消耗所需要的营养，不暴饮暴食。我们不但应当保重身体，而且更应当注意理智和心灵方面的健康。因为它们宛如灯火：若不继续添油，便会油干灯灭。此外，锻炼往往会使身体变得粗壮，但是理智方面的锻炼却能使头脑变得更加精细。</p>
<p>凯基利乌斯所说的“喜剧中的老糊涂”是指那种轻信、健忘、邋遢、马虎的老人。<strong>轻信、健忘、邋遢、马虎并不是老年本身所固有的缺点，只有那些懒散迷糊、老年昏聩的人才是如此</strong>。比起老年人来，年轻人往往是比较任性和放荡的，但也不是所有的年轻人都是如此，只是那些品性不好的年轻人才是如此。那样，老年痴呆(通常叫作“愚钝”)也不是所有老年人的通病，只有心智不健全的老人才是如此。</p>
<p>活力。其实，只要老年人表明自己的权威，维持自己正当的权利，不屈从于任何人，他便是值得尊敬的。因为，<strong>正如我钦佩老成的青年一样，我也钦佩有朝气的老年</strong>。<strong>凡力求保持青春活力的人，虽然他的身体也许会老，但他的心灵是永远不会老的。</strong></p>
<p><strong>一个总是在这些学习和工作中讨生活的人，是不会察觉自己老之将至的</strong>。因此，他是在不知不觉中渐渐地衰老的。<strong>他的生命不是突然崩溃，而只是慢慢地寂灭。</strong></p>
<h1 id="3-老年剥夺人感官上的快乐"><a href="#3-老年剥夺人感官上的快乐" class="headerlink" title="3 老年剥夺人感官上的快乐"></a>3 老年剥夺人感官上的快乐</h1><p>老年对任何快乐都没有强烈的欲望这一点绝不是指责老年的理由，相反，这是老年最值得赞誉的优点。但是，你们也许会说，老年被剥夺了饮食之乐，即失去了饱餐美食、开怀畅饮的乐趣。不错，它的确不能享受这些快乐，因此也没有酒醉头疼、胃胀失调、彻夜难眠的痛苦。不过我们应当承认，快乐具有很大的吸引力，要想抵御它的诱惑不是件容易的事情。柏拉图说得好，他把快乐称作“罪恶的诱饵”，因为人们确实像鱼上钩一样，很容易上它的当。因此我认为，老年虽然必须避免豪奢的宴饮，但是参加一些有节制的宴会还是可以的。</p>
<p>老年虽然不能充分享有这种快乐，但并不是完全没有这种快乐。正像坐在剧院里观看安必维乌斯·图尔皮奥的喜剧表演，虽然坐在前排的人所得到的快乐比坐在后排的人多些，但是坐在后排的人毕竟也能得到快乐-样，年轻人因为离这种快乐较近，看得比较真切，所以他们的乐趣也许就更大些，但是老年人，即便离它们较远，看得不太真切，也能得到不少乐趣。可以说，一个人在经历了情欲、野心、竞争、仇恨以及一切激情的折腾之后，沉人筹思，享受超然的生活，这是何等幸福啊！实际上，如果有一些研究能力或哲学功底的话，世界上再没有比闲逸的老年更快乐的了。</p>
<p>但是在我的整个谈话过程中，你们必须记住，<strong>我所赞美的只是那种年轻时代已经打好基础的老年</strong>。由此可以推断出我曾经发表过的那种为人们普遍赞同的观点：<strong>需要自我辩解的老年肯定是一种可怜巴巴的老年</strong>。无论是白发还是皱纹都不可能使人突然失去威望，因为<strong>一个人最终享有威望乃是他早年品行高尚的结果</strong>。虽然有些事情一般被看作是微不足道和理所当然的，比如受人敬礼、被人求见、为人让路、来人时起立、去演讲时来回都有人陪同、征求意见等等，但这一切都是尊敬的表示，我们奉行这些礼节，其他国家也是如此。社会风气越好的地方，对老年人总是越尊敬。</p>
<p>不过，有人也许会说，老年人烦躁不安，脾气古怪，不好相处。如果这样说的话，他们还很贪婪。<strong>但这些都是性格的缺点，不是年龄的缺点。</strong>而且，烦躁不安以及我所提到的其他缺点毕竟还是有理由的(当然，这个理由是不充分的。但它仍不失为一个理由)，那就是：老年人自以为被人忽视，被人看不起，被人嘲弄。此外，由于身体孱弱，哪怕最轻微的伤害都会导致痛苦。不过，只要性格开朗并受过良好的教育，这些缺点是可以克服的。在现实生活中就有这方面的例子。而且《两兄弟》这出戏中的那两兄弟也是一个例证：一个是多么尖刻，一个是多么宽厚！事实上，人的性格就像酒一样，酒放时间长了并不都会变酸，同样，人的性格到老年也并不都会变得尖刻。我赞成老年人要有威严，不过这也应当像其他事物一样，有一个适当的限度。但是我绝不赞成尖刻。<strong>至于老年人的贪婪，我真弄不懂他们究竟图的是什么。因为这好比一个旅行者：剩下的旅途越短，他越想筹措更多的旅资。难道还有比这更荒唐的事情吗？</strong></p>
<h1 id="4-老年意味着死亡的临近"><a href="#4-老年意味着死亡的临近" class="headerlink" title="4 老年意味着死亡的临近"></a>4 老年意味着死亡的临近</h1><p>剩下还有第四个理由一-死亡的临近。它似乎比其他任何个理由更使我这种年纪的人苦恼，使他们处于焦虑之中。<strong>应当承认，老年人离死是不远了。但是，如果一个老年人活了一辈子还不知道死亡并不是一件可怕的事情，那么他肯定是一个非常可怜的老糊涂！</strong>死亡无非有两种可能：或者使灵魂彻底毁灭，或者把灵魂带到永生的境界。如果是前者，我们完全无所谓；如果是后者，我们甚至求之不得。除此之外，绝无第三种可能。如果我死后注定是或者没有痛苦，或者甚至很幸福，那么我又有什么可害怕的呢？</p>
<p><strong>有谁(不管他有多么年轻)会蠢到竟然敢打包票说，自己一定能活到今天晚上呢？</strong>实际上，年轻人死亡的机缘比我们老年人还多：他们更容易得病，而且生起病来更厉害，治疗起来也更困难。因此，只有少数人才能活到老年死亡的临近怎么能算是老年的缺憾呢？要知道，年轻人也同样存在这个问题。无论什么年纪都是会死的。</p>
<p>你们也许会说：是的，但年轻人希望活得长久，而老年人却不可能有这个希望。谁要是抱这种希望，他就是个傻瓜，因为他把不确定的事物看作是确定的，把虚幻的事物看作是真实的，还有什么比这更愚蠢的呢？也许有人会说：“老年人甚至没有什么可希望的了。”嘿，正是在这一点上，他就比年轻人强，因为年轻人所希望的东西，他都已经得到了。年轻人希望活得长久，而他却已经活得长久了。</p>
<p>天哪！ <strong>人怎样才算是活得“长久”呢</strong>？因为即便我们能活到塔特苏斯的国王那样的岁数，那也是有极限的。我从一篇记载中获知，加德斯有个叫作阿伽陶尼乌斯的人，他在位80年，活了120岁。但是我觉得，<strong>只要有“终结”，那就算不得长久，因为大限一到，过去的一切都将消逝。唯有一样东西可以存留，那就是你用美德和正义的行为所赢得的声誉</strong>。实际上，年、月、日、时都在流逝，<strong>过去的时间去不再复返；至于未来，那是不可知的。因此，每个人无论能活多久都应当感到满足</strong>。</p>
<p><strong>一个演员，为了贏得观众的称赞，用不着把戏从头演到尾；他只要在他出场的那一幕中使观众满意就行了。一个聪明的人也不需要老是留在人生的舞台上一直等到最后的“喝彩”。因为不管生命怎么短暂，活得光明磊落和体面总还是可以的</strong>。但是假如你的寿命比较长，你也不应当发牢骚，就像农夫不应当因为春季的消逝和夏秋的来临而发牢骚一样。“春天”这个词在某种程度上使人联想到青春，并意味着未来的获，而其他季节则适合于谷物的收割和储藏。我以前常说，<strong>老年的收获就是对早年生活中幸福往事的大量回忆</strong>。另外，<strong>一切顺乎自然的事情都应当被认为是好事。但是还有什么比老年人寿终正寝更顺乎自然的呢</strong>？当然，年轻人也会天折，但那是违背自然的。我觉得，<strong>年轻人的死亡犹如熊熊烈火被一场暴雨所浇灭；而老年人去世就像一团火在没有任何外力作用的情况下渐渐烧尽而自行熄灭一样</strong>。青绿的苹果很难从树上摘下，熟透的苹果会自动路到地上。人们像苹果一样，少年时的死亡，是受外力作用的结果老年时的死亡是成熟后的自然现象。我认为，接近死亡的“成熟阶段”非常可爱。<strong>越接近死亡，我越觉得，我好像是经历了一段很长的旅程，最后见到了陆地，我乘坐的船就要在我的故乡的港口靠岸了</strong>。</p>
<p>另外，老年没有固定的界限，<strong>只要你能担负起责任，将生死置之度外，你就是在非常恰当地利用老年。因此，老年甚至比青年还自信、还勇敢。</strong></p>
<p>因此，<strong>老年人对于自己短暂的余生既不应当过分贪恋，也不应当无故放弃</strong>。毕达哥拉斯告诫我们：若没有我们的指挥官即上帝的命令，切不可撤离生命的堡垒和前哨。梭伦确实很聪明，他在为自己所写的挽歌中说，他不希望自己死时没有朋友为他哀悼。我想，他可能缺乏朋友的挚爱。但是，我倒觉得恩尼乌斯说得更好：谁也不要用眼泪对我表示敬意，更不要嚎啕大哭，使我的葬礼沉浸在悲哀的气氛中。他认为，死后灵魂不朽，所以死并不是一件令人悲伤的事情。此外，<strong>人临终时可能会有某种痛苦，但这只是短暂的</strong>，尤其是老年人。当然，死后，人们或者感到很快乐，或者什么感觉也没有。但是<strong>我们必须从青年时代起就接受这方面的教育，才能置生死于度外，因为没有这方面的知识，就不可能有宁静的心境。因为人总有一死，而且谁也不能肯定自己今天会不会死。因此，死亡每时每刻都在威胁着我们，所以，要是怕死，心里怎么能够安宁？</strong></p>
<p>只要回忆一下下述情形就足够了：我们的军团常常雄赳赳气昂昂地开赴战场，然而士兵们心里都清楚，他们是不可能从战场上活着回来的。因此，连年轻人——他们不但没有受过教育，而且都非常幼稚——都认为无所谓的事情，我们这些有知识的老年人还有什么可害怕的呢？我认为，对一切事情的厌倦必然会导致对人生的厌倦，这是一条普遍真理。有些事情适合于童年，难道年轻人还会留恋那些事情吗？有些事情则适合于青年，到了所谓“中年”的那个时期，难道还会要求去做那些事情吗？另外有些事情则适合于中年，到了老年就不会想去做了。最后，还有些事情则属于老年。因此，正像早年的快乐和事业有消逝的时候一样，老年的快乐和事业也有消逝的时候。到了那个时候，<strong>人也就活够了</strong>，可以毫无遗憾地谢世了。</p>
<p>我认为，我完全可以把我个人对死亡的看法告诉你们，因为我觉得，自己离死亡比较近，所以相对地说来对这个问题看得也比较清楚。因为，<strong>只要我们被囚禁在这躯壳里，我们就得履行某种职责，就得做命运分配给我们的工作</strong>。实际上，灵魂来源于天国，是从其至高无上的故乡遣送下来的，因此也可以说是被埋在尘世——即与其神圣和不朽的本性格格不人的地方。但是我想，不朽的诸神之所以要把灵魂植人人的躯体，就是为了能有某种东西俯瞰这个世界，同时还注视天体的秩序，以便将这种永恒不变的秩序贯彻于人类生活之中。</p>
<p><strong>此外，最聪明的人总是能从容地去死，最愚蠢的人总是最舍不得去死，这又怎么解释呢？这是因为有些灵魂的目光比较锐利，看得比较远，知道死后自己要到一个更好的地方去，而有些灵魂的目光比较短浅，看不到这一点，难道你们不这样认为吗</strong>？至于我，现在很想去见你们的父亲，他们都是我所敬爱的人。我不但非常想见我所认识的那些人，而且也非常想见我所听说过的、在书中读到过的，或在我本人的历史著作中写到过的那些人。当我动身去见他们的时候，当然谁也很难把我拉回来，或者像煮珀利阿斯那样把我的生命再“煮”回来。而且，<strong>即使有某个神灵允许我返老还童，让我再次躺在摇篮里哇哇啼哭，我也是会断然拒绝的，因为我几乎已经跑完了全程，确实不愿意再被叫回来从头跑起。活在世上有什么意思呢？还不是受累？即使假定活在世上是很有意思的，但不管怎么说，最终也会有活够了的时候</strong>。我并不想，像许多人和有些著名的哲学家常常所做的那样，贬低人生；我对自己活在世上也不感到后悔。因为我一生的经历使我觉得我并没有白来这尘世一趟。<strong>但是我告别人生，好像是离开旅馆，而不是离开家。因为“自然”给与我们的是一个暂时的寓所，而不是永久的家园。</strong></p>
<p>假如我们不是永生的，那么，<strong>一个人在适当的时候死去也是件值得欣慰的事情</strong>。因为“自然”为一切事物设定了极限，人的生命也不例外。可以说，<strong>老年是人生的最后一幕，这时我们已疲惫不堪，尤其是当我们自己也觉得已经活够了的时候，那就该谢幕了。</strong>关于老年，我要说的就是这些。祝愿你们都能活到老年，到时你们可以通过实践来检验我的话是否正确。</p>
<hr>
<h1 id="读后笔记"><a href="#读后笔记" class="headerlink" title="读后笔记"></a>读后笔记</h1><p>这真是一篇达观的文章，文笔优美，行文流畅，细细品读给人豁然开朗之感。这种哲学教育给人一种更加开阔的视野，以及深刻的智慧启迪。我们所需要思考的不仅是死亡，还有老年，这些重要的话题。这篇古罗马哲学家的文章补上了重要的一课。我隔一段时间就会又重新把这一篇《论老年》拿出来重读一遍。每读一遍，都觉得这种哲学观实在是太美好。</p>
<p>首先西塞罗做出了很好的一种区分，就是把年纪和其缺点的强关联和强绑定给否定了：</p>
<blockquote>
<p>本身不懂得如何过一种愉快而幸福的生活的人，无论什么年纪都会觉得活得很累。</p>
<p>应当指责的是性格，而不是人生的某个时期。因为通情达理、性格随和、胸怀开朗的老人都会觉得晚年很好过；而性情乖戾、脾气不好的人，无论什么年纪，都会觉得日子不好过。</p>
<p>年轻人往往是比较任性和放荡的，但也不是所有的年轻人都是如此，只是那些品性不好的年轻人才是如此。那样，老年痴呆(通常叫作“愚钝”)也不是所有老年人的通病，只有心智不健全的老人才是如此。</p>
</blockquote>
<p>他指出，老年人所拥有的那些缺点并不是普遍的，如果注重身体和内心性格的修养，年老的人也不会遇到困难，也有其用处和独特的品德。一个豁达的人，无论是年轻还是年老，一样可以活得非常地自在。人们的幸福在于其自身，如果不懂得如何从自身中挖掘幸福，那么无论什么年纪都会觉得活得很累，这不是年纪变老所带来的。这一说法很有其见地。</p>
<p>这篇文章就是围绕着人们讨厌衰老的四个原因进行一一的分析和辩驳，分别是 1. 让人丧失体力；2.让人没办法做积极的工作；3.让人丧失感官娱乐；4.死亡的临近。</p>
<p>符合自然规律的东西不会是不好的，这是一种很符合 Stoicism 的看法：</p>
<blockquote>
<p>当你身强力壮时，你就享受那份幸福；当你身体衰老时，你就别指望再恢复昔日强健的体魄——除非我们认为，年轻人应当希望自己再回到童年时代，中年人应当希望自己再回到青年时代。生命的历程时固定不变的，“自然”只安排了一条道路，而且每个人只能走一趟；我们生命的每一阶段都各有特色；童年的稚弱、青年的激情、中年的稳健、老年的睿智——都有某种自然优势，人们应当适合时宜地享用这种优势。</p>
<p>一切顺乎自然的事情都应当被认为是好事。但是还有什么比老年人寿终正寝更顺乎自然的呢？</p>
</blockquote>
<p>作为一个人，应当认识到这种自然规律，认识到时间是一个人最宝贵的财富。而且，在西塞罗看来，只要是有期限的事情，就算不得“长久”。活得很长的人，可以是一直在虚度光阴；活得不那么长的人，可以活出了有意义的一生。</p>
<p>人来到这世界上，灵魂被装到了这副躯壳里，就必须要完成特定的任务、工作、履行一些职责、扮演一些角色。正如此，柏拉图才会说：“身体是灵魂的牢笼”。或许在很多人看来，死亡就是离开了熟悉的温暖的家，但是在西塞罗看来，恰恰相反：</p>
<blockquote>
<p>我告别人生，好像是离开旅馆，而不是离开家。因为“自然”给与我们的是一个暂时的寓所，而不是永久的家园。</p>
<p>越接近死亡，我越觉得，我好像是经历了一段很长的旅程，最后见到了陆地，我乘坐的船就要在我的故乡的港口靠岸了</p>
</blockquote>
<p>人生是“去程”，还是“归途”？真是有意思的思考角度。</p>
<p>我觉得西塞罗说出了一点我之前从来没想到过的一种想法——那就是“活够了”。我经常听人说还不愿意死，我就没听过有哪个人说自己活够了。死亡教育的一个目的：让人学会何为“将生死置之度外”。如同西塞罗所说，</p>
<blockquote>
<p>一个演员，为了贏得观众的称赞，用不着把戏从头演到尾；他只要在他出场的那一幕中使观众满意就行了。一个聪明的人也不需要老是留在人生的舞台上一直等到最后的“喝彩”。因为不管生命怎么短暂，活得光明磊落和体面总还是可以的</p>
</blockquote>
<p>把人生比作舞台，把我们一个个人都比做舞台上的演员，这个比喻倒是不稀罕。而每个演员演出的剧本，能在这个戏台上呆多久，倒也不是我们自己就能决定的。正如西塞罗所说，每个人呆在人生的舞台上的时间也不是无限的，只要能在有限的时间中把这一幕戏演好就可以了。</p>
<blockquote>
<p>我们必须从青年时代起就接受这方面的教育，才能置生死于度外，因为没有这方面的知识，就不可能有宁静的心境。因为人总有一死，而且谁也不能肯定自己今天会不会死。因此，死亡每时每刻都在威胁着我们，所以，要是怕死，心里怎么能够安宁？</p>
<p>最聪明的人总是能从容地去死，最愚蠢的人总是最舍不得去死，这又怎么解释呢？</p>
</blockquote>
<p>“要是怕死，心里怎么能够安宁？” 这正是人们普遍没有意识到死亡距离自己有多么的近。似乎内心的平静 inner peace，就是在这种沉思中获得的。</p>
]]></content>
  </entry>
  <entry>
    <title>C++学习之类的构造函数和析构函数</title>
    <url>/2017/06/07/Constructor-Destructor/</url>
    <content><![CDATA[<p>对于Stock类，我们还有其他一些工作要做。因为类提供被称为<strong>构造函数</strong>和<strong>析构函数</strong>的标准函数。</p>
<p>C++的目标之一就是让使用对象类像使用标准类型一样，然而在上一节的Stock类代码中还不能像初始化一个int那样来初始化Stock类对象。比如<code>int a=1</code>; 对于一个结构初始化等，那样的操作是不能用于Stock类的。</p>
<p>为什么要有构造函数？原因在于：数据部分的访问状态是私有的。程序不能直接访问私有成员。因此需要设计合适的成员函数，才能成功地初始化对象。</p>
<p>在前面的代码中，我们是用<code>acquire</code>成员函数来初始化一个Stock类对象：<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Stock</span> A;</span><br><span class="line"><span class="attribute">A</span>.acquire(abc, <span class="number">10</span> ,<span class="number">10</span>);</span><br><span class="line"><span class="attribute">A</span>.buy(<span class="number">10</span>, <span class="number">24</span>,<span class="number">75</span>);</span><br></pre></td></tr></table></figure></p>
<p>但是我们要做到的是一个名为Stock的构造函数，使得每次创建一个新对象，都能把他初始化。虽然用别的函数可以达到这个目的，但我们不能强行假设用户会每次都会去调用函数初始化。构造函数的目的就在于确保声明新的类对象时立刻初始化它，这是自动的。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><p>由于新建一个Stock类对象，需要提供3个值，因此构造函数默认提供3个参数。（total_val是计算得出的）</p>
<p>tips：如果只想设置company，其他的都是0，则可以用到默认参数。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">Stock(<span class="params">const</span> <span class="params">string</span> &amp; <span class="params">co</span>, <span class="params">long</span> <span class="params">n</span> = 0, <span class="params">double</span> <span class="params">pr</span> = 0.0)</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意：<strong>函数名称和类型名相同。没有返回类型。</strong>原型位于类声明的<strong>共有部分</strong>。</p>
<p>添加构造函数后的Stock类在右边。其实这个可能的构造函数与函数acquire()的代码是相同的。区别在于，程序声明对象时，会自动调用构造函数。</p>
<p>这个可能的构造函数与函数<code>acquire()</code>的代码是相同的。区别在于，程序声明对象时，会<strong>自动调用构造函数</strong>。而<code>acquire()</code>，需要你手动显式地调用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Stock::<span class="constructor">Stock(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span> &amp; <span class="params">co</span>, <span class="params">long</span> <span class="params">n</span>, <span class="params">double</span> <span class="params">pr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	company = co;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative.&quot;</span></span><br><span class="line">			&lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">		shares = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		shares = n;</span><br><span class="line">	share_val = pr;</span><br><span class="line">	set<span class="constructor">_tot()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，可能由于不熟悉构造函数的写法，有可能会将成员名作为构造函数的参数名：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Stock::<span class="constructor">Stock(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span> &amp; <span class="params">company</span>, <span class="params">long</span> <span class="params">shares</span>, <span class="params">double</span> <span class="params">share_val</span>)</span></span><br><span class="line">&#123;<span class="operator"></span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>这是错误的，参数名不能与类成员名相同，否则会出现这样的代码：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">shares</span> <span class="operator">=</span> shares<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>从而引起混乱。</p>
<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>调用方法及注意点</p>
<p>• 法1：显式地调用构造函数。<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Stock</span> A = Stock(<span class="string">&quot;Future Technology&quot;</span>, <span class="number">250</span>, <span class="number">1</span>.<span class="number">25</span>);</span><br></pre></td></tr></table></figure></p>
<p>• 法2：隐式地调用构造函数。<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Stock</span> B(<span class="string">&quot;Sun Prison&quot;</span>, <span class="number">50</span>, <span class="number">2</span>.<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>• 构造函数与new结合在一起使用的方法。这条语句会创造一个Stock对象，但是是没有名称的，只能通过用p代它的地址来管理该对象。这就是对象指针。<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Stock</span> *p = new Stock(<span class="string">&quot;Sun Empire&quot;</span>, <span class="number">18</span>, <span class="number">19</span>.<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>• 不能通过类对象来调用构造函数</p>
<h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>默认构造函数是用于未提供显示初始值时候用来初创建对象（也就是说，并没有初始化）的构造函数。就好像<code>int a;</code>并没有立即给 a 赋值，只是声明一个int变量一样。</p>
<p>如果没有提供任何构造函数，C++会自动提供默认构造函数，提供隐式声明类对象的方法，不对对象做任何初始化。也就大概是这样的：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果提供了非默认构造函数，如</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">Stock(<span class="params">const</span> <span class="params">string</span> &amp;<span class="params">co</span>, <span class="params">long</span> <span class="params">n</span> = 0, <span class="params">double</span> <span class="params">pr</span> = 0.0)</span>;</span><br></pre></td></tr></table></figure>
<p>却没有提供默认构造函数，则隐式且不带初始值的声明会出错！原因就是禁止创建未初始化的对象。</p>
<p>设置默认构造函数的方式有两种：</p>
<ul>
<li><p>为已有构造函数的所有参数提供默认值。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">Stock(<span class="params">const</span> <span class="params">string</span> &amp;<span class="params">co</span> = <span class="string">&quot;ERROR&quot;</span>, <span class="params">long</span> <span class="params">n</span> = 0, <span class="params">double</span> <span class="params">pr</span> = 0.0)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过函数重载定义另一种构造函数——没有参数的构造函数。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stock</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于只能存在一个默认构造函数，所以，<strong>不要同时使用这两种方法</strong>。实际上，通常应该初始化所有的对象，以确保一开始所有的成员就有已知的合理值。例如下面这个默认构造函数：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Stock:</span>:Stock()</span><br><span class="line">&#123;</span><br><span class="line">	company = <span class="string">&quot;No name&quot;</span>;</span><br><span class="line">	<span class="keyword">shares </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">share_val </span>= <span class="number">0</span>.<span class="number">0</span>;</span><br><span class="line">	total_val = <span class="number">0</span>.<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>用构造函数创建对象时，程序负责跟踪此对象，至到其过期为止。<strong>对象过期时</strong>，程序将调用一个特殊的成员函数，来完成清理工作。这个成员函数的名字就叫做<strong>析构函数</strong>。</p>
<p>析构函数完成的就是清理工作，实际上是很有用的。例如如果构造函数用了<code>new</code>，那么在析构函数里使用<code>delete</code>来释放这些内存。Stock类的构造函数没有用<code>new</code>，因此析构函数是没啥需要完成的实际任务的。然而，了解如何声明和定义析构函数十分重要，下面我们试着来写一个Stock类的析构函数。</p>
<h2 id="声明和定义析构函数"><a href="#声明和定义析构函数" class="headerlink" title="声明和定义析构函数"></a>声明和定义析构函数</h2><p>和构造函数一样，析构函数的名称也是很特殊的：在类名前加上<code>~</code>。因此，Stock类的析构函数一定是<code>~Stock()</code>。析构函数一样没有返回值和类型声明，但与构造函数不同的是，析构函数没有参数，因此析构函数的原型声明也是固定的：<code>~Stock();</code></p>
<p>Stock类的析构函数不承担任何工作，因此可以其定义这样编写。其他不承担工作的析构函数同理：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Stock::~<span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而如果想看到函数何时被调用，可以这样写：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Stock</span><span class="symbol">:</span><span class="symbol">:~Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Bye, &quot;</span> &lt;&lt; company &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tips：什么时候会调用析构函数呢？</p>
<p>这由编译器决定。通常，不应该在代码中显示地调用析构函数，</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>析构函数调用时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储类</td>
<td>程序结束时自动调用</td>
</tr>
<tr>
<td>自动存储类</td>
<td>程序执行完相对应代码块（对象在其中定义）时自动调用</td>
</tr>
<tr>
<td>通过new创建的对象</td>
<td>驻留在栈内存或者自由存储区，当使用delete来释放内存是，调用析构函数</td>
</tr>
<tr>
<td>程序创建的临时对象</td>
<td>程序在结束对该对象的使用时调用析构函数</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>Death Philosophy 耶鲁大学死亡哲学课程笔记</title>
    <url>/2021/07/13/Death-Philosophy/</url>
    <content><![CDATA[<p>Professor : Shelly Kagan</p>
<h1 id="1-Course-Introductory"><a href="#1-Course-Introductory" class="headerlink" title="1 Course Introductory:"></a>1 Course Introductory:</h1><p>Questions will be discussed on this class:</p>
<ol>
<li>metaphysical（形上学）: What is the nature of death. What are we? What kind of entity is a person? Particularly, do we have souls? (soul: some immaterial thing of human components, distinct from body) <strong>Something will survive the death of our body?</strong> And if not, what is the nature of death? What kind of event is called death? What is it for me to survive?</li>
<li>about identity（同一性）: 明天的我和昨天的我是同一个东西吗？</li>
<li>about value theory（价值论）: Is death a bad thing? If it is a bad thing, does it mean immortality is good? I am going to die, what will this affect my view towards life? What should my altitude be towards my inevitable mortality? Should I be afraid of death? Rationality and morality about suicide.</li>
</ol>
<p>Go through this course, Shelly tries to make you believe these common opinions about death are wrong from beginning to end:</p>
<ol>
<li>death is dreadful. (thus immortality is good)</li>
<li>we have souls (we are not just body). so after our flesh vanished, we can live in other kinds of existence. </li>
<li>life is wonderful and precious. (thus commit-suicide is immoral, unresponsible and unreasonable)</li>
</ol>
<p>by the end of this course, you will find(or you may disagree, but lecturner try to make you think about or convince you that)</p>
<ol>
<li>no soul on this world. Immortality is not a good thing.</li>
<li>Fear of death is actually normal response to death.</li>
<li>Suicide, under certain circumstances, might be raionally and morally justified.</li>
</ol>
<p>Typecally, in this class, <strong>No appeal to religion argument or evidence.</strong> （不使用诉诸宗教权威的论据和论证）</p>
<h1 id="2-人的本质：二元论与物理主义"><a href="#2-人的本质：二元论与物理主义" class="headerlink" title="2 人的本质：二元论与物理主义"></a>2 人的本质：二元论与物理主义</h1><h2 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h2><p>Question: Can I survive my death? If there might be possibility that I might still exist or survive after my death? Is there a life after death? 我是否有可能免于一死，或死后仍然存在？</p>
<p>要搞清楚 Can I survive 这个问题，可能首先要问：</p>
<ol>
<li>“人”是什么？什么样的东西才能称之为人？What is a person?</li>
<li>“活着”意味着什么？What is concept of surviving? </li>
<li>幸存之后，未来的我又是什么样的呢？What is it for something that exists in the future to be me?</li>
</ol>
<p>这些问题可以归结成这样的问题：同一性的持存本质是什么？What is the nature of persistence of identity over time?<br><strong>个人同一性（Personal identity）</strong>：这周的我和下周的我有什么不同和相同吗？</p>
<h2 id="Objection-illusion"><a href="#Objection-illusion" class="headerlink" title="Objection: illusion"></a>Objection: illusion</h2><p>This question, “is there a life after death”, is a misconception.<br>Death: the end of life.<br>So if you ask, is there a life after death, then you are asking is there a life after the end of life. This answer is clear, no. </p>
<p>The same to “May I survive my death?” -&gt; “May I still to be alive after the end of life” -&gt; “No.”</p>
<h2 id="Responce"><a href="#Responce" class="headerlink" title="Responce"></a>Responce</h2><p>Make this question more clear.<br>经过一系列生物过程（停止呼吸、血液停止流动、心跳停止、新陈代谢停止、细胞不再分裂工作和修复机体、脑缺氧、脑死亡）这就是死亡，但我们管他叫<strong>生物上的死亡(bodily death)</strong><br>问题现在变为: May I exist after my bodily death? Would I survive my death? <strong>“肉体死亡后，我后还能存在吗？”</strong> 这个问题起码能够合理地被提出了。</p>
<h2 id="Personal-Identity"><a href="#Personal-Identity" class="headerlink" title="Personal Identity"></a>Personal Identity</h2><p>要探讨这个问题，需要探讨 <strong>Personal identity</strong>. “‘我’究竟是个什么东西” What exactly is it for something to be me? What am I?<br>What kind of entity am I? 我究竟是一个什么实体？</p>
<p>一个人肉体死亡后能否存在，取决于这个<strong>人是如何被构造的，他有哪些组成部分</strong>。<br>如果某个人相信，一个人除了肉体之外，还有灵魂存在的话，那么当肉体死亡后，灵魂还可以留存于世。<br>那么问题就转换成了，要<strong>证明对于人，除了肉体，还存在某些非物质的组成部分</strong>。</p>
<h2 id="Point-of-views-on-both-sides"><a href="#Point-of-views-on-both-sides" class="headerlink" title="Point of views on both sides:"></a>Point of views on both sides:</h2><p>Two basic position about what is a person:</p>
<ol>
<li><strong>二元论 Dualist view: body &amp; soul</strong>. 人可能是肉体（由分子和原子组成的物质实体，骨头、器官、组织、肌肉，等等）和其他某物的结合体。这种东西（人格？心灵？精神？思想？想法？意识？personality? mind? psyche? thought? idea?）被认为是与肉体区分开来的，截然不同的，非物质的，非物理的存在。用一个哲学名词去描述，就叫<strong>灵魂 (soul)</strong>。人是由肉体和灵魂构成。</li>
<li><strong>一元论 Monist: only body</strong>. 只有一个唯一存在的，基本的东西，就是肉体。人当然就是肉体，人当然只是肉体。这种观点也叫 <strong>Physicalism 物理主义</strong>。Physicalism 的论述是 “A person is a body that can … “ 自然，灵魂是不存在的。物理主义是一种 <strong>Materialism 唯物主义</strong>。</li>
<li>自然而然地逻辑上存在的第三种立场就是，世界上只存在思想和心灵，物理对象有可能不存在，或者只是幻觉，或者肉身的存在只是用来表达思想，最根本的存在还是思想。这种观点就是 <strong>Idealism 唯心主义</strong>。唯心主义这个想法在哲学历史上占据了很长的时间，但是在这节死亡哲学课，并不涉及唯心主义的观点和方法。</li>
</ol>
<p>一些二元论的观点：</p>
<ol>
<li>灵魂可以指示和命令身体。身体又能输出指令，让灵魂有所感觉和触动。它俩是一种互动的连结关系（你用针扎我的手臂，我的心灵会感受到疼痛）</li>
<li>灵魂寓于身体之内，但是又不能打开身体指出灵魂具体所在。</li>
<li>当肉体死亡的时候，由于灵魂是非物质的存在，因此还可以存在，尽管肉体已经消耗殆尽。这是二元论非常吸引人的一点：相信灵魂的存在，就是相信你死后依然还能存在。</li>
<li>生前，肉体和灵魂是连接的（偶尔来个“灵魂出窍”），而死亡意味着这种连接的切断，所以灵魂不仅让我们我们幸免于死亡，还能让我们在肉体灭亡之后，以一种神秘的存在，获得了前所未有的自由。</li>
<li>可以合理导出如下的结论，灵魂变成了主体：可以毁灭我的肉体，却不能毁灭我的灵魂；只要灵魂不灭，我便存在。（就像，你可以摧毁我的房子但无法摧毁我本人）因此，一个人严格来讲，就是灵魂。（A person, strictly speaking, is a soul) 是我的灵魂和某个肉体产生了连结，而不是说人就等同于是灵魂加肉体（有点深奥了这里）。</li>
</ol>
<p>好了，现在导出如下问题：（括号内是涉及到的 topic）</p>
<ol>
<li>要怎么严格证明灵魂是存在的呢？怎么证明人是灵魂和肉体的结合体呢？（二元论）</li>
<li>soul 一定是 非物质的吗 immaterial？（物理论）</li>
<li>肉体被摧毁后 soul 可以存活吗？在肉体物理死亡的时候，灵魂完全有可能同时被摧毁。（灵魂的不朽性 immortality）</li>
<li>如果灵魂存在且能在肉体死亡后存活，它能活多久？how long can it survive? Forerver? 如果是永远存在，那么拥有灵魂的我们就是永生吗？</li>
</ol>
<h1 id="3-灵魂存在与否的论证（一）"><a href="#3-灵魂存在与否的论证（一）" class="headerlink" title="3 灵魂存在与否的论证（一）"></a>3 灵魂存在与否的论证（一）</h1><p>一元论者认为，人只不过是肉体，但是是可以做到其他物体做不到的功能的肉体。人会思考、推理、创造…… 能做到收音机、小汽车那样的物件做不到的事情。假设这一系列功能（其他物体做不到的事情）统称为P，那么，人 就是具有 P 功能的肉体。</p>
<p>心灵(mind)在物理主义者的论述中的位置，仅仅是肉体所具有的各种精神功能的方式。物理论者不否认心灵的存在，但是只是意味着“我们人类不是随随便便的肉体，是可以 think 的肉体”。简而言之，mind 是 P 所囊括的各种能力之一，是对肉体还能正常工作时各种精神能力的概述，只不过我们给他起了个名字叫 mind。因此，不存在另一种非物质的组成部分，也就是说，灵魂不存在。</p>
<p>例如，笑(smile)是人类能做到的一件事。但是如果你问人由什么部分组成？你可能会列举 牙齿、嘴唇、脸颊，但你不会列举 smile. 但是 smile 确实是由牙齿、嘴唇、脸颊所组成的一种能力。</p>
<p>因此，人体死亡就是肉体停止运作各种 P 功能。人没有灵魂，也不会在死后存在。这是物理论者的观点。</p>
<p>一元论者和二元论者都是认为存在肉体的，问题是，有没有什么凌驾于物体之上的东西存在？</p>
<p>by the way, 我们要怎么证明某个东西存在？</p>
<ol>
<li>经验主义 empiricism：我能用五官看见、听见、触摸到。<br>2.<strong>“最佳解释推理” Inference to the best explanation</strong>: 对于无法直接用五官感受到的东西，可以先假设 (posit) 它的存在，然后由于它存在可以解释一些现象，而且它是我们能够想到的最好的解释 (not just possible, but the best, explaination)，因此这个假设是对的。例如，原子假设可以佐证物理现象，因此原子 atom 是存在的。我为什么相信微生物是存在的？因为微生物可以解释人类为什么生病，而且解释得比另一种假设（例如人类生病是因为有一个魔鬼缠身）更好。</li>
</ol>
<p>那么，是否有某种现象，使得 灵魂存在 的假设，可以对物理主义者无法做出解释的问题做出更好的解释，也许是最好的解释，好过我们只有肉体？假设有一个功能 F,argument likes “although we cannot see the soul, but we have reason to believe in the soul, because positing the existence of the soul can help us better explain why we have function F, which cannot be explained by materialism.”</p>
<p>教授提醒：以下这些问题都很难解释的，不用着急下结论，需要仔细思考。</p>
<p>现在问题是，F是什么？有没有这样的现象，需要诉诸灵魂才能得到好的解释？</p>
<ol>
<li>ordinary: life, love, think, emotion</li>
<li>extraordinary, supernatural things: 托梦、心灵感应、弥留之际的回光返照、濒死体验</li>
</ol>
<p>one: 或许需要诉诸灵魂，才可以解释人为什么活着。因为灵魂和肉体结合，所以人就是活着的生命。当灵魂脱离肉体，肉体就变成了死尸。假设灵魂的存在，就提供一种可能解释生命和非生命的区别。（生物学不发达时人类对生命的常见看法，不过我们现在都知道了生命的起源是受精卵、细胞分裂和分化等等）</p>
<p>two: 计算机遵守着代码，热导飞弹遵循着控制模块的指令，那么人类除了肉体之外有没有别的东西在指导躯体的行动？人类是不是也只是由外部指令控制的机器人？二元论者：我们人类有自由意志，我们不是遵守指令的机器人。why we have free will? you need soul to explain the free will.</p>
<h1 id="4-灵魂存在与否的论证（二）"><a href="#4-灵魂存在与否的论证（二）" class="headerlink" title="4 灵魂存在与否的论证（二）"></a>4 灵魂存在与否的论证（二）</h1><p>二元论者认为，<strong>人具有感觉</strong>，而机器虽然可以做一些事情，<strong>但机器是没有感觉的</strong>。人之所以有感觉，<strong>人之所以与机器不同，是因为人有灵魂的存在</strong>，有独特的非物质性质的组成部分。<br>一元论者认为，可以以科幻小说的方式（象棋程序、人工智能）来假想（例如这个例子，一个高度人工智能，当要被人类关掉时会说“我感到悲伤”的电脑程序），<strong>纯粹物质(material) 也可以拥有感觉</strong>，或者所谓的灵魂。</p>
<p>二元论对此有一个回应。<strong>“感受”可以分为两类</strong>，第一类是<strong>行为面 (behavioral)</strong>范畴的 “信念、目标、对策、规划”。另一类是<strong>感受面(feeling)</strong> “sensation of what is feeling like inward while all these behavioral stuff is going on” （内心有一种对感知的直觉，与其他行为层面的东西同时发生，典型如喜怒哀乐，恐惧，沮丧，等等）。机器人获得了情绪的“行为面” behavioral side，但是他们没有“感受面” feeling side. </p>
<p>例如人和机器都看到红色<br>行为面：辨别出这个是红色。机器也可以做到。但是机器有没有对看到红色的知觉 (sensation) 和感觉 (feeling, experience) 呢？<br>感受面：人看见红色可能会心情愉快。</p>
<p>机器体会不到感受面，机器只能做到行为面。于是，人不是机器，我们不仅仅是物理对象。</p>
<p>意识 consciousness 还是一个谜团，人类对其了解得不够，无法从物理主义的角度去解释。</p>
<p>We shouldn’t be dissmisive to dualist. when they said “we got to be believing in soul to explain it.”<br>We shouldn’t be dissmisive, doesn’t mean we should be convinced. We don’t yet know how to explain consciousness physically. We know little about it yet.</p>
<p>14世纪的人也无法理解用物理和生物学观念去解释生命，认为之所以为生命肯定是有某种超物质的东西。现在我们无力对意识做物理性的解读（例如，我们现在对大脑的了解可以说甚至是知之甚少），有可能就像14世纪的人无法对生命做出物理解读是一样的阶段。</p>
<p>二元论者会说：“你们提供不了解释。而我提供了解释。人就是因为有灵魂才会有意识啊！”<br>一元论者：“那请问灵魂是怎么产生意识的”<br>二元论者：“……”</p>
<p>与此相似的观点是：“我们人有思考的能力/创造力/自由意志/主观能动性…… 而机器没有创造了/机器是deterministic的，只遵循代码和物理规律，没有自由意志和主观能动性。因此我们和机器不一样，因此我们有灵魂（因此需要诉诸灵魂 we have to appeal to soul in order to explain it.）。”</p>
<p>而有的计算机程序已经具有了创造力（深度学习写诗、对对联、谱曲）<br>自由意志 free will 是一个哲学上极其复杂的主题，并不是二元论者的制胜法宝。</p>
<h1 id="4-柏拉图《斐多篇》the-Phaedo"><a href="#4-柏拉图《斐多篇》the-Phaedo" class="headerlink" title="4 柏拉图《斐多篇》the Phaedo"></a>4 柏拉图《斐多篇》the Phaedo</h1><p>柏拉图《斐多篇》通过苏格拉底和他的两个朋友的谈话，证明了灵魂不朽(immortality of soul)的这一主题。</p>
<h1 id="灵魂存在与否的论证（三）自由意志与濒死体验"><a href="#灵魂存在与否的论证（三）自由意志与濒死体验" class="headerlink" title="灵魂存在与否的论证（三）自由意志与濒死体验"></a>灵魂存在与否的论证（三）自由意志与濒死体验</h1><h2 id="Three-premises-about-appealing-to-soul-to-explain-free-will"><a href="#Three-premises-about-appealing-to-soul-to-explain-free-will" class="headerlink" title="Three premises about appealing to soul to explain free will."></a>Three premises about appealing to soul to explain free will.</h2><p>why we have free will? you need soul to explain the free will.</p>
<p>The process of the argument is like this:</p>
<ol>
<li>We have free will.</li>
<li>nothing subject to determinism has free will.</li>
<li>All purely physical systems are subject to determinism.</li>
<li>So, we are not a pure physical system. We have souls.</li>
</ol>
<p>This argument is <strong>valid</strong>. If all its premises have to be true, then the conclusion can be sound and true. </p>
<p>But all these three premises could be plausible challenged. </p>
<p>自由意志、决定论、因果论，都是哲学上很大的话题。下面只给出对于为什么否定由自由意志得出人类具有灵魂的浅显的讨论。</p>
<ul>
<li>Premise No.1: We mistakenly believe we got free will. Free will is a sense that we could have done it differently but it is just an illusion. </li>
<li>Premise No.2: Compatibilism（相容论）</li>
<li>Premise No.3: 在物理学种，物理定律也不一定是决定论的，例如，量子力学中有很多定律是概率论的。premise No.3 can be false.</li>
</ul>
<p>We shouldn’t be so quick to believe we have to believe the existence of the soul in order to explain why we have free will. This argument requires a lot. There are reasonable philosophical and scientifical reasons to worrying about each one of these premises.</p>
<h2 id="Supernatural-phenomenon"><a href="#Supernatural-phenomenon" class="headerlink" title="Supernatural phenomenon"></a>Supernatural phenomenon</h2><p>或许更好的支持灵魂存在的论证，着眼点应该放在不寻常的，超自然的现象。(supernatural. not everyday)</p>
<p>依然遵从“最佳解释原则”。例如，我们需要假设灵魂的存在去解释鬼魂(ghost)，ESP（第六感），濒死感受(near-death experience)，降神、与死者通灵（communicate with the dead）。</p>
<p>这里老师依然给我们展示的是一种哲学思考的谨慎态度。对于濒死体验证明灵魂存在说，老师提到，有一种常见的反驳是这样的：“你没有真正的死掉啊，你又活了（其实相当于你没死），那么你说所谓濒死的说法怎么能站得住脚呢？” 对于这个说法，并不是一个哲学上比较好的反对，有点 misguided。大意就是：“你没有真的去过法国，所以你不能评论法国。就算你之前在那里住过然后搬回来了，就不行”。这么想不太对，他总有一些经验可以分享。</p>
<p>关于通灵现象，找物理主义者问：“你能不能用物理定律和科学方法解释通灵。” 这是浪费时间。你应该去找魔术师去问，毕竟他们的职业就是这个。当然，这种情况，就存在打假者，类似徐晓东。“悬赏一万块，悬赏任何可以通灵的人在我面前跟鬼魂通话，但是我会揭穿你如何作假。” 然后没有一个人真的可以领到这个钱。这样就使得这种解释的力度大大下降了。</p>
<p>It’s up tp you to choose which explaination. For example 有一天你梦见死去的亲人。dualist 会说，他们的灵魂昨天晚上来找你了。monoist 会说，it’s just a dream! 你会梦见她，只是因为潜意识里惦记着她。哪一种解释更好呢？相信哪种说法取决于自己~ （有的时候，前一种说法可以让你感受好一点，那么这样想想也无妨呀。无法用理性、逻辑、事实、经验去想通的东西，不妨用感性去赋于它意义吧！</p>
<p>教授认为，采取二元主义的论述的一个理由，可能是物理主义给不出好的解释，任何物理主义解释都站不住脚。但是要主义，not yet seeing how to explain, is not the same thing as seeing that it can’t be explained. “还没有合理的解释”不能认为“不能解释”</p>
<h2 id="Cartesian-argument"><a href="#Cartesian-argument" class="headerlink" title="Cartesian argument"></a>Cartesian argument</h2><p>之前的论证要么是来源于经验的，要么是双方在争论看谁能更好地解释的。下面教授给出一个 a pure philosophical argument 而且是一个非常有意思，存粹只靠思想实验，但却能令很多人都信服的论证（来自笛卡尔的第一哲学沉思录</p>
<p>进行这种哲学思考的要点是在于，不去想“这在经验上可行吗？”，而是想象这个故事的主角就是自己。</p>
<p>“我可以想象心灵存在而肉体不存在的故事”，就这一点而言，肉体和心灵就是根本逻辑上、形而上学意义上的两个不同的东西。<br>这里的关键是加上一个 philosophical premise: 如果我能想象一个东西独立于另一个东西存在，那么者两个东西就肯定是不同的。<br>如果我可以 imagine A without B, 那么，A and B have to be logically different, distinct things. </p>
<p>例如，这里有一个书桌，请你想象，“这个书桌既存在，又不存在，的场景”。<br>你无法这样想象，因为这违反了逻辑学的定律。<br>而我们可以想象心灵存在而肉体不存在的故事。<br>所以，我的心灵肯定不是我的身体，我的心灵和我的身体肯定不是一回事。<br>因为如果心灵只是身体的另一种说法，那么，想象“心灵存在而身体不存在”，就和“想象身体存在而身体不存在”一样将会变得不可能。</p>
<p>不过这个论证不是在说“能想象=存在”。“我能想象独角兽，但这不意味着独角兽就存在”。而且，这个论证也不否定，现实经验世界中，某物不能脱离某物而独立存在，但是不是这个论证关心的重点。这个论证说的是，如果我可以想象某物独立于另一物存在，A without B 则意味着 A 和 B 不是 identical 的，A 和 B 是 separate的，肯定是彼此不同的。因为你无法想象 A exists and A don’t exists at the same time. </p>
<h1 id="Plato-1-灵魂存在与否的论证-（四）"><a href="#Plato-1-灵魂存在与否的论证-（四）" class="headerlink" title="Plato 1. 灵魂存在与否的论证 （四）"></a>Plato 1. 灵魂存在与否的论证 （四）</h1><p>对于这个论证，还是要很小心，为何“容易想象” could easily imagine 可以成为理性的来源？</p>
<p><strong>柏拉图的形而上学</strong>（哲学术语 Platonic Forms，型相）：人的灵魂拥有的能力，是能理解和思考 ideas, forms（型相）, 例如, beauty, circle, justice, health. 例如，现实经验世界中不存在完美的圆，我们却可以想象一个完美的圆。现实生活中存在各种公正和不公正的现象，但我们看不到 justice itself。不存在完全的公正的社会结构，但我们却可以用心灵去相信和把握 Justice 是怎么样的，因此而得出对当下社会的各种缺点的思考。现实世界中存在各种很美的事务，但是它们不是美本身 beauty itself. 他们只是“参与”了美 participate beauty.</p>
<p>（柏拉图借）苏格拉底（之口）认为：肉体的感觉是归肉体管（这和另一些 dualist 认为的 feeling 是由灵魂管是不一样的），<strong>灵魂负责的就是人类思考这种纯粹概念、理念的能力</strong> mind is able to grasp them, not a job of body。我们的心里可以去理会这些概念中的真理。可以把自己从肉体的干扰和享乐的欲望中分离出来，而去追求对理想事务、终极意义的追寻。这就是精神和肉体的分离的原因。当死后，精神和肉体分离，精神就会进入天堂，在那里，可以更直接地接触到 Platonic Forms。</p>
<p>amazing. 例如 数学就不是一种经验，而是一种心灵可以掌握，但是物理世界中并不存在的东西。</p>
<h1 id="Plato-2-灵魂永恒与否的论证"><a href="#Plato-2-灵魂永恒与否的论证" class="headerlink" title="Plato 2. 灵魂永恒与否的论证"></a>Plato 2. 灵魂永恒与否的论证</h1><p>在 Plato 这里，灵魂存不存在 Is there a soul? 不是一个问题，也没有给出多少 defend，几乎是 take it for granted. 主要问题是，灵魂是不是不朽的？Is the soul immortal? </p>
<p>如果 soul 摆脱了 flesh 的 distraction，可以更好地去思考 Platonic Forms。因此，苏格拉底并不惧怕死亡，因为最后的分离时刻就要到了，他的灵魂可以去和别的伟大的不朽的灵魂永远地思考、永远地对话下去。柏拉图认为，人生在世的时候，需要不断地锻炼这种思考和不受肉体欲望干涉的能力。不然的话，当死亡的时候，灵魂过于贪恋肉欲，就会投胎到另一个人或者动物身上。</p>
<p>这一节讨论柏拉图的各种论证。</p>
<h2 id="argument-from-the-nature-of-the-forms"><a href="#argument-from-the-nature-of-the-forms" class="headerlink" title="argument from the nature of the forms."></a>argument from the nature of the forms.</h2><p>论证一：心灵可以认识永恒的型相，前提是它必须从肉体的束缚中解脱出来。因此，那些对此已经做好准备的哲学家，不仅不会惧怕死亡，而且还会欢迎死亡的到来。</p>
<p>这里就有一个疑问，当肉体死亡的时候，灵魂会不会随之被摧毁呢？</p>
<p>“型相本质论”论证(argument from the nature of the forms) 型相，例如正义、美德、美，都不是物理实体 physical object 却又真实存在，是以一种非物质的形式存在 immaterial。forms 不能被物理的对象所理解，如肉体。forms 只能被同样是 immaterial 的东西所理解，那就是 soul。</p>
<p>人可以生老病死，而类似于完美的正义这种概念都是不朽的，永恒的，因为不随着个体的消亡而消亡。</p>
<p>论证如下：</p>
<ol>
<li>ideas (forms) are eternal, non-physical, immaterial.</li>
<li>Eternal / non-physical can only be grasped by eternal / non-physical</li>
<li>So, that which grasps Ideas (forms) mush be eternal / non-physical.<br>non-physical -&gt; not the body<br>eternal -&gt; immortal<br>so soul is imortal.</li>
</ol>
<p>premise no.2 比较容易不令人信服。</p>
<h2 id="argument-from-the-recycling"><a href="#argument-from-the-recycling" class="headerlink" title="argument from the recycling"></a>argument from the recycling</h2><p>“循环观点”论证<br>任何东西的组成部件都先于该东西本身存在而存在。<br>所以我的灵魂先于我本身存在。<br>也不太能够令人信服。</p>
<h2 id="argument-from-the-recollection"><a href="#argument-from-the-recollection" class="headerlink" title="argument from the recollection"></a>argument from the recollection</h2><p>回忆：某个东西A让你想起B。A和B不是同一个东西。例如朋友的照片让你想起了这个朋友（照片和朋友不是同一个东西）<br>这个世界普通的事务，都能引起我们对 forms 的回忆。<br>如果一张照片可以让我想起我的朋友露丝，那么我必定先前见过露丝。<br>我在这个世界，看到盘子可以想到完美的圆的概念一样，<br>我只是看到了 participate forms 的东西可以让我想到 forms itself。<br>那么我必定之前看过 forms itself<br>但是我这一辈子都没有看过 forms itself，那么必定在我的肉身存在之前，就有东西直接去看了。<br>灵魂肯定在人诞生之前就存在。</p>
<p>这个论证的一个问题是，我能理解某种 form，就必须认定我在出生之前就已经直接熟悉了这些概念吗？</p>
<h1 id="Plato-3-灵魂永恒与否的论证"><a href="#Plato-3-灵魂永恒与否的论证" class="headerlink" title="Plato 3. 灵魂永恒与否的论证"></a>Plato 3. 灵魂永恒与否的论证</h1><h2 id="argument-from-the-simplicity"><a href="#argument-from-the-simplicity" class="headerlink" title="argument from the simplicity"></a>argument from the simplicity</h2><p>就算我们同意回忆论，那也只是证明了灵魂在人体存在之前存在，<br>灵魂不会随着人体的灭亡而消散吗？<br>苏格拉底讨论了 什么东西会消散？<br>柏拉图的意思是，如果一个东西是能被摧毁的，那么这个东西有 parts，那么如果一个东西没有 parts，是 simple 的，那么就不能被摧毁，也就是 immortal。</p>
<ol>
<li>only composite things can be destroyed </li>
<li>only changing things are composite</li>
<li>invisible things don’t change</li>
<li>so, invisible things can’t be destroyed.<br>and soul is invisible</li>
<li>so, soul can’t be destroyed.</li>
</ol>
<p>这个argument被一个门徒 Cebes 反驳，一个主人可以穿很多件衣服，但是主人和衣服都会消逝。主人比衣服更加接近 immortality，但是不是真的 immortal。苏格拉底没有回应这个 objection </p>
<p>Simmias 反对前提四。琴和旋律的和谐 harmony 同时被摧毁。<br>这个论证并不存在。。<br>柏拉图也在《理想国》中说过，灵魂分为三个部分，分别掌握 理性、情感、欲望，因此柏拉图也在别的场合说过并不觉得灵魂是 simple 的。</p>
<h1 id="Plato-4-灵魂永恒与否的论证"><a href="#Plato-4-灵魂永恒与否的论证" class="headerlink" title="Plato 4. 灵魂永恒与否的论证"></a>Plato 4. 灵魂永恒与否的论证</h1><p>to be continued …</p>
<h1 id="死亡的本质"><a href="#死亡的本质" class="headerlink" title="死亡的本质"></a>死亡的本质</h1><p>to be continued …</p>
<p>课程的最后老师 share 了这首小诗：</p>
<blockquote>
<p>So death, the most terrifying of ills,<br>is nothing to us, since so long as we exist,<br>death is not with us; but the death comes,<br>then we do not exist.<br>It does not then concern either the living or the &gt;dead,<br>Since for the former it is not,<br>and the latter are no more.<br>——Epicurus</p>
<p>死亡，最恐怖的罪恶，其实对我们没有影响，<br>因为当我们还存在的时候，<br>死亡还未降临；<br>而当死神来临，<br>我们就不再存在。</p>
</blockquote>
<hr>
<blockquote>
<p>God made mud.<br>God got lonesome.<br>So God said to some of the mud, “Sit up!”<br>“See all I’ve made,” said God, “the hills, the sea, the<br>sky, the stars.”<br>And I was some of the mud that got to sit up and look around.<br>Lucky me, lucky mud.<br>I, mud, sat up and saw what a nice job God had done.<br>Nice going, God.<br>Nobody but you could have done it, God! I certainly couldn’t have.<br>I feel very unimportant compared to You.<br>The only way I can feel the least bit important is to think of all the mud that didn’t even get to sit up and<br>look around.<br>I got so much, and most mud got so little.<br>Thank you for the honor!<br>Now mud lies down again and goes to sleep.<br>What memories for mud to have!<br>What interesting other kinds of sitting-up mud I met!<br>I loved everything I saw!</p>
<p>——Kurt Vonnegut Jr. Cat’s Cradle</p>
<p>上帝创造了泥人。<br>上帝烦了。所以上帝对一些泥人说：“坐起来！”<br>“看我创造的一切！”上帝说。“高山、大海、天空、星辰。”<br>我就是那坐起来环顾四周的泥人。<br>幸运的我，幸运的泥人。<br>我，一个泥人，坐了起来，看见了上帝创造的奇迹。<br>你太棒了，上帝！<br>和您相比，我觉得自己十分渺小，无足轻重。<br>只有想到，还有许多泥人未能坐起来环顾四周，我才觉得我有一&gt;点点重要。<br>我已经得到这么多，而大多泥人近乎一无所获，<br>谢谢您的垂顾！<br>现在，泥人又躺下睡了。<br>泥人有什么样的值得回忆的事啊！<br>我曾和多少有趣的坐起来的泥人见过面啊！<br>我爱我看见过的一切！</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>C++学习之包含对象的类、私有和保护继承</title>
    <url>/2017/06/07/Contains-and-Private-Protected-Inheritance/</url>
    <content><![CDATA[<p>C++的一个主要目的是<strong>促进代码重用</strong>。公有继承是实现这种目标的方式之一。但不是唯一的方式。其他方法：使用本身就是另一个类的对象的类成员。例如<code>Stock</code>类中包含一个<code>string</code>类成员。这种方式成为包含（containment）、组合（composition）或层次化（layering）。以及使用私有或保护继承，可以实现<code>has-a</code>关系。模板（Template）也是实现代码重用的一个重要手段。</p>
<h1 id="包含对象成员的类"><a href="#包含对象成员的类" class="headerlink" title="包含对象成员的类"></a>包含对象成员的类</h1><p>Student类，计划用一个<code>string</code>类对象来表示姓名，一个<code>valarray&lt;double&gt;</code>类来表示成绩。</p>
<p>这里公有派生，从valarray中、或者string类中派生出学生类就不太适合了，因为学生和姓名，学生和成绩不是is-a关系。而是has-a关系——学生有姓名，学生有成绩。方法就是包含，即创建一个包含其他对象的类。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	valaaray&lt;<span class="built_in">double</span>&gt; scores;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将上述成员声明为私有的，<code>Student</code>类成员函数可以使用<code>string</code>类和<code>valarray</code>类的公有方法来修改<code>name</code>和<code>scores</code>对象。对于这种情况，描述为：<strong>Student类获得其成员对象的实现，但没有继承接口</strong>。举个例子说，就是虽然<code>Student</code>使用了<code>string</code>类对象用作表示姓名，但<code>Student</code>没有获得使用<code>string::operator+=()</code>的能力。（没有用加号来让两个学生对象的姓名相连的接口），如果要实现这种功能，做法是要在<code>Student</code>里，通过<code>name</code>对象调用<code>string</code>的方法。例如<code>name.size();</code>   通过<code>scores</code>对象来调用<code>valarray</code>方法，例如<code>scores.max();</code></p>
<p>对<code>has-a</code>关系来说，类对象不能自动获得被包含对象的接口是一件好事。例如两个<code>string</code>对象可以使用<code>+=</code>来实现连接的功能。但对<code>Student</code>来说<code>+=</code>是没有意义的。</p>
<h1 id="私有继承：Student类的新版本"><a href="#私有继承：Student类的新版本" class="headerlink" title="私有继承：Student类的新版本"></a>私有继承：Student类的新版本</h1><p>C++实现has-a关系的另一种方法：<strong>私有继承</strong>。使用私有继承，<strong>基类的公有成员和保护成员都将成为派生类的私有成员</strong>。这意味着：基类方法将不会成为派生类对象的公有接口的一部分，但可以在派生类的成员函数中使用它们。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Student :<span class="keyword">private</span> std::<span class="built_in">string</span>, <span class="keyword">private</span> std::valarray&lt;double&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	typedef std::valarray&lt;double&gt; ArrayDb;</span><br><span class="line">	std::ostream &amp; arr<span class="constructor">_out(<span class="params">std</span>::<span class="params">ostream</span> &amp; <span class="params">os</span>)</span>const;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">Student()</span> :std::<span class="built_in">string</span>(<span class="string">&quot;Null Student&quot;</span>), <span class="constructor">ArrayDb()</span> &#123;&#125;</span><br><span class="line">	explicit <span class="constructor">Student(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span> &amp; <span class="params">s</span>)</span></span><br><span class="line">		:std::<span class="built_in">string</span>(s), <span class="constructor">ArrayDb()</span> &#123;&#125;</span><br><span class="line">	explicit <span class="constructor">Student(<span class="params">int</span> <span class="params">n</span>)</span> :std::<span class="built_in">string</span>(<span class="string">&quot;Nully&quot;</span>), <span class="constructor">ArrayDb(<span class="params">n</span>)</span> &#123;&#125;</span><br><span class="line">	<span class="constructor">Student(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span> &amp; <span class="params">s</span>, <span class="params">const</span> ArrayDb &amp; <span class="params">a</span>)</span></span><br><span class="line">		:std::<span class="built_in">string</span>(s), <span class="constructor">ArrayDb(<span class="params">a</span>)</span> &#123;&#125;</span><br><span class="line">	<span class="constructor">Student(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">str</span>, <span class="params">const</span> <span class="params">double</span> <span class="operator">*</span> <span class="params">pd</span>, <span class="params">int</span> <span class="params">n</span>)</span></span><br><span class="line">		:std::<span class="built_in">string</span>(str), <span class="constructor">ArrayDb(<span class="params">pd</span>, <span class="params">n</span>)</span> &#123;&#125;</span><br><span class="line">	~<span class="constructor">Student()</span> &#123;&#125;</span><br><span class="line">	double <span class="constructor">Average()</span> const;</span><br><span class="line">	double &amp; operator<span class="literal">[]</span>(<span class="built_in">int</span> i);</span><br><span class="line">	double operator<span class="literal">[]</span>(<span class="built_in">int</span> i)const;</span><br><span class="line">	const std::<span class="built_in">string</span> &amp; <span class="constructor">Name()</span> const;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//friend</span></span><br><span class="line">	<span class="comment">//input and output</span></span><br><span class="line">	friend std::istream &amp; operator&gt;&gt;(std::istream &amp; is, Student &amp; stu);</span><br><span class="line">	friend std::istream &amp; getline(std::istream &amp; is, Student &amp; stu);</span><br><span class="line">	friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Student &amp; stu);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="基类组件"><a href="#基类组件" class="headerlink" title="基类组件"></a>基类组件</h2><p>因为隐式继承组件而不是成员对象将影响代码的编写。没有<code>name</code>和<code>scores</code>来描述对象了。而必须使用用于公有继承的技术。对于构造函数，<strong>使用类名而不是成员名</strong>。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Student</span><span class="params">()</span></span> :std::<span class="built_in">string</span>(<span class="string">&quot;Null Student&quot;</span>), <span class="built_in">ArrayDb</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问基类方法"><a href="#访问基类方法" class="headerlink" title="访问基类方法"></a>访问基类方法</h2><p>使用私有继承时，只能在派生类的方法中使用基类的方法。使用包含时，是用对象名和成员运算符”.”来调用方法，而使用私有继承时使用类名和作用域解析运算符。举下面这个方法为例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> <span class="title class_">Student</span>::<span class="title function_ invoke__">Average</span>() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="title class_">ArrayDb</span>::<span class="title function_ invoke__">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">ArrayDb</span>::<span class="title function_ invoke__">sum</span>() / <span class="title class_">ArrayDb</span>::<span class="title function_ invoke__">size</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问基类对象"><a href="#访问基类对象" class="headerlink" title="访问基类对象"></a>访问基类对象</h2><p>使用作用域解析运算符可以访问基类的方法。但如果要使用基类对象本身，该如何做呢？例如，下面这段代码是使用<em>包含*</em>关系的<code>Student</code>类有<code>Name()</code>方法<br><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">string</span> &amp; Student::Name()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但使用私有继承时，该string对象<strong>没有名称</strong>，那么如何访问内部string对象？答案是使用<strong>强制类型转换</strong>。由于<code>Student</code>类是由<code>string</code>类派生的，因此可以通过强制类型转换来把<code>Student</code>类转换为<code>string</code>类对象。指针this来指向用来调用方法的对象，*this则为调用方法的对象本身。而且为了避免调用构造函数创建新的对象，所以创建一个引用，返回引用。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp; Student::Name()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="私有继承的指针关系"><a href="#私有继承的指针关系" class="headerlink" title="私有继承的指针关系"></a>私有继承的指针关系</h2><p>这一行代码：<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">&quot;Scores of&quot;</span> &lt;&lt; (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) stu &lt;&lt; <span class="string">&quot;:\n&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>这里用的是<code>operator&lt;&lt;(ostream &amp; ,const string &amp;);</code>原因：在私有继承中，未进行显示类型转换的派生类引用和指针，无法赋值给基类的引用和指针。</p>
<h2 id="使用包含还是私有继承？"><a href="#使用包含还是私有继承？" class="headerlink" title="使用包含还是私有继承？"></a>使用包含还是私有继承？</h2><p>大多数C++程序倾向于使用包含。首先，<strong>包含易于理解</strong>。其次，继承会引起很多问题，尤其是多重继承。例如，如果某个类需要3个string类对象，那么可以包含3个独立的string成员，然而使用继承的话很麻烦，只能使用一个这样的对象（对象没有名称，难以区分）</p>
<p>然而，<strong>私有继承的特性比包含多</strong>。例如：派生类可以重新定义虚函数，但包含不能。例如 派生类可以访问保护成员，包含不能。</p>
<p>下面是上述用私有继承实现的Student类的完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STUDENTC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STUDENTC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;valarray&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="keyword">private</span> std::string, <span class="keyword">private</span> std::valarray&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::valarray&lt;<span class="type">double</span>&gt; ArrayDb;</span><br><span class="line">	<span class="function">std::ostream &amp; <span class="title">arr_out</span><span class="params">(std::ostream &amp; os)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>() :std::<span class="built_in">string</span>(<span class="string">&quot;Null Student&quot;</span>), <span class="built_in">ArrayDb</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">const</span> std::string &amp; s)</span></span></span><br><span class="line"><span class="function">		:std::string(s), ArrayDb() &#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">int</span> n)</span> :std::string(<span class="string">&quot;Nully&quot;</span>), ArrayDb(n) &#123;</span>&#125;</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> std::string &amp; s, <span class="type">const</span> ArrayDb &amp; a)</span><br><span class="line">		:std::<span class="built_in">string</span>(s), <span class="built_in">ArrayDb</span>(a) &#123;&#125;</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span> * str, <span class="type">const</span> <span class="type">double</span> * pd, <span class="type">int</span> n)</span><br><span class="line">		:std::<span class="built_in">string</span>(str), <span class="built_in">ArrayDb</span>(pd, n) &#123;&#125;</span><br><span class="line">	~<span class="built_in">Student</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Average</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="type">double</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">	<span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span>;</span><br><span class="line">	<span class="function"><span class="type">const</span> std::string &amp; <span class="title">Name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//friend</span></span><br><span class="line">	<span class="comment">//input and output</span></span><br><span class="line">	<span class="keyword">friend</span> std::istream &amp; <span class="keyword">operator</span>&gt;&gt;(std::istream &amp; is, Student &amp; stu);</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::istream &amp; <span class="title">getline</span><span class="params">(std::istream &amp; is, Student &amp; stu)</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> Student &amp; stu);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::istream;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private method</span></span><br><span class="line"><span class="function">std::ostream &amp; <span class="title">Student::arr_out</span><span class="params">(std::ostream &amp; os)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> lim = ArrayDb::<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (lim &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			os &lt;&lt; ArrayDb::<span class="keyword">operator</span>[](i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">4</span>)</span><br><span class="line">				os &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>)</span><br><span class="line">			os &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		os &lt;&lt; <span class="string">&quot;empty array&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public methods</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ArrayDb::<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ArrayDb::<span class="built_in">sum</span>() / ArrayDb::<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp; <span class="title">Student::Name</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">const</span> string &amp;) *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> &amp; Student::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ArrayDb::<span class="keyword">operator</span>[](i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Student::<span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ArrayDb::<span class="keyword">operator</span>[](i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//friend</span></span><br><span class="line">std::istream &amp; <span class="keyword">operator</span>&gt;&gt;(std::istream &amp; is, Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">	is &gt;&gt; (string &amp;)stu;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::istream &amp; <span class="title">getline</span><span class="params">(std::istream &amp; is, Student &amp; stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">getline</span>(is, (string &amp;)stu);</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Scores of&quot;</span> &lt;&lt; (<span class="type">const</span> string &amp;) stu &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">	stu.<span class="built_in">arr_out</span>(os);</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> pupils = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> quizzes = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student ada[pupils] = &#123; <span class="built_in">Student</span>(quizzes),<span class="built_in">Student</span>(quizzes),<span class="built_in">Student</span>(quizzes) &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; i++)</span><br><span class="line">		<span class="built_in">set</span>(ada[i], quizzes);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nStudent List:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; i++)</span><br><span class="line">		cout &lt;&lt; ada[i].<span class="built_in">Name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nResults:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; endl &lt;&lt; ada[i];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;average: &quot;</span> &lt;&lt; ada[i].<span class="built_in">Average</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Done.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please enter the student&#x27;s name: &quot;</span>;</span><br><span class="line">	<span class="built_in">getline</span>(cin, sa);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please enter &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; quiz scores:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; sa[i];</span><br><span class="line">	<span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h1><p>保护继承是私有继承的辩题。使用关键字<code>protected</code><br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Student: <span class="symbol">protected</span></span> <span class="symbol">std::<span class="symbol">string</span>, <span class="symbol">protected</span></span> <span class="symbol">std::<span class="symbol">valarray</span></span>&lt;<span class="symbol">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。</p>
<p>当从派生类派生出另一个类时，私有继承和保护继承之间的主要差别就出来了。使用私有继承时，第三代类就不能使用基类的接口，因为基类的公有方法在派生类中是私有方法。使用保护继承时，基类的公有方法在第二代类中将变成保护的，因此在第三代类中可以使用。</p>
<h1 id="各种继承小总结"><a href="#各种继承小总结" class="headerlink" title="各种继承小总结"></a>各种继承小总结</h1><table>
<thead>
<tr>
<th>特征</th>
<th>公有继承</th>
<th>保护继承</th>
<th>私有继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>公有成员变成</td>
<td>派生类的公有成员</td>
<td>派生类的保护成员</td>
<td>派生类的私有成员</td>
</tr>
<tr>
<td>保护成员变成</td>
<td>派生类的保护成员</td>
<td>派生类的保护成员</td>
<td>派生类的私有成员</td>
</tr>
<tr>
<td>私有成员变成</td>
<td>只能通过基类的接口访问</td>
<td>只能通过基类的接口访问</td>
<td>只能通过基类接口访问</td>
</tr>
<tr>
<td>能否隐式向上转换？</td>
<td>能</td>
<td>能（但只能在派生类中）</td>
<td>不能</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>阅读 DPDK 中文论文两则</title>
    <url>/2018/04/06/DPDK-papers-reading/</url>
    <content><![CDATA[<h1 id="基于DPDK的高效数据包捕获技术分析与应用"><a href="#基于DPDK的高效数据包捕获技术分析与应用" class="headerlink" title="基于DPDK的高效数据包捕获技术分析与应用"></a>基于DPDK的高效数据包捕获技术分析与应用</h1><h2 id="本文应用场景"><a href="#本文应用场景" class="headerlink" title="本文应用场景"></a>本文应用场景</h2><p>网络安全领域的数据包捕获技术,对系统有高性能需求，要在短时间内成功收集、分析、处理大量数据，实时捕获效率低下。</p>
<h2 id="旧有传统数据包处理机制"><a href="#旧有传统数据包处理机制" class="headerlink" title="旧有传统数据包处理机制"></a>旧有传统数据包处理机制</h2><ul>
<li><code>BPF</code>，伯克利封包处理器，是 Unix Linux 上的链路层的一种原始接口，许多功能以此为基础。</li>
<li><code>libpcap</code>，linux 下的 C 语言网络数据包捕获函数库，大多数网络包分析软件以此为基础。</li>
<li><code>pf-ring</code> 是 Luca Deri 发明的一种 API 函数库。</li>
</ul>
<p>有所缺陷：</p>
<ul>
<li>在 Linux 内核中完成，导致程序要随着 Linux 的各种功能紧密耦合，难以维护，降低可移植性和通用性</li>
<li>在内核网络协议栈中，涉及系统调用（用户应用程序角度）、中断（网卡驱动角度）、多次内存拷贝操作（内核中、cache 中）</li>
</ul>
<h2 id="DPDK"><a href="#DPDK" class="headerlink" title="DPDK"></a>DPDK</h2><p>DPDK 是数据包转发处理套件。</p>
<ul>
<li>允许用户空间的进程通过 DPDK 的库直接访问网卡，无需经过内核（也就是所谓 <strong>bypass kernel</strong>，或<strong>user space stack</strong>）。</li>
<li>首先明确一个概念，它不是协议栈，和 TCP/IP 不是对等的概念。不提供二层、三层转发功能、防火墙、ACL 等功能，但通过 DPDK 可以开发出上述功能。</li>
<li>其次，它是一套强大的 user space driver，用户空间库和驱动程序。DPDK 总体来讲是一个二层应用。原本是网卡设备驱动、driver、kernel space、user space 的功能，移到 user space 来做了。当然，DPDK 也提供了很多三层 API，例如转发、LPM 等等。DPDK 的功能相当于 Linux 的<strong>设备无关接口层</strong>，处于 socket 之下，driver 之上。</li>
</ul>
<p>主要有四个技术点：</p>
<ul>
<li><strong>大内存页</strong>提高内存使用效率。</li>
<li>在 <strong>user space</strong> 实现绝大部分功能。</li>
<li><strong>cpu affinity</strong> 实现将控制面线程以及各个数据面线程绑定到不同的 CPU 来避免反复调度、进出内核切换带来的性能消耗。</li>
<li>实现从 driver -&gt; kernal -&gt; user space 过程中的 <strong>Zero copy</strong>。它直接从网卡驱动抓取数据，把一系列的工作放到用户态，使得 CPU 将更多的资源放在数据处理上，大大加快数据包处理速度。</li>
</ul>
<p>主要部件：</p>
<ul>
<li><code>rte_eal + libc</code> 内存统一组织管理者</li>
<li><code>librte_ring</code>  无锁队列</li>
<li><code>librte_mempool</code> 提供内存池功能</li>
<li><code>librte_mbuf</code> 提供缓冲区功能</li>
<li><code>librte_malloc</code> 对外提供分配释放内存的API</li>
<li><code>librte_timer</code> 主要用于各种服务间的同步</li>
</ul>
<p>主要函数</p>
<ul>
<li><code>rte_eal_init()</code></li>
<li><code>init_mbuf_pools()</code></li>
<li><code>init_ports(ports-&gt;id[i])</code></li>
<li><code>rte_eth_rx_brust(port_num, 0, buf, PACKET_READ_SIZE)</code></li>
</ul>
<p>实验的 workflow 也比较清晰：</p>
<p><code>rte_eal_init()</code>、<code>init_port()</code>、<code>init_mbuf_pools()</code> 进行 DPDK 、端口、内存池、队列初始化。利用<code>rte_eth_rx_brust()</code> 轮询各端口接收数据包。自定义函数<code>process_packets()</code>来对数据包进行一个初步处理。</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/1%20packet%20process1.png" alt=""></p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/1%20packet%20process2.png" alt=""></p>
<p>接下面两张图是实验 topo：</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/1%20ideal%20topo.png" alt=""></p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/1%20experiment%20topo.png" alt=""></p>
<hr>
<h1 id="基于多核平台的高速网络流量实时捕获方法"><a href="#基于多核平台的高速网络流量实时捕获方法" class="headerlink" title="基于多核平台的高速网络流量实时捕获方法"></a>基于多核平台的高速网络流量实时捕获方法</h1><h2 id="本文应用场景-1"><a href="#本文应用场景-1" class="headerlink" title="本文应用场景"></a>本文应用场景</h2><p>网络数据包的实时采集和分析。</p>
<h2 id="旧有解决方案"><a href="#旧有解决方案" class="headerlink" title="旧有解决方案"></a>旧有解决方案</h2><ul>
<li>基于专用定制化硬件，性能较好，成本较高，模块固定，扩展性差。</li>
<li>基于软件，成本低。</li>
</ul>
<h2 id="传统的报文处理"><a href="#传统的报文处理" class="headerlink" title="传统的报文处理"></a>传统的报文处理</h2><ul>
<li>Linux 网络协议栈的报文处理是典型的软件系统。</li>
</ul>
<p>简述工作原理：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">        <span class="variable">interrupt</span>                            <span class="variable">system</span> <span class="variable">call</span></span><br><span class="line"><span class="variable">driver</span> ----------&gt; <span class="variable">kernel</span> (<span class="variable">protocol</span> <span class="variable">stack</span>)  &lt;----------- <span class="variable">user</span> <span class="function"><span class="title">space</span>(<span class="variable"><span class="class">application</span></span>)</span></span><br><span class="line">       &lt;----------                          -----------&gt;</span><br><span class="line">           <span class="variable">copy</span>       <span class="variable">context</span> <span class="variable">switch</span>        <span class="function"><span class="title"><span class="built_in">copy</span></span>(<span class="variable"><span class="keyword">or</span></span> <span class="variable">sleep</span>)</span></span><br></pre></td></tr></table></figure>
<p>性能瓶颈分析：</p>
<ul>
<li>流量串行访问带来的性能瓶颈。涉及到现代 NIC 的接收端扩展（receiver-side scaling，RSS），使用这种技术，<strong>分组的捕获过程</strong>可以并行化，<strong>然而上层</strong>协议栈和用户程序对此<strong>没有很好的利用</strong>。</li>
</ul>
<p>图：RSS bottleneck</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/2%20RSS%20bottleneck.png" alt=""></p>
<ul>
<li>driver ~ kernel ~ user space 的的过程中，至少包含 2 次<strong>数据拷贝</strong>。一次复制消耗 500~2000 个 CPU 周期。</li>
<li>内核态用户态的<strong>上下文切换</strong>，在每个包上面执行的系统调用产生的上下文切换消耗近 1000 个 CPU 周期。</li>
<li>缺少内存本地化，在内存 copy 时，由于逐字拷贝导致 cache 一直被替换，cache 命中率低下。<strong>cache miss</strong> 导致额外 13.8% 的 CPU 周期。</li>
</ul>
<p><strong>可以看出，协议栈处理数据包时的拷贝操作是性能瓶颈。</strong>旧有方案不能很好地克服这些困难。</p>
<h2 id="思考对传统模式的改进方向"><a href="#思考对传统模式的改进方向" class="headerlink" title="思考对传统模式的改进方向"></a>思考对传统模式的改进方向</h2><ul>
<li><strong>预分配、重用内存资源。</strong>（大页表、内存池）</li>
<li><strong>CPU 亲和</strong>（CPU affinity）是一种技术，允许进程或线程在制定的处理器核心上运行。在本地核心中，cache 更容易命中，减少 cache miss。</li>
<li>内存映射。应用程序的内存区域可以映射到内核态的内存区域，应用程序可以在没有中间副本的情况下进行读写，用这种方式使得应用直接访问网卡的 DMA 内存区域，这种技术叫<strong>零拷贝</strong>。也可以理解为 <strong>zero copy</strong>。</li>
</ul>
<p>这三点是同上一篇论文一样的，下面两点是这篇论文额外所涉及：</p>
<ul>
<li>数据包采用<strong>并行直接通道传递</strong>（特定 RSS 队列、特定 CPU 核心、特定用户程序）（这个特性在某一篇教程中有运用到，设置了多个虚拟网卡。）</li>
<li>数据包<strong>批处理</strong>。以某种策略将数据包划分为组，主要是为了减少系统调用和上下文切换的次数，减少<strong>平摊</strong>处理和复制每个数据包的消耗。</li>
</ul>
<p>这些中没有明确拿<strong>轮询</strong>出来提。轮询主要是避免 system call 引起的 context switch 的技术。</p>
<blockquote>
<p>NAPI（new API) 是 Linux 2.6.0 内核之后采用的一种提高数据包处理性能的新技术，其核心就是使用中断和轮询组合收包</p>
<p>其假设场景是，一旦网卡开始接收到数据包，数据包就会以高频率到达，换言之，就是针对一直有数据包到达的网络环境做了优化，：网卡在接收到第 1 个数据包时将触发硬件中断，中断处理函数会将该网卡加入到设备轮询表中，同时，为了防止后续到达的数据包触发频繁的硬件中断，需要用一条指令设置该中断使之不再接收中断请求；随后，操作系统会触发一个软中断，软中断的处理函数将对轮询表上的设备进行轮询，检查是否有数据包到达并处理；直到本次处理的 cpu 时间片用尽或者数据包的处理过程结束，网卡才重新设置中断屏蔽位开中断接收中断请求．</p>
</blockquote>
<p>不过，上述技术还是有缺陷的，频繁的<strong>软中断</strong>在更高要求的网络环境下也无力了。所谓软中断就是还是有进出内核的操作，不是完全 user space 不是完全 zero copy。</p>
<h2 id="DPDK-数据平面开发套件"><a href="#DPDK-数据平面开发套件" class="headerlink" title="DPDK 数据平面开发套件"></a>DPDK 数据平面开发套件</h2><p>队列管理<code>rte_ring</code> <strong>无锁队列</strong>，环形，大小固定，先进先出，支持无锁，单/多生产者/消费者的排队场景，存储对象的指针。各个 P C 有指针来访问控制。相较于普通的用长度不限的双链表实现的队列，有两个好处：</p>
<ul>
<li>无锁机制</li>
<li>减少了由于突发操作和大量数据传输导致的 cache miss</li>
</ul>
<p><strong>环境抽象层</strong><code>EAL</code>是 DPDK 的一个核心。建立物理内存的映射，是在 DPDK 库之上构建应用时使用的内存的基本单元。每个 CPU 核心对 rte 内存池保有一个本地 cache，这也是为什么要 cpu affinity 和采用批处理的原因。</p>
<p><strong>缓存管理</strong><code>rte_mbuf</code> 用来访问某一个 mempool。</p>
<p>关于核心组件，打算之后要深入看源码，先贴上关于这一部分的一个缩略图。</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/core%20components%20architecture.png" alt=""></p>
<p>参考链接：<a href="http://www.dpdk.org/doc/guides/prog_guide/overview.html#core-components">here</a></p>
<h2 id="网络流捕获系统设计"><a href="#网络流捕获系统设计" class="headerlink" title="网络流捕获系统设计"></a>网络流捕获系统设计</h2><p><strong>系统总体设计</strong>：可维护、可靠、灵活、可重用</p>
<ul>
<li>数据包接收、处理模块</li>
</ul>
<p>收包 workflow</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/2%20DPDK%20packet%20process%20workflow%20.png" alt=""></p>
<p>采用<strong>轮询替代中断和系统调用</strong>来收包，所以收包模式是：程序主动调用<code>rte_eth_rx_burst()</code>接口去接受一定数量的数据包，需要对其进行封装，接收到一个包作为一个事件，触发一系列挂载在上面的回调函数对数据包进行处理。</p>
<p>多线程：一个<code>local_main()</code>不断在每个核心上运行，循环地接受包，在收到包的时候调用<code>rte_eth_rx_burst()</code>处理每个包，根据每个包的包头再调用不同的函数进行处理（parser）</p>
<p>而后的数据包处理模块，每一种报文解析的应用就是一种数据包处理模块，例如解析 http 协议的 http 模块、处理 DNS 的 DNS 模块等，各种不同的模块需要有统一设计和接口，内部解析逻辑各有区别</p>
<ul>
<li>内存管理模块</li>
</ul>
<p>设计两个全局大页内存池，分别是 TCP 流报文池和普通报文池。报文存储在内存池，在队列中存储报文的地址。</p>
<ul>
<li>改进 hash 算法</li>
</ul>
<p>RSS 机制现有一个问题就是会将同一个 TCP 连接的数据包映射到不同的网卡队列。本文改进了一种 hash 算法，将同一 TCP 连接的数据包映射到同一个网卡 RSS 队列。</p>
<ul>
<li>实验框架</li>
</ul>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/2%20%20architecture.png" alt=""></p>
<h1 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h1><p>新系统无论在 cpu 使用率和系统吞吐率还是在丢包率上相比传统数据包捕获系统都有很大优势。</p>
<p>第二篇论文中提到了 DPDK 的系统在试验中相较于 Linux 的内核有 10 倍以上的吞吐量提升。</p>
<h1 id="本次收获"><a href="#本次收获" class="headerlink" title="本次收获"></a>本次收获</h1><p>更加了解了 DPDK 的创新点和工作原理，对于如何用 DPDK 做出基本的网络流量捕获有一个大概的了解。</p>
<p>深刻理解一定的操作系统知识对于理解 DPDK 的创新点非常必要且重要，列出以供参考：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span> 驱动</span><br><span class="line">中断</span><br><span class="line">系统调用</span><br><span class="line">内核空间、用户空间</span><br><span class="line"><span class="variable">cache</span></span><br><span class="line">进程、线程</span><br><span class="line">虚拟内存、页表</span><br><span class="line">上下文切换</span><br><span class="line">单<span class="operator">/</span>多生产者消费者、读者写者等经典信号量同步问题</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="文献："><a href="#文献：" class="headerlink" title="文献："></a>文献：</h1><ul>
<li>[1] 赵　宁, 谢淑翠, 基于 DPDK 的高效数据包捕获技术分析与应用 [J].计算机工程与科学, 2016, 38(11): 2209-2215.</li>
<li>[2] 令瑞林　李峻峰　李　丹, 基于多核平台的高速网络流量实时捕获方法 [J].计算机研究与发展, 2017, 54(6): 1300-1313.</li>
</ul>
]]></content>
      <categories>
        <category>paper-reading</category>
      </categories>
  </entry>
  <entry>
    <title>读《独立宣言》有感</title>
    <url>/2019/07/27/Declaration-of-Independence-and-Lincoln-Gettysburg-Address/</url>
    <content><![CDATA[<p><strong>我们认为下面这些真理是不证自明的：人人生而平等，造物者赋予他们若干不可剥夺的权利，其中包括生命权、自由权和追求幸福的权利。为了保障这些权利，人们才在他们之间建立政府，而政府之正当权力，则来自被统治者的同意。任何形式的政府，只要破坏上述目的，人民就有权利改变或废除它，并建立新政府；新政府赖以奠基的原则，得以组织权力的方式，都要最大可能地增进民众的安全和幸福。</strong>的确，从慎重考虑，不应当由于轻微和短暂的原因而改变成立多年的政府。<strong>过去的一切经验也都说明，任何苦难，只要尚能忍受，人类都宁愿容忍，而无意废除他们久已习惯了的政府来恢复自身的权益。</strong>但是，当政府一贯滥用职权、强取豪夺，一成不变地追逐这一目标，足以证明它旨在把人民置于绝对专制统治之下时，那么，<strong>人民就有权利，也有义务推翻这个政府，并为他们未来的安全建立新的保障。</strong></p>
<p><strong>We hold these truths to be self-evident, that all men are created equal, that they are endowed by their Creator with certain unalienable Rights, that among these are Life, Liberty and the pursuit of Happiness.–That to secure these rights, Governments are instituted among Men, deriving their just powers from the consent of the governed</strong>, –<strong>That whenever any Form of Government becomes destructive of these ends, it is the Right of the People to alter or to abolish it, and to institute new Government, laying its foundation on such principles and organizing its powers in such form, as to them shall seem most likely to effect their Safety and Happiness.</strong> Prudence, indeed, will dictate that Governments long established should not be changed for light and transient causes; <strong>and accordingly all experience hath shewn, that mankind are more disposed to suffer, while evils are sufferable, than to right themselves by abolishing the forms to which they are accustomed.</strong> But when a long train of abuses and usurpations, pursuing invariably the same Object evinces a design to reduce them under absolute Despotism, <strong>it is their right, it is their duty, to throw off such Government, and to provide new Guards for their future security.</strong></p>
<blockquote>
<p>endowed：天赋<br>unalienable：不可剥夺的<br>deriving：obtain something from… 得到；推导；派生<br>prudence：/‘pruːdns/ 谨慎<br>be disposed to：倾向于，有意<br>usurpation /ˌjuːzɜː’peɪʃn/：强取豪夺<br>evince(s) /iˈvins(is)/：表明<br>Despotism /‘despətɪzəm/：独裁；专制统治</p>
</blockquote>
<p>下面是我对独立宣言的读后感。</p>
<p>在国内的初高中大学课题的英文教育，实在是太肤浅了。我们着重于词汇、语法的背诵而已，初中时代要求也仅仅只是背诵一些所谓的课文，高中都是为了通过高考，而我所呆的大学，大部分大学生的追求也只是通过所谓的四六级考试，更可笑的是，还有一些人考了四五次考不过，甚至还引以为傲。并没有人对英语世界的政治、历史、文化、哲学有很多的兴趣。我认为，英文，不仅是一种外语，更是一种 different way of thinking. 我们的教育，真的只是把词法与文法填鸭式地灌送给我们，并没有教给我们去真正地“学一门语言”，学习这种 different way of thinking. 可以说，我自己对于 Declaration of Independence 的学习是第一次给我这种感觉的。</p>
<p>在开篇，独立宣言先定论，人是有造物者赋予的<strong>不可剥夺的权利</strong>的，三个权利分别是 <strong>life、liberty、the pursuit of happiness</strong>. 这里我们可以看到，liberty 是摆在第二位的，自由是美国精神中非常核心的一环，是紧接在生命权之后的，让我想到了那句著名的名言：give me liberty or give me death. 除了生命权和自由权，作为人，最重要的权利，<strong>是追求幸福的权利</strong>。人，是为了什么活着？因为我看到这里，我想到了一些大学生，活着每天像行尸走肉，沉迷在游戏、直播、小视频等“奶嘴”中，只是吃了睡，睡了吃，到了课堂上也只是玩手机，跟猪有什么分别呢？很不幸，很多大学生就是这样。the pursuit of happiness 这几个短短单词，很简单，但我感受到了其中巨大的力量，人活着的最重要的目标，就是追求自己的幸福。我最近在背GRE单词，背GRE单词是一件很枯燥很无聊又很难的事情，但是我每次在背单词的时候，我就会想到独立宣言里的：the pursuit of happiness.</p>
<p>在确定自由和追求幸福是人类不可剥夺的权利之后，宣言提出，政府是为了保护人的这些权利而建立的，此概念直接来自于卢梭的《社会契约论》。紧接着，独立宣言提出非常重要的概念，那就是，<strong>政府的正当权利来自于被统治者的同意</strong>，也就是所谓 <strong>the consent of the governed</strong>. consent 是名词，同意的意思。这里有一个被动语态 governed，the + 形容词指“被统治者”。这个词组就是我所说的 different way of thinking，因为这和中国的传统儒家忠君思想很不一样，在咱们中国的传统文化中，皇帝就是天子，中央集权、大权独揽、乾纲独断，根本就不存在什么 the consent of the governed 这么一种说法。对此我有一种社会生活上的体会：在现代社会，关于AI和Machine learning技术的使用常涉及到公民个人数据的隐私保护问题。我们用户的数据流向了企业，企业本着“不存白不存，以后会有用”的心思把我们的数据留了下来。在中国的环境，只要有一家下作的企业拿着这个隐私数据去卖钱或者干一些下作的勾当，但却没有遭到法律的惩罚，其他的企业看到了之后只会丧心病狂地模仿。以至于在 2018 年李彦宏大言不惭地说，中国人不太在意隐私，愿意拿隐私换取一定程度的便利。与之相反，欧盟在2018年推出了GDPR(General Data Protection Regulation) 是一个用于保护欧盟公民数据隐私的法律，其中有多项条款明确要求企业只有获得了用户的明确同意之后才可以使用用户的数据且必须给予用户随时关闭服务和清空已经上传的个人数据的权利，这就是 the consent of the governed 的完美体现。最令我感慨的是，一个人的思考方式受到自己文化环境的影响太大。如果你不学一门新的语言，那么你就没有方法了解到一种 different way of thinking. the consent of the governed 已经成为了一个英语的政治学名词，而在中文语境下，我们并没有这样的自觉，李彦宏会说出这样的语句也就不足为奇了。在此方面我大大感叹我们与西方发达国家的差距。</p>
<p>既然，政府的正当权利来自于被统治者的同意，所以，只要政府破坏了人民的 life, liberty, the pursuit of happiness <strong>人民就有权改变或者废除它</strong>。这一段论述就非常合理，接下来一句话是对仗的格式：laying its foundation on such principles and organizing its powers in such form 这体现了英语的语言的美。而在初高中的填鸭式教育中，学生是无法体会到的。那不叫“学语言”，只不过是为了应付考试罢了。</p>
<p>然后是话锋一转，承认<strong>出于谨慎的态度，我们不应该因为很细微的原因就推翻一个政府</strong>，因为社会也需要稳定性。接下来一句就特别特别特别的精彩了。all experience hath shewn(has shown), that <strong>mankind are more disposed to suffer, while evils are sufferable</strong>. 人类的耐受力是非常强的，如果对于邪恶还是处于可以容忍的状态时，那么人类很容易保持睁一只眼闭一只眼的态度，甚至会觉得，忍忍就过去了，这只恶魔会高抬贵手的！读到这里的时候，我就不禁佩服美国国父们的洞见了。我甚至强烈怀疑这句话是在描写我们中国人！因为，我想到了文革，其中符合 mankind are more disposed to suffer, while evils are sufferable 这句话所描述的例子实在多到令我不忍细说！甚至到了如今，中国人看到不公正或者为非作歹的事情的时候，“明哲保身”、“沉默的大多数”往往是统治大部分人的第一选择。到了灭顶之灾降临到自己头上的那一天，往往也会叫天不应叫地不灵，上访的结果可能是被维稳，网络上发帖的后果可能是被删帖。对于这不合理的一切，人们宁可容忍，带出来接下来这一句，than to right themselves by abolishing the forms to which they are accustomed. 语言的美和文字的力量在这一句中浑然天成，铿锵有力。首先，right 在这里用作了动词，right themselves 意为“恢复他们的权利”. forms 最普通的意义是表格或者是形成，这里意味着体制。to which they are accustomed 是一个定语从句。这句话读起来实在是有气势，在警示着人们，丧钟不是为他人而鸣，若对这种不公正不公平的现象没有内心最基本的善恶判断而只是一味地忍受，那么丧钟也正是为你而鸣。</p>
<p>pursuing invariably the same Object evinces a design to reduce them under absolute Despotism. 这里有一个词非常有意思，那就是 design。我们都知道 design 是设计，说到设计我们想到的可能都是一些比较美好的东西，比如设计一个雄伟的建筑物或者精美的雕塑等。但是，这里的设计是要 to reduce them under absolute Despotism. 将人民置于专制统治，是可以“设计”的，是有意图的。这令我不寒而栗，尤其是让我将其和希特勒斯大林金家王朝联系到了一起。美国国父告诉美国同胞，当这种情况发生的时候，it is their <strong>right</strong>, it is their <strong>duty</strong>, 已经不仅仅是人民的权利去这样做了，而是人民有义务去这样做，to throw off such Government, and to provide new <strong>Guards</strong> for their future security. 这里我注意到这个 new Guards 这个词，特别地有意思，为什么是 provide new guards 而不是 provide a new government 呢？这里面的区别是：废除了一个政府之后，不只是简简单单地建立一个新政府替代它而已。就好像元朝亡了，大明建立起来，大明又亡了，大清又建立起来，但都是封建主义的专制统治，government 是变了，但 system 并没有改变。这里我想引用台北市长柯文哲的洞见：如果一辆车换了三四个司机还都一直撞，那就不是司机的问题了，而是车有问题。这里用了 guard 这个单词，就是说美国国父决心建立一套新的<strong>保障</strong>，新的体制，要确保这套体制不会重蹈先前失败的政府的覆辙，能够保障未来的人民的安全，不会再收到这种专制主义的压迫。因此，美国国父在建立宪法的时候，普遍采取对政府不信任的态度，建立了三权分立的制度来制衡立法、行政、司法三个权力，并且延续到了今天，美国也成为了世界上最强大的国家。</p>
<p>说实话，第一次看独立宣言给我冲击不小，最明显的一点在于若政府是不合格不称职的政府，人民是有权改变或废除它的，这对我来说是以前完全想都不敢想的说法。读完第一遍，很多单词都不认识。但是，我被其中的力量感动，读第二遍、第三遍、…… 我有一段时间，每天起床背单词，抑或是来到实习单位，坐在电脑前开始上班的时候，我的内心就会飘过独立宣言里面提到的天赋人权，我是在 pursuit of happiness. 这三个单词在内心激励着我。于是我每天开始工作前都会把独立宣言默念一遍，直到现在我已经可以熟练地背诵……</p>
<p>我在二十多岁的这个阶段，对我们国家的历史不由得越发感兴趣。因为我之前听说了一个说法，叫做<strong>乾隆和华盛顿是同一个时代的人</strong>。我心想，难道真的是我们的老祖宗智力就不如人家吗？还是说美国国父们就是这么伟大，而炎黄子孙就是天生就是贱民的命。为什么在西方人能提出这么伟大的思想的时候，我们还处在封建黑暗的时代？在北京实习的时候，我逛了几处重要的景点，其中有颐和园和恭王府。在去颐和园之前，我突发奇想地把洋务运动以及甲午战争那阵的历史回顾了一遍（上油管看了一位叫做石国鹏老师的讲课视频，他以前是北京四中的历史老师，现在已经在墙内被block）。从恭王府回来之后，我看了百家讲坛上面清华历史学博士后张宏杰讲乾隆的视频。同时，也把独立宣言重温了一下。回顾完这段历史之后，在逛颐和园和恭王府的时候，我的心情并没有很轻松，因为我知道了颐和园是慈溪太后挪用北洋海军军费给自己盖的祝寿享乐的园子，以及乾隆后期中国的政治是多么的腐败。相比之下，日本天皇是从自己伙食费里抠钱都要省下来大力发展海军，同时期的美国国父们写下了独立宣言。历史不容假设，但倘若我们的老祖宗争气一点，今天的中华民族想必会比现在更加繁荣昌盛吧？</p>
<p>但是更重要的是，我发现了自己是一个自由的人。我每一天醒来，是为了追求幸福而活着，这是我的权利，也是我生而为人的根本。</p>
<hr>
<p>八十七年前，我们的父辈们在这块陆地上建起了一个新的国家，<strong>它孕育于自由，并奉行人人生而平等的主张。</strong></p>
<p>Four score and seven years ago our fathers brought forth on this continent, a new nation, <strong>conceived in Liberty, and dedicated to the proposition that all men are created equal.</strong></p>
<p>如今，我们正在进行一场伟大的内战，考验着那个国家，或任何有此信仰和主张的国家，能否长久地存续下去。我们在这场战争的伟大战场上相遇，为了使那一国家得以存续，我们将在这片战场上找到我们最后的安息之地，——那些为此而死去的人已经这么做了，——这对我们而言是恰当的，也是适宜的。</p>
<p>Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.</p>
<p>然而，从更广泛的意义上说，我们无法在此祭奠，我们无法在此奉献，我们无法使这片土地得以神圣化；那些活着的人，和死去的人，曾在此拼搏过的，已经使它神圣化，而这一意义是我们乏弱的力量远远不能有所增减的。世界不会注意到，也不会长久地记住我们在这儿说过什么，但它绝不会忘记那些人曾在这儿做过什么。虽然大业尚未完竟，但那些为此奋斗过的烈士们已使这一事业进入了最后的成熟阶段，无疑，我们这活着的人当继续致力于这一事业。我们应当投身于那留在我们面前的伟大任务——从那些为此投入了全部热忱的逝者那里，我们将获得更多的热忱；我们将不会，绝不会使那些为此献出生命的人白白献出生命；我们将使这个国家，在上帝的庇佑下，从自由里获得新生；而<strong>那一为民所有、为民所治、为民所享的政府，也绝不会从这片土地上消亡。</strong></p>
<p>But, in a larger sense, we can not dedicate—we can not consecrate—we can not hallow—this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us—that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion—that we here highly resolve that these dead shall not have died in vain—that this nation, under God, shall have a new birth of freedom—and <strong>that government of the people, by the people, for the people, shall not perish from the earth.</strong></p>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之类与动态内存分配</title>
    <url>/2017/06/07/Dynamic-memory-allocation/</url>
    <content><![CDATA[<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>动态分配内存——防止大量浪费或者增加计算机内存负载。也就是程序运行时（而不是编译时）确定使用多少内存的问题。在类构造函数中使用new，在这种情况下，析构函数是必不可少的。有时候，还必须重载赋值运算符。</p>
<p>为了学习动态内存分配在类设计中的相关知识，我们先设计一个StringBad类，然后设计一个功能稍强的String类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stringbad.h -- 有缺陷的string类声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringBad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> *str;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num_strings;<span class="comment">//静态类成员，对象的数量。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> *s);</span><br><span class="line">	<span class="built_in">StringBad</span>();</span><br><span class="line">	~<span class="built_in">StringBad</span>();</span><br><span class="line">	<span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> StringBad &amp; st);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> StringBad::num_strings = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">	len = std::<span class="built_in">strlen</span>(s);</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];<span class="comment">//用到了new，动态内存分配</span></span><br><span class="line">	std::<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">	num_strings++;</span><br><span class="line">	cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\&quot; object created\n&quot;</span>;<span class="comment">//调用构造函数时，打印一句提示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBad::<span class="built_in">StringBad</span>()</span><br><span class="line">&#123;</span><br><span class="line">	len = <span class="number">4</span>;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">4</span>];</span><br><span class="line">	std::<span class="built_in">strcpy</span>(str, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">	num_strings++;</span><br><span class="line">	cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\&quot; object created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBad::~<span class="built_in">StringBad</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;object deleted. &quot;</span>;<span class="comment">//调用析构函数时，打印一句提示</span></span><br><span class="line">	num_strings--;</span><br><span class="line">	cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot; left\n&quot;</span>;</span><br><span class="line">	<span class="keyword">delete</span> [] str;<span class="comment">//析构函数保证对象过期时，由new分配的内存被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; st.str;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme1</span><span class="params">(StringBad &amp;)</span></span>;<span class="comment">//按引用传递的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme2</span><span class="params">(StringBad)</span></span>;<span class="comment">//按值传递的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::endl;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">StringBad <span class="title">a1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">		<span class="function">StringBad <span class="title">a2</span><span class="params">(<span class="string">&quot;def&quot;</span>)</span></span>;</span><br><span class="line">		<span class="function">StringBad <span class="title">a3</span><span class="params">(<span class="string">&quot;ghi&quot;</span>)</span></span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;用a1传递给某按引用传递的函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">callme1</span>(a1);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将a2传递给某按值传递的函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">callme2</span>(a1);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;初始化对象a4，用a3为其赋值&quot;</span> &lt;&lt; endl;</span><br><span class="line">		StringBad a4 = a3;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;初始化对象a5，分配给另一个对象a1&quot;</span> &lt;&lt; endl;</span><br><span class="line">		StringBad a5;</span><br><span class="line">		a5 = a1;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a5:&quot;</span> &lt;&lt; a5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;main函数结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme1</span><span class="params">(StringBad &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;按引用传递了字符串：&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme2</span><span class="params">(StringBad s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;按值传递了字符串：&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170608085643622-1731237515.png" alt=""></p>
<p>从执行结果来看，StringBad类是一个名副其实的，有缺陷的类。存在以下问题：</p>
<ol>
<li>按值传递的函数，使得对象作为函数参数来传递时会导致析构函数被调用，会使得原始字符串无法识别。a2过早的被delete。</li>
<li>main里删除对象和建立对象的顺序相反，所以最先删除的三个对象会是a5、a4和a3。a5中出现了很奇怪的字符串<code>↓h</code></li>
</ol>
<p>下面的语句：<code>StringBad a4 = a3;</code>这用的是哪个构造函数呢？显然不是默认构造函数，也不是参数为<code>const char *</code>的构造函数，而是<strong>复制构造函数</strong>，原型如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">StringBad(<span class="params">const</span> StringBad &amp;)</span>;</span><br></pre></td></tr></table></figure>
<p>上述main代码测试出的问题都是由编译器自动形成的<strong>特殊成员函数</strong>引起的。下面介绍这个主题。</p>
<h1 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h1><p>对于C++的类，在没有提供这种类型的函数时，会<strong>自动</strong>提供如下的成员函数：</p>
<p>• 默认构造函数<br>• 默认析构函数<br>• 复制构造函数<br>• 赋值运算符<br>• 地址运算符</p>
<h2 id="默认复制构造函数（copy-constructor）"><a href="#默认复制构造函数（copy-constructor）" class="headerlink" title="默认复制构造函数（copy constructor）"></a>默认复制构造函数（copy constructor）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>原型如下：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">Class_name(<span class="params">const</span> Class_name &amp;)</span>;</span><br></pre></td></tr></table></figure></p>
<p>调用时机：<strong>新建一个对象并将其初始化为同类现有对象时</strong>。例如a1是一个StringBad对象，则下面四种声明都会调用复制构造函数</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">StringBad <span class="built_in">a2</span>(<span class="built_in">a1</span>);</span><br><span class="line">StringBad <span class="built_in">a3</span> = <span class="built_in">a1</span>;</span><br><span class="line">StringBad <span class="built_in">a4</span> = StringBad(<span class="built_in">a1</span>);</span><br><span class="line">StringBad *<span class="built_in">a5</span> = new StringBad(<span class="built_in">a1</span>);</span><br></pre></td></tr></table></figure>
<p>还有就是每当程序生成对象副本（按值传递时意味着创建原始变量的一个<strong>副本</strong>），编译器都将使用复制构造函数。具体地说，当函数按值传递对象，（如上一章的<code>callme2()</code>函数）或按值传递的函数返回对象时，都将调用复制构造函数。</p>
<p>由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间空间。</p>
<h3 id="功能和存在的问题"><a href="#功能和存在的问题" class="headerlink" title="功能和存在的问题"></a>功能和存在的问题</h3><p>默认的复制构造函数逐个复制非静态成员，复制的是成员的<strong>值</strong>。</p>
<p><code>callme2()</code>被调用时，复制构造函数被用来初始化<code>callme2()</code>的形参，以及语句：<code>StringBad a4 = a3;</code>也会用到复制构造函数。</p>
<p>第一个异常是计数器的异常。由于是默认的复制构造函数，所以不会增加计数器<code>num_strings</code>的值（<code>num_strings</code>的值是在构造函数中自增的）。但是析构函数会在任何对象过期时调用，而不管对象是如何被创建的。</p>
<p>第二个异常更加危险。由于隐式复制构造函数是<strong>按值复制</strong>的。所以<strong>复制的并不是字符串</strong>，<strong>而</strong>是一个指向字符串的<strong>指针</strong>。也就是说，将a4初始化为a3后，得到的是两个指向同一个字符串的指针。当析构函数被调用的时候，会出现问题。当a4先被删除时，会被正常删除，但a3对象过期时，<strong>调用析构函数时会把已经释放的内存再次释放</strong>，对同一块内存delete两次，这有可能导致程序崩溃。</p>
<p>解决方法：进行<strong>深度复制</strong>，而不是浅度复制。也就是说，复制的时候应当创建副本，并将副本赋给str成员，而<strong>不仅仅复制字符串地址</strong>。这样每个对象都有自己的字符串，而不是引用另一个对象的字符串。</p>
<h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p>浅复制的原理图：</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170607190628981-1576764955.png" alt=""></p>
<h3 id="深度复制"><a href="#深度复制" class="headerlink" title="深度复制"></a>深度复制</h3><p>深度复制的原理图：</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170607190632809-1648528248.png" alt=""></p>
<h3 id="定义新的复制构造函数，实现深度复制"><a href="#定义新的复制构造函数，实现深度复制" class="headerlink" title="定义新的复制构造函数，实现深度复制"></a>定义新的复制构造函数，实现深度复制</h3><p>如果类中包含使用了new初始化的指针成员，应当定义一个复制构造函数，用来复制指向的数据，而不是复制指向数据的指针（默认复制构造函数就是复制成员的值，导致错误）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">StringBad</span>(<span class="keyword">const</span> StringBad &amp; st);</span><br><span class="line"></span><br><span class="line">StringBad::<span class="title function_ invoke__">StringBad</span>(<span class="keyword">const</span> StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	num_strings++;</span><br><span class="line">	len = st.len;</span><br><span class="line">	<span class="type">str</span> = new <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	std::<span class="title function_ invoke__">strcpy</span>(<span class="type">str</span>, st.<span class="type">str</span>);</span><br><span class="line">	cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; <span class="type">str</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;\&quot; object created\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符（assignment）"><a href="#赋值运算符（assignment）" class="headerlink" title="赋值运算符（assignment）"></a>赋值运算符（assignment）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>将<strong>已有</strong>的对象赋值给另一个对象将使用重载的赋值运算符。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">StringBad a5<span class="comment">;</span></span><br><span class="line"><span class="attribute">a5</span> <span class="operator">=</span> a1<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>如果在一条语句内初始化对象，不一定会使用赋值运算符，而是复制构造函数。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">String a4 <span class="operator">=</span> a3<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>这个是使用复制构造函数的例子。但实际也可能分两步来实现，就是使用复制构造函数创建临时对象，再把临时对象赋值给新对象。</p>
<p>也就是说，初始化一定会调用复制构造函数，而使用<code>=</code>运算符时允许调用赋值运算符。</p>
<h3 id="默认重载的赋值运算符对StringBad类有什么问题？"><a href="#默认重载的赋值运算符对StringBad类有什么问题？" class="headerlink" title="默认重载的赋值运算符对StringBad类有什么问题？"></a>默认重载的赋值运算符对StringBad类有什么问题？</h3><p>和隐式复制构造函数一样，存在数据受损的问题，原理也是成员复制的问题。也会进行浅度复制。也会造成同一段内存被释放两次的错误。</p>
<p>提供赋值运算符的深度复制的定义。与复制构造函数有一些差别是：<br>• 由于目标对象可能引用了以前分配的数据，所以应先使用<code>delete[]</code>。<br>• <strong>应当避免对象赋值给自身</strong>；否则释放内存的操作可能删除对象的内容。<br>• <strong>返回一个引用。使得可以连续赋值</strong>。</p>
<h3 id="为StringBad类编写赋值运算符"><a href="#为StringBad类编写赋值运算符" class="headerlink" title="为StringBad类编写赋值运算符"></a>为StringBad类编写赋值运算符</h3><p>赋值运算符是<strong>只能用成员函数重载</strong>的几个运算符之一。详见重载限制。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="type">const</span> StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>==&amp;st)             <span class="comment">//避免赋值给自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">delete</span> [] str;            <span class="comment">//释放原来的内存</span></span><br><span class="line">	len = str.len;</span><br><span class="line">	str= <span class="keyword">new</span> <span class="type">char</span> [len + <span class="number">1</span>];</span><br><span class="line">	std::<span class="built_in">strcpy</span>(str,st.str);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果在构造函数中使用new来初始化指针对象，则</p>
<p>• 析构函数不再是可有可无的了，必须在析构函数中使用delete。<br>• new和delete必须互相兼容。new对应delete，new []对应delete[];<br>• 如果有多个构造函数，则必须用相同的方法使用new。要么都带中括号，要么都不带。因为只能有一个析构函数，要与所有构造函数兼容。<br>• 应定义一个复制构造函数，通过深度复制将一个对象初始化给另一个对象。<br>• 应定义一个赋值运算符，通过深度复制将一个对象赋值给另一个对象。</p>
<h1 id="改进后的String类"><a href="#改进后的String类" class="headerlink" title="改进后的String类"></a>改进后的String类</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string1.h -- 改进后的string类</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  STRING1_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  STRING1_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">using</span> std::istream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> *str;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num_strings;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> CINLIM = <span class="number">80</span>;	<span class="comment">//通过cin输入的上限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *s);			<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">String</span>();						<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">String</span> &amp;st);		<span class="comment">//复制构造函数</span></span><br><span class="line">	~<span class="built_in">String</span>();						<span class="comment">//析构函数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> len; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	<span class="type">String</span> &amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">String</span> &amp;);</span><br><span class="line">	<span class="type">String</span> &amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">	<span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//友元函数重载</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> <span class="type">String</span> &amp;st1, <span class="type">const</span> <span class="type">String</span> &amp;st2);</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> <span class="type">String</span> &amp;st1, <span class="type">const</span> <span class="type">String</span> &amp;st2);</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> <span class="type">String</span> &amp;st1, <span class="type">const</span> <span class="type">String</span> &amp;st2);</span><br><span class="line">	<span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> <span class="type">String</span> &amp;st);</span><br><span class="line">	<span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, <span class="type">String</span> &amp;st);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态类成员函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">HowMany</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ! STRING1_H_</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//string1.cpp -- 方法定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;string1.h&quot;</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">String</span>::num_strings = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">String::HowMany</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num_strings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *s)<span class="comment">//由c风格字符串来创建类对象</span></span><br><span class="line">&#123;</span><br><span class="line">	len = std::<span class="built_in">strlen</span>(s);</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	std::<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">	num_strings++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>::<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">	len = <span class="number">4</span>;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	num_strings++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">String</span> &amp;st)<span class="comment">//深度复制的复制构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">	num_strings++;</span><br><span class="line">	len = st.len;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	std::<span class="built_in">strcpy</span>(str, st.str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>::~<span class="built_in">String</span>()<span class="comment">//必要的析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">	--num_strings;</span><br><span class="line">	<span class="keyword">delete</span>[]str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> &amp; <span class="type">String</span>::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">String</span> &amp;st)<span class="comment">//赋值运算符，用一个String对象赋值给另一个对象</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;st)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span>[]str;</span><br><span class="line">	len = st.len;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	std::<span class="built_in">strcpy</span>(str, st.str);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> &amp; <span class="type">String</span>::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *s)<span class="comment">//赋值运算符，用C风格字符串赋值给一个String对象</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]str;</span><br><span class="line">	len = std::<span class="built_in">strlen</span>(s);</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	std::<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> &amp; <span class="type">String</span>::<span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="comment">//重载中括号，使得可以使用中括号访问法访问String类对象的字符</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; <span class="type">String</span>::<span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span><span class="comment">//为const String对象编写的相同功能的重载版本</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> <span class="type">String</span> &amp;st1, <span class="type">const</span> <span class="type">String</span> &amp;st2)<span class="comment">//比较函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (std::<span class="built_in">strcmp</span>(st1.str, st2.str) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> <span class="type">String</span> &amp;st1, <span class="type">const</span> <span class="type">String</span> &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> st2 &lt; st1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> <span class="type">String</span> &amp;st1, <span class="type">const</span> <span class="type">String</span> &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span>(std::<span class="built_in">strcmp</span>(st1.str, st2.str) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> <span class="type">String</span> &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; st.str;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, <span class="type">String</span> &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> temp[<span class="type">String</span>::CINLIM];</span><br><span class="line">	is.<span class="built_in">get</span>(temp, <span class="type">String</span>::CINLIM);</span><br><span class="line">	<span class="keyword">if</span> (is)</span><br><span class="line">		st = temp;</span><br><span class="line">	<span class="keyword">while</span> (is&amp;&amp;is.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之函数探幽</title>
    <url>/2017/06/07/Functions-exploration/</url>
    <content><![CDATA[<p>C++提供许多新的函数特性，使之有别于C语言。包括内联函数、按引用传递变量、默认参数值、函数重载（多态）以及模板函数。</p>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><h2 id="内联函数定义"><a href="#内联函数定义" class="headerlink" title="内联函数定义"></a>内联函数定义</h2><p>内联函数是C++为了提高程序运行速度而做出的一项改进。内联函数与常规函数的<strong>主要区别不在于编写方式</strong>，而在于C++编译器<strong>如何把它们组合到程序中</strong>。</p>
<p>常规函数调用会使程序立即跳到一个地址（函数的地址），并在函数结束时返回。执行函数调用时，程序在函数调用后立即存储该指令的内存地址，并且把函数参数复制到堆栈，跳到标记函数起点的地址，然而执行函数代码，最后跳回之前保存的指令地址处。来回跳跃并记录跳跃位置意味着使用常规函数，需要一定的内存开销。</p>
<p>内联函数提供了另一种选择。内联函数的代码编译与其他程序代码“内联”起来了。<strong>也就是说，对于内联函数代码，程序无需跳到一个位置处理函数，再跳回来</strong>。因此内联函数的执行速度会稍快，但是代价是更多的内存。</p>
<p><strong>应有选择地使用内联函数</strong>。如果执行函数代码的时间比函数调用机制的时间长，则节省的时间只是占整个过程的很小一部分。如果代码执行时间短，则内联函数调用机制可以节省大部分时间。但是另一方面，虽然节省了大部分时间，但实际上节省的时间也不长，除非该函数会被反复调用多次。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>使用这项特性，采取以下方法中的一种：</p>
<ul>
<li>在函数声明前加上关键字inline</li>
<li>在函数定义前加上关键字inline</li>
</ul>
<p>编译器<strong>不一定</strong>会满足<code>inline</code>的要求。它有可能认为函数调用了自己（内联函数不允许递归），或者有的编译器没有这种特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//an inline function definition</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="type">double</span> a, b;</span><br><span class="line">	<span class="type">double</span> c = <span class="number">13.0</span>;</span><br><span class="line">	a = <span class="built_in">square</span>(<span class="number">5.0</span>);</span><br><span class="line">	b = <span class="built_in">square</span>(<span class="number">4.5</span> + <span class="number">7.5</span>);<span class="comment">//can pass expression</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;, csquared = &quot;</span> &lt;&lt; <span class="built_in">square</span>(c++) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数定义都放在了一行之中，（不是非得这样做，但是请保证函数尽量简短）然而如果函数定义占多行，则将其作为内联函数就不太合适。</li>
<li><ul>
<li>tips1：对于函数语句内有while、switch如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数(自己调用自己的函数)是不能被用来做内联函数的。</li>
</ul>
</li>
<li><ul>
<li>tips2：对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。</li>
</ul>
</li>
<li><p>内联扩展是用来消除函数调用时的时间开销。它通常用于频繁执行的函数。 一个小内存空间的函数非常受益。</p>
</li>
<li><p>注意到，内联函数和常规函数一样，也是按值传递参数的。如果参数为表达式，如4.5+7.5，则内联函数能传递表达式的值（C语言中实参可以是表达式，形参不能是表达式）。这使得C++的内联功能胜过C语言的宏定义。</p>
</li>
</ul>
<h2 id="与宏定义的比较"><a href="#与宏定义的比较" class="headerlink" title="与宏定义的比较"></a>与宏定义的比较</h2><p>内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如</p>
<figure class="highlight tp"><table><tr><td class="code"><pre><span class="line">#define SQUARE(<span class="keyword">X</span>) <span class="keyword">X</span>*<span class="keyword">X</span></span><br></pre></td></tr></table></figure>
<p>宏定义最重要的性质是它通过<strong>替换字符串</strong>来实现功能。所以如果<code>a=SQUARE(5)</code>，能得到正确结果25，但是如果<code>b=SQRARE(4.5+7.5)</code>，结果会是<code>4.5+7.5*4.5+7.5</code>，不会是我们要的结果144。</p>
<p>所以在写宏定义的时候一般都是这么写：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#define</span> SQUARE(X) ((X)*(X))</span><br></pre></td></tr></table></figure>
<p>tips：所有用到参数的地方加上左右括号，最后再用左右括号把整个定义括起来。</p>
<p>但仍然存在问题：不能按值传递。所以当遇到SQRARE(c++)这样的情况，会把C递增两次。但如果依照上面的内联函数写法，会求出C的平方值后，只递增一次。</p>
<p>而且事实上我们可以用内联函数完全取代预处理宏。</p>
<p>内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>C++ 新增了一种符合类型——引用变量。引用，是已定义的变量的别名。例如将a作为已经定义的b变量的引用，则可以交替使用a和b来表示改变量。</p>
<p>这有何作用呢？</p>
<h2 id="使用引用变量"><a href="#使用引用变量" class="headerlink" title="使用引用变量"></a>使用引用变量</h2><p>C 和 C++使用<code>&amp;</code>来表示变量的地址。C++给<code>&amp;</code>赋予了另一个意义，可以用来声明引用。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">101</span>;</span><br><span class="line"><span class="built_in">int</span> &amp; b = a;</span><br></pre></td></tr></table></figure>
<p>那么 <code>b</code> 就是 <code>a</code> 的一个<strong>别名</strong>。</p>
<p>其中，<code>&amp;</code> 不是地址运算符，而且类型标示符的一部分。就像 <code>char *</code> 指的是指向 char 的指针一样，<code>int &amp;</code> 就是指向 int 的引用。</p>
<p>引用：支持已定义变量和其引用变量互换</p>
<ul>
<li>他们代表相同的值，指向相同的内存单元。</li>
<li>将其中一个变量改变会影响两个变量。</li>
<li>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个<strong>别名</strong>，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。</li>
</ul>
<h2 id="引用与指针、地址的关系"><a href="#引用与指针、地址的关系" class="headerlink" title="引用与指针、地址的关系"></a>引用与指针、地址的关系</h2><p>初始引用变量，我们很容易想到原本C语言中就有的指针和地址。<br>那么，具体区别如下：</p>
<p>表达式b和*c都可以和a互换。<br>&amp;b和c都可以和&amp;a互换。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> &amp;b = a;<span class="comment">//reference</span></span><br><span class="line"><span class="built_in">int</span> *c = &amp;a;<span class="comment">//pointer</span></span><br></pre></td></tr></table></figure>
<p>在上段代码中，各种表达式的意义如下：</p>
<table>
<thead>
<tr>
<th>b</th>
<th>&amp;b</th>
<th>c</th>
<th>*c</th>
<th>a</th>
<th>&amp;a</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用</td>
<td>引用的地址</td>
<td>指针</td>
<td>间接访问</td>
<td>变量</td>
<td>变量的地址</td>
</tr>
</tbody>
</table>
<p>引用看起来很像伪装表示的指针。实际上，引用还是很不同于指针的。除了表示法不同以外，还有其他的差别，例如差别之一是<strong>必须在声明引用的同时初始化</strong>，不能像指针那样先声明，后赋值。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> *c;</span><br><span class="line">c = &amp;a; <span class="comment">//yes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> &amp;b;</span><br><span class="line">b = a;<span class="comment">//no</span></span><br></pre></td></tr></table></figure>
<p>编译器会报错：引用变量“b”需要初始值设定项。</p>
<p>引用有一种const指针的味道——必须在声明的时候初始化，一旦初始化，就和某个变量关联起来，而且一直效忠于它。</p>
<p>引用作为真实对象的别名，必须进行初始化，除非满足下列条件之一：</p>
<ol>
<li>引用变量被声明为外部的，它可以在任何地方初始化</li>
<li>引用变量作为类的成员，在构造函数里对它进行初始化</li>
<li>引用变量作为函数声明的形参，在函数调用时，用调用者的实参来进行初始化</li>
</ol>
<p>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。如果<code>ra</code>是<code>a</code>的引用，则<code>&amp;ra</code>与<code>&amp;a</code>相等。</p>
<p>可以建立数组的引用，C++中解决数组做形参的降价问题就是通过使用数组的引用。</p>
<p>不能建立引用的引用，不能建立指向引用的指针。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">int <span class="meta">&amp;&amp;r=n；<span class="comment">//错误</span></span></span><br><span class="line">int <span class="meta">&amp;*p=n;<span class="comment">//错误</span></span></span><br></pre></td></tr></table></figure>
<p>可以建立指针的引用</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> *p;</span><br><span class="line"><span class="built_in">int</span> *&amp;q=p;<span class="comment">//正确，即指针p起别名q。</span></span><br></pre></td></tr></table></figure>
<h2 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h2><p>下面看看swap函数的三种写法：按值传参数、传指针做参数（地址）、按引用传递。</p>
<p>不用我说也知道：按值传递不能成功交换两个值，而后面传地址or传引用都是可以成功交换的。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> swapr(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b);//a,b are aliases <span class="keyword">for</span> ints;</span><br><span class="line"><span class="type">void</span> swapp(<span class="type">int</span> *p, <span class="type">int</span> *q);//q,p are addresses</span><br><span class="line"><span class="type">void</span> swapv(<span class="type">int</span> a, <span class="type">int</span> b);//a,b are variables</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> swapr(<span class="type">int</span> &amp; a, <span class="type">int</span> &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">temp</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">temp</span> = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = <span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> swapp(<span class="type">int</span> *p, <span class="type">int</span> *q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">temp</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">temp</span> = *p;//use *q <span class="keyword">and</span> *p <span class="keyword">for</span> <span class="keyword">values</span> <span class="keyword">of</span> variables</span><br><span class="line">	*p = *q;</span><br><span class="line">	*q = <span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> swapv(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">temp</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">temp</span> = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = <span class="keyword">temp</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用常常被作为参数来传递，使得函数中的变量名是程序中变量的别名。这种传递方法叫做<strong>按引用传递</strong>。按引用传递可以<strong>允许被调用函数访问变量</strong>。C语言只能按值传递，调用函数使用的是程序中变量值的拷贝。所以C语言函数为了修改变量，得避开按值传递的限制，使用修改地址的方法。</p>
<p>像这个交换两个值的函数，我们知道函数swapv不起作用的原因是函数交换的是原变量的副本值，而不是交换变量。但传递引用，就可以使得函数使用原始数据。</p>
<p>如果a和b分别是w1和w2的引用，调用swapr(a,b)和swapv(a,b)。因为a和b是变量的别名，所以swapr交换两个引用的值，自然相当于交换变量a和b的值。但在swapv中，变量a和b只是复制了w1和w2的值的新变量，因此交换两个变量的值并不会影响w1和w2。</p>
<p>引用的最多用处就是作为函数的参数（常见于结构体和对象），通过引用变量作参数可以是函数使用原始数据，而不是拷贝。</p>
<h2 id="引用就是给变量取别名，那别名究竟是什么意思？"><a href="#引用就是给变量取别名，那别名究竟是什么意思？" class="headerlink" title="引用就是给变量取别名，那别名究竟是什么意思？"></a>引用就是给变量取别名，那别名究竟是什么意思？</h2><blockquote>
<p>引用么，如同给你取了一个别名。如你真名叫张三，你去参加了一档真人秀节目，在这个真人秀节目中，你有个昵称叫做张三疯，然后在真人秀节目中，有人打了张三疯一拳，你觉得本名叫张三的你会不会感觉到疼？真人秀 -&gt; 函数。张三 -&gt; 对象原名。张三疯 -&gt; 引用传递的参数名。打了张三疯一拳 -&gt; 改变对象的值。试试不就知道了。</p>
<p>作者：蓝色<br>链接：<a href="https://www.zhihu.com/question/54151133/answer/138137011">https://www.zhihu.com/question/54151133/answer/138137011</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="与按值传递的区别"><a href="#与按值传递的区别" class="headerlink" title="与按值传递的区别"></a>与按值传递的区别</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//regular and reference arguments</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">double</span> &amp;ra)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="type">double</span> x = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">cube</span>(x);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; = cube of &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">refcube</span>(x);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; = cube of &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这儿故意写的求立方函数写的比较奇怪（对本身参数进行了修改）*/</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a *= a*a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">double</span> &amp;ra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ra *= ra*ra;</span><br><span class="line">	<span class="keyword">return</span> ra;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<br><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170607124020122-109433244.png" alt=""></p>
<p><code>refcube(x)</code>函数修改了 main 里的 x 的值，而 <code>cube(x)</code>没有。</p>
<p>这提醒我们为何通常选择按值传递。变量 a 位于 cube()中，它被初始化为 x 的值，但修改 a 并不会影响 x。但由于 refcube() 使用了引用参数，因此修改 ra 实际上就是修改 x。</p>
<p>如果程序员的意图是让函数使用参数，但不对参数进行修改，同时又想使用按引用传递，则应该使用按常量引用。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> <span class="built_in">ref</span>cube(<span class="keyword">const</span> <span class="built_in">double</span> &amp;ra);</span><br></pre></td></tr></table></figure>
<p>如有const，检测到函数要修改ra，会生成报错信息。</p>
<h2 id="何时使用引用参数？"><a href="#何时使用引用参数？" class="headerlink" title="何时使用引用参数？"></a>何时使用引用参数？</h2><p>主要原因有两个：<br>    • 程序员要修改调用函数中的数据对象<br>    • 通过传递引用，而不是整个数据对象，提高运行速度</p>
<p>下面有一些指导原则</p>
<p>如果数据对象<br>    • 很小，选择按值传递。<br>    • 是数组，选用指针，这是唯一的选择，如果不修改数组内容，用const<br>    • 是较大的结构，使用const指针或者const引用。<br>    • 是类对象，const引用。类设计的语义常常需要使用引用。传递类对象参数的标准方式是按引用传递</p>
<p>对于修改调用函数中的数据的函数：<br>如果数据对象<br>    • 是内置数据类型，则使用指针。如果看到类似func(int &amp;x)这样的代码，很明显函数会修改x的。<br>    • 是数组，则只能使用指针。不能有const<br>    • 结构，使用指针或引用<br>    • 类对象，只能使用引用</p>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>下面介绍C++的一项新内容——默认参数。默认参数是指当函数调用时，省略了实参时自动使用的一个值。</p>
<p>例如有函数func(int n)，设置n的默认值为1，则函数调用func()相当于func(1)，这极大提高了使用函数的灵活性。</p>
<h2 id="设置默认参数"><a href="#设置默认参数" class="headerlink" title="设置默认参数"></a>设置默认参数</h2><p>设置默认值，<strong>必须</strong>通过函数原型。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str, <span class="type">int</span> n = <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>例如，left函数它有两个参数，字符串str和int型整数n，它的作用是返回字符串的前n个字符。准确的说，这个函数返回一个char型指针，指针指向由原始字符串中被选中的部分组成的字符串。</p>
<p>如果调用left(“theory”,3)，则会返回指向新的字符串”the”的指针。假设第二个参数n的默认值被设定成了1，那么3会覆盖默认值。但是调用函数left(“theory”)将不会出错，它认为第二个参数是默认值1，会返回新的字符串”t”的指针。</p>
<p>如果说，这个程序经常需要抽取一个字符，偶尔需要抽取很长的字符，那么这种默认值的设置会很有帮助。</p>
<p><strong>！默认参数定义的顺序为自右到左</strong></p>
<p>对于带参数列表的函数，<strong>必须从右向左</strong>添加默认值，也就是说，为某个参数设置了默认值，则必须为它右边的所有参数都设置默认值。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m = 1, <span class="type">int</span> j)</span></span>;<span class="comment">//invalid</span></span><br></pre></td></tr></table></figure></p>
<p>实参必须按照从左至右的顺序依次赋给相应的形参，而不能跳过任何参数。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">mal</span>(int a, int b=<span class="number">3</span>, int c=<span class="number">5</span>); <span class="comment">//默认参数</span></span><br><span class="line"><span class="built_in">mal</span>(<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>); <span class="comment">//调用时有指定参数，则不使用默认参数</span></span><br><span class="line"><span class="built_in">mal</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">//调用时只指定两个参数，按从左到右顺序调用，相当于mal(3,5,5);</span></span><br><span class="line"><span class="built_in">mal</span>(<span class="number">3</span>); <span class="comment">//调用时只指定1个参数，按从左到右顺序调用,相当于mal(3,3,5);</span></span><br><span class="line"><span class="built_in">mal</span>( ); <span class="comment">//错误，因为a没有默认值</span></span><br><span class="line"><span class="built_in">mal</span>(<span class="number">3</span>, , <span class="number">9</span>) <span class="comment">//错误，应按从左到右顺序逐个调用（调用实参，即，实参必须是连续的）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mal</span><span class="params">(<span class="type">int</span> a=<span class="number">8</span>, <span class="type">int</span> b=<span class="number">3</span>, <span class="type">int</span> c=<span class="number">5</span>)</span></span>; <span class="comment">//默认参数</span></span><br><span class="line"><span class="built_in">mal</span>( ); <span class="comment">//正确，调用所有默认参数，相当于mal(8,3,5);</span></span><br></pre></td></tr></table></figure>
<p>实际上，默认函数并非编程方面的重大突破，而是提供了一种便捷的方式。在设计类的时候，通过默认函数，可以减少析构函数、方法、方法重载的数量。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>GRE 做题词汇记录</title>
    <url>/2019/10/05/GRE-practice-record/</url>
    <content><![CDATA[<h1 id="section-1-3-10"><a href="#section-1-3-10" class="headerlink" title="section 1 (3/10)"></a>section 1 (3/10)</h1><p>capricious 反复无常的；任性的<br>mercenary 贪婪的<br>intransigent 不妥协的；不让步的</p>
<p>haunted 闹鬼<br>clamorous 吵闹的 闹哄哄<br>invidious 令人反感的<br>numinous 超自然的<br>sonorous 响亮的<br>emprical 经验的 实验的</p>
<p>dearth 缺乏<br>presumption 假定</p>
<p>sterling 极好的<br>exhaustive 详细的<br>gainsay 否定</p>
<p>auction 拍卖<br>intensification 激烈<br>fickle 多变，薄情<br>wide-ranging 广泛的 大规模<br>antiquarian 古玩</p>
<p>deviate from 从……偏离<br>recoil from 畏缩<br>yield 屈服；产生 导致<br>succumb to 屈服</p>
<p>singular 非凡的 奇特 / 单数<br>archaic 古老的<br>counterfeit 伪造的</p>
<p>overstatement 夸大其词<br>epilogue 结语<br>hyperbole 夸张<br>10.<br>imminent 迫在眉睫<br>stern 严肃的<br>prescient 有先见之明的<br>prophetic 预言的<br>pessimism 悲观<br>misinterpretation 误解<br>imprecision 不准确</p>
<h1 id="section-2-6-10"><a href="#section-2-6-10" class="headerlink" title="section 2 (6/10)"></a>section 2 (6/10)</h1><p>didactic 教导的，灌输的，教化的<br>self-perpetuating 自我延续</p>
<p>discontinuity 中断</p>
<p>lopsided 不平衡的</p>
<p>routinely 常规地<br>occupant 乘客<br>unimpeded 畅通 未受阻<br>overlook 忽视</p>
<p>repertoire 曲目<br>augmented 加强<br>ameliorate 改善<br>anticipate 预料</p>
<p>literal 字面<br>honorific 表示敬意的<br>ironic 讽刺的<br>maligned 非议 诽谤<br>disputed 争议</p>
<p>disclose 透露<br>repudiate 否认<br>weigh 称重 / assess the importance</p>
<p>regurgitate 反流<br>fecundity 肥沃 = fertility</p>
<p>sanguinity<br>sanguine 乐观<br>verisimilitude 逼真<br>10.<br>conceal 隐藏<br>habitual 习惯性的<br>cordiality 亲切 真挚 和睦<br>irascibility 易怒<br>disorganize 混乱<br>conviviality 换了<br>diffidence 缺少自信<br>exasperation 激怒</p>
<h1 id="section-3-8-10"><a href="#section-3-8-10" class="headerlink" title="section 3 (8/10)"></a>section 3 (8/10)</h1><p>contemptuous 轻视的 鄙视的<br>condone 宽容<br>decry 假装<br>remedy 补救<br>boast of 自夸<br>downplay 淡化 轻描淡写</p>
<p>explicable 可解释的<br>deduce 推断</p>
<p>objectivity 客观性</p>
<p>incinerator 焚化炉<br>loath 厌恶</p>
<p>emulate 模仿<br>document 记录<br>discredit 信誉<br>aesthetics 美学价值</p>
<p>censure 批判 谴责<br>ambivalent 矛盾的<br>muddle 混乱 糊涂<br>supplanted by 被替代<br>sifted from 筛选<br>overshadow 蒙上阴影</p>
<p>neophyte 新手<br>pragmatist 实用主义<br>zealot 狂热分子</p>
<p>maze 迷宫<br>prevalent 流行的 = popular</p>
<p>mediated 调停 调解<br>10.<br>unwarranted 毫无根据的 / warrant 保证<br>illuminating 照明<br>groundless 无依据的<br>promising 有希望的</p>
<h1 id="section-4-7-10"><a href="#section-4-7-10" class="headerlink" title="section 4 (7/10)"></a>section 4 (7/10)</h1><p>detritus 碎石</p>
<p>monolithic 单片的 / 整体 完全统一 /（单片机<br>opportunistic 机会主义者 投机取巧的人<br>anomalous 不正常的<br>haphazard 偶然的<br>collective 集合的<br>assortment 混合物 of tods 一堆工具<br>enterprise 事业</p>
<p>compassionate 有同情心的<br>grandstanding 哗众取宠的<br>partisanship 偏见<br>nepotistic 裙带关系的<br>vacillation 动摇</p>
<p>toddler 初学步的孩子<br>inattentive 不注意的 / inattention<br>futile 无用的</p>
<p>irked 不高兴的 激怒的<br>flippancy 浮躁的<br>tendentious 倾向性<br>prose 散文<br>discursion 离题<br>subtlely 细微 微妙</p>
<p>stigma 污名 耻辱<br>blemish 污点 缺陷<br>inveterate 根深蒂固 = congenital （先天的</p>
<p>exigency 紧急状态</p>
<p>fractious 易怒的<br>sagacious 智慧的</p>
<p>erode 侵蚀<br>revise 修改<br>10.<br>heterogeneous 异质的<br>intriguing 有趣的<br>comprehensive 全面<br>disparate 完全不同的<br>engaging 迷人的</p>
<h1 id="section-5-6-10"><a href="#section-5-6-10" class="headerlink" title="section 5 (6/10"></a>section 5 (6/10</h1><p>enigmatic 神秘的<br>misrepresented 报道失实</p>
<p>orthodox 正统的 （非正统：heterodox，unorthodox）<br>far from 不能</p>
<p>forbore: forbear 克制 的过去式</p>
<p>exploitative 剥削的<br>mercenary 雇佣者；唯利是图的<br>antagonistic 对抗的，敌对的 antagonize 反对</p>
<p>dichotomous 对立的 二分的<br>untenable 站不住脚的<br>subversive 颠覆性<br>efficacious 有效</p>
<p>trifling 琐事</p>
<h1 id="section-6-6-10"><a href="#section-6-6-10" class="headerlink" title="section 6 (6/10"></a>section 6 (6/10</h1><p>anachronistic（过时的</p>
<p>acrimony（辛辣，尖刻；争吵<br>C. comity     礼让<br>D. conformity 动词 conform 遵守<br>E. mordancy   尖酸；刻薄；辛辣</p>
<p>extrapolate 推算<br>peculiarity 特质，特点（peculiar 特别的<br>dispense with 免除；无需<br>dispense 免除；分配分发</p>
<p>inexperience 经验不足<br>routinely 例行公事地</p>
<p>atypical 非典型的<br>insurmountable 无法克服的<br>preserve 保护<br>shy away 回避<br>elicits adversities 激发困境<br>emerge victorious 取得胜利<br>steadfastly 踏实地、不变的、坚定的（steady的副词）</p>
<p>osut = expel = 驱逐</p>
<p>Coagulation 凝固物<br>numerals 数字  Roman numerals 罗马数字<br>A. nullify     A.无效<br>B. obviate     B.消除<br>C. mitigate    C.减轻</p>
<p>quirky 古怪的<br>10.<br>undue = excessive = 过量的<br>scant = limited = 有限的<br>dwindling = 逐渐下降的</p>
<h1 id="section-7-7-10"><a href="#section-7-7-10" class="headerlink" title="section 7 (7/10"></a>section 7 (7/10</h1><p>felicitous 恰当的；善于措辞的；幸福的<br>prolific 多产的<br>abbreviated 简短的</p>
<p>corroborates 给出证明</p>
<p>meticulousness 细致慎微<br>erudition 博学。 adj. erudite<br>edify 教悔，启迪，开导</p>
<p>discreet 谨慎 = prudent<br>thoughtful 深思的，体贴的，周到的 considerate<br>tactful 机智的 老练的<br>precipitate 鲁莽的，仓促的</p>
<p>fortune n.命运，运气，幸运<br>condescending 居高临下的<br>cliché 陈词滥调<br>10.<br>opaque n.不透明物 adj. 不透明的<br>onerous 繁重的</p>
<h1 id="section-8-8-10"><a href="#section-8-8-10" class="headerlink" title="section 8 (8/10"></a>section 8 (8/10</h1><p>prescient 有先见之明的<br>circumspect 谨慎的 = prudent<br>magisterial 有权威的<br>sanguine 乐观的 = optimistic</p>
<p>rapacious 贪婪的<br>interdependent 互相依赖</p>
<p>underappreciated 未被重视；未受到充分赏识的；未得到正确评价的<br>problematic 有问题的</p>
<p>versatile 多才多艺的<br>upkeep 保养</p>
<p>debunk 揭露<br>malady 疾病<br>plague 瘟疫</p>
<p>discuss A.讨论<br>proclaim B.宣布 宣告 = announce<br>profess C.宣称 断言 = claim, declare<br>reject D.拒绝<br>disown E.无视<br>betray F.背叛</p>
<p>downright 彻头彻尾 = thoroughly</p>
<p>discern 辨别，识别 = detect<br>envisage 设想<br>10.<br>refutation 反驳 v.refute</p>
<h1 id="section-9-3-10"><a href="#section-9-3-10" class="headerlink" title="section 9 (3/10)"></a>section 9 (3/10)</h1><p>loquacious 话多的<br>irascible 易怒的 暴躁的<br>perfidious 不忠的<br>sanguine 乐观的<br>voracious 贪婪的 贪吃的 狼吞虎咽的</p>
<p>haphazard 偶然的 偶然地<br>burlesque 滑稽讽刺作品；模仿 嘲弄 取笑<br>satire 讽刺<br>pastiche 模仿<br>chronicle 编年史 记录<br>parody 拙劣模仿</p>
<p>grossly 严重地<br>esoteric 深奥的<br>derivative 导数，派生物，受……影响的</p>
<p>surreptitious 秘密的<br>clandestine 秘密的<br>vexatious 无理取闹的<br>equitable 公平的</p>
<p>churlish 粗鲁 =rude<br>cagey 小心 吝啬 谨慎</p>
<p>implausible =  难以置信的 not reasonable</p>
<p>pugnacious 好斗的 好战的<br>deliberate 深思熟虑的；故意的<br>punctilious 一丝不苟的 精密细心的<br>courteous 有礼貌<br>complacent 自满的<br>truculent 好斗，野蛮的</p>
<p>A. arduous     辛苦<br>B. precarious  危险的 = D<br>C. clandestine = E = 秘密的<br>D. perilous<br>E. covert<br>F. exhilarating 振奋人心的，使人高兴的<br>10.<br>mundane 世俗的 平凡的 普通的<br>momentary 短暂的 = evanescent<br>illusory 虚幻的<br>metaphoric 隐喻的<br>prosaic 平凡的</p>
<h1 id="section-10-7-10"><a href="#section-10-7-10" class="headerlink" title="section 10 (7/10)"></a>section 10 (7/10)</h1><p>quantifiable 可量化的</p>
<p>impenetrable 不可穿透的；不可理解的；顽固的 不接纳的<br>self-perpetuating 能使自身永久存在的</p>
<p>skullduggery 欺诈<br>indolence 懒惰<br>incivility 没礼貌的行为<br>quixotic 唐吉诃德式的；狂想家的；愚侠的</p>
<p>lethargy      无精打采，死气沉沉；昏睡<br>fervor        热情<br>conciliatory  安抚的；调和的；调停的</p>
<p>beguile：欺骗<br>beguiled：被迷惑<br>baffled：困惑 = perplexed<br>buoyed 使振作<br>insouciance 无忧无虑；漫不经心；满不在乎<br>stoicism 斯多葛学派；恬淡寡欲<br>alacrity 敏捷；轻快；乐意</p>
<p>disprove 反对</p>
<p>pedestrian adj.缺乏想象力的，无聊的 n.行人</p>
<p>vapid 无趣味的；无生气的；索然乏味的 = dull<br>banal 陈腐 老一套 platitude<br>sagacious 机智的<br>10.<br>extraneous 外来的，来自体外的；没有关联的 = irrelevant</p>
<h1 id="section-11-5-10"><a href="#section-11-5-10" class="headerlink" title="section 11  (5/10"></a>section 11  (5/10</h1><p>desertion 逃离 （desert沙漠，v.抛弃</p>
<p>exposition 博览会；阐述<br>elucidation 阐明<br>animadversion 批评 非难<br>culmination 高潮<br>divination 占卜 预测</p>
<p>discretionary 自由裁量权；任意的；自由决定的<br>replete with = fill with 充实</p>
<p>naysayer 摇头族（指那些说某事一定成不了、经常否定、拒绝或者反对一些事情的人）<br>pushover 易于征服或控制的人；容易打败的对手；容易做的事情<br>braggart 喜欢吹牛逼的壬<br>absorbing 十分有趣的；引人入胜的（absorb：吸收；接受；使全神贯注</p>
<p>anachronistically 过时地<br>stem from 源于<br>alienation 疏远</p>
<p>engender = yield 产生</p>
<p>polemically 争论性的<br>avaricious = rapacious = 贪婪<br>precarious 危险的</p>
<p>limpid = 清澈透明的<br>10.<br>heterogeneous 异质的（同质的：homogeneous<br>rudimentary 起步的 初期的 </p>
<h1 id="section-12-6-10"><a href="#section-12-6-10" class="headerlink" title="section 12 (6/10)"></a>section 12 (6/10)</h1><p>improbable 不可能的<br>extraneous 外来的<br>demonstrable 可证明的</p>
<p>perfunctory 敷衍的<br>overt 公开的</p>
<p>scientific inquiry. 科学探究<br>dealt v.处理（deal的过去式和过去分词）<br>probabilistic 概率性的；</p>
<p>interpret 解释</p>
<p>importunate 再三要求的，纠缠不休的；无理的；坚持的；令人烦恼的<br>garrulous   唠叨的 话多的 喋喋不休的<br>mercurial  易变的，情绪不稳定</p>
<p>intoxicated by 使迷人 使醉人<br>celebrated 有名望的<br>discounted 被低估；打折的<br>prevalent 流行的</p>
<p>outstripped 超过 超出</p>
<p>abound v.大量 丰富 充盈<br>coalesce 联合<br>diversify 使多样<br>stagnate 停滞、凝滞<br>10.<br>occasioned by…… 由……引起的<br>occasioned 被引起；偶然地<br>fragility 脆弱性<br>degeneracy = decadence = 堕落<br>serenity 宁静</p>
<h1 id="section-13-7-10"><a href="#section-13-7-10" class="headerlink" title="section 13 (7/10)"></a>section 13 (7/10)</h1><p>megalomaniacal 巨大的<br>charismatic 有魅力的 charisma 魅力</p>
<p>imperturbable 稳健的 = calm<br>volatile 易变的<br>duplicitous 欺骗的；双重的；搞两面派的</p>
<p>laboratory 实验室</p>
<p>intransigent 不妥协的 = uncompromising<br>feckless 无效的；软弱的；不负责任的 = irresponsible<br>taciturn 沉默寡言的</p>
<p>conundrum = riddle = 谜语 难题<br>paragon 完美的典范 模范 adj 完美的<br>stump 使为难</p>
<p>the meaning of nothingness 虚无的概念<br>philosophical 哲学的<br>tangible 有形的；可感觉的<br>palpable 明显的；可感觉的<br>nebulous 朦胧的<br>nettlesome 杂乱无章的<br>incontrovertible 无可争议的</p>
<p>aberration 异常<br>mainstay 支柱 基石</p>
<h1 id="section-14-6-10"><a href="#section-14-6-10" class="headerlink" title="section 14(6/10)"></a>section 14(6/10)</h1><p>boisterous 热闹的 noisy<br>unpretentious 谦逊的；含蓄的；不炫耀的；不铺张的 朴实无华的<br>pretentious 自命不凡；炫耀；做作的<br>idiosyncrasy 个人气质 性格</p>
<p>univocal 明确的<br>panacea 万能药</p>
<p>revisionist 历史修正主义</p>
<p>centerpiece 核心</p>
<p>prescient 有先见之明的<br>pathology 病理<br>concession 让步</p>
<p>perilous 危险的 = precarious</p>
<h1 id="section-15-5-10"><a href="#section-15-5-10" class="headerlink" title="section 15(5/10)"></a>section 15(5/10)</h1><p>intricacy 复杂（intricate的名词<br>metaphorical 隐喻的 = figurative<br>sectarian 宗派的</p>
<p>sycophancy 阿谀奉承<br>clarity 清晰度<br>obeisance 服从</p>
<p>debilitate 使人衰弱<br>preclude 排除 妨碍 阻止</p>
<p>contemplation 沉思<br>plenitude 丰富</p>
<p>wary 警惕<br>convivial 欢乐的</p>
<p>profusion 大量 丰富<br>resurgence n.复活</p>
<p>imminent 紧急的</p>
<h1 id="section-16-1-10-median"><a href="#section-16-1-10-median" class="headerlink" title="section 16 (1/10) median"></a>section 16 (1/10) median</h1><p>specious 似是而非的 superficially plausible, but actually wrong.<br>pervasive 无处不在的</p>
<p>utilitarian 实用主义的 功利主义的<br>perfunctory 敷衍的<br>egregious 惊人 过分 恶名昭彰的<br>empirical 基于实验经验的<br>inductive 归纳的</p>
<p>scathing 严厉、刻薄、挖苦的<br>confessional 认罪的 悔罪的<br>evenhanded 不偏不倚 公正的<br>spirited 热情洋溢的 enthusiasm</p>
<p>testimony 见证 证词 证明</p>
<p>aspirant 有抱负的 有上进心的<br>relish 津津有味 v. enjoy greatly<br>moneyed 富裕的 affluent<br>evoke 激起 唤起</p>
<p>well-worked 做得好的<br>well-studied 精心研究的</p>
<p>ubiquity 无处不在<br>omnipresence 无处不在</p>
<p>replete 充满 充实 = fill<br>encomiums 歌功颂德的文字<br>indict 起诉<br>rehabilitate 康复<br>exalt 赞扬<br>valorize 赞扬<br>excoriate 苛责</p>
<p>disdain 蔑视<br>trickster 骗子<br>10.<br>ploy 策略<br>quandary 困惑<br>betray nothing = 不能展示任何关于人的感受或想法的东西</p>
<h1 id="section-17-2-10"><a href="#section-17-2-10" class="headerlink" title="section 17(2/10)"></a>section 17(2/10)</h1><p>sycophantic 阿谀奉承的<br>pedantic 迂腐的；学究式的；卖弄学问的；假装学者的</p>
<p>wherewithal 必要的资金（或手段<br>panache 华丽的派头</p>
<p>signal v.示意</p>
<p>speculative 推测的（基于猜想而不是知识）；投机的（investment  involving a high risk of loss.</p>
<p>recapitulation 概括，重述要点；<br>accretion 加，积聚 积淀物 增生<br>wholesale 批发</p>
<p>elusive 模糊不清的 难以捉摸的<br>marketable 适合销售的<br>elitist 精英主义的<br>scrutiny 审查<br>censure 谴责</p>
<p>A. spike     刺；增长<br>B. upsurge   增长<br>C. harbinger 预示<br>D. portent   预示<br>E. lull     使平静<br>F. respite  缓解；暂缓</p>
<p>amalgam 合并</p>
<p>collegiality 合力（colleague<br>exactitude 正确 精确 严格（exact<br>meticulousness 细小谨慎（meticulous<br>eminence 卓越（eminent<br>tenacity 韧性<br>10.<br>B. long-winded      冗长 啰嗦<br>C. exhaustive       全面<br>D. rambling         闲聊的 漫步的<br>E. overbearing      专横的，傲慢的；压倒一切的<br>F. undiscriminating 无鉴别力的；不加区别的</p>
<h1 id="section-51-6-10-easy"><a href="#section-51-6-10-easy" class="headerlink" title="section 51 (6/10) easy"></a>section 51 (6/10) easy</h1><p>sycophantic 阿谀奉承的<br>prosaic 平淡的<br>disparate 不同的<br>incorporate 包括<br>energize = energy的动词 赋予力量<br>delineate 描绘<br>recast 撤回重做<br>balk 犹豫；不接受<br>revel 享乐<br>expedited 加速<br>endemic 地方性的</p>
<h1 id="section-52-6-10"><a href="#section-52-6-10" class="headerlink" title="section 52 (6/10)"></a>section 52 (6/10)</h1><p>profess 宣称<br>cachet 声望 名望<br>certitude 确信的名词<br>humility 谦逊的名词<br>predilection 偏爱<br>propitiate 安抚<br>occlude 遮挡 掩盖<br>presage 预言<br>unassuming 谦逊<br>gullible 易听信的 = credulous<br>antithesis = 反对<br>bountiful 丰富的（bounty 赏金<br>atypical 非典型的<br>aversion 讨厌 厌恶<br>inert 惰性 不动的</p>
<h1 id="section-53-7-10"><a href="#section-53-7-10" class="headerlink" title="section 53(7/10)"></a>section 53(7/10)</h1><p>diffident 因为不自信而心虚的<br>一丝不苟 小心翼翼 谨小慎微<br>punctilious meticulous<br>sagacious 明智的<br>alarmist 危言耸听 someone who is considered to be exaggerating a danger and so causing needless worry or panic.<br>circumspect 小心谨慎的<br>peripatetic 四处游历的人<br>itinerant 巡回的<br>idiosyncratic 特殊的 特异的<br>ungainly 笨拙地<br>eloquent 意味深长的；雄辩的，有口才的；有说服力的；动人的<br>austere 严峻的；简朴的；苦行的；无装饰的<br>project 预测；投射；计划；表达</p>
<h1 id="section-54-6-10"><a href="#section-54-6-10" class="headerlink" title="section 54(6/10)"></a>section 54(6/10)</h1><p>omniscient 全知的 无所不知的<br>abject 卑鄙的<br>adverse 不利的；相反的<br>in reality 要理解成一个 取反<br>oversee 监督 负责<br>render 渲染；给予 give 呈现 交纳<br>preclude 排除<br>devolve 下放权力 transfer or delegate (power) to a lower level<br>forgo 放弃<br>magnitude 大小；量级；[地震] 震级；重要；<br>suppleness 灵活度 supple  柔软的；灵活的；顺从的；易弯曲<br>enormity 巨大。（adj enormous</p>
<h1 id="section-55-5-10"><a href="#section-55-5-10" class="headerlink" title="section 55 (5/10)"></a>section 55 (5/10)</h1><p>corollary 推论<br>abstemious 节制的<br>devote 奉献（这我都忘了？devote oneself doing sth<br>chagrin （因为失败而）失望 烦恼<br>complacency 自满<br>exacerbate 加剧<br>resolve 解决 分析 毅力 意志<br>address：被解决<br>conflate 合并<br>impugn 抨击 指责 非难<br>countenance 支持<br>ebullience 奔放；兴高采烈；沸腾；冒泡<br>reticence  沉默寡言<br>introspection 内省；反省<br>analogous 相似的<br>sketchy 写生的 概略的<br>rudimentary 初步的 起初的<br>vitiate 损害<br>unwavering 坚定不移的<br>clog 堵塞</p>
<h1 id="section-56-6-10"><a href="#section-56-6-10" class="headerlink" title="section 56 (6/10)"></a>section 56 (6/10)</h1><p>succinct 简洁的<br>imperturbable 冷静的<br>prolixity 啰嗦的<br>rigor 严格 rigorous  严格的<br>revile 批评<br>adulate 拍马屁<br>materialize 实现 come into being<br>manifest: adj = self-evident 明显的明白的 v. 表现<br>deference n.顺从 尊重</p>
<h1 id="section-57-8-10"><a href="#section-57-8-10" class="headerlink" title="section 57 (8/10)"></a>section 57 (8/10)</h1><p>mercurial 多变的<br>exiguous 很小的<br>notwithstanding = 尽管<br>demise 衰亡 减少<br>innocuous 无害的<br>stark 完全的 complete，僵硬的 rigid<br>veil 掩盖<br>fervent 热切的<br>sabotage 破坏<br>intractability 难处理 intractable 棘手的<br>facile （言语或理论）轻率的，未经深思熟虑的<br>ethereal 优雅的；轻飘的；缥缈的；超凡的<br>tortuous 拐弯抹角的；冗长费解的；弯弯曲曲的，曲折的<br>convoluted 复杂的<br>protracted 拖延的<br>consilience 一致性<br>phenomena 现象（phenomenon 的复数 ）<br>reducible 可还原的；可缩小的；[数] 可约的，可化简的；<br>imperialist  帝国主义者 帝国主义的（雄心勃勃的<br>forebear 祖先<br>narcissistic 自恋的<br>impetuous 急躁<br>hubristic 暴躁</p>
<h1 id="section-58-5-10"><a href="#section-58-5-10" class="headerlink" title="section 58(5/10)"></a>section 58(5/10)</h1><p>civic 公民的<br>choleric 易怒的<br>officious 过分殷勤的 多管闲事的<br>irenic 和平的 和平主义的<br>prudent 谨慎 慎重 保守 持重的</p>
<p>abstruse 深奥的 玄妙的<br>cursory 匆忙的，不注意细节的</p>
<p>ignoble 卑贱的，卑鄙的；无知的<br>seminal  创新的，开创性的<br>sporadic  断断续续的；零星的 零落 </p>
<p>contentious 有争议的<br>illustrious 杰出的<br>fraught 会导致……结果 / 充满 / 忧虑<br>sordid 肮脏的；卑鄙的；利欲熏心的；色彩暗淡的</p>
<p>implausible 难以置信 / plausible 可信的<br>spiteful 恶意的 坏心肠的</p>
<h1 id="section-59-7-10"><a href="#section-59-7-10" class="headerlink" title="section 59 (7/10)"></a>section 59 (7/10)</h1><p>mollify    vt.平息，抚慰，缓和<br>emulsify  使…乳化<br>denigrate    vt. 诋毁，污蔑<br>petrify    v.使僵化，使失去活力<br>disabuse 使省悟；解迷惑；释疑；矫正 打消错误念头，纠正，劝阻</p>
<p>forbearance    自控;克制,宽容。 “n.克制；忍耐 v. bear 忍受，承担”<br>exuberant    adj.非常高兴的，热情洋溢的 n.exuberance<br>obduracy obdurate 固执的 冷酷无情的”<br>exacerbate vt.使加剧,使恶化<br>delineate 勾画 delineated 规划的<br>tempered. 使……温和； （temper 的过去式和过去分词）  脾气……的，性情……的；有气质的；温和的，不暴力的<br>choatic 混乱的 choas的形容词<br>aggression 侵略，侵犯，攻击。aggressive的形容词<br>grandeur 宏伟（grand</p>
<p>erroneousness 错误的 error的形容词<br>plethora    n.过量，过剩<br>surfeit     v./n. （使）过量，（使）饮食过度</p>
<p>avaricious 贪婪的</p>
<h1 id="section-60-7-10"><a href="#section-60-7-10" class="headerlink" title="section 60  (7/10)"></a>section 60  (7/10)</h1><p>gregarious 爱社交 群居的<br>grandiose 自命不凡 浮夸的<br>self-effacing 谦逊的（efface 消去 抹去）<br>imperious    adj. 傲慢的，专横的</p>
<p>counterparts 副本（copies）；对方（opposite side）</p>
<p>interminable = endless 无限的<br>rebuff 拒绝<br>recount 重述<br>hazard of ……的风险（hazard 冒险 风险</p>
<p>contract 感染<br>neutralize    vt.使无效；中和</p>
<p>perilous 危险的（三次不懂<br>improbable 不可能的（第二次不懂</p>
<h1 id="section-61-6-10"><a href="#section-61-6-10" class="headerlink" title="section 61 (6/10)"></a>section 61 (6/10)</h1><p>languish    vi. 变得衰弱<br>dubious 可疑的</p>
<p>tentative 试验性的，假定的<br>irreparably 不可挽回<br>entail 意味着</p>
<p>onset 发作（疾病开始）<br>intake 摄入<br>expenditure 支出<br>manifest: adj = self-evident 明显的明白的 v. 表现<br>precocious 早熟的 n. precociousness<br>nefarious 穷凶极恶的<br>naïve 天真 （n.naïveté<br>ingenuousness 率直；正直</p>
<h1 id="section-62-8-10"><a href="#section-62-8-10" class="headerlink" title="section 62 (8/10)"></a>section 62 (8/10)</h1><p>approbation 赞许<br>gaffe 错误<br>obloquy 批评<br>jeremiad 批评<br>dispute 争吵<br>self-aggrandizing 自我强化<br>virtuosity 技巧 技艺<br>deemphasized 轻描淡写<br>estranged 疏远的<br>placebo 安慰剂<br>paucity 不足<br>brevity 简洁<br>triteness （trite）陈腐<br>infuriate    vt. 激怒</p>
<h1 id="section-63-5-10-median"><a href="#section-63-5-10-median" class="headerlink" title="section 63 (5/10) median"></a>section 63 (5/10) median</h1><p>stalwart    adj. 坚定的<br>solicitous    adj.为他人操心的；热心的；挂念的<br>pretentious 自命不凡 自大的</p>
<p>unqualified 不受限制的<br>venal 贪污的<br>cliché 陈词滥调 = platitude<br>euphemism 委婉语<br>multifaceted 多面的<br>suspicious 可疑的<br>obliterated 消灭<br>emendation 修改</p>
<p>circumscribe 限制 restrict (something) within limits.<br>protean    adj.多才多艺的，善变的；相当于volatile</p>
<p>A. dearth<br>B. glut<br>C. deficiency<br>D. surfeit<br>E. abundance<br>F. profusion</p>
<p>AC不足<br>BD过量<br>EF大量</p>
<p>with no bearing on 与……没有关系<br>harking back to 追溯到</p>
<p>prototype = paradigm = 模范 标准<br>vestige = relic = 遗迹<br>pretense 虚伪 借口。</p>
<h1 id="section-64-3-10"><a href="#section-64-3-10" class="headerlink" title="section 64 (3/10)"></a>section 64 (3/10)</h1><p>rhetoric 修辞的<br>apoplectic 世界末日的；预言的</p>
<p>hortatory 劝诫的，劝告的<br>communal 公共的<br>vaccinated against smallpox.  接种天花疫苗</p>
<p>ostensibly 表面上 ostensible 表面上的<br>high-minded 高尚的<br>escapist 逃避现实者<br>lurid     adj.恐怖的，令人反感的</p>
<p>largesse n.慷慨<br>disquieting 令人不安的<br>laudable 值得夸赞的<br>inexpressible 无法表达 </p>
<p>modest 谦逊 = humble / modesty humility<br>“诚实”是 honest</p>
<p>poised 保持平衡<br>wan 衰落<br>ebb 衰落（落潮<br>vindication 证明无罪</p>
<p>galvanize = excite 刺激；提起兴趣（电镀</p>
<p>pledged 承诺<br>evoke 唤起，激起，诱发<br>deified 神化（感情色彩很重的词<br>venerated = honored 推崇</p>
<h1 id="section-65-7-10"><a href="#section-65-7-10" class="headerlink" title="section 65 (7/10)"></a>section 65 (7/10)</h1><p>crass 愚钝的<br>crassness = vulgarity<br>flagrant 公然的；不能容忍的；非常的；臭名远扬的；明目张胆的；恶名昭著的（名词flagrancy<br>ingenuity 独创性<br>ingenuous 天生的<br>disingenuous 不诚实 不真诚的<br>adroit 熟练的 迅速的 巧妙的 / maladroit 笨拙的</p>
<p>renounce 放弃<br>denounce 批评<br>compartmentalize 划分（compartment 隔间<br>scaremongers 危言耸听者 = alarmist</p>
<p>suffice to 足够<br>invalidate 是无效<br>vitiate 损害<br>vindicate 证明 辩护</p>
<p>vacillation 犹豫不决 vacillate 犹豫 = hesitate<br>belligerence = pugnacity = 好战 好斗</p>
<p>laconic 简洁的；话少<br>taciturn 沉默寡言的<br>ascetic 禁欲 苦行<br>tempestuous 暴风雨般的 tempest 暴风雨</p>
<p>distressing 苦恼<br>sagacious 有智慧的 n.sage 智者</p>
<h1 id="section-66-7-10"><a href="#section-66-7-10" class="headerlink" title="section 66 (7/10)"></a>section 66 (7/10)</h1><p>negate 否认<br>quibble 狡辩<br>pedant 学究</p>
<p>rival 竞争对手<br>savior = save 的人称代词，救星<br>rallied(rally的过去式) 团结<br>be indebted to 感激（indebt 负债<br>self-styled 自封的 自称的</p>
<p>precocity 早熟的名词（precocious 形容词）</p>
<p>ritualized 礼仪化<br>structural / structured 程序化<br>acquired 获得的 后天获得的<br>communal 公用的 公共的 社区的</p>
<p>exceptional <strong>例外的</strong>；非凡的，优秀的</p>
<p>hail = acclaim = 称赞</p>
<p>wayward 难以控制的<br>errant 不定的；误入歧途的<br>incisive 尖锐，鞭辟入里的</p>
<p>fabricated 捏造的</p>
<h1 id="section-67-4-10"><a href="#section-67-4-10" class="headerlink" title="section 67(4/10)"></a>section 67(4/10)</h1><p>jejune 无聊的 肤浅的<br>indiscreet 轻率的<br>finicky 过分挑剔的</p>
<p>in eclipse 衰弱<br>unsurpassed 不可超越的</p>
<p>demur 反对</p>
<p>trenchant = incisive 鞭辟入里<br>derision 嘲笑 = ridicule</p>
<h1 id="section-68-7-10"><a href="#section-68-7-10" class="headerlink" title="section 68 (7/10)"></a>section 68 (7/10)</h1><p>impertinence n.无礼 / adj.impertinent 不恰当的；无礼的；粗鲁的；不相干的<br>precedent adj.在前的 n.先例</p>
<p>precautious 谨慎的<br>vengeful 复仇的<br>reflective 反射的；沉思的</p>
<p>address v. 写（收信人）姓名地址；<strong>演说</strong>；向……说话，致词；冠以（某种称呼）；<strong>设法解决</strong>；就位击（球）；<strong>提出</strong><br>n. 地址；所在地；<strong>演讲</strong>；称呼；致辞；谈吐；<strong>技巧</strong></p>
<p>remedy vs restore<br>治疗 挽救 补救 / 恢复<br>set right / bring back</p>
<p>pack n.包装；<strong>一群</strong>；背包；包裹；vt.包装；压紧；捆扎；塞满<br>snappish 暴躁的<br>umbrage    n.不悦，生气 populist 民粹主义（populist umbrage 民粹主义的愤怒）</p>
<p>tether v.系绳 / untethered 不受束缚的<br>constricted 压缩的<br>conventions of gentility 礼仪的传统<br>gentility 有教养，文雅；上流阶层</p>
<p>abstracted from 与……分离 = divorce from<br>attune 调和</p>
<p>cordiality n.真挚 热诚 和睦 / cordial 亲切的 热诚的 真心的 合意的<br>conviviality n. 欢乐 / convivial 欢乐的</p>
<p>inversion 倒置</p>
<h1 id="section-69-5-10"><a href="#section-69-5-10" class="headerlink" title="section 69 (5/10)"></a>section 69 (5/10)</h1><p>hackneyed 陈腐的<br>uncanny    adj. 离奇的，奇异的，怪诞的，不可思议，神必</p>
<p>exacerbate vt.使加剧,使恶化<br>transgress    vt. 违背，犯错</p>
<p>quantification 量化 / quantifiable 可量化</p>
<p>premise 前提</p>
<p>eclipse 除了日食/遮蔽之外，还有“超越 胜过”的意思 = outdo，dominant<br>parsimonious    n.过度节俭的，吝啬的 = stingy</p>
<h1 id="section-70-5-10"><a href="#section-70-5-10" class="headerlink" title="section 70 (5/10)"></a>section 70 (5/10)</h1><p>dour 严厉的 严格的<br>astringent 尖刻的，严格的<br>felicitous 适当的 / infelicitous 不适当的<br>hyperbolic 夸张的（hyperbole n.夸大的言辞</p>
<p>singular 非凡的 奇特 / 单数<br>sketchy 梗概的，粗略的<br>unkempt    adj. 凌乱的，无序的<br>competent 胜任的<br>loquacious 话多的<br>reticent taciturn 沉默寡言的</p>
<p>divulge 泄露<br>fluster 慌乱<br>inattentive 不专心<br>affliction 痛苦<br>gloat 幸灾乐祸</p>
<p>hindsight 后见之明 事后诸葛</p>
<p>flummoxed 困惑的，<br>confounded 困惑的。</p>
<p>tantamount to 等同于 </p>
<h1 id="section-71-4-10"><a href="#section-71-4-10" class="headerlink" title="section 71 (4/10)"></a>section 71 (4/10)</h1><p>surreptitious    adj. 偷偷摸摸的，保密的 / 为什么我记错了单词（记成不好的）的意思还能作对呢？<br>obtrusive    adj.扎眼的，显眼的，突兀的</p>
<p>demarcation 分界线<br>episodes 情节 插曲</p>
<p>valedictory 告别的 valediction = farewell<br>ungracious 不礼貌的<br>whimsical    adj. 反复无常的</p>
<p>obviate 消除 remove</p>
<p>imposition 强加 / impose 的名词<br>undue 过分 过度的 / subdue 征服<br>infringement 侵权<br>comportment 体格 / behavior; bearing.<br>estrangement from 疏远<br>proximity 接近<br>avidity 热望 / avid 狂热的<br>resignation 辞职</p>
<p>covetous 贪婪的<br>covet v.垂涎 羡慕<br>coveted 令人羡慕的，梦寐以求的</p>
<p>spurious 虚假的（spur 刺激<br>implausible 难以置信 / not reasonable</p>
<p>tonic / restorative / salubrious / salutary / wholesome 有益健康的</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo 博客建站记录贴</title>
    <url>/2018/05/21/Hexo-Maintainance/</url>
    <content><![CDATA[<h1 id="在新的电脑上部署-Hexo，并保留原有博客的方法"><a href="#在新的电脑上部署-Hexo，并保留原有博客的方法" class="headerlink" title="在新的电脑上部署 Hexo，并保留原有博客的方法"></a>在新的电脑上部署 Hexo，并保留原有博客的方法</h1><ol>
<li>U盘拷贝整个blog文件夹。</li>
<li>在新的电脑上装好git并配置好用户名和密钥。</li>
<li>安装 node.js</li>
<li>安装 hexo：<code>npm install hexo-cli -g</code></li>
<li>用U盘把blog文件夹拷贝到新的电脑上。在新电脑上，在blog文件夹中打开终端，输入：<code>npm install</code>。注意，在创建一个新的博客的时候到这一步是<code>hexo init</code>，而由于我们已经要继承之前的设置和博文，所以这一步不能输入<code>hexo init</code>。</li>
<li>至此，完成移植。使用<code>hexo new</code>、<code>hexo d -g</code> 等指令测试是否成功吧。</li>
</ol>
<h1 id="Empty-HTML-hexo-issue"><a href="#Empty-HTML-hexo-issue" class="headerlink" title="Empty HTML hexo issue"></a>Empty HTML hexo issue</h1><blockquote>
<p>降级 node 到 13 或者 12 。或者升级 hexo 到 4.2.1 及以上。</p>
</blockquote>
<p><a href="https://alanlee.fun/2021/02/28/hexo-empty-html/">https://alanlee.fun/2021/02/28/hexo-empty-html/</a></p>
<h1 id="为页面增加阅读次数"><a href="#为页面增加阅读次数" class="headerlink" title="为页面增加阅读次数"></a>为页面增加阅读次数</h1><p><a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E4%B8%8D%E8%92%9C%E5%AD%90-%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0/">https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E4%B8%8D%E8%92%9C%E5%AD%90-%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0/</a></p>
<h1 id="为页面添加密码阅读"><a href="#为页面添加密码阅读" class="headerlink" title="为页面添加密码阅读"></a>为页面添加密码阅读</h1><p><a href="https://github.com/D0n9X1n/hexo-blog-encrypt">https://github.com/D0n9X1n/hexo-blog-encrypt</a></p>
<h1 id="新增新的-subdirectory-菜单"><a href="#新增新的-subdirectory-菜单" class="headerlink" title="新增新的 subdirectory 菜单"></a>新增新的 subdirectory 菜单</h1><p><a href="https://theme-next.iissnan.com/getting-started.html#menu-settings">https://theme-next.iissnan.com/getting-started.html#menu-settings</a></p>
<h1 id="翻页按钮显示不正常"><a href="#翻页按钮显示不正常" class="headerlink" title="翻页按钮显示不正常"></a>翻页按钮显示不正常</h1><p>翻页按钮不正常显示，显示为<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>的HTML编码</p>
<p><a href="https://www.cnblogs.com/xiejava/p/12456273.html">https://www.cnblogs.com/xiejava/p/12456273.html</a></p>
<h1 id="为博客添加搜索功能"><a href="#为博客添加搜索功能" class="headerlink" title="为博客添加搜索功能"></a>为博客添加搜索功能</h1><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</a></p>
<p><a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a></p>
<h1 id="Upgarde-Hexo-Next"><a href="#Upgarde-Hexo-Next" class="headerlink" title="Upgarde Hexo / Next"></a>Upgarde Hexo / Next</h1><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ hexo --version</span><br><span class="line"><span class="symbol">hexo:</span> <span class="number">3.3</span><span class="number">.7</span></span><br><span class="line">hexo-<span class="keyword">cli</span>: <span class="number">4.3</span><span class="number">.0</span></span><br><span class="line"><span class="symbol">os:</span> win32 <span class="number">10.0</span><span class="number">.22621</span></span><br><span class="line"><span class="symbol">node:</span> <span class="number">12.16</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h2 id="Next-compatibility-with-Hexo-version"><a href="#Next-compatibility-with-Hexo-version" class="headerlink" title="Next compatibility with Hexo version:"></a>Next compatibility with Hexo version:</h2><p><a href="https://theme-next.js.org/docs/getting-started/upgrade">https://theme-next.js.org/docs/getting-started/upgrade</a></p>
<p>It’s recommended to upgrade NexT to <strong>version 8</strong> to get the latest features and supports in the new Theme-Next repository. Which means it needs to upgrade hexo to 5.0 or later version first. </p>
<p>Run <code>npm i hexo@5.4.2</code>,</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ hexo --version</span><br><span class="line"><span class="symbol">hexo:</span> <span class="number">5.4</span><span class="number">.2</span></span><br><span class="line">hexo-<span class="keyword">cli</span>: <span class="number">4.3</span><span class="number">.0</span></span><br><span class="line"><span class="symbol">os:</span> win32 <span class="number">10.0</span><span class="number">.22621</span></span><br><span class="line"><span class="symbol">node:</span> <span class="number">12.16</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>升级过后测试 hexo -s 遇到一种乱码问题，通过下面方式解决：<br><a href="https://blog.csdn.net/qq_39898645/article/details/109181736">https://blog.csdn.net/qq_39898645/article/details/109181736</a></p>
<h2 id="Upgrade-Next-not-try"><a href="#Upgrade-Next-not-try" class="headerlink" title="Upgrade Next (not try)"></a>Upgrade Next (not try)</h2><p>check next version: go to next _config.yml in the theme next folder, go to the last line, see the version is 5.1.1</p>
<p>Follow this doc to upgrade:<br><a href="https://theme-next.js.org/docs/getting-started/upgrade#Upgrade-from-Legacy-Version">https://theme-next.js.org/docs/getting-started/upgrade#Upgrade-from-Legacy-Version</a></p>
<p><code>npm install hexo-theme-next@8.14.2</code></p>
<ol>
<li>rename old next folder -&gt; next-old, so that you can switch back to old version anytime.</li>
<li>back up two folder /themes/next, /source/_data</li>
<li>$ npm install hexo-theme-next@8.14.2</li>
</ol>
<p>todo: <a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/INSTALLATION.md">https://github.com/theme-next/hexo-theme-next/blob/master/docs/INSTALLATION.md</a></p>
<p><a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html">https://www.imczw.com/post/tech/hexo5-next8-updated.html</a></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>如何在本科生阶段做科研 How to make outstanding research in undergraduate</title>
    <url>/2018/04/04/How-to-make-outstanding-research-in-undergraduate/</url>
    <content><![CDATA[<h1 id="找科研"><a href="#找科研" class="headerlink" title="找科研"></a>找科研</h1><p>1 勇于迈出第一步（联系老师、找项目</p>
<p>2、勇于表达自己的需求（为了什么</p>
<p>3、方向变化是很正常的，要勇于面对，不要回避。</p>
<p>最有效的克服困难的方法是与人沟通。主动出击，科研就没什么难的</p>
<p>研究方向自己不满意；核心部分收获少；资源受制；希望做出现实成果而比较理论，或与现实比较脱节；过于现实，开发一个软件，不利于长久发展；实验室环境：人过多，老师忙；项目太难出成果；多人合作，自己承担的工作过少；</p>
<p>怎么转变方向：主动和项目里的人交流；和师兄交流；和老师交流要得体，不能一言不发就跑，或者甩狠话。。</p>
<p>负责的态度，做好科研是对自己 对老师都负责。</p>
<h1 id="情商"><a href="#情商" class="headerlink" title="情商"></a>情商</h1><p>非常重要。。。</p>
<p>小到做一个实验，得到一个数据，大到申请出国，引荐。。</p>
<p>导师不是科研机器。而是要处好关系</p>
<p>好的第一份科研：体验整个流程，采集数据、建立模型、论文写作……</p>
<p>并不是有独立课题才最好，没paper也可以申请得不错</p>
<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p>成功与否很大情况决定于规划，因为本科时期科研能力有限，有限的大牛才能做出很棒的原创性成果。</p>
<p>1、 在平时 一周两天左右的时间，忙的时候一周四五天</p>
<p>2、和老师沟通，是主要低位？还是放在次要低位？</p>
<p>3、期望成果？什么样的论文？专利？关注 paper 的 deadline</p>
<p>4、工作的有效执行？怎么执行计划？提出构想，和老师深入交流，因为自己想的计划可能并不好执行</p>
<p>5、非常好的方法，每天写一写小结，每周回顾自己的一周工作。</p>
<h1 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h1><p>不是表面功夫，而是要自信，展现自己工作的价值</p>
<p>对老师展示（当面沟通、组会、weekly report，谈进展，谈收获，谈想法展望）</p>
<p>对外展示，论文写作，做好平时阶段性的积累，有利于写论文。积极吸取导师和师兄的经验，只靠自己去写应该说是很困难的，要主动咨询。非常适合使用在线协作文档编辑工具。Google docs</p>
<h1 id="else"><a href="#else" class="headerlink" title="else"></a>else</h1><p>复现别人的成果，也是学习的一环。</p>
<p>科研主要是想法，钻研问题，想出创新性的思想。思想比那些知识、公式重要。</p>
<p>读paper 如何进入一个领域？学一学 introduction的论文，然后深入科研来了解。</p>
<p>找第一份科研，觉得自己拖后腿？ 不要有心理压力，老师也不会对你要求过高，以自己的收获为主，体验整个流程是最好的。例如，询问师兄整个流程需要什么样的知识；帮助完成一个工作等等。。这样，下一次就可以独立完成一个工作了。</p>
<p>如果说找到了自己的兴趣，忙也是一种乐趣吧。</p>
<p>科研门槛不是只向尖子生开放，本科生需要的是你的主动和投入。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>休谟的经验主义怀疑论 Hume&#39;s Empirical Skepticism</title>
    <url>/2020/10/19/Hume-Skepticism-and-Empricism/</url>
    <content><![CDATA[<p>本文是对大卫·休谟的一部分哲学观点的学习过程的自我总结。</p>
<p><img src="/2020/10/19/Hume-Skepticism-and-Empricism/hume.jpg" alt="hume"></p>
<p>大卫·休谟 (David Hume, 1711-1776) 是一位苏格兰哲学家，18 世纪的经验主义者，怀疑主义者。他被后世的学者认为是西方哲学史中最重要的人物之一。在许多人看来，他是公认的哲学史上最杰出的天才之一，在写出他的代表作《人性论》(<em>A Treatise of Human Nature</em>) 时他年仅 26 岁。这本书后来成为了英语世界的一本伟大哲学著作，本书也被大多数现代的学者视为休谟最重要的著作、哲学历史上最重要的著作之一。休谟的哲学对当时的时代和对后世都产生了相当巨大的影响：休谟与当时的其他启蒙思想家建立了联系，卢梭、亚当·斯密是他的朋友；休谟的怀疑论被法国的启蒙思想家拿来作为批判宗教、追求自由平等博爱的理论武器；康德读到休谟对怀疑论的辩护时说：“自从有形而上学以来，对于这一学科的命运来说，它所遭受的没有什么能比休谟所给予的打击更为致命”、<strong>“休谟把我从独断论的迷梦中唤醒”(I freely admit that the remembrance of David Hume was the very thing that many years ago first interrupted my dogmatic slumber)</strong>；爱因斯坦也曾写道，在研究狭义相对论时，他受到了休谟哲学的启发。</p>
<h1 id="Backgrounds"><a href="#Backgrounds" class="headerlink" title="Backgrounds"></a>Backgrounds</h1><p>下面要介绍的内容是关于<strong>知识论</strong> (Epistemology) 的。有必要先进行相关名词解释。知识论是哲学的一个研究分支（哲学其他的主要研究分支包括 形上学 metaphysics, 伦理学 ethics, 美学 aesthetics）。我们对世界有很多发现和看法，其中相当一部分凝结成为了<strong>知识</strong> (knowledge)。尽管知识是我们日常生活中再熟悉不过的一个概念，但是准确地定义“什么是知识”仍然是令哲学家着迷的话题。<strong>知识论，即关于知识的理论，是研究这样的问题的哲学：使信念成为真的东西是什么？什么使知识成为可能？如果信念为真，我们怎样才能知道？</strong> (What is the condition of knowledge? What makes knowledge possible and how do we know it?)</p>
<p>关于确定某条陈述是哪种类型的真理，以及我们是怎样知道这一点的问题，引发了哲学中两个流派的分裂。</p>
<p><strong>理性主义</strong>或<strong>唯理论</strong> (Rationalism) 认为人的<strong>理性可以作为知识的来源</strong>。理性 (Reason) 是指人能够运用理智进行抽象的思考、形成逻辑论证、进行推理来导出结论的能力。理性主义是指一种认定真理不依赖感官而依赖于理智和演绎推理的方法论或理论。古代和中世纪绝大多数的哲学家都是唯理论者，例如柏拉图、亚里士多德、阿奎那。近代伟大的理性主义哲学家包括笛卡尔、斯宾诺莎、莱布尼茨、黑格尔。典型的理性主义者认为，人类首先本能地掌握一些基本原则，如几何法则，随后可以依据这些推理出其余知识。此外，他们还认为人的理性可以对最基本的哲学问题提出解答，而且这些解答可以是必然真理。这也被称作唯理论。</p>
<p>而<strong>经验主义</strong> (Empiricism) 说的是这样一种不同的哲学观念——用约翰·洛克的话说——人刚出生时，心灵是一块“<strong>白板</strong>” (blank slate)，人生下来就如白纸一般，没有内在或与生俱来的心智，是后来的<strong>经验</strong> (Experience) 在它上面写下了我们对知识的理解和细节。<strong>经验主义是一种认为知识只能或应基本来源自感官 (Sense) 经验的理论</strong>。所有的知识都是逐渐从他们的感官和经验而来，所有的知识来源于经验。伟大的经验论者包括约翰·洛克、大卫·休谟、约翰·密尔和伯兰特·罗素等。</p>
<p>理性主义和经验主义也不是绝对和一分为二的，有时两者之间的区分并不像看上去的那么显著（不是说理性主义者就完全不相信经验的作用，经验主义者完全不相信理性的作用），区别只是在于两者重要性的不同。在唯理论者看来，经验能给我们提供思维材料或者解决问题的契机，也认同经验科学的重要性，但是他们认为真理是不随着经验的变化而变化的，单凭经验是教不会人们什么东西的，更重要的是理性。经验主义者们当然也相信理性，但是他们认为这仅限于纯粹的逻辑活动（例如数学推导和逻辑计算），且经验主义者们不相信理性能够对基本的哲学问题给出可靠的回答。唯理主义者并不会去排斥感觉和主观上的证据，他们只是认为经验并不能给予哲学以真理。经验主义者也会同意，像“如果所有的 P 是 Q，且 S 是 P，那么 S 是 Q”（演绎法的三段论的形式表示）这样的陈述因为理性的缘故而成为了必然的真理。<strong>他们的意见真正发生分歧的地方是：哲学的基本问题能否被回答，应该怎样被回答？</strong></p>
<h1 id="问题的引子：怀疑论的一个假设"><a href="#问题的引子：怀疑论的一个假设" class="headerlink" title="问题的引子：怀疑论的一个假设"></a>问题的引子：怀疑论的一个假设</h1><p>假如我跟你说，你现在在做梦，而不是真实地醒着。你要怎么跟我证明自己现在不是在做梦？你怎么跟我证明，你不处于“楚门的世界”？</p>
<p>长期以来，这是一个哲学家经常使用的问题，来论证其知识论的严密性。对于这个问题，哲学家不得不给出证明，澄清知识是什么、实在是什么，以及我们如何才能真正地知道某样东西。</p>
<p>在这里非常有必要去了解一下柏拉图的“<strong>洞穴隐喻</strong>” (Myth of cave)和笛卡尔的“<strong>我思故我在</strong>” (I think, therefore I am)。了解洞穴隐喻和笛卡尔的故事的一个非常好的视频材料是<a href="https://www.bilibili.com/video/BV1fx411b7Hp?p=5">Crash Course Philosophy(p5和p6)</a>。在本篇笔记中不打算赘述这两个故事，而只是简单地引入的是这两个哲学故事中共同蕴含的一个假设，并由这个假设引出了经验主义者的讨论。</p>
<p>如果你熟悉洞穴隐喻和笛卡尔的故事，你大概会知道这两个故事存在一个共同的隐含着的假设。这个假设就是：<strong>真实世界分为两个不同的存在</strong>，一个是真实的外部世界，一个是我们所能直接知道的（无论是通过理性还是经验）经验世界（或者说观念世界、心灵世界）。本文接下来会用“两个世界的假设”指代这个概念。</p>
<p>我们再用更详细的语言来陈述这个假设：（1）存在一个“外部”世界，处在我们经验和信念之外的，不会受到我们想法的世界。这个外部世界通常被认为是最“真实”，最“实在”的世界。（2）我们能够直接认识的不是真实的世界本身，而是我们自己的心灵内容，包括我们的各种观念、信念、经验、知识，以及那些所谓的必然真理。（3）洞穴隐喻和我思故我在的故事无论给你怎样的震撼，上述两条陈述无论看上去多么合理，然而，如果把它们放在一起，会直接导出一个可能令我们无法容忍的结论：<strong>我们的心灵内容，和那个最真实的世界永远有一定的差距。我们永远不可能认识这个世界，我们永远无法真的确信我们认识了、理解了这个世界</strong>。</p>
<p>那么，我们所认为的必然真理，是否仅仅只对我们的感觉、语言或者思考方式来说才是真的，而非世界本身的样子？说不同语言的人，其拥有的世界也不同吗？这个世界是我们想出来的或是我们说出来的吗？下面是否这句话是否成立：“人类碰巧拥有语言，所以自诩拥有理性”？</p>
<p><strong>这些关于我们可能根本无法认识世界的怀疑被称为怀疑论</strong> (Skepticism)。从这个假设出发，我们接下来将会看到休谟怎样提出彻底的怀疑论来作为他的经验主义哲学的推动力。</p>
<h1 id="休谟的叉子-Hume’s-Fork"><a href="#休谟的叉子-Hume’s-Fork" class="headerlink" title="休谟的叉子 Hume’s Fork"></a>休谟的叉子 Hume’s Fork</h1><p>铺垫了两千多字，终于要进入休谟的世界了。</p>
<p>休谟是一个经验主义者。休谟认为刚才的“两个世界的假设”是为真的，<strong>不过他思考要怎样才能给出其为真的证明</strong>。<strong>休谟通过自己的工作，得出了一个否定性的结论：我们无法知道这个问题的答案。而且，我们不仅得不到证明“两个世界的假设”为真的答案，他又进一步地论证我们日常生活中最基本的原理、知识、指导原则都是得不到辩护的</strong>。休谟的怀疑论立场是：<strong>我们无法知道这些问题的答案，哪怕是一些我们一度认为是很容易回答的问题。</strong></p>
<p>休谟提出了哲学史上，比笛卡尔还严格的怀疑论。</p>
<p>上面我们提过，休谟可以算得上是一个天才。休谟的论证，既简洁又优美，自它诞生以来，哲学家们一直试图反驳，但罗素认为，还没有哪个人取得了成功。罗素评价休谟的证明“既难以反驳，又难以接受”。</p>
<p>休谟令人信服地阐述了他的思想。他运用了一种哲学工具被称为<strong>休谟的叉子</strong> (Hume’s Fork)。</p>
<p><img src="/2020/10/19/Hume-Skepticism-and-Empricism/fork.jpg" alt="fork"></p>
<p>休谟认为，<strong>一切值得相信的陈述，可以分为两种（而且只能分为两种）类型</strong>：</p>
<ul>
<li>要么是一个<strong>可以用经验去判断的</strong>“<strong>事实</strong>” (Matters of fact)，</li>
<li>要么是一个<strong>可以用思维逻辑去证明其真实性的</strong>“<strong>理性真理</strong>”(Truth of reason, <strong>或叫“观念的关系”</strong>, relations of ideas)。</li>
</ul>
<p><strong>如果一种信念不能作为上述两种类型中的任意一种得到证明，那么它就是没有根据，不值得相信的。</strong></p>
<p>具体地来说，休谟作为一个经验主义者，会认为人类的知识是来自于经验。<strong>但他考虑了那些我们没有直接观察到的知识是如何形成的</strong>。</p>
<p>例如我们关于数学或抽象演算的知识就不是通过直接的观察形成的。我可能没有在生活中可以亲眼看见过一个数学意义上完美的三角形，但是依然不妨碍我心中拥有对何谓三角形的概念，其是一个有三条边组成的图形，并且有如两边之和大于第三边这样的最基本的性质。这是一个仅凭思维活动就可以得到的理性真理，或者叫——用休谟的术语是——<strong>观念的关系</strong>(relations of ideas)。休谟认为，它们之所以成立，是因为对这些想法的反驳直接构成了自我矛盾。现在请你想象出一个只有两条边的三角形，你可以想象得出来吗？或者说一个某两边之和小于等于第三边的三角形？你想象不出来。所以休谟说，这些观念的关系是必要的理性真理，而且我们仅凭逻辑思维的运作，就可以知道它们必定为真。因此，理性真理是一部分我们既不能通过直接的观察来形成，却又能够通过理性来形成的关于世界确实样貌的一种知识——“所有的三角形有三条边，两边之和大于第三边”。类似的知识还有“二加二等于四”。</p>
<p>那么休谟之叉的另一个组成部分，可以通过经验去判断的<strong>事实</strong>(Matters of fact)是什么样类型的知识呢？当我们在思考没有直接观察到的事实与知识之间的关系时我们要运用归纳法。例如，我们都知道不要玩火的道理，这是因为过去很多玩火的人用手指碰到火都感受到了疼痛或者烧伤，因此我们归纳地得出了不能玩火的知识，这是来源于我们的感官经验，用经验可以去判断的。</p>
<p>休谟的策略就是，当休谟他老人家碰到任何信念，他都会这样发问：“这个信念是一个可以通过经验或实验得到辩护的‘事实’吗？抑或是一个可以通过逻辑或演算而获知的‘观念的关系’吗？” <strong>如果对这个问题的回答是“二者皆非”，那么休谟就认为，这条陈述缺乏合理的辩护，没有资格成为我们的信念或知识。</strong></p>
<h1 id="休谟使用-Hume’s-Fork-对普遍因果性定理的反驳"><a href="#休谟使用-Hume’s-Fork-对普遍因果性定理的反驳" class="headerlink" title="休谟使用 Hume’s Fork 对普遍因果性定理的反驳"></a>休谟使用 Hume’s Fork 对普遍因果性定理的反驳</h1><p>休谟怀疑了“因果论”。</p>
<p><strong>普遍因果性理论</strong> (principle of universal causality) 就是认为“每一个事件都有他发生的原因”的理论。简单来讲就是“<strong>有果就有因</strong>”。</p>
<p>什么？休谟要反对“有果就有因”这样的陈述？我靠，我有点感受到怀疑论的伟大了。竟然连这么简洁、看似完全合理的、大多数人都会不假思索认为是绝对为真的陈述都要进行怀疑！他真是对自己的思想和智力负责任到了极致！</p>
<p>对<strong>因果关系</strong> (causality) 的研究是休谟最具影响力的哲学思想之一。休谟指出，我们大多数人类都相信观察到一件事物随着另一件事物而来，就会认为两件事物存在因果关系。他认为，我们对于因果的概念，只不过发展了一个思考习惯，把总是前后相继的两类客体或事件联系起来，除此之外，我们无法感知到原因和结果，只不过是期待某一件事物会伴随另一件事物而来的想法罢了。事实上真实的情况并不像我们所想的那样“有因就有果”。</p>
<p>使用休谟之叉的方法，休谟提问：“有因就有果”是一个可以用经验获知或加以判断的事实吗？或者它是一个可以通过逻辑而获知的“观念的关系”吗？我们先来考察休谟之叉的第二点。“有因就有果”是逻辑上可以证明为真的吗？好像很难，我们认为其不言自明，似乎都是从经验判断的角度出发的。换个问法，我们能够在逻辑上想象一个所有事情都不存在原因的世界吗？诶，似乎是可以的。现在的物理学家也已经在讨论，各种没有原因的原子散射，我们可以逻辑上想象出空间中孤立的粒子朝一个方向没有原因的射出的系统。那么，“有果就有因”的休谟之叉的第二点是不成立了。</p>
<p>我们会习以为常地认为从经验判断“有果就有因”的确是经验上的事实。比如，某人在打台球，红球进袋是<strong>结果</strong> (result)，这个结果的<strong>原因</strong> (cause) 是红球开始滚动，而红球为什么会滚动的原因是因为红球被白球撞击，为什么会被白球撞击是因为某人拿着球杆击打了白球…… 这一切构成了<strong>因果关系</strong> (causality)。这难道不是万事万物都有其发生的原因，“有果就有因”吗？？当我们的论述进行到这里时，休谟他老人家跳出来说：No No No! 这种想法是不合理的。</p>
<p>休谟反对“有果就有因”是一个可以用经验判断的事实，他提出了一个叫做“<strong>恒常联结</strong>” (constant conjunction) 的精彩概念。恒常连接的意思是，<strong>我们看到的只是事情的连续发生，却会误以为，某件事总是造成了另一件事</strong>。<strong>我们只看到事物接连发生</strong>——我们看到了拿起球杆，击打白球，白球撞击红球，红球进袋——<strong>但是我们没有看到“理由”</strong>。<strong>我们只看到了 constant conjunction，我们没有看到 causality</strong>. </p>
<p><strong>休谟认为，我们没有经验或感觉上的理由去相信“是由先前事物造成了后面的事物”。我们只不过发展了一个思考习惯，把总是前后相继的两类客体或事件联系起来。休谟主张人类有信赖和寻找因果关系的心理本能，这来自我们神经系统养成的习惯和人性。但我们没有任何论点、也不能以演绎或归纳来证明这个习惯是正确的。</strong></p>
<p>哇塞…… 18世纪中叶，就出现了这样的哲学思想，出现了这样的哲学家！他否定了我们平日的信念——相信有果必有因。同时这个怀疑论强大到，对于这些信念，无法找到任何令人满意的证实。没有办法证明！</p>
<p>休谟通过休谟之叉对“有果必有因”发问，而回答是“二者皆非”，于是“有因就有果”不成立。</p>
<hr>
<p>休谟的看法无疑是正确的，他有力地驳斥了因果关系。甚至后来如罗素这样的哲学家完全抛弃了因果概念，将因果关系视为迷信。如果我们在这里还不想走的这么远，把因果关系一棍子打死，那么起码我们承认现在已经得知了一个宝贵的发现：<strong>事件 B 发生在事件 A 之后，不代表 A 和 B 成立因果关系</strong>。仔细想想，因果关系其实在逻辑上是一个非常难证明的强关系。我作如下浅显的思考，要证明“因为 A 所以 B”，除了要观察到事件 B 发生在事件 A 之后，我们还得证明事件 B 的发生不是因为其他别的什么 C, D, E, F … X, Y, Z 事件导致的事件 B，这样才能证明“因为 A 所以 B”。</p>
<p>我们现在知道了，<strong>相关性不等于因果性</strong>，然而，最早提出这一论断的休谟，竟然是一位三百年前的哲人！</p>
<h1 id="休谟对归纳法的思考"><a href="#休谟对归纳法的思考" class="headerlink" title="休谟对归纳法的思考"></a>休谟对归纳法的思考</h1><p>上面对因果性的思考，休谟提出了他对归纳法的思考。</p>
<p><strong>归纳法</strong> (Induction) 是一种论证的方法，从个别事例出发进行概括，尝试获得可信的结论。我们人类必须使用归纳思考，由过去的经验或行动，作为预测未来的可靠指导。归纳思考蕴含的基本假设是：<strong>自然性质的统一性</strong>(the uniformity of nature)，也就是我们认为未来的情况会类似于过去的情况。如果没有这个基本假设，归纳法不会成为有效的思想来源。</p>
<p>很明显我们会用归纳法来得出普遍因果性定理。如果我们观察足够多的事情都（<strong>看起来貌似</strong>）有原因，我们<strong>就会理所当然地归纳地认为</strong>所有的事情真的都有其原因，这是很自然的想法。不过，根据之前的叙述，我们已经知道休谟驳斥了普遍因果性定理。那么，他现在要将他的结论进一步发展，提出一些关于归纳法的洞见。</p>
<p><strong>休谟认为，我们不能将我们的归纳思考能力解释为理性的产物</strong>。他对归纳法提出了如下的意见：</p>
<p><strong>一、现在被认定为真的归纳原则，未来有可能停止运作</strong>。例如，我们观察了很久的一段日子，这段日子中我们每一天都观察到太阳都是从东边升起西边落下的，那么我们就会归纳地得出“太阳在东边升起，在西边落下”的知识。然而完全有可能，这一知识在未来的某一天突然不成立，而且我们完全可以通过逻辑和纯粹的思维写出符合这一设定的科幻小说。</p>
<p>别的例子比如说，“天下大势，分久必合，合久必分”这个信念，就是来自于归纳。我们想象是某个活了很久的中国古代老头子归纳所说出来的。他通过对历史的了解，加上他活了这么久的经验，确信这个国家的确是天下大乱然后合归一统，然后又天下大乱的治乱循环。那么这句话可以成为令人信服的知识吗？可以成为客观真理吗？有没有可能，他死了之后很多年过去了，他的国家分了之后再也合不起来了呢？抑或是出现整个世界合了之后再也没分过的情况呢（如国界消失、世界政府成立）？所以说他出错的可能还是存在的。</p>
<p>换一个更直白的例子的话，比如，我根据我过去二十几年的经验归纳出“过去二十年我的头发一直是黑色，所以我未来的头发也一直都会是黑色的”这个信念，这句话很明显是错的，是不能成为知识的。</p>
<p>归纳法其实就是这样的思维过程：</p>
<blockquote>
<p>All observed F have been G （现在观察到的所有的F是G）<br>Because the future resembles the past（因为未来的情况会与过去的情况相类似）<br>So all unobserved F in the future are G （所以所有未观察到的所有F在未来也会是G）</p>
</blockquote>
<p>我们知道“我未来的头发一直都会是黑色的”这一句话明显不是知识的原因是“我们知道”未来头发会变灰变白。然而这里的关键在于，由归纳法得出其他的结论的<strong>理性基础</strong>和“我未来的头发一直都会是黑色的”是一样的。</p>
<p><strong>二、我们不能诉诸于之前运用归纳法推理的成功经验来证明归纳法推理的可靠性，因为这将造成循环论证</strong>（“因为过去归纳法都是可靠的，所以归纳法是可靠的”）。</p>
<p>从上面两点，休谟认为，<strong>我们没有理性依据认为归纳法是理性的</strong>（这个结论有点 philosophical，细细品味~）。比如说，在飞机还没有被发明的年代，人类向往着天空，在思考人是否可以飞翔。自然地，那时的人类会根据归纳法得出“从高山山顶跳下来会死”、“人类无法像鸟儿那样飞起来”。这是归纳法得出的结果，然而这是真理吗？如果这是真理的话，那么人类岂不是应该永远发明不了飞机才对？</p>
<p>这里注意，休谟不是在说：</p>
<ol>
<li><strong>他并不是主张由于归纳法不属于演绎法所以不理性。他主张的是，我们的思考能力其实并没有一个理性的基础，因为没有任何形式的理性可以证实这样的能力存在</strong> (这个结论 mind-blowing!!)。<strong>如果理性没有任何的依据能够构成我们的思想，且如果我们的思想从头到尾都是由理性所构成的话，那么我们根本不能相信任何（理性导出的）东西，包括直觉、归纳法和演绎法所得出的任何真相在内。</strong></li>
<li><strong>他并不是主张，归纳法不可行，也并不是认为归纳法无法达成可靠的结论。休谟点明的是，归纳法事实上不是由理性所构成的，换句话说，这是一种对人类理性究竟能达到怎样高度的谨慎和怀疑</strong>。用休谟自己的话说是：“我們不能信賴我們的理性所做出的錯誤演繹，這種理性不但思考緩慢，而且打從我們出生下來在一生中都非常容易犯下錯誤”。</li>
<li>他虽然对归纳法属于理性思考抱有悲观态度，但他仍然认为归纳法有相当神奇的预见未来的能力。这和今天我们了解的经验主义的科学(Science)的作用非常相似。这个说法已经是前达尔文时代对于人类归纳思考能力做出的最接近进化论的理论了。</li>
</ol>
<h1 id="休谟分析“两个世界的假设”"><a href="#休谟分析“两个世界的假设”" class="headerlink" title="休谟分析“两个世界的假设”"></a>休谟分析“两个世界的假设”</h1><p>怀疑论中的基本假设：世界分为真实的外部世界和我们能感受到的内部世界。接下来就可以用休谟之叉自然而然地导出该信念是否为真的结论。</p>
<p>我们能说明存在一个外部世界是逻辑的“理性真理”吗？当然不能。因为我们可以想象世界不存在是什么样子，或者像笛卡尔那样认为我们都单纯地在做梦。</p>
<p>那么“存在一个外部世界”是用“经验”可以判断的“事实”吗？也不能，因为当我们说到“经验”这个词，那么它只能是“经验世界”的一部分。</p>
<p>所以，休谟认为，<strong>如果我们接受“存在两个世界”的假设，那么结果只能是我们的经验世界存在而外部世界不存在。而且在这个经验世界里，我们永远无法依靠经验说明事情不是这样。</strong></p>
<p>我对休谟哲学思想的学习就总结到这里。</p>
<h1 id="怀疑论的价值"><a href="#怀疑论的价值" class="headerlink" title="怀疑论的价值"></a>怀疑论的价值</h1><p>康德认真地思考了 Hume’s Fork 并且意识到，一个人只要认识到并接受“两个世界的划分”，那么怀疑论就是无法避免的！</p>
<p>怀疑论与其说是解答了什么问题，不如说是宣布了“没有答案”和“我们无法知道答案”。怀疑论更多的不是作为一种要被人接受的哲学立场，而是被当成一个需要迎接的挑战。<strong>怀疑论之所以成为强而有力的哲学，是因为怀疑论使得你能够对那些太过显然的但实际上不能给出合理辩护而站不住脚的教条保持警惕。怀疑论之所以有价值，是因为它是我们意识到了，我们多么容易轻信：显然的就是客观正确的</strong>！</p>
<blockquote>
<p>从来如此， 便对么？——鲁迅《狂人日记》</p>
</blockquote>
<p>学习哲学的关键，就是使得我们能够超越那些我们起初认为自明的东西，对事物进行彻底的思考，直至能捍卫我们相信的东西。</p>
<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>哲学是对重大问题的探究，是一种对事物寻根究底的过程，是一种对那些大部分时间内被认为是理所当然、从未有疑问的想法提出根本性质疑的过程。哲学是对智慧的爱！对怀疑论这个分支的学习，最能让我体会到这些句子所述的哲学之意义。</p>
<p>我们遇到的这些历史上伟大的哲学家，他们之所以伟大，是因为他们雄辩地阐述了自己的观点，并出色地为之做了辩护。休谟是其中的一位，他的观点是清晰简洁的，是“如无必要，勿增实体”的上佳体现。如果你认为你够聪明，你就应该去了解他。太棒了。</p>
<p><img src="/2020/10/19/Hume-Skepticism-and-Empricism/David_hume_statue.jpg" alt="David_hume_statue"></p>
<hr>
<p>我昨晚有一個非常神奇的體驗。我十二點多睡覺前，用手機打開一個油管上講休謨哲學思想的視頻聼。然後大概快一點我就要睡着了，我就把手機一關。但是，我腦子裏的對於休謨哲學的思考一直在繼續著。我既不是清醒狀態也不是沒有知覺的睡着的狀態，而是腦子裏一直在斷斷續續地思索他的哲學……然後有一瞬間我突然就清醒了，看下手機是三點鐘。我越思考，就越清醒。我的内心有一股强烈的將這些想法進行整理的衝動，於是就從床上起身，打開電燈，開始寫這篇博文，一直寫到中午12點喫了午飯才睡。而且我睡到下午三點鐘就醒了，依然非常地精神……</p>
<p>“這個哲學太棒了ㄟ(≧◇≦)ㄏ 对这些问题的思考才是人類的智慧樂趣所在呢。我現在根本不想管別的爛事！”</p>
<hr>
<p>休谟之叉的两端分别是 relations of ideas &amp; matters of facts. 休谟在这里发展出了“<strong>要学会区分事实和观点</strong>”的道理，休谟的怀疑论进一步得出“<strong>我们要对我们的观点保持谨慎</strong>”。这应该是从小就教导给小孩子的，而我们现在很多成年人都还没有这个能力。</p>
<p>由学会区分<strong>事实</strong>(fact)和<strong>观点</strong>(idea)，进一步发展为要能够区分<strong>信念</strong>(belief)和<strong>知识</strong>(knowledge)。</p>
<p>下面这个图是在英文维基百科 Epistemology 中找到的：</p>
<ul>
<li><strong>人们信以为真的命题就是信念</strong>。基本上，凡是可以在“我相信”后面接的一句话，都算是那个人的信念。如，“我相信1+1=2”、“我相信张三是杀人凶手”、“我相信做人应该守信用”、“我相信并非所有天鹅都是白色的”等等。</li>
<li>而对知识的一个简洁的定义是: <strong>Justified True Belief</strong>，得到有力辩护的真信念就是知识。</li>
</ul>
<p>justified true belief 又称 JTB，这个对知识的定义出自于葛梯尔，虽然这个定义它也有问题，不能覆盖全部的情况，但是对于让我们了解信念和知识的区别已经足够了。</p>
<p><img src="/2020/10/19/Hume-Skepticism-and-Empricism/knowledge.jpg" alt="knowledge"></p>
<p>可以看到，Proposition 表示所有的命题。左边红圈 Truth 代表真值为真的命题，右边蓝圈代表我们的信念。红圈和蓝圈重合的部分其实还不全是知识（黄圈），而是紫圈，紫圈的英文是 JTB 前面加上一个副词 poorly。意思是，如果论证不是有力的而是无力的，还不足以成为知识。换言之，原本认为整块紫色区域都是知识，后来变为，要称之为知识，除了要是得到辩护的真信念之外，那个辩护的力度还必须足够强才行。</p>
<p>学习知识论，让我们知道何以使得信念成为知识。<strong>得到了足够多强力理由和证据支持的真观点就是事实，否则就只是观点</strong>。休谟对于任何信念，都要用休谟之叉来考察它们，才能确信他们是否值得接纳。我们也不妨一试。</p>
<blockquote>
<p>我们如果相信这些原则，那么我们在各个图书馆将会有多大的破坏呢？我们如果在手里拿起任何一本书，例如神学书或经院哲学的书，那么我们就可以问：其中包含任何关于数或量的任何抽象推理吗？没有。其中包含着关于事实和存在的任何经验推理吗？没有。那么，我们就把它投到火里去，因为它所能包含的没有别的，只有诡辩和幻想。—— 休谟《人类理智研究》</p>
</blockquote>
<p>写到这里，我们可以看到休谟是怎么样作为一个出色的哲学家去论证批判性思考(critical thinking)的意义的。以前我对于 critical thinking 只是觉得它很有道理，应该被接受。今天我通过休谟展示的哲学更加深刻地知道了其内涵和意义所在。</p>
<hr>
<p>有些知识由老师（不仅是初高中大学的老师，想象一下广义的社会）教导给你之后，会不会变成教条？它成为你知识的同时，也限制了你想象的空间。从此，你会因为受到教育而变笨，因为你的想象力受到了压缩，而人类的进步，最重要靠想象力。在接受父母、学校、老师、社会、传媒、政治的一些信念，你有没有考虑过，它们有可能是不对的？还是你只是简单地相信它们？</p>
<p>我们是否可以怀疑，我们所受的教育，是否暗藏一个黑暗目的，黑幕就是，<strong>教育是为了要让你变笨</strong>。我老早就开始怀疑这个。密不透风的窗户打开之后唯一吹进内心的一股清流，就是 philosophy。因为只有接触了哲学，我们才学会如何去思考这种 metaphysical 和 epistemological 问题，“受教育让我们变笨了还是变聪明？”</p>
<p>18世纪的英国，出现了休谟这样的思想家。经验主义，是英国人的起点。从经验主义开始，向一切的信念发出的挑战。如果没有这种哲学思想，就会把很多东西当成教条去看待，完全不了解经验告诉我们的内容。对我来讲，已经如此的震撼。我更加深刻地了解，中国思维的落后在哪，东西方文化差距之大在哪。落后不仅仅是走了反右文革大跃进折腾的十几二十年的冤枉路；也不仅仅是在甲午海战发现北洋水师和洋务运动的失败后才开始知道的“器物和制度均落后”；也不仅仅是1840年的事情才让我们觉得我们落后。而是上溯至18世纪乃至更早的启蒙时代开始，我们走了几百年的冤枉路，直到现在还在走。我们的教育把我们变得越来越笨，而他们的教育把他们变得越来越聪明。我们的教育体制，存在不仅能决定考试成绩的标准答案，还有可以管天管地管空气、管个人管集体管社会、管言论管思想管自由管学术、管道德管历史管未来的“标准答案”；而他们的教育体制获得成功的原因恰恰是，他们对于“问题的答案”是“没有答案”！是不再对“发现世界真实的样子”抱有非常大的信心，而是要一五一十地想办法弄清楚自己的思想里到底有多少是可信的。</p>
<p>未来我会花时间阅读 Hume 的原著，读完之后会再来对文章进行补充。最后，我再一次说出哲学的字面意义作为本文的结尾：哲学就是爱智慧！</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Wiki links: </p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E5%8D%AB%C2%B7%E4%BC%91%E8%B0%9F">大卫·休谟 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%9F%A5%E8%AF%86%E8%AE%BA">知识论 - 维基百科，自由的百科全书</a></li>
<li><a href="https://en.wikipedia.org/wiki/Epistemology">Epistemology - Wikipedia</a>    </li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%80%A7%E4%B8%BB%E4%B9%89">理性主义 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BB%8F%E9%AA%8C%E4%B8%BB%E4%B9%89">经验主义 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%80%A7">理性 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%84%9F%E6%80%A7">感性 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%99%BD%E6%9D%BF_(%E5%93%B2%E5%AD%A6">白板 (哲学) - 维基百科，自由的百科全书</a>)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%B6%93%E9%A9%97">經驗 - 维基百科，自由的百科全书</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hume%27s_fork">Hume’s fork - Wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%9F%A5%E8%AF%86">知识 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%88%91%E6%80%9D%E6%95%85%E6%88%91%E5%9C%A8">我思故我在 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%A9%B4%E5%AF%93%E8%A8%80">地穴寓言 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E6%9E%9C%E5%85%B3%E7%B3%BB#%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6">因果关系 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E9%A2%98">命题(Proposition) - 维基百科，自由的百科全书</a></li>
<li><a href="https://en.wikipedia.org/wiki/Knowledge#Theories_of_knowledge">Knowledge - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Justification_(epistemology">Justification (epistemology) - Wikipedia</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/Argument">Argument - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Belief">Belief - Wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%91%9B%E6%A2%AF%E5%B0%94%E9%97%AE%E9%A2%98">葛梯尔问题 - 维基百科，自由的百科全书</a></li>
</ul>
<p>我的文章写的很差 :)，各位还应该看一看下面的东西来参考 (<em>^_^</em>)</p>
<p>书籍：</p>
<ul>
<li><a href="https://book.douban.com/subject/26806808/">人性论 (豆瓣)</a></li>
<li><a href="https://book.douban.com/subject/25961458/">大问题 - 简明哲学导论 (豆瓣)</a></li>
</ul>
<p>文章：</p>
<ul>
<li><a href="https://zh.m.wikiquote.org/zh-hans/%E5%A4%A7%E5%8D%AB%C2%B7%E4%BC%91%E8%B0%9F">大卫·休谟 - 维基语录，自由的名人名言录</a></li>
<li><a href="https://en.wikiquote.org/wiki/David_Hume">David Hume - Wikiquote</a></li>
<li><a href="https://www.douban.com/group/topic/50829093/">时间与习惯——大卫·休谟的托利史观</a></li>
<li><a href="https://medium.com/@LiuZhongjing/%E8%8B%B1%E5%9C%8B%E5%8F%B2%E7%AD%94%E5%95%8F-1776a966c899">關於休謨《英國史》的答問記錄</a></li>
<li><a href="http://www.cunman.com/new/6544ca37f18447e680c4ac272c510400">大卫休谟人性论导读</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/126175818">区分“事实”与“观点” - 知乎专栏</a></li>
<li><a href="https://iep.utm.edu/epistemo/">Epistemology | Internet Encyclopedia of Philosophy</a></li>
</ul>
<p>在线课程：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1fx411b7Hp?p=5">Crash Course Philosophy</a></li>
<li><a href="https://www.bilibili.com/video/BV1c4411y7Ez/">【西方哲学四.3】怀疑论-休谟 - bilibili</a></li>
<li><a href="https://www.youtube.com/watch?v=T7QYXXCsBfU">CH04-2. 知識論(二) 承襲洛克的休謨 / 苑舉正 - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=-QpUrSn3cWU">PHILOSOPHY - Epistemology: Hume’s Skepticism and Induction, Part 1 [HD] - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=dPlNsyXl-0c">Epistemology: Hume’s Skepticism and Induction Part 2 - YouTube</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>基于Cisco IWAN 的 SDWAN 技术分析</title>
    <url>/2017/05/21/IWAN-en/</url>
    <content><![CDATA[<p>This artical is reorganized based on Cisco’s White papers: <em>Intelligent WAN Is the Foundation for the SoftwareDefined WAN</em> by Zeus Kerravala, at September 2015.</p>
<p><a href="http://www.cisco.com/c/dam/en/us/solutions/collateral/enterprise-networks/intelligent-wan/intelligent-wan-foundation.pdf">Cisco’s page link</a></p>
<p><a href="http://www.cisco.com/c/en/us/solutions/enterprise-networks/intelligent-wan/index.html">source</a></p>
<h1 id="Introduction-Digital-Transformation-Drives-WAN-Evolution"><a href="#Introduction-Digital-Transformation-Drives-WAN-Evolution" class="headerlink" title="Introduction: Digital Transformation Drives WAN Evolution"></a>Introduction: Digital Transformation Drives WAN Evolution</h1><p>Digital transformation is reshaping the business landscape faster than at any time in history.  It used to take decades to disrupt a market, but natively digital companies such as <strong>Uber</strong> and <strong>Airbnb</strong> have disrupted their industries in just half a decade.</p>
<p><strong>Digitization</strong> is creating new winners and losers at an unprecedented rate —— that is, having the ability to take advantage of market opportunities faster than the competition. This <strong>shift to being an agile business</strong> has now become a top initiative for IT and business leaders. This is why businesses spent more than $12 billion on technology to make IT more agile in 2014, according to ZK Research.</p>
<p>However, one part of IT that has yet to <strong>evolve and lacks flexibility</strong> is the enterprise wide area network (WAN) Evolving the WAN must be a top priority for every IT and business leader.</p>
<h2 id="Other-factors-driving-the-evolution-of-the-WAN"><a href="#Other-factors-driving-the-evolution-of-the-WAN" class="headerlink" title="Other factors driving the evolution of the WAN"></a>Other factors driving the evolution of the WAN</h2><ul>
<li>Cloud computing continues to skyrocket.</li>
</ul>
<p>More applications and workloads are heading to the cloud.  Today, <strong>the cloud is the fastest growing segment of enterprise software</strong>, grow from $46 billion globally in 2014 to more than $116 billion in 2019. (Exhibit 1). The surge in cloud traffic is <strong>driving significantly different traffic patterns over enterprise WANs</strong>.</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170521234016572-664702559.png" alt=""></p>
<ul>
<li>Collaboration becomes business critical. </li>
</ul>
<p>For the digital enterprise, competitive advantage is based on an organization’s <strong>ability</strong> to <strong>make the right decision</strong> while <strong>involving the best people</strong> in <strong>as short a time as possible</strong>,<strong> regardless of where they are located.</strong></p>
<p>communications (UC) and video conferencing mission are critical.  Multimedia applications, such as <strong>voice and video</strong>, are putting a strain on today’s WANs.</p>
<ul>
<li>Computing shifts to a network-centric model.</li>
</ul>
<p><strong>Mobile computing, the cloud, the Internet of Things (IoT) and big data</strong> are at the top of almost every organization’s priority list. These new compute models are all <strong>network centric</strong>, meaning the network plays a significant role in the success or failure of these initiatives. </p>
<h1 id="II-Challenges-with-the-Traditional-WAN"><a href="#II-Challenges-with-the-Traditional-WAN" class="headerlink" title="II: Challenges with the Traditional WAN"></a>II: Challenges with the Traditional WAN</h1><p>The current architecture used to design business WANs has been in place for more than 30 years. </p>
<p>The existing model was designed for <strong>predictable</strong> traffic flows from client/server computing and <strong>best effort</strong> Internet traffic. The centralized architecture is optimized for manageability but <strong>lacks</strong> any kind of <strong>dynamism</strong> or <strong>granular access control</strong> required for today’s diverse and varied traffic types driven from mobile users, extranets and telecommuters.</p>
<p> video traffic consumes up to 90% of business traffic today, which is a major shift from even a decade ago when video constituted less than 10% of network traffic.</p>
<p> The evolving business climate is putting<strong> new demands </strong>on the WAN that <strong>cannot be met with legacy deployment models</strong> because of the following challenges:</p>
<ul>
<li><p>Inefficient use of network bandwidth:</p>
<p><strong>“active/passive” mode</strong> almost all organizations provision backup network connections. In most cases, the dual network connections are put in “active/passive” mode, where all traffic is sent down the primary connection and the backup link only becomes active when the primary fails. This causes organizations to pay for up to twice the amount ofbandwidth they are actually using.</p>
</li>
</ul>
<ul>
<li>High cost of bandwidth: </li>
</ul>
<p>the only way to ensure the availability of bandwidth for applications is to use expensive private IP network services such as Multiprotocol Label Switching (MPLS). </p>
<ul>
<li>Security and performance are overlay technologies:</li>
</ul>
<p>Securing a legacy WAN is typically accomplished by layering on additional physical appliances to add the new functionality required.  The overlay approach, which is built on multiple appliances, can further <strong>increase the complexity of the network</strong>. </p>
<ul>
<li>Little to no automation capabilities:</li>
</ul>
<p>WANs have almost no ability to automate network operations tasks.</p>
<p>The provisioning of new services and the implementation of configuration changes are typically done manually on a box-by-box basis, <strong>creating long lead times</strong> for any kind of change to be made.</p>
<p> In this era of network-centric IT, a network engineer’s time is extremely valuable.</p>
<ul>
<li><p>Difficulty optimizing the user experience:</p>
<p>It is still difficult for most network managers to optimize the user experience of WAN-based applications.</p>
<p>Consequently, network managers are often tuning quality-of-service (QoS) settings, creating alternative paths or changing other network parameters. This<br><strong>tweaking</strong> of the network is often done <strong>“ad hoc”</strong> <strong>when</strong> users are complaining about problems</p>
</li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170521234020853-204518874.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170521234030385-339956449.png" alt=""></p>
<p>Improving the quality of experience for applications requires <strong>having deep visibility</strong> into application behavior, <strong>identifying optimal paths</strong> and then <strong>automating constant changes to QoS settings</strong> and other factors.</p>
<hr>
<p>Business leaders must shed their legacy thinking.</p>
<p>It’s time for the software-defined WAN.</p>
<hr>
<h1 id="III-Introducing-the-Software-Defined-WAN"><a href="#III-Introducing-the-Software-Defined-WAN" class="headerlink" title="III: Introducing the Software Defined WAN"></a>III: Introducing the Software Defined WAN</h1><p>A software-defined WAN can be thought of as the <strong>next generation of WAN architecture</strong> that is <strong>optimized for</strong> network-centric compute models such as <strong>cloud, mobile computing and IoT</strong>.</p>
<p>An SD-WAN is built on the <strong>concepts</strong> of openness, agility, orchestration, analytics and security while continuously optimizing application performance. It enables application policies to be used to automate configuration changes, move traffic flows or enact other changes to ensure the network continually meets the needs of the organization. </p>
<p>One approach to accomplishing this is to abstract the control functions into an external controller. This provides the benefit of centralized policy expressions with distributed enforcement for scalability. Other benefits include zero-touch deployment as well as simplified configuration and troubleshooting。</p>
<p>However, it can pose challenges with enforcing security at the branch and with performance and resiliency <strong>depending on where the controller is located.</strong></p>
<p>Another approach is to have the controller <strong>distributed</strong> as part of the network infrastructure. This provides the benefits of centralization but also enables stronger security in the branch, greater availability and more resiliency along with faster adaptation to network conditions.</p>
<h2 id="Criteria"><a href="#Criteria" class="headerlink" title="Criteria"></a>Criteria</h2><p>In 2014, the Open Networking User Group (ONUG) defined the following 10 criteria for an SD-WAN: </p>
<ol>
<li><p>Ability for branch offices to leverage both public and private WAN connections in an <strong>active/active configuration</strong></p>
</li>
<li><p>Ability to deploy customer-premises equipment (CPE) in either a physical or a virtual form factor on <strong>any hardware</strong>, including commodity infrastructure </p>
</li>
<li><p><strong>Secure hybrid WAN architecture</strong> that allows for <strong>dynamic traffic engineering capabilities</strong> across private and public WAN paths as specified by application policies, network WAN availability and/or degradation at the transport or application layer</p>
</li>
<li><p><strong>Visibility, prioritization and steering of business-critical and real-time applications</strong> as per security and corporate governance and compliance policies</p>
</li>
<li><p>A <strong>highly available and resilient hybrid WAN</strong> for an optimized application experience. </p>
</li>
<li><p><strong>Layer 2 and layer 3 interoperability</strong> with a directly connected switch and/or router</p>
</li>
<li><p><strong>Management dashboard</strong> that provides site-, application- and VPN-level performance reporting</p>
</li>
<li><p><strong>Open, northbound (NB) APIs</strong> for controller access and management and the ability to forward specific log events to network event correlation managers and security event managers</p>
</li>
<li><p><strong>Zero-touch deployment capabilities</strong> at branch sites with minimal to no configuration changes directly on the infrastructure to ensure the highest level of agility</p>
</li>
<li><p><strong>FIPS 140-2 validation</strong> certification with automated certificate lifecycle management and reporting</p>
</li>
</ol>
<p>The definition of an SD-WAN is continually evolving, and there is <strong>no “de facto standard”</strong> when it comes to what is and what is not an SD-WAN. </p>
<hr>
<h1 id="IV-Cisco’s-IWAN"><a href="#IV-Cisco’s-IWAN" class="headerlink" title="IV: Cisco’s IWAN"></a>IV: Cisco’s IWAN</h1><p>Cisco’s Intelligent WAN can be thought of as a platform for WAN transformation.</p>
<p>A business could start by implementing a hybrid WAN today to gain the cost benefits of the Internet, and then migrate to an SD-WAN at a later date without adding more appliances and complexity in the branch. Once the SD-WAN is in place, the organization can use IWAN as a foundation for branch automation and service virtualization.</p>
<h2 id="IWAN-enables-the-following-WAN-capabilities"><a href="#IWAN-enables-the-following-WAN-capabilities" class="headerlink" title="IWAN enables the following WAN capabilities:"></a>IWAN enables the following WAN capabilities:</h2><ul>
<li>Application experience: </li>
</ul>
<p>Application optimization features such as intelligent path selection and WAN acceleration to ensure the best possible user experience.</p>
<ul>
<li>Secure access:</li>
</ul>
<p>Advanced threat detection to block most threats but also quickly identify any breaches that do occur and then rapidly mitigate them.</p>
<ul>
<li>Lower costs: </li>
</ul>
<p>Transport-independent WANs so that any combination of broadband, 3G/4G wireless or traditional networking services (e.g., MPLS VPNs) can be used for network transport simultaneously, with a single, common network design across every transport.</p>
<ul>
<li>Simplicity: </li>
</ul>
<p>Automation and orchestration of network services to ensure that the provisioning of new services and the implementation of network changes are driven by business policy and done at the speed required by a digital organization</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170521234033853-1185431835.png" alt=""></p>
<p>some reference linking:</p>
<ul>
<li><a href="http://www.cisco.com/c/en/us/products/security/dynamic-multipoint-vpn-dmvpn/index.html">Dynamic Multipoint VPN (DMVPN)</a></li>
<li><a href="http://docwiki.cisco.com/wiki/PfRv3:Home">Cisco Performance Routing (PfRv3)</a></li>
<li><a href="https://en.wikipedia.org/wiki/FIPS_140-2">FIPS 142-2</a></li>
<li><a href="http://www.cisco.com/c/en/us/about/security-center/next-generation-cryptography.html">Next Generation Encryption : AES-GCM-256</a></li>
<li><a href="https://developer.cisco.com/site/apic-em/">APIC Enterprise Module (APIC-EM)</a></li>
</ul>
<h2 id="Additional-benefits"><a href="#Additional-benefits" class="headerlink" title="Additional benefits:"></a>Additional benefits:</h2><ul>
<li>Full system validation:</li>
</ul>
<p>Deploying an SD-WAN can be a daunting task for most customers. To help simplify deployment, Cisco has created a number of technology design guides, or Cisco Validated Designs (CVDs).</p>
<ul>
<li>End-to-end solution:</li>
</ul>
<p>The ability to “software define” the WAN provides many benefits to the customer. However, organizations should also consider bringing the benefits of software-defined networking to the campus edge (wired and wireless) and the data center. </p>
<ul>
<li>Single platform for features beyond the SDWAN:</li>
</ul>
<p>The Cisco Integrated Services Router(ISR)</p>
<ul>
<li>Open platform: </li>
</ul>
<p>As a company, Cisco has been committed to developing standards-based, open platforms, and the SD-WAN is no exception.The open strategy enables a broad third-party ecosystem to interoperate with and enhance Cisco’s IWAN. This includes expert-system partners such as LiveAction, Glue Networks and Akama.</p>
<ul>
<li>Ability to extend Cisco Application Centric Infrastructure (ACI) to the WAN edge:</li>
</ul>
<p>The Cisco Application Policy Infrastructure Controller Enterprise Module (APIC-EM) </p>
<ul>
<li>Automation capabilities:</li>
</ul>
<p>The Cisco APIC-EM controller’s IWAN Application automates the configuration and deployment of advanced IWAN features such as security, path optimization, enhanced application visibility and QoS on Cisco’s 4000 series Integrated Services Router.</p>
<ul>
<li><p>Cisco Services and large partner ecosystem…</p>
</li>
<li><p>Next-generation branch…</p>
</li>
</ul>
<h1 id="V-Conclusion-and-Recommendations"><a href="#V-Conclusion-and-Recommendations" class="headerlink" title="V: Conclusion and Recommendations"></a>V: Conclusion and Recommendations</h1><p>The digital era is here and is creating new market leaders almost overnight. Business and IT leaders must focus on building an IT foundation that is dynamic, secure and agile to capitalize on digitization. Shifting the organization’s WAN strategy away from legacy architectures to a software-defined WAN is a key step in building an agile IT foundation.</p>
<p>However, the SD-WAN market is still evolving, and there is no industry-wide accepted definition for this technology. Consequently, it’s important to build a flexible foundation on which services can be deployed today but can then expand in the future as the needs of the business change and as SD-WANs continue to evolve. </p>
<p>Any organization looking to harness the power of digital transformation should make evolving to an SD-WAN a top priority. As next steps, ZK Research recommends the following: </p>
<ul>
<li>Evaluate solution providers on their ability to enable SD-WAN services today, but ensure the needs of the business will be met in the future. </li>
</ul>
<p>For example, Cisco’s IWAN takes an architectural approach to building an SD-WAN and enables businesses to start with network automation; but then it allows them to move past this phase, evolve the branch office and transition to a virtual services model to deliver any application or service to all users, no matter where they are located. </p>
<ul>
<li>Consider real-time traffic when building an SD-WAN.</li>
</ul>
<p>Real-time traffic applications such as voice and video are among the most difficult to run over a WAN. The requirements of these types of applications must be considered when architecting a next-generation WAN</p>
<ul>
<li>Shed conventional thinking around network design.</li>
</ul>
<p><strong>Many factors</strong> are involved in designing a WAN, and IT leaders must be willing to <strong>think differently today</strong>. </p>
<p>For example, years ago, organizations <strong>would never have</strong> considered using <strong>broadband Internet</strong> or <strong>cellular services</strong> for business connectivity. Today, it’s possible to use a combination of <a href="https://zh.wikipedia.org/wiki/DSL">DSL</a>, cable and 4G wireless to connect branch offices. <strong>An SD-WAN isn’t a traditional WAN</strong>, and it’s important that IT leaders <strong>not discount possible solutions</strong> because of <strong>historical biases</strong>. </p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title>基于Cisco IWAN 的 SDWAN 技术分析（译）</title>
    <url>/2017/05/24/IWAN-zh/</url>
    <content><![CDATA[<p>该文章是基于2015年9月由思科的 Zeus Kerravala 所撰 SDWAN 白皮书整理而来的：<em>Intelligent WAN Is the Foundation for the SoftwareDefined WAN</em>.</p>
<p><a href="http://www.cisco.com/c/dam/en/us/solutions/collateral/enterprise-networks/intelligent-wan/intelligent-wan-foundation.pdf">Cisco’s page link</a></p>
<p><a href="http://www.cisco.com/c/en/us/solutions/enterprise-networks/intelligent-wan/index.html">source</a></p>
<h1 id="引言：数字转型驱动广域网演进"><a href="#引言：数字转型驱动广域网演进" class="headerlink" title="引言：数字转型驱动广域网演进"></a>引言：数字转型驱动广域网演进</h1><p>数字转型正在重塑商业景观，而且比历史上的任何时间都要更迅速。可能需要几十年才能扰乱了市场，但一些数码公司如<strong>Uber</strong>和<strong>Airbnb</strong>在短短的五年间就已经扰乱了他们的行业。</p>
<p><strong>数字化</strong>以前所未有的速度创造新的赢家和输家 - 也就是说，有能力比竞争对手更快地利用市场机会。 <strong>向敏捷业务的转变</strong>已经成为IT和商业领袖的首要举措。 据ZK研究报告，这就是为什么企业在2014年花费超过120亿美元的技术来使IT更加敏捷。</p>
<p>然而，IT的一部分，企业广域网（WAN），目前<strong>尚未发展和缺乏灵活性</strong>。不断发展的广域网必须是每一个IT和业务领导者的第一要务。</p>
<h2 id="推动广域网发展的其他因素"><a href="#推动广域网发展的其他因素" class="headerlink" title="推动广域网发展的其他因素"></a>推动广域网发展的其他因素</h2><ul>
<li>云计算服务的飞涨</li>
</ul>
<p>更多的应用和工作负载正在移往云端。今天，云是企业软件<strong>增长最快</strong>的部分，从2014年的全球460亿美元增长到2019年的1160亿美元。（图表1）。 云流量的激增<strong>在企业广域网</strong>上显示出不同的流量模式。</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170521234016572-664702559.png" alt=""></p>
<ul>
<li>协作成为业务关键</li>
</ul>
<p>For the digital enterprise, competitive advantage is based on an organization’s <strong>ability</strong> to <strong>make the right decision</strong> while <strong>involving the best people</strong> in <strong>as short a time as possible</strong>,<strong> regardless of where they are located.</strong></p>
<p>通信（UC）和视频会议任务至关重要。 多媒体应用程序（如<strong>语音和视频</strong>）正在对当今的广域网造成压力。</p>
<ul>
<li>计算转向以网络为中心的模式</li>
</ul>
<p><strong>移动计算，云，物联网（IoT）和大数据</strong>几乎在每个公司的优先列表（priority list）上。 这些新的计算模型都是<strong>以网络为中心的</strong>，这意味着网络在这些举措的成功或失败中起着重要的作用。</p>
<h1 id="II-传统广域网面临的挑战"><a href="#II-传统广域网面临的挑战" class="headerlink" title="II: 传统广域网面临的挑战"></a>II: 传统广域网面临的挑战</h1><p>当前，用来设计企业广域网的架构已经存在了30多年。</p>
<p>The existing model was designed for <strong>predictable</strong> traffic flows from client/server computing and <strong>best effort</strong> Internet traffic. The centralized architecture is optimized for manageability but <strong>lacks</strong> any kind of <strong>dynamism</strong> or <strong>granular access control</strong> required for today’s diverse and varied traffic types driven from mobile users, extranets and telecommuters.</p>
<p>现有的模型，设计用于来自<strong>客户端/服务器</strong>计算、<strong>可预测的</strong>流量和<strong>best effort</strong>。集中式架构针对可管理性进行了优化，但<strong>缺乏</strong>由移动用户，外部网和远程办公人员所驱动的多样化的流量类型所需要的<strong>动态行</strong>或<strong>细粒度的访问控制</strong>。</p>
<p>视频流量今天消耗高达90％的业务流量，这是一项重大转变，十年前视频占网络流量还不到10％。</p>
<p> The evolving business climate is putting<strong> new demands </strong>on the WAN that <strong>cannot be met with legacy deployment models</strong> because of the following challenges:</p>
<p>不断变化的商业环境正在使广泛对WAN提出<strong>新的需求</strong>，而这些新需求不能被面临如下挑战的传统模型所满足：</p>
<ul>
<li><p>网络带宽效率低下：</p>
<p><strong>“active/passive” mode</strong> 几乎所有组织都提供备用网络连接。 在大多数情况下，双网络连接处于“主动/被动”模式，其中所有流量都在主连接上发送，备用链路仅在主要故障时才变为活动状态。 这导致组织支付高达他们实际使用的带宽数量的两倍。</p>
</li>
</ul>
<ul>
<li>高带宽成本：</li>
</ul>
<p>确保应用带宽可用性的唯一方法是使用昂贵的私有IP网络服务，如多协议标签交换（MPLS）。</p>
<ul>
<li>Security and performance are overlay technologies:</li>
</ul>
<p>保护传统广域网通常通过增加新的物理设备层次来实现或添加所需的新功能。 这种建立在多个设备上的<strong>覆盖方法</strong>（overlay approach）会进一步增加网络的复杂性。</p>
<ul>
<li>几乎没有自动化功能：</li>
</ul>
<p>WAN几乎无法自动执行网络操作任务。</p>
<p>The provisioning of new services and the implementation of configuration changes are typically done manually on a box-by-box basis, <strong>creating long lead times</strong> for any kind of change to be made.</p>
<p>新服务的配置和配置更改的实施通常是以逐个方式手动完成的，进行任何更改都要耗费大量的交货时间（long lead times）。在这个以网络为中心的IT时代，网络工程师的时间是非常有价值的。</p>
<ul>
<li>难以优化用户体验：</li>
</ul>
<p>大多数网络管理员仍然难以优化基于WAN的应用的用户体验。<br>网络管理员通常会调整服务质量（QoS）设置，创建替代路径或更改其他网络参数。 这种对于网络问题的调整通常是在当用户抱怨问题的时候，才来亡羊补牢。<strong>“ad hoc”</strong></p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170521234020853-204518874.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170521234030385-339956449.png" alt=""></p>
<p>Improving the quality of experience for applications requires <strong>having deep visibility</strong> into application behavior, <strong>identifying optimal paths</strong> and then <strong>automating constant changes to QoS settings</strong> and other factors.</p>
<p>提高应用程序的体验质量需要<strong>对应用程序行为有深刻的可视化</strong>，<strong>识别最佳路径</strong>，然后自动对QoS设置<strong>进行不断的更改</strong>等因素。</p>
<hr>
<p>商界领袖必须摆脱传统思维。</p>
<p>现在是软件定义的广域网的时候了。</p>
<hr>
<h1 id="III：软件定义的WAN"><a href="#III：软件定义的WAN" class="headerlink" title="III：软件定义的WAN"></a>III：软件定义的WAN</h1><p>A software-defined WAN can be thought of as the <strong>next generation of WAN architecture</strong> that is <strong>optimized for</strong> network-centric compute models such as <strong>cloud, mobile computing and IoT</strong>.</p>
<p>软件定义的广域网可以被认为是<strong>下一代的广域网架构</strong>，针对以网络为中心的计算模型，例如<strong>云</strong>、<strong>移动计算</strong>和<strong>物联网</strong>。</p>
<p>SD-WAN建立如下的重要概念上：开放性，敏捷性，编排，分析，安全性，（ openness, agility, orchestration, analytics and security）不断优化应用程序性能。 它使应用程序策略可用于自动化配置更改，移动流量或执行其他更改，以确保网络不断满足组织的需求。</p>
<p>实现的一个方法是将控制功能抽象为外部控制器。这提供了集中策略控制表达的优点，具有可扩展性。 其他好处包括零触摸部署（zero-touch deployment）以及简化配置和故障排除。</p>
<p>但是，根据控制器所在的位置，它可能会在分支机构执行安全性和性能和弹性方面带来挑战。另一种方法是将控制器作为网络基础设施的一部分<strong>分发</strong>（distributed）。 这提供了集中化的好处，但也可以实现分支机构更强的安全性，更高的可用性和更大的弹性以及更快地适应网络条件。</p>
<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>在2014年，开放网络用户组（the Open Networking User Group，ONUG）为SD-WAN定义了以下10个标准：</p>
<ol>
<li><p>分支机构能够在<strong>主动/主动配置</strong>（active/active configuration）中利用公共和私有WAN连接</p>
</li>
<li><p>能够在<strong>任何硬件</strong>上（包括商品基础设施） ，以物理或虚拟形式，部署客户端设备（CPE）</p>
</li>
<li><p><strong>安全混合广域网（hybrid WAN）架构</strong>，允许通过应用策略指定的私有和公共WAN路径上的动态流量工程功能，确保传输或应用层的网络WAN可用性和/或降级（network WAN availability and/or degradation at the transport or application layer）</p>
</li>
</ol>
<ol>
<li><p>根据安全政策和公司治理和合规政策的<strong>业务关键型和实时应用程序的可视化、优先级实现</strong> </p>
</li>
<li><p><strong>高可用性和弹性</strong>的混合广域网，以优化应用体验。</p>
</li>
<li><p><strong>第2层和第3层的互操作性</strong> </p>
</li>
<li><p><strong>管理仪表板</strong>，提供站点，应用程序和VPN级别的性能报告</p>
</li>
<li><p><strong>开放北向API</strong>，用于控制器访问和管理，以及将特定日志事件转发到网络事件相关管理器和安全事件管理器的能力</p>
</li>
<li><p><strong>零触摸部署功能</strong> 要在分支站点做改动，能直接在基础架构上进行最少的配置更改，以确保最高级别的敏捷性</p>
</li>
<li><p><strong>FIPS 140-2 认证</strong> 自动证书生命周期管理和报告。（automated certificate lifecycle management and reporting）</p>
</li>
</ol>
<blockquote>
<p>联邦信息处理标准（FIPS）出版物140-2（FIPS PUB 140-2），是用于批准加密模块的美国政府计算机安全标准，是加密模块的安全要求。 初步出版于2001年5月25日，最后更新于2002年12月3日。</p>
</blockquote>
<p>SD-WAN的定义不断发展，当提到什么是以及什么不是SD-WAN的时候，没有<strong>“事实上的标准”</strong></p>
<hr>
<h1 id="IV-Cisco’s-IWAN"><a href="#IV-Cisco’s-IWAN" class="headerlink" title="IV: Cisco’s IWAN"></a>IV: Cisco’s IWAN</h1><p>思科的智能广域网（Intelligent WAN，IW）可以被认为是广域网转型的平台。</p>
<p>业务可以从今天实施混合广域网开始，以获得互联网的成本优势，然后在以后迁移到SD-WAN，而不会增加分支机构和复杂性。 一旦SD-WAN到位，组织可以使用IWAN作为分支自动化和服务虚拟化的基础。</p>
<h2 id="IWAN启用以下WAN功能："><a href="#IWAN启用以下WAN功能：" class="headerlink" title="IWAN启用以下WAN功能："></a>IWAN启用以下WAN功能：</h2><ul>
<li>应用程序的体验优化: </li>
</ul>
<p>应用优化功能，如智能路径选择和广域网加速，以确保最佳的用户体验。</p>
<ul>
<li>安全访问：</li>
</ul>
<p>高级威胁检测可以阻止大多数威胁，但也可以快速识别发生的任何违规行为，然后快速缓解这些威胁。</p>
<ul>
<li>降低成本：</li>
</ul>
<p>与传输无关的广域网（Transport-independent WANs），宽带，3G / 4G无线或传统网络服务（例如，MPLS VPN）的<strong>任何组合</strong>都可以可以<strong>同时</strong>用于网络传输，以单一的共同网络设计，跨越每个传输。</p>
<ul>
<li>简便：</li>
</ul>
<p>网络服务的自动化和编排，以确保提供新服务和实施网络变更是由业务政策驱动的，并以数码公司所需的速度完成。</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170521234033853-1185431835.png" alt=""></p>
<p>一些参考链接：</p>
<ul>
<li><a href="http://www.cisco.com/c/en/us/products/security/dynamic-multipoint-vpn-dmvpn/index.html">动态多点VPN，Dynamic Multipoint VPN (DMVPN)</a></li>
<li><a href="http://docwiki.cisco.com/wiki/PfRv3:Home">思科性能路由，Cisco Performance Routing (PfRv3)</a></li>
<li><a href="https://en.wikipedia.org/wiki/FIPS_140-2">联邦信息处理标准（FIPS）出版物140-2（FIPS PUB 140-2）</a></li>
<li><a href="http://www.cisco.com/c/en/us/about/security-center/next-generation-cryptography.html">下一代加密：AES-GCM-256</a></li>
<li><a href="https://developer.cisco.com/site/apic-em/">APIC企业模块：APIC Enterprise Module (APIC-EM)</a></li>
</ul>
<h2 id="额外的优点："><a href="#额外的优点：" class="headerlink" title="额外的优点："></a>额外的优点：</h2><ul>
<li>全系统验证：</li>
</ul>
<p>为大多数客户部署SD-WAN可能是一项艰巨的任务。 为了简化部署，Cisco已经创建了许多技术设计指南，或Cisco认证设计（CVD）。</p>
<ul>
<li>端对端解决方案：（End-to-end solution）</li>
</ul>
<p>SDWAN的能力为客户带来了许多好处。 然而，组织还应考虑将软件定义网络的优势带到校园边缘（campus edge）（有线和无线）和数据中心。</p>
<ul>
<li>SDWAN以外的功能的平台：</li>
</ul>
<p>思科集成业务路由器（ISR）</p>
<ul>
<li>开放平台：</li>
</ul>
<p>作为一家公司，思科一直致力于开发基于标准的开放式平台，而SD-WAN也不例外。开放式战略使广泛的第三方生态系统能够与思科的IWAN进行互操作和增强。 这包括专家系统合作伙伴，如LiveAction，Glue Networks和Akama。</p>
<ul>
<li>能够将思科应用中心基础设施（Cisco Application Centric Infrastructure，ACI）扩展到WAN边缘：</li>
</ul>
<p>思科应用策略基础架构控制器企业模块（APIC-EM） </p>
<ul>
<li>自动化功能：</li>
</ul>
<p>思科APIC-EM控制器的IWAN应用程序可自动配置和部署高级IWAN功能，例如Cisco 4000系列集成服务路由器上的安全性，路径优化，增强的应用程序可见性和QoS。</p>
<ul>
<li><p>思科服务和大型合作伙伴生态系统</p>
</li>
<li><p>下一代的分支网…</p>
</li>
</ul>
<h1 id="V：结论和建议"><a href="#V：结论和建议" class="headerlink" title="V：结论和建议"></a>V：结论和建议</h1><p>如今，数字时代几乎在一夜之间创造了新的市场领导者。 企业和IT领导者必须注重建立一个动态，安全和敏捷的IT基础，以利用数字化。 将组织的广域网战略从传统架构转移到软件定义的广域网是构建敏捷IT基础的关键一步。</p>
<p>然而，SD-WAN市场仍在不断发展，对于这项技术来说，没有业界可以接受的定义。 因此，重要的是建立一个灵活的基础，今天可以部署哪些服务，但随着业务需求的变化以及随着SD-WAN的不断发展，将来可以扩展。 </p>
<p>任何希望利用数字转换功能的组织都应该发展成为SD-WAN的首要任务。</p>
<p>接下来的步骤，ZK建议如下：</p>
<ul>
<li>评估解决方案提供商今天能够启用SD-WAN服务的能力，但确保将来满足业务需求。</li>
</ul>
<p>例如，思科的IWAN采用架构方式构建SD-WAN，并使企业能够从网络自动化开始; 但是，它允许他们走过这个阶段，发展分支机构并转换到虚拟服务模型，以便将所有应用程序或服务交付给所有用户，无论它们位于何处。</p>
<ul>
<li>在构建SD-WAN时考虑实时流量。</li>
</ul>
<p>实时流量应用程序（如语音和视频）是通过WAN时最难运行的。 在构建下一代WAN时，必须考虑这些类型的应用程序的要求</p>
<ul>
<li>Shed conventional thinking around network design.</li>
</ul>
<p>广域网的设计涉及许多因素，IT领导者今天必须愿意以不同的角度去思考。</p>
<p>例如，多年以前，组织永远不会考虑使用宽带互联网或蜂窝业务进行业务连接。 而在今天，我们可以使用<a href="https://zh.wikipedia.org/wiki/DSL">DSL</a>、有线、无线4G连接分支机构。 <strong>SD-WAN不是传统的WAN</strong>，对于IT行业的领导者来说，不要因为历史偏见（historical biases）而忽视（discount）可能的解决方案是很重要的。</p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title>李敖先生05年北大演讲内容摘选</title>
    <url>/2019/10/05/In-memory-of-Li-Ao/</url>
    <content><![CDATA[<p>有人说，为了国家，请你牺牲自己的个人自由。但胡适却说，争取你个人的自由，就是争取国家的自由。一个真正的开明进步的国家，不是由一群奴隶奴才造成的，而是由有独立个性，自由思想的人造成的。</p>
<p>富兰克林：“哪里有自由，哪里就是我的国家”<br>李敖：“哪里是我的国家，我就要使哪里变得自由”</p>
<p>什么是自由主义？两个部分：1 反求诸己。2 反求诸宪法。当宪法落实的时候，自由主义就没有了意义。</p>
<ol>
<li>郑成功 2. 北大 3. 俄国女人卖娼赚钱支持革命，但自认为是处女（对于性的态度）</li>
</ol>
<p>当我们自己困扰的时候，重要的问题是自己如何解开。自由主义最重要的是你的心灵能否得到解放。如果你的心灵是郑成功式的，那你自己会把自己困死。</p>
<p>跟政府的关系：</p>
<ol>
<li>政府这么坏，我不活了，我嗝了。（屈原）</li>
<li>我跑了（孔子：危邦不入 乱邦不居）</li>
<li>我猫起来（隐士，诸葛亮）</li>
<li>我怂了（我怕你，我不跟你玩了）</li>
<li>我火了，和你干上了。（人民忍无可忍的时候，全世界任何政府在这个时候都是王八蛋）</li>
</ol>
<p>不能聪明点吗？这五个方法都是消极的，你不能把政府摆平，自己也跟着受害。李敖式写书（著作等身，且许多书被封禁）。项羽，李自成可以革命，是因为他们手里的武器和统治者手里的差不多。所以说，人民要自由，人民也要聪明。</p>
<p>什么东西开放言论自由就更安全？性。丹麦开放A片那一年，强奸罪减少16%，偷窥犯减少80%。</p>
<p>擦边球！很多事情要考虑对方立场。有些话不能说，但有的人可以打擦边球，把这个话说出来，还不出事。这是一个非常重要的能力！争取言论自由，就要靠这种能力。</p>
<p>“我不以为它是假的，只要我们认真，它就是真的”<br>“别以为它是假的，当我们努力，它就是真的。别以为他们在骗我们，当我们认真，他们就骗不了我们”</p>
<p>鸦片战争后，民族英雄林则徐做了替罪羊。林则徐写了一封信给友人，面对英国人，关公岳飞都束手无策。这是真相，可是却不能发表，因为如果发表，他们会说我不爱国。</p>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之类继承和动态内存分配</title>
    <url>/2017/06/07/Inheritance-with-new/</url>
    <content><![CDATA[<p>如果基类使用的动态内存分配，并重新定义了赋值和复制构造函数，这将怎样影响派生类的实现？</p>
<h1 id="情况1：派生类不使用new"><a href="#情况1：派生类不使用new" class="headerlink" title="情况1：派生类不使用new"></a>情况1：派生类不使用new</h1><p>假设基类在构造函数中使用new，析构函数、复制构造函数和重载赋值运算符也做了相应处理。现在，从base类派生出一个类，<strong>这个派生类不使用new</strong>，只是包含一些新的数据而已。那么就<strong>不需要</strong>为派生类定义显式析构函数、复制构造函数、赋值运算符。</p>
<ol>
<li>默认析构函数合适吗？合适，因为派生类没有执行任何特殊的new操作，所以先调用派生类的默认析构函数，再调用基类的析构函数，很ok。</li>
<li>复制构造函数合适吗？合适。以前介绍过，默认复制构造函数执行的成员浅式复制对动态内存分配是不合适，但对于没有new操作的派生类是合适的。对于派生类复制，派生类的复制构造函数使用显示的基类构造复制构造函数来赋值派生类对象的基类部分数据。因此，默认复制构造函数对于新的派生类成员是合适的。</li>
<li>同理，默认赋值运算符也合适。</li>
</ol>
<p>派生类对象的这些属性也适用于包含其他类对象成员的类。例如实现<code>Stock</code>类时，可以用<code>string</code>类而不是<code>char *</code>来存储公司名称。众所周知<code>string</code>类有采用动态内存分配，而<code>Stock</code>的默认构造函数不会产生问题，我们现在知道了原因——默认构造函数使用<code>string</code>的复制构造函数来复制<code>company</code>成员，<code>Stock</code>的默认赋值运算符使用<code>string</code>的赋值运算符来给<code>company</code>对象赋值，而<code>Stock</code>的析构函数会自动调用<code>string</code>类的析构函数。</p>
<h1 id="情况2：派生类使用new"><a href="#情况2：派生类使用new" class="headerlink" title="情况2：派生类使用new"></a>情况2：派生类使用new</h1><p>在这种情况下，必须为派生类定义显示析构函数、复制构造函数、赋值运算符。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含动态内存分配的类继承</span></span><br><span class="line">#ifndef _DMA_H_</span><br><span class="line">#define _DMA_H_</span><br><span class="line">#<span class="keyword">include</span>&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> baseDMA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">char</span> *label;</span><br><span class="line">	<span class="built_in">int</span> rating;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	base<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">l</span> = <span class="string">&quot;null&quot;</span>, <span class="params">int</span> <span class="params">r</span> = 0)</span>;</span><br><span class="line">	base<span class="constructor">DMA(<span class="params">const</span> <span class="params">baseDMA</span> &amp; <span class="params">rs</span>)</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~base<span class="constructor">DMA()</span>;</span><br><span class="line">	baseDMA &amp; operator=(const baseDMA &amp; rs);</span><br><span class="line">	friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const baseDMA &amp; rs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> lacksDMA :public baseDMA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	enum &#123; COL_LEN = <span class="number">40</span> &#125;;</span><br><span class="line">	<span class="built_in">char</span> color<span class="literal">[COL<span class="identifier">_LEN</span>]</span>;</span><br><span class="line">public:</span><br><span class="line">	lacks<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">c</span> = <span class="string">&quot;blank&quot;</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">l</span> = <span class="string">&quot;null&quot;</span>, <span class="params">int</span> <span class="params">r</span> = 0)</span>;</span><br><span class="line">	lacks<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">c</span>, <span class="params">const</span> <span class="params">baseDMA</span> &amp; <span class="params">rs</span>)</span>;</span><br><span class="line">	friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const lacksDMA &amp; rs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> hasDMA :public baseDMA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">char</span><span class="operator"> * </span>style;</span><br><span class="line">public:</span><br><span class="line">	has<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">c</span> = <span class="string">&quot;none&quot;</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">l</span> = <span class="string">&quot;null&quot;</span>, <span class="params">int</span> <span class="params">r</span> = 0)</span>;</span><br><span class="line">	has<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">s</span>, <span class="params">const</span> <span class="params">baseDMA</span> &amp; <span class="params">rs</span>)</span>;</span><br><span class="line">	has<span class="constructor">DMA(<span class="params">const</span> <span class="params">hasDMA</span> &amp; <span class="params">hs</span>)</span>;</span><br><span class="line">	~has<span class="constructor">DMA()</span>;</span><br><span class="line">	hasDMA &amp; operator=(const hasDMA &amp; hs);</span><br><span class="line">	friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const hasDMA &amp; hs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#<span class="keyword">include</span>&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">baseDMA::base<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">l</span>, <span class="params">int</span> <span class="params">r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	label = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[<span class="identifier">std</span>::<span class="identifier">strlen</span>(<span class="identifier">l</span>) + <span class="number">1</span>]</span>;</span><br><span class="line">	std::strcpy(label, l);</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA::base<span class="constructor">DMA(<span class="params">const</span> <span class="params">baseDMA</span> &amp; <span class="params">rs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	label = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[<span class="identifier">std</span>::<span class="identifier">strlen</span>(<span class="identifier">rs</span>.<span class="identifier">label</span>) + <span class="number">1</span>]</span>;</span><br><span class="line">	std::strcpy(label, rs.label);</span><br><span class="line">	rating = rs.rating;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA::~base<span class="constructor">DMA()</span></span><br><span class="line">&#123;</span><br><span class="line">	delete<span class="literal">[]</span> label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA &amp; baseDMA::operator=(const baseDMA &amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (this<span class="operator"> == </span>&amp;rs)</span><br><span class="line">		return *this;</span><br><span class="line">	delete<span class="literal">[]</span>label;</span><br><span class="line">	label = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[<span class="identifier">std</span>::<span class="identifier">strlen</span>(<span class="identifier">rs</span>.<span class="identifier">label</span>) + <span class="number">1</span>]</span>;</span><br><span class="line">	std::strcpy(label, rs.label);</span><br><span class="line">	rating = rs.rating;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const baseDMA &amp;rs)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Label: &quot;</span> &lt;&lt; rs.label &lt;&lt; std::endl;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Rating: &quot;</span> &lt;&lt; rs.rating &lt;&lt; std::endl;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lacksDMA::lacks<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">c</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">l</span>, <span class="params">int</span> <span class="params">r</span>)</span></span><br><span class="line">	:base<span class="constructor">DMA(<span class="params">l</span>,<span class="params">r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	std::strncpy(color, c, <span class="number">39</span>);</span><br><span class="line">	color<span class="literal">[<span class="number">39</span>]</span> = <span class="character">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lacksDMA::lacks<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">c</span>, <span class="params">const</span> <span class="params">baseDMA</span> &amp; <span class="params">rs</span>)</span></span><br><span class="line">	:base<span class="constructor">DMA(<span class="params">rs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	std::strncpy(color, c, COL_LEN - <span class="number">1</span>);</span><br><span class="line">	color<span class="literal">[COL<span class="identifier">_LEN</span> - <span class="number">1</span>]</span> = <span class="character">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const lacksDMA &amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; (const baseDMA &amp;)rs;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Color: &quot;</span> &lt;&lt; rs.color &lt;&lt; std::endl;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hasDMA::has<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">c</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">l</span>, <span class="params">int</span> <span class="params">r</span>)</span></span><br><span class="line">	:base<span class="constructor">DMA(<span class="params">l</span>, <span class="params">r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	style = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[<span class="identifier">std</span>::<span class="identifier">strlen</span>(<span class="identifier">c</span>) + <span class="number">1</span>]</span>;</span><br><span class="line">	std::strcpy(style, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::has<span class="constructor">DMA(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">s</span>, <span class="params">const</span> <span class="params">baseDMA</span> &amp; <span class="params">rs</span>)</span></span><br><span class="line">	:base<span class="constructor">DMA(<span class="params">rs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	style = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[<span class="identifier">std</span>::<span class="identifier">strlen</span>(<span class="identifier">s</span>) + <span class="number">1</span>]</span>;</span><br><span class="line">	std::strcpy(style, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::has<span class="constructor">DMA(<span class="params">const</span> <span class="params">hasDMA</span> &amp; <span class="params">hs</span>)</span></span><br><span class="line">	:base<span class="constructor">DMA(<span class="params">hs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	style = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[<span class="identifier">std</span>::<span class="identifier">strlen</span>(<span class="identifier">hs</span>.<span class="identifier">style</span>) + <span class="number">1</span>]</span>;</span><br><span class="line">	std::strcpy(style, hs.style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::~has<span class="constructor">DMA()</span></span><br><span class="line">&#123;</span><br><span class="line">	delete<span class="literal">[]</span>style;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA &amp; hasDMA::operator=(const hasDMA &amp; hs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (this<span class="operator"> == </span>&amp;hs)</span><br><span class="line">		return *this;</span><br><span class="line">	baseDMA::operator=(hs);</span><br><span class="line">	delete<span class="literal">[]</span>style;</span><br><span class="line">	style = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[<span class="identifier">std</span>::<span class="identifier">strlen</span>(<span class="identifier">hs</span>.<span class="identifier">style</span>) + <span class="number">1</span>]</span>;</span><br><span class="line">	std::strcpy(style, hs.style);</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const hasDMA &amp; hs)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; (const baseDMA &amp;)hs;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Style: &quot;</span> &lt;&lt; hs.style &lt;&lt; std::endl;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="上述代码注意点："><a href="#上述代码注意点：" class="headerlink" title="上述代码注意点："></a>上述代码注意点：</h1><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>基类使用了动态内存分配，所以声明包含了使用new时所需要的特殊方法：</p>
<p>析构函数：<code>virtual ~baseDMA();</code></p>
<p>复制构造函数：<code>baseDMA(const baseDMA &amp; rs);</code></p>
<p>重载赋值运算符：<code>baseDMA &amp; operator=(const baseDMA &amp; rs);</code></p>
<h2 id="基类使用new，派生类不使用new"><a href="#基类使用new，派生类不使用new" class="headerlink" title="基类使用new，派生类不使用new"></a>基类使用new，派生类不使用new</h2><p>lacksDMA类，没有使用动态内存分配，所以无需提供特殊方法。</p>
<h2 id="基类-派生类析构函数"><a href="#基类-派生类析构函数" class="headerlink" title="基类/派生类析构函数"></a>基类/派生类析构函数</h2><p>这里有两个派生类，派生类析构函数会自动调用基类的析构函数，所以<strong>各自的职责</strong>就是对派生类构造函数执行的工作进行清理。<code>hasDMA</code>类释放<code>style</code>，<code>baseDMA</code>类释放<code>label</code>。</p>
<h2 id="派生类如何访问基类的友元？"><a href="#派生类如何访问基类的友元？" class="headerlink" title="派生类如何访问基类的友元？"></a>派生类如何访问基类的友元？</h2><p>作为派生类的友元，<code>&lt;&lt;</code>重载函数，不是基类的友元，那怎么访问基类成员<code>label</code>和<code>rating</code>呢？答案是使用<code>baseDMA::operator&lt;&lt;()</code>。因为友元不是成员函数，不能通过作用域解析运算符来指示要使用哪个函数，所以这里的处理方法是使用强制类型转换，以便通过匹配正确原型来使用正确的函数。</p>
<h2 id="复制构造函数也用上了成员初始化列表"><a href="#复制构造函数也用上了成员初始化列表" class="headerlink" title="复制构造函数也用上了成员初始化列表"></a>复制构造函数也用上了成员初始化列表</h2><p><code>hasDMA</code>类的复制构造函数只能访问派生类的数据，所以它必须调用<code>baseDMA</code>的复制构造函数来处理共享的基类数据.</p>
<h2 id="特别需要注意的一点：派生类的赋值运算符"><a href="#特别需要注意的一点：派生类的赋值运算符" class="headerlink" title="特别需要注意的一点：派生类的赋值运算符"></a>特别需要注意的一点：派生类的赋值运算符</h2><p><code>baseDMA::operator=(hs);</code>实际上该语句的语义是：<code>*this = hs;</code>也就是说，使用基类的赋值运算符，来复制派生类对象的基类部分的数据。为使用了new的派生类设计赋值运算符时，必须给类的每个成员都提供赋值运算符，<strong>而不仅仅是新的</strong>。</p>
<h2 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h2><p>当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符，都必须<strong>使用相应的基类方法</strong>来处理基类元素。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>Internet 校验和的数学性质</title>
    <url>/2018/02/10/Internet-Checksum-and-Abel-Group/</url>
    <content><![CDATA[<p>Internet 校验和（Checksum）<strong>仅计算头部的正确性</strong>，这一点很重要，这意味着 IP 协议<strong>不检查 IPv4 packet 有效载荷部分的数据正确性</strong>。为了保证有效载荷部分的正常传输，其他协议必须通过自己的协议数据完整性检测机制来保护重要数据。我们可以看到在封装在 IP 的几乎所有协议（UDP、TCP、ICMP、IGMP）在自己头部中都有一个涵盖头部数据的校验和。</p>
<p><strong>IPv6 放弃了校验和字段。</strong>原因如下：位错误带来的后果一般是数据被投递到错误的目的地、数据的来源显示错误、有效载荷中的位错误。由于位错误比较少见，而且其他上层协议的字段提供了对有效载荷部分的更有力的确保正确性的机制，因此IPV6删除了这个字段。</p>
<p>特别的，当 IPv4 的数据包经过一台路由器时，TTL 字段减一会导致头部校验和的重新计算，即<strong>每一跳路由都会导致校验和的重新计算。</strong></p>
<p>校验和检测失败时 IPv4 <strong>将直接丢弃接收到有误的数据包不会生成差错信息</strong>，更高层需要以某种方式检测丢失的数据报并在必要时重新传输。</p>
<h1 id="internet校验和的内容"><a href="#internet校验和的内容" class="headerlink" title="internet校验和的内容"></a>internet校验和的内容</h1><h2 id="Internet-校验和的内容如下"><a href="#Internet-校验和的内容如下" class="headerlink" title="Internet 校验和的内容如下"></a>Internet 校验和的内容如下</h2><ol>
<li>将校验和的字段设置为零。</li>
<li>将整个<strong>头部</strong>（仅有 header 部分）认为是一个 16 bits integer 的一个序列。计算这一系列的 16 位整数的<strong>反码和</strong>。将运算结果存放到校验和字段内。</li>
<li>收到 IPv4 packet 时，对整个 header （校验和字段不是 0 而是有填充）进行相同的计算。反码和结果应该为 0 ，代表数据无误。若非 0 ，则代表数据有误</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>例如要发送的 packet 内容是 ：<strong>E3 4F 23 96 44 27 99 F3 【00 00】</strong> （checksum 字段清零）</p>
<p>将整个序列看成 16 位的整数，一个十六进制数是 4 bits，所以要看成 4 个十六进制数为一个整数。</p>
<blockquote>
<p>二进制反码求和:从低位到高位逐列进行和计算,如果最高位(16位)进位,则得到的结果加1,一直循环到最高位没有进位为止.最后把得到的结果取反.</p>
</blockquote>
<p>可以用如下的简单方法求<strong>反码和</strong>：对几个数进行补码和，也就是我们通常所用的加法，然后将进位的数字加到最低位。</p>
<p>最后把结果取反。</p>
<ul>
<li>补码和：E34F + 2396 + 4427 + 99F3 = 1E4FF</li>
<li>反码和：进位的数字加到最低位：E4FF + 1 = E500</li>
<li>取反：checksum = ~(E500) = 1AFF</li>
</ul>
<p>则填充 checksum 之后发送的 packet 内容变成：<strong>E3 4F 23 96 44 27 99 F3 【1A FF】</strong></p>
<p>接收方检测过程：计算包括 checksum 在内的整个 packet 的反码和，再取反。</p>
<ul>
<li>补码和：E34F + 2396 + 4427 + 99F3 + 1AFF = 1FFFE</li>
<li>反码和：进位的数字加到最低位：FFFE + 1 = FFFF</li>
<li>取反结果 = ~(FFFF) = 0</li>
</ul>
<p>若结果为 0 ，说明数据在传输过程中没有发生变动。若结果不为 0 ，则数据在传输过程中有变动、受损。</p>
<h2 id="数学性质"><a href="#数学性质" class="headerlink" title="数学性质"></a>数学性质</h2><p>这里运用到离散数学中关于群论的知识点。</p>
<p>集合 G 不为空集，在 G 上的二元运算满足封闭性、结合律、存在单位元、每个元素都有逆元，则称<G, +=""> 为群，若满足交换律，则称群 G 为阿贝尔群。</G,></p>
<p>可以通过观察发现，16 位整数的一个十六进制值序列集合 V = {0001,0002，…，FFFF} ，定义 + 为二进制反码和运算，<code>&lt;V, +&gt;</code> 构成<strong>阿贝尔群</strong>。</p>
<ul>
<li>对于任意的 X,Y in V, (X + Y)  in V [封闭]</li>
<li>对于任意的 X,Y,Z in V, X + (Y + Z) = (X + Y) + Z [可结合]</li>
<li>对于任意的 X in V, e + X = X + e = X ，e = FFFF [单位元 e 是 FFFF]</li>
<li>对于任意的 X in V, 存在 X′ in V 使 X + X′ = e [每个元素都存在逆元]</li>
<li>对于任意的 X,Y in V, (X + Y) = (Y + X) [交换律]</li>
</ul>
<p>事实上，观察构造 checksum 的过程我们可以得知：checksum 其实是前面 4 个 16 bit integer 做二进制反码和运算（下文用 ‘+’ 代替）的结果的<strong>取反</strong>。<strong>取反</strong>这个操作特别的有意思，因为你对任何一段长度为 n 的二进制数据取反，与原来的数据相加，结果一定是长度为 n 的 1 串。</p>
<p>例如：1011，取反是 0100。1011 + 0100 = 1111</p>
<p>所以，对于 16 bit integer，这个结果一定是 FFFF。<strong>FFFF</strong> 在我们前面的分析中，就是阿贝尔群<code>&lt;V, +&gt;</code>的<strong>单位元</strong>！所以我们可以得出一个结论：在构造 packet checksum 时，checksum 其实就是其余数据在群<code>&lt;V, +&gt;</code>中的<strong>逆元</strong>！！</p>
<p>当收到 packet 的一方，在做验证的时候，因为前面的 4 个 16 bit integer 和后面这 2 个字节的 checksum 是互为<strong>逆元</strong>的，所以对它们进行 + 的运算结果<strong>一定是单位元 FFFF</strong>。而由于整个运算集合构成了一个群，因此<strong>确保了每一个元素都有一个对应的逆元，也就证明了：如果检验和检测正确，意味着数据完好，如果出错，意味着数据受损。</strong></p>
<p>关于这个十六位整数的十六进制值序列集合，非常让人感兴趣的一点是 <strong>其中没有 0000</strong>。这是为什么呢？我们考虑一下，如果将数字0000放入集合，则 <code>&lt;V, +&gt;</code> 不再是一个阿贝尔群。</p>
<p>0000 显然可以作为单位元 e。对于群，每个元素都要有一个逆元，取随意的元素 AB12 来说，需要有一个逆元 X′ + AB12 = 0000，这样的 X′ 在<code>&lt;V, +&gt;</code>是不存在的。因此，我们需要排除 0000 ，使得<code>&lt;V, +&gt;</code> 构成阿贝尔群。</p>
<p>那么<strong>排除 0000</strong>的道理又何在呢？首先，排除 0000 使得<code>&lt;V, +&gt;</code>是一个阿贝尔群，之前已经说过了。第二条理由是，任何一个合法的 IPv4 包，<strong>不可能所有的字节都为 0</strong> 。如果要将 0000 纳入群众，则是考虑存在一个合法的 IPv4 包，除了 checksum 之外的字节都为 0 的情况，而这种情况 </p>
<ol>
<li>会导致<code>&lt;V, +&gt;</code> 不再是一个阿贝尔群。 </li>
<li>实际是不存在的，不存在任何一个合法的 IPv4 头部全是 0 的情况。</li>
</ol>
<p>因此我们可以排除 0000，由此推断出 Internet 校验和的群属性。</p>
<hr>
<p>参考链接：<a href="http://blog.csdn.net/qq_34369618/article/details/60603867">http://blog.csdn.net/qq_34369618/article/details/60603867</a></p>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈内卷化在教育方面对中国人潜移默化的影响</title>
    <url>/2019/12/09/Involution/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/12/09/PTx7JyGlms5LIa4.jpg" alt="高考的难度"></p>
<p>今天要聊的内容是内卷。我最近对这个词有了一定的思考并且积累了一些身边的例子，认为这是一个值得说的话题。</p>
<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>我们先来讲讲这个词的起源。这个词的起源是来自于美国人类学家克利福德·格尔茨，他对于印度尼西亚的小岛做的研究中的出来的。英文为 Involution，为 evolution（进化）的反义词，主要含义是内卷、内缠、退化等。格尔茨在他对印度尼西亚小岛的研究中观察到，当地人主要产业是农业，当地人收成之后，会把自己的所有产能再次投入到土地上继续发展农业。显而易见的是，土地的产能是有限的，人对土地的开发投入是会到一个极限的，所以到了一个阶段之后，人们再怎么加大投入到农业上，产能也不会有更大的提高。此外，在没有外部因素介入的条件下，当地社会不可能有什么翻天覆地的变化或者进步。总的来说，就是走进了死胡同，而且靠自身再也无法有大的提升。在格尔茨的书中提出，“印度尼西亚爪哇人因缺少资本、缺乏剩余劳动力转移的途径、加之行政性障碍，无法将农业向外延扩展，致使劳动力不断填充到有限的水稻生产之中”的这一过程，格尔茨将其概括为“农业内卷化”[1]。这就是内卷化这个概念第一次提出来的时候的样子。这个词传到中国来之后，被一些中国学者应用于对于中国社会方方面面的研究，算是提及程度较高的概念了。今天我想谈的是我对这一个现象在中国教育中的表现的观察，和我认为的这对人潜移默化的影响。</p>
<h1 id="先讲两个故事"><a href="#先讲两个故事" class="headerlink" title="先讲两个故事"></a>先讲两个故事</h1><blockquote>
<p>记者采访一个放羊的男孩，曾留下这样一段经典对话：<br>“为什么你要放羊？”<br>“为了挣钱。”<br>“为什么你要挣钱？”<br>“因为我想娶媳妇”<br>“为什么你要娶媳妇？”<br>“生孩子。”<br>“那你生了孩子要让他做什么？”<br>“放羊。”[2]</p>
</blockquote>
<p>第二个故事是这样的（这是一位前辈跟我讲的）。大概二三十年前，那个时候大家都是真正的快乐学习，快乐高考。大家在学校并不需要很费力地刷题做卷子，大家很平常地学习，到了考场上就凭自己的智商去考试，这样大家最后都能进入和自己智商相符的大学——智商最高的一批人去最好的大学，智商中等的去中等大学，普通的学生去普通大学，诸如此类——而且最重要的是，大家的学生时代没有很重的负担。但是，让我们设想一下，突然有一年，智商中等的同学，发现通过做卷子能够提升成绩，于是他做了二十套高考历年卷。因为他刷了这些卷子，于是“他在应试教育体制下的做题能力”就提升了，于是在最后的高考中，这位智商中等的同学去了最好的大学。过了两三年，智商最高的那批人突然发现不对了。我智商是比较高的啊？我怎么考试成绩考不过他呢？噢，原来如此，原来他是做了卷子的。本来是智商最高的那批人可以去最好的大学的，但是现在这个名额被智商中等的人抢走了。没办法了，那智商高的人为了在高考中胜出（他原本就是智商高的人），于是乎他也做了二十套卷子。故事到这里就基本结束了，可以看出来，智商高中低的人最后到还是去到了和自己水平相符合的学校，但是唯一变化的就是每个人都多做了二十套卷子。</p>
<p>我并不是在评判这个“第一个做卷子”的人，而是尝试分析这一个体制化问题的起源。因为是体制化的问题，所以对于个人来说，可能没有太好的办法做什么改变，也没有多少选择。请看我接下来的分析吧。</p>
<h1 id="何为内卷及其各种表现和危害"><a href="#何为内卷及其各种表现和危害" class="headerlink" title="何为内卷及其各种表现和危害"></a>何为内卷及其各种表现和危害</h1><p>不知道诸位对这个现象有何思考？这可以说是我国目前教育体系中最司空见惯的现象了，所以可能并没有人觉得有任何问题，毕竟大家都是这样来的，这又怎么联系到今天的标题——内卷化呢？我个人对适用于中国教育体系范畴的内卷化有一个定义。我自己给内卷下的定义是：<strong>没有扩展自己知识的边界（没有在学新的东西），而是在知识的边界以内，为了竞争，提高考试成绩，而做大量的、重复的练习。</strong>举个最简单的例子，一般而言，在中国，会在高一高二两年内就把高中三年的知识都学完，然后高三做一年的卷子。在高三的这一年中，你并没有学新的东西，所以你知识的边界并没有往前推移，你只是在知识的边界内，做不断的、重复的、大量的练习。为什么呢？是为了提高自己的做题技巧，为了得到一个好成绩。</p>
<p><strong>这个现象其实是有害的。</strong>我问大家一个问题，为什么美国普通人的数学并不好，但是应该没有人会认为美国的科技不先进吧？为什么中国人学着全世界最难的数理化，但是诺贝尔的自然科学奖很少有中国人的身影呢？这个问题，我在知乎上看过一个回答。作者是付云皓，是 IMO (International Mathematical Olympiad，国际数学奥林匹克竞赛)的金牌选手，他写了这一篇长长的回答，给了我很深的启发，链接贴在下面的参考链接内大家可以去看一下[3]。我总结一下他的观点，他的中心论点有两个：</p>
<ol>
<li>美国普通人的数学水平是很差，但是<strong>美国的天才可以受到非常好的数学教育。</strong></li>
<li>在中国，某些其实智商不算最高，也不是非常适合数学竞赛的孩子，出于这样那样的原因，被家长或者老师塞到了竞赛班。他们为了竞赛的初赛、省赛奖状，可能就是通过大量刷题的方式来学习、并提高成绩的。而中国真正的天才们，为了在与这样的同龄人竞争中不至于一开始就被刷掉，因此也不得不去大量刷题，具体逻辑可以参考上面那个三十年前高中低智商参加高考的故事。相反，美国的天才们可以一直不断学习，也就是不断扩展自己的知识边界。他们<strong>完全不需要做大量的、重复的练习，而这种过早地大量做题被证明是会在某种程度上扼杀孩子的创造力和天才的。</strong></li>
</ol>
<p>付云皓的文章很长，但是看完之后，我觉得上述这两点真的是肺腑之言。那么我就开始思考一个问题，<strong>为什么会内卷？内卷的原因是什么？</strong>这个问题我没有思考很久就得出了答案——<strong>资源少</strong>。资源少，为了得到优质的资源，<strong>那就要争</strong>，那就要抢。<strong>既然要争，就必然会内卷</strong>。在中国，世界排名前一百的大学，只有清华北大，但是清北一年招多少本科生呢？而美国的top100，基本上约等于世界top100。这是一种多么大的差距？就是打比方说，不知道各位有没有想过，假设中国有一百所清华北大那样的学校，会怎么样？或者说，如果中国的总人口只有三亿（这是美国的人口），会怎样？中国高中生的学习压力会不会小很多？比如说，在福建，如果你想上一个本地211福州大学，你也需要在本省二十万考生中排名七八千名才能选到比较不错的专业，这也已经在百分之五以内了。就算是普通一本，也要起码前百分之二十以内。这里我想定义得清楚一点，就是你的孩子的“在应试教育体制下的考试能力排在全体同龄人的前百分之五”，甚至还要更少，因为你还要算上上中专的、没有上高中的同龄人。如果你学过概率论，姑且假设“你的孩子的在应试教育体制下的考试能力”是一个随机变量，请问这个随机变量是在前百分之五、前百分之二十的概率高，还是在后百分之八十的概率高？答案不言而喻吧？更何况就算是985211，那教育质量好不好，也得打一个问号。</p>
<p>在这里我就联想到我所经历过的大学教育。大多数的高中生经历了12年的应试教育，自然还是把这一套思路延续到大学。对于大一那一年，说实话学习体验与我所想相差甚远，基本上还是跟高中没什么两样。我就举线性代数这门课为例子吧，有多少人学懂了？知道为什么要有矩阵？线性空间的意义是什么？大多数人只是懂得“特征值怎么算”而已，而根本不知道“为什么要有特征值”。这就是<strong>做题家</strong>。大多数人每一周的课外学习时间，我看不超过应付下一周的书面作业所花的半小时而已。每门课对于大多数同学的意义，就是最后变成了教务系统上的一个代表成绩的数字而已。教材、教学、课程质量之差，让我觉得我没有学到真正的知识，而是为了考试在应付。再说说英语课吧，大一时我上了两位国内英语老师的课（之后我都选择选外教的课了）。第一位老师的课我觉得很不错，每节课都听的津津有味，上课做笔记、课前预习、复习、做题目，整个课程下来我都觉得非常轻松而且主动性很强，老师的教学水平非常高，我能学到很多东西，说实话这里面有百分之八十的功劳是老师的，期末考也考得不错，82。之后的第二位上课上的巨烂，我一点听的兴趣都没有，只是在期末考前把那些考试范围里的题做了，反倒是考了更高的成绩 86。这方面（教学这么差、成绩体现不出来）倒让我觉得大学是很个奇怪的地方。我觉得，掌握了考试方法就行，成绩不会差，倒是真的能学到什么是个疑问。</p>
<p>再说回高考。福建，已经算是高考难度 easy mode 的省份了。看看河北，环首都贫困带，一年七十万考生，清华北大录取的人数是最少的。<strong>自从有了衡水中学，整个河北的考生都不得安宁了</strong>。这里的逻辑和最开始那个高中低智商考生的故事的逻辑是一摸一样的。河北省高考，七百分以上的考生有一两百人，你考个六百四五十分都全省一两万名。如果你投胎投到了河北、河南、山东、四川这种人口大省，那真的是绝望。而我与来自北京的朋友聊高中生活，他说他高一的时候下午三四点就放学了，而我高一就要晚自习到九点半；他高三的时候每天也就晚自习到八点半，而我要到十点半。其实我并没有在抱怨这种不公平，而我在思考的是，如果各位不考虑现实因素诸如到底有没有能力或者有没有钱或者户口政策之类的，如果你真的，真的可以有选择的话，你会想让你的孩子出生在山东河南河北四川还是福建？你会想让你的孩子出生在福建还是出生在北京？你会想让你的孩子出生在中国还是美国？</p>
<p>举国外的例子。对于美国大学，都是申请制的。你把你的所有材料递交给学校，材料一般包括成绩单、个人陈述、简历、推荐信、和标准化语言（所谓的雅思托福GRE）考试成绩。学校根据你的这些材料来决定录不录取你。语言的标准化考试，首先第一个，不是一考定终身。学校会规定一个录取要求，比如 80 minimum，90 recommended，就是我们学校最低要求托福 80 分，推荐你考到 90。如果你一次考不到，那么你可以考多次直到你达到这个要求。此外，这个标准化考试的分数线，其意义和中国的本一线差别是很大的。在国内，我可以上某大学，就是因为我实实在在地挤掉了另一个不能上该大学的人，我才能上的。本一线划在某个分数，就是按照招生计划本一这个批次一共招多少人，那个最后一名的分数就是那个分数线。而美国学校划的这个托福分数线，意思就是，如果你的托福考到这个分数，就达到了语言方面的要求了。而且比方说这个 90 recommended，你也不一定要 90 以上，也不需要分考越高越好（而中国什么考试都是分越高越好），因为美国大学会在各个方面考察你，就算你托福成绩不是特别高，但如果你其他方面（竞赛、实习、科研经历、推荐信等）很出色，学校还是会考虑要你的。相反，他们对于标准化考试并不非常看重，因为标准化考试体现的就是英文水平，仅此而已，学校认为 <strong>good enough 就足够了，并不需要做到 perfect</strong>，这一点在中国是做不到的，因为你需要挤掉别人才能上大学，所以你需要考的越高越好。此外，申请国外的学校，只要你给的起申请费，你想申请多少所学校都可以。等你把材料都递给学校，学校决定给不给你offer。等你接到offer了，是你可以决定去或者不去（你可能有多个offer）。</p>
<p>再来说说国内的考研。首先，你只能报考某一个学校，你需要通过初试的笔试，初试过了之后还有复试。鄙人曾经也是有想过考研的，查过 2017 年某大学报录比，我就读的专业那一年该校考研招收名额约 100 人，有 1600 人报名，留 400 人进复试，复试比有 4：1，报录比 16：1…… 我的导师大概就是十几二十年前参加的考研，据他的说法，他“考前复习了两个月就考上了”。而在当下 2019 年，大多数人准备考研都会花整个大三下和大四上学期，时间跨度从当年的二三月份至十二月份。更有甚者，从大学刚一入学，就立下考研的目标和志向，让人啼笑皆非。试问，高等教育的目标是考研吗？因为大多数考研人花的这八九个月时间，大部分的时间会用在做微积分题目上，真的是把二三十年的考研真题都做遍了，微积分做题的奇技淫巧、边边角角都研究透透了。我想问，会不会做这些千奇百怪的微积分，到底和一个人的科研能力有多大的关系？和一个人能在研究生阶段取得成功有多大的关系？考研初试中另外的科目也是纯粹的浪费生命的存在。举个例子，中国大学的教材质量饱受诟病令人作呕，但是为什么换不得呢？其中有一个原因是“某教材是考研指定教材”。这一观点并不是我乱说的，Berkeley 的教授 Yi Ma 也有指出[4]。就跟罢黜百家，独尊儒术那样，自从指定儒家思想为不可撼动的绝对地位之后，儒学在之后的几千年里再也没有了进步。某些考研指定教材，大概二三十年前就写出来了，错误百出，质量低下，就如同老女人的裹脚布那样恶臭不堪，但是指定为考研的考纲教材，广大考研学子就必须要浪费大好时光在这上面。有了自由的环境和充分公平竞争的市场，才会真正地诞生精品，无论是教材还是课程。指定一个垃圾教材当考试标准，全国学生内卷无穷无尽。我想问，大学生花八九个月的时间，早上八点出门，晚上九点回寝室，就是去内卷做这些东西？我想问做什么别的事情做不好啊，做科研，做实习，还是做项目，花八九个月，都可以做得很好了吧？但是，考研是很多同学的第一选择，他们并没有意识到这个问题的存在。众多大学为了“照顾同学要考研”，在大三下大四上只安排所谓“水课”，这不是劣币驱逐良币？</p>
<p>最后我想举一个我同学的例子，在这篇文章中举例子我也是想批评他了。他和我一样，也是想去美国留学的，因此我们俩个会互相交流一下诸如托福考得怎样、GRE考得怎样。托福满分是120分，考到100分以上就算不错了，我学习托福的时间是报班学了两个月，每周周末两节课，我自己备考花了一个月的时间，考了101分。托福是有那种历年真题存在的，我做了10套听力，5套阅读，而口语和作文基本上就是靠平时的积累而没有特别地准备。我问该同学考得怎样，他说他考了106分，比我高了5分，但是他做了整整50套的历年真题。我备考GRE花了三个月，做题做了一个月，考了319，并不是什么很高的成绩，但是申请绝对够用了（一般来说320就算一个学校不会因为GRE而卡掉你的分数了，而且GRE在申请中的重要性不高）。我这位同学考了330分，算是非常高的高分了，但是他花了大半年，考了三次才得到这个分数。我问他怎么复习备考的，他说他临近考试的时候一天可以做100道单词选择题或者20篇阅读，这大概就是需要“早上八点出门，晚上九点回寝室”的工作量，而我一个月做的题，大概他三天就做完了。对于上面这些现象，其实不难理解。从 60 分提到 80 分的难度远远低于从 80 分提到 90 分的难度。我会以最好的效率做到 good enough 就可以了，而且并不需要做到 perfect。我问他怎么看待我与他的不同，他给我的回复是：“分当然是越高越好啊”。他回复我的时候是以非常自然的口气，所以他大概也不认为他想的有什么不对。但是，就像我刚才所说，美国大学录取，标准化考试只是其中的一部分。他如果可以像我这样花比较少的工夫在标准化考试上，此外的三四个月时间去做一份实习或者科研，反而对他的申请会更有帮助。而“分越高越好”很明显是高考式内卷思维，我这位朋友，是一位要申请美国研究生的人，竟然也难免受到此种思想的影响。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>我写这篇文章，是因为我觉得我发现了一个社会现象，我想把它点明。我觉得能够点明一个社会现象，本来就是一件了不起的事情，是值得写一篇文章的。就像《红楼梦》并不只是曹府的八卦，《红楼梦》之所以有如此大的文学价值，就是因为曹雪芹揭露了当时社会的真实，今天的人们通过看《红楼梦》可以理解当时清朝的社会。试想，如果我们是生活在清朝的人，有多少人能逃过那种吃人的社会呢？怕是几乎没有。我们也生活在我们现在当下所处的社会之中，有一些事情，真的是司空见惯习以为常了，我们也并没有觉得有什么不好或者问题。但是，如我上面所分析的那样，这个社会会对人的思想方式有着潜移默化的影响，有可能妨碍我们获得美好的人生。</p>
<p>我前些天和某位朋友聊天的时候突然冒出来一句话，我是这么说的：“我现在细细回想，我在上大学以前的人生中没有花哪怕一秒钟去学一些对我的人生真正有意义的东西”。从我自己对内卷的定义——<strong>没有扩展自己知识的边界（没有在学新的东西），而是在知识的边界以内，为了竞争，提高考试成绩，而做大量的、重复的练习。</strong>——就可以看出，我对学习的态度，和对内卷的鄙弃。我认为学习就应该扩展自己知识的边界而不是相反停留在原地。我厌恶那种内耗式的做题，我认为那不能称之为学习。学习的目的，是为了丰富自己和追求真理。学习的目的，本不应该是为了和别人比，甚至到一种互害的程度。但是幸运或者不幸地是，我们就生活在这样的社会中。</p>
<p>内卷阿，内卷阿，不在内卷中爆发，就在内卷中灭亡！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>[1]<a href="https://zh.wikipedia.org/wiki/%E5%86%9C%E4%B8%9A%E7%9A%84%E5%86%85%E5%8D%B7%E5%8C%96%EF%BC%9A%E5%8D%B0%E5%BA%A6%E5%B0%BC%E8%A5%BF%E4%BA%9A%E7%94%9F%E6%80%81%E5%8F%98%E8%BF%81%E7%9A%84%E8%BF%87%E7%A8%8B">农业的内卷化：印度尼西亚生态变迁的过程 - 维基百科，自由的百科全书</a></li>
<li>[2]<a href="https://wiki.mbalib.com/wiki/%E5%86%85%E5%8D%B7%E5%8C%96%E6%95%88%E5%BA%94">内卷化效应 - MBA智库百科</a></li>
<li>[3]<a href="https://www.zhihu.com/question/20953633/answer/113930231">为什么美国中小学生学的数学比我们简单，美国人却还能做出超级牛的东西？ - 知乎</a></li>
<li>[4]<a href="https://weibo.com/3235040884/IezPSmWWz?type=repost">国内如果像国外一样，每个教授可以自由选择… 来自毅马当闲 - 微博</a></li>
</ul>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>我只是足够幸运，符合社会规范罢了</title>
    <url>/2021/02/13/Just-Lucky-Enough-to-be-Accordance-with-the-Social-Norm/</url>
    <content><![CDATA[<p>最近有一个非常重大的感想：I am not smart/clever/hard-working/successful. Instead, I am just lucky enough to be accordance with social norm.</p>
<p>所谓 social norm，也就是所谓的社会常规，也就是“人人都认为最稳妥的路子”，比如对于我们华人来说，无非就是还是儿童的时候要当一个乖孩子，学生时代当一个好（zuo）学（ti）生（jia），上一个好大学选一个热门的专业，毕业了之后找一个好对象和好工作（至于什么是“好”也当然是 social norm 的一部分），然后成家立业生育下一代…… 这是一条路子，光鲜亮丽的路子，似乎是每个人都应该追求的。“大家都是这样的”。</p>
<p>了解了哲学之后，尤其是接受了存在主义，existentialism，和自由主义教育学的一些观点之后，结合身边发生的事情和整个社会的风气，我有了痛苦的思考和回答。</p>
<p>比如说，大多数的孩子，没有机会接受我接受过的教育。一般我们的父母会苦口婆心地讲，如果现在不好好学习将来只能去扫马路，当不了人上人。我也可以确信的是，如果以后我生了孩子，也不可避免地要落入这个俗套。那么，凭什么我可以进大学而他们不可以呢？当考试成绩下来的那一刻，父母亲会夸奖我：“你很聪明，你很努力”。现在的我变得不懂，我是真的聪明吗？really？是我努力吗？是我很专注吗？是我很用功吗？那么那些考不上大学的孩子，就是笨吗？他们就不努力，不乖？活该去念中专？问题又可以是，为什么一定要上大学？</p>
<p>在这里的思考，我接受了一些基督教观念：人究竟是无法看清一些东西的，没有办法做到那么 judgemental。比方说，我喜欢英语，学英语几乎不费劲，随随便便考将近满分的分数。而我听到一位中专生的自我表露，他说他不喜欢英语，英语书整整三年都没有翻开，中考英语只考了四五十分。我们两个人，只是一个人喜欢英语，一个人不喜欢英语而已。更何况在我看来，他不喜欢英语甚至不是他的责任。为什么不喜欢英语的人就是“不聪明”、“不努力”、“不乖”呢？如果说，这个世界不需要英语也可以活得很好的话，或者评价标准换一换，也许他就变成了乖孩子，而我就变成了“钻研奇怪的旁门左道的不听话的不争气的人”了。这个问题，我觉得与其评价人们的智性或努力程度专注程度等个人特质，不如归结到适应客观世界的能力上来评价会更好。所以，与其说我“这个孩子聪明”，不如说“这个孩子符合 social norm”，在我看来，后面这个说法没有前者那么 judgemental。</p>
<p>我觉得我，不过是属于从小就非常幸运的人罢了。不是我聪明努力——相反我常有认为自己非常不努力的时刻——而是我非常幸运，符合 social norm，意即自己的生活状态符合社会大多数期望一般人运行的轨道上。</p>
<p>教育应该不只有考试。成绩作为唯一的评价标准，那样只是选拔而不是教育。所有人都不得不参与这场残酷的选拔游戏，一代接着一代。社会应该留给个性发展的余地和空间，因为那种个人独特的智性和天才的创造性犹如天边的流星，得不到呵护无法成长很快就会熄灭。关于这些深刻的见解，密尔已经在他的《论自由》和《功利主义》中作出了精彩的展示。</p>
<hr>
<p>再谈谈 LGBT. </p>
<p>我理解 LGBT 那种悲惨的生活状态——没有办法牵起恋人的手，作为 gay 还要被逼迫去娶妻生子，如果是 trans 被家长发现了扭送到精神病院接受电击治疗等，真是无法一一赘述。</p>
<p>我所受到的教育、看过的书籍、过去的经历，塑造了今天的我。今天的我会觉得，如果一个人不能够做自己，真是作为人类最痛苦最痛苦的悲哀了。</p>
<blockquote>
<p>Diversity is essential to happiness.- Bertrand Russell<br>参差多态，乃是幸福本源 —— 伯兰特·罗素</p>
</blockquote>
<p>虽然痛苦和愚昧从古至今都主宰着我们，但希望人类未来可以生活在更幸福的世界。</p>
]]></content>
  </entry>
  <entry>
    <title>微软实习感受</title>
    <url>/2020/02/19/Microsoft-internship/</url>
    <content><![CDATA[<p>这篇文章很早就该写，而拖了很久了。</p>
<p>2019 年 6 月 19 日至 2019 年 9 月 12 日，大三暑假，我在北京微软进行了暑期实习。我在这篇文章中不想说太多关于实习项目内容本身——代码、程序、技术——虽然在微软这里的技术水平当然也非常好，但我更想着墨于另外的几件“小事”。</p>
<p>某天，我记得那天是星期四，早上在开会的时候，组里的老大对我们说，某人昨天为了赶一个 release 忙到了一点多才回家，所以上完周四这天班就让他星期五六日连休三天。这件事情给我这个刚来公司没几天的实习生留下了很深刻的印象。</p>
<p>过了几天，六月份底是当年财年的结束，我和组里的其他人第一次一起聚餐。当我们下了班在外面聚餐的时候，没有任何一个人在谈论工作上的事情，例如项目进展或者代码等，这挺让我震惊。我们也有微信群，但是我在上面只看到过请假，或诸如“堵车了，今天会议要迟到一下，不好意思”之类的信息。我在那个时候意识到，作为一个实习生的我，在下班回到家后，可以不用再打开邮箱，也不会有任何通信软件的触角伸进我下班后的生活。</p>
<p>七月初，有一封邮件发进了我的邮箱，是微软有一个软件（这个软件叫做 Microsoft MyAnalytics）可以通过你使用邮件的情况、使用通讯软件的时间，来判断下班之后有多少时间被打扰。这封邮件列出一个月的日期中，你有多少天在下班时间之后还处理邮件或开会，占比是多少。这个软件会提供给你下列建议：有足够休息的人压力少、幸福感高、更有可能取得成功；你需要在该休息的时候抛开工作，放松休息；在下班后关掉软件的推送消息通知；为同事考虑，尊重同事的私人时间等。这个软件还有另一项我觉得不错的功能，统计你的开会时间。若你开会时间占比过多，多于一天两个小时，这个软件就会提示你，不要开一个接一个无休止的会议，因为这会分散你的注意力，妨碍你研究具有挑战性的工作。如果你作为召开会议的人，你需要经常检查某些会议是否有召开的必要。（注1：本段我描述的软件细节都是公开资料）（注2：我最近看了斯诺登的自传，懂得了收集元数据的恐怖之处，所以我的意见变得有所保留。但是这个软件符合GDPR的要求，而且是为了保护个人，所以要点个赞。我还是选择忠实地记录下我当时的感想）</p>
<p>这些事让我懂得了真正尊重员工，尊重劳动法的公司是什么样子的。</p>
<p>一般来说，男厕所的小便池上方都会贴一些标语，但无非就是什么“靠近一小步，文明一大步”、“瞄准之后再发射”之类的在我看来挺烂俗的东西。不过，微软公司里的男厕所小便池上方贴的东西是这样的：你的尿液颜色和你身体缺水情况的对比图——白色透明代表饮水过多，淡黄透明表示饮水充足，蜜色代表你需要立刻补充水分……</p>
<p>我在公司餐厅吃自助餐的时候注意到了一个小细节，每道菜旁边都有一个小牌子，上面标注着卡路里、蛋白质、脂肪等营养信息。此外，还有一个颜色标识，分为红黄绿三种。比如炸鸡块这道菜，就会被标上红色，意思是希望这道菜你少吃点，若是青菜，就会标上绿色鼓励你多吃。公司几乎各个地方随处可见各种健康常识提示，我看到的包括但不限于：如何保持健康饮食、在疲劳的时候休息、少喝含糖饮料多喝水、如何进行运动锻炼等。</p>
<p>以上这两件事，让我感受到了以人为本的关怀。</p>
<p>公司网络里有一些 SharePoint 文档，里面有许多公司的政策，有的时候会收到邮件要求你去看，但更多时候我受到好奇心的驱使而如饥似渴地翻阅这些文件。在这些文档中，我接触到了这些关键字：<strong>多元化</strong>（Diversity）、<strong>包容性</strong>（Inclusive）、<strong>平等就业机会</strong>（Equal employment）。我回想到，我经常在公司看到有拄着拐杖的残疾员工。我还在食堂看见了穿着女式凉鞋、短裙、留着披肩长发的女装男子（她也有可能是MtF，跨性别女性）。虽然我们只是萍水相逢，但我真的打心底为她能够自由地成为自己而感到高兴。</p>
<p>在北京微软，任何一个有男女厕所的地方，都搭配着第三个厕所，“全性别厕所”。这是一个小的独立的卫生间，里面有一个坐便器、洗手台和镜子。这解决了跨性别者选择厕所的窘境，这在我之前二十多年的人生中，是从来没有这样想过的。但这还不是最让我震惊的。微软大楼的一楼是向公众开放的，在一楼的全性别厕所门口上，有一行字写着：“全性别厕所，所有人都可以使用的厕所”，最让我震惊的是，在这行字的下面竟然搭配了盲文！就是那种凸点、靠触觉感知的文字！此刻我的内心除了赞叹之外没有别的感情了，这家公司竟然可以为了少数人的方便做到如此极致的地步！后来我了解到，这叫做 <strong>accessibility</strong>，就是在设计产品或服务时，能够让所有人都易于使用，包括具有视觉障碍、听力障碍等不方便的用户。我没有在别的公司工作过，不过我在想，在全中国有几家公司可以做到这样呢？</p>
<p>我曾经听说过一个“文明阶段论”，这个理论是分阶段来考察一个国家的文明程度的。这个理论大致是这样，要看一个国家够不够文明，第一步，看这个国家的广场上面有没有鸽子——如果在一个极度贫困的地方，人们的眼里就看不到鸽子，而只会看到蛋白质，自然也没有文明可言。第二步，看这个国家的公共厕所里面有没有手纸——我想到了各种大爷大妈进公厕顺走所有手纸的事情。后面的几个阶段我记不清了，但大概就是这样的理论。联系到上面的经历，我突然想到，这个文明阶段论里，就应该有这么一个阶段：一个国家的文明程度，就看这个国家对于少数人的权益有没有尽可能地提供保护。</p>
<p>在这里我想说一个“无知之幕”的理论。这是个思想实验，是一种判断特定道德问题的方法。想象一下，在你在出生之前，有一块“无知之幕”挡在你面前，你不清楚自己出生后的一切条件：会出生在怎样的家庭、是否富有、也不知道自己的智商水平、未来的能力、社会地位、阶层、拥有的资源。不清楚的东西也包括自己的性取向，是否会残疾等等。请问，在无知之幕之后，让你来选择这个社会将是怎样的社会，你会怎么选？你是要一个弱肉强食、少数必须被强迫服从多数、社会达尔文主义的社会，还是一个能够尽最大可能为少数、弱势群体的基本权益提供最起码、最基础保护的社会？</p>
<p>现在经常看见有的人说，西方的政治正确无处不在，不可以歧视黑人歧视同性恋，不可以问别人年龄、收入、宗教信仰、政治派别，这也是红线那也是红线，那还说什么言论自由？所以西方的言论自由都是假的！我反对这种看法，因为这种看法把两个议题混淆了。过度的 political correctness(PC) 造成逆向歧视，和到底有没有 freedom of speech，是两码事。适当的 PC 其实体现了一种对于弱势或少数群体的保护和尊重，过度的 PC 才会产生各种问题，而我不觉得我们现在的社会已经对边缘少数群体已经采取了不歧视的宽容态度。我希望我生活的地方能够越来越文明。我宁可承受一些 PC 带来的些许不便，也不想看到有人以此为借口忽悠别人心安理得地接受失去 freedom of speech 的现实。</p>
<p>这篇文章很早就该写，而拖了很久了。我终于在今天写下这篇文章，代表我对生命和生活应该是什么样子有了更加深刻的认识和思考。</p>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之类的this指针、对象数组、作用域、ADT</title>
    <url>/2017/06/07/More-class-design/</url>
    <content><![CDATA[<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p>对于Stock类，还有很多工作要做。到目前为止，每种类成员函数都最多只涉及一个对象，即调用它的对象。但显然有时候方法可能不只涉及到一个对象，在这种情况下需要用到C++的this指针。</p>
<p>例如，Stock类虽然能显示各种数据，但缺乏分析能力，如果我们要设计一个输出哪一只股票的价格最高，由于程序无法直接访问<code>total_val</code>，因此无法做出判断。我们设计两个函数，一个函数查看<code>total_val</code>的值，另一个函数比较两个对象的<code>total_val</code>的值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">total</span>()<span class="keyword">const</span></span> &#123; <span class="keyword">return</span> total_val; &#125;</span><br></pre></td></tr></table></figure>
<p>另一个函数，我们定义一个成员函数，它查看两个Stock类对象，并返回股价较高的那个对象的引用。</p>
<p>由此我们可以引出以下两个问题来讨论：</p>
<ol>
<li>如何将两个对象提供给成员函数呢？假设这个方法命名为topval()，则stock1.topval()将访问stock1的数据，则必须将第二个对象作为参数传递给它。出于效率方面的考虑，我们就可以按引用来传递参数。</li>
<li>如何返回答案呢？最直接的方案就是返回那个引用。因此可以这么写原型：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Stock &amp; <span class="title">topval</span><span class="params">(<span class="type">const</span> Stock &amp;s)</span><span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>好的，假设实现完了topval细节，如何调用呢？很明显下面两个语句都是可行的：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">top</span> <span class="operator">=</span> stock1.topval(stock2)<span class="comment">;//隐式访问stock1，显示访问stock2</span></span><br><span class="line"><span class="attribute">top</span> <span class="operator">=</span> stock2.topval(stock1)<span class="comment">;//隐式访问stock2，显示访问stock1</span></span><br></pre></td></tr></table></figure></p>
<p>这表示法也挺反人类的，但不要紧，我们这里就要着重介绍<strong>this指针</strong>的用法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Stock &amp; topval(<span class="keyword">const</span> Stock &amp;s)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.total_val&gt;total_val)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> ???????;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>s.total_va</code>是参数的成员，<code>total_val</code>是调用这个方法的对象的成员。问题在于在else分支内，<code>stock1</code>是没有别名的，如何称呼这个调用这个方法的对象自己呢？</p>
<p>C++解决这种问题的方法就是使用<strong>名称为this的特殊指针</strong>。this指针是<strong>指向用来调用成员函数的对象</strong>。这样，函数调用<code>stock1.topval(stock2);</code>，<code>this</code>指针就是<code>stock1</code>对象的地址。一般来说，所以的类方法都将this指针设置为调用它的对象的地址。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Stock &amp; topval(<span class="keyword">const</span> Stock &amp;s)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.total_val&gt;total_val)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是返回的是整个引用，this只是地址，记得加上*运算符。</p>
<h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><p>类似于结构体数组，可以创建同一个类的多个对象，就是使用创建对象数组。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Stock <span class="selector-tag">a</span><span class="selector-attr">[3]</span>;</span><br></pre></td></tr></table></figure></p>
<p>数组里的每一个元素都是对象。都可以使用类方法。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>].update()<span class="comment">;</span></span><br><span class="line">a[<span class="number">1</span>].show()<span class="comment">;</span></span><br><span class="line">const Stock * tops <span class="operator">=</span> a[<span class="number">2</span>].topval(a[<span class="number">1</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>使用构造函数初始化数组元素。如果这样做，必须为每个元素调用构造函数<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Stock a<span class="literal">[<span class="number">3</span>]</span> = &#123;</span><br><span class="line">	<span class="constructor">Stock(<span class="string">&quot;a&quot;</span>,1,2)</span>;</span><br><span class="line">	<span class="constructor">Stock(<span class="string">&quot;b&quot;</span>,3,4)</span>;</span><br><span class="line">	<span class="constructor">Stock(<span class="string">&quot;c&quot;</span>,5,6)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果有多种构造函数，可以对不同的元素使用不同的构造函数，没有调用构造函数的将使用默认构造函数。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Stock b<span class="literal">[<span class="number">10</span>]</span> = &#123;</span><br><span class="line">	<span class="constructor">Stock(<span class="string">&quot;d&quot;</span>,7,8)</span>;</span><br><span class="line">	<span class="constructor">Stock()</span>;</span><br><span class="line">	<span class="constructor">Stock(<span class="string">&quot;e&quot;</span>,9,10)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始化的方案是：首先使用默认构造函数创建数组，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应元素中。要创建对象数组，要求这个类必须有默认构造函数。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>在类定义的名称（成员名、成员函数名）的作用域都为整个类。</p>
<p>作用域在整个类的名称，只在该类中是可知的，在类外是不可知的。因此可以在不同类中使用相同类成员名而不会引起冲突。另外，类作用于以为着不能从外部直接访问类成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必须通过对象。</p>
<h2 id="作用域为类的常量"><a href="#作用域为类的常量" class="headerlink" title="作用域为类的常量"></a>作用域为类的常量</h2><p>有时候，使符号常量的作用域为类很有用。例如，类声明用字面值30来指定数组的长度，由于该常量对所有对象来说都是相同的，因此创建一个所有对象共享的常量是个不错的主意。</p>
<p>错误的代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Bakery</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">int</span> Months = <span class="number">12</span>;<span class="comment">//wrong</span></span><br><span class="line">	<span class="built_in">double</span> costs[Months];</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是行不通的，因为声明类值描述对象形式，并没有创建对象。因此，将没有储存这个值的空间。然而，有两种方法可以实现这个目标，而且效果相同。</p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>类中声明枚举。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Bakery</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123;Months = <span class="number">12</span>&#125;;</span><br><span class="line">	<span class="built_in">double</span> costs[Months];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在类声明中的枚举的作用域为整个类，因此可以用枚举为整型常量提供类作用域的符号名称。而且这种方式声明枚举并不会创建类数据成员，也就是说，所以对象其实都不包含枚举，Months也只是一个符号名称，在类的代码里遇到Months编译器都是会用12来代替。</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>C++提供了另一种在类中定义常量的方式——使用关键字static。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bakery</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> Months;</span><br><span class="line">	<span class="type">double</span> costs[Months];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Bakery::Months = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></p>
<p>这将创建一个静态变量Months，该常量将于其他静态变量存储在一起，不存储在对象中。因此，这只有一个Months常量，被所有的类对象共享。</p>
<h1 id="ADT-——-抽象数据类型"><a href="#ADT-——-抽象数据类型" class="headerlink" title="ADT —— 抽象数据类型"></a>ADT —— 抽象数据类型</h1><p>Stock类非常具体。然而，程序员常常通过定义类来表示很多更通用的概念。例如，就实现抽象数据类型（abstract  date type， ADT）而言，使用类就是非常好的方式。类概念非常适合ADT方法，可以用公有成员函数表示ADT操作的接口，公有接口应隐藏数据，而且使用通用的术语来表达，例如栈的压入，弹出等。私有数据成员负责存储ADT数据，需要表明数据的存储方式，可以使用常规数组、动态分配或者更高级的数据结构等。</p>
<p>下面是一个栈的class实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stack.h -- class defination for the Stack ADT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; MAX = <span class="number">100</span> &#125;;</span><br><span class="line">	Item items[MAX];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> Item &amp; item)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Item &amp; item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack.cpp -- Stack member functions</span></span><br><span class="line"><span class="comment">//#include &quot;stack.h&quot;</span></span><br><span class="line">Stack::<span class="built_in">Stack</span>()</span><br><span class="line">&#123;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::isempty</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::isfull</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">const</span> Item &amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &lt; MAX)</span><br><span class="line">	&#123;</span><br><span class="line">		items[top++] = item;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::pop</span><span class="params">(Item &amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		item = items[--top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Stock-设计改进"><a href="#Stock-设计改进" class="headerlink" title="Stock 设计改进"></a>Stock 设计改进</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span> <span class="comment">//class declaration</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string company;</span><br><span class="line">	<span class="type">long</span> shares;</span><br><span class="line">	<span class="type">double</span> share_val;</span><br><span class="line">	<span class="type">double</span> total_val;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares*share_val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//two constructors</span></span><br><span class="line">	<span class="built_in">Stock</span>();	<span class="comment">//default constructor</span></span><br><span class="line">	<span class="built_in">Stock</span>(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n = <span class="number">0</span>, <span class="type">double</span> pr = <span class="number">0.0</span>);</span><br><span class="line">	~<span class="built_in">Stock</span>();	<span class="comment">//noisy destructor</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//delete function acquire</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> price)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">Stock::<span class="built_in">Stock</span>()	<span class="comment">//default constructor</span></span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Default constructor called\n&quot;</span>;</span><br><span class="line">	company = <span class="string">&quot;no name&quot;</span>;</span><br><span class="line">	shares = <span class="number">0</span>;</span><br><span class="line">	share_val = <span class="number">0.0</span>;</span><br><span class="line">	total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> std::string &amp; co , <span class="type">long</span> n, <span class="type">double</span> pr)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Constructor using &quot;</span> &lt;&lt; co &lt;&lt; <span class="string">&quot; called\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	company = co;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative.&quot;</span></span><br><span class="line">			&lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">		shares = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		shares = n;</span><br><span class="line">	share_val = pr;</span><br><span class="line">	<span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::~<span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Bye, &quot;</span> &lt;&lt; company &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//other methods</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Number of shares purchased can&#x27;t be negative.&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot; Transaction is aborted.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		shares += num;</span><br><span class="line">		share_val = price;</span><br><span class="line">		<span class="built_in">set_tot</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Number of shares sold can&#x27;t be negative.&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot; Transaction is aborted.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (num&gt;shares)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;You can&#x27;t sell more than you have!&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot; Transaction is aborted.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		shares -= num;</span><br><span class="line">		share_val = price;</span><br><span class="line">		<span class="built_in">set_tot</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::update</span><span class="params">(<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	share_val = price;</span><br><span class="line">	<span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> std::ios_base;</span><br><span class="line">	<span class="comment">//set format to #.###</span></span><br><span class="line">	ios_base::fmtflags orig =</span><br><span class="line">		cout.<span class="built_in">setf</span>(ios_base::fixed, ios_base::floatfield);</span><br><span class="line">	std::streamsize prec = cout.<span class="built_in">precision</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">		&lt;&lt; <span class="string">&quot; Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; Shares Price : $&quot;</span> &lt;&lt; share_val;</span><br><span class="line">	<span class="comment">//set format to #.##</span></span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//restore original format</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(orig, ios_base::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">using</span> std::cout;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Using constructors to create new objects\n&quot;</span>;</span><br><span class="line">		<span class="function">Stock <span class="title">stock1</span><span class="params">(<span class="string">&quot;Future Technology&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>)</span></span>;		<span class="comment">//syntax 1</span></span><br><span class="line">		stock1.<span class="built_in">show</span>();</span><br><span class="line">		Stock stock2 = <span class="built_in">Stock</span>(<span class="string">&quot;Sun Prison&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>);			<span class="comment">//syntax 2</span></span><br><span class="line">		stock2.<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Assigning stock1 to stock2\n&quot;</span>;</span><br><span class="line">		stock2 = stock1;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Listing stock1 and stock2\n&quot;</span>;</span><br><span class="line">		stock1.<span class="built_in">show</span>();</span><br><span class="line">		stock2.<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Using a constructor to create an object\n&quot;</span>;</span><br><span class="line">		stock1 = <span class="built_in">Stock</span>(<span class="string">&quot;Sun Empire&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Revised stock1:\n&quot;</span>;</span><br><span class="line">		stock1.<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\nDone\n\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//to see how destructor works</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li>面对对象编程强调的是程序如何表示数据。使用OOP方法解决问题的第一步是根据它与程序间的接口来描述数据。</li>
<li>公有成员函数，又称为方法，提供访问数据的途径。</li>
<li>类将数据和方法组合成一个单元，其私有性实现数据隐藏。</li>
<li>通常将类声明放在头文件中、定义成员函数的源代码放在方法文件中，便将接口描述与实现细节分开了。从理论上说，只需知道公有接口就可以使用类。</li>
<li>类是用户定义的类型，对象是类的实例。如果提供了构造函数，则在创建对象时可以初始化对象。如果提供了析构函数，则对象消亡时将执行析构函数。</li>
<li>如果希望成员函数对多个对象进行操作，则可以使用this指针。*this是这个对象的别名。</li>
<li>类很适合用来描述ADT。</li>
</ol>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>《网络多人游戏架构与编程》读书笔记</title>
    <url>/2019/04/21/Multiplayer-Network-Game-architecture-and-programming/</url>
    <content><![CDATA[<p>在图书馆发现一本《网络多人游戏架构与编程》—— Joshua Glazer, Sanjay Madhav 著。书挺新的，17年出版的，内容很有趣，翻一翻可以学到不少在《计算机网络》上不会讲到的内容，故做此纪录。</p>
<p>前几章，第一章简单介绍了网络游戏的历史和发展，第二章讲了how Internet works, 第三章讲的是 Berkeley Socket，就略过了。</p>
<h1 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h1><p>序列化：是指把内存中的内容转化为比特流的形式。比特流是通过网络传输的形式，在主机和服务器上还可以恢复为原始格式。</p>
<p>可能不是很好理解，书中举一个例子来说，如果有一只猫 RoboCat 对象要传输，猫的类定义代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoboCat</span> : <span class="keyword">public</span> GameObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RoboCat</span>() : <span class="built_in">mHealth</span>(<span class="number">10</span>), <span class="built_in">mMeowCount</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int32_t</span>              mHealth;</span><br><span class="line">    <span class="type">int32_t</span>              mMeowCount;</span><br><span class="line">    GameObject *         mHomeBase</span><br><span class="line">    <span class="type">char</span>                 name[<span class="number">128</span>];</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; mMiceIndices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用socket发送这只猫的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendRoboCat</span>(<span class="params"><span class="built_in">int</span> inSocket, <span class="keyword">const</span> RoboCat * inRoboCat</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    send(inSocket,</span><br><span class="line">        reinterpret_cast&lt;<span class="keyword">const</span> <span class="built_in">char</span> *&gt;(inRoboCat),</span><br><span class="line">        <span class="keyword">sizeof</span>(RoboCat), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看好像是没有什么问题对不对？服务器那端用 recv 函数把这个对象接住就可以。问题在哪呢？比如看这一行：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>()</span>;</span><br></pre></td></tr></table></figure>
<p>问题就在于，你发送的不是比特流而是<strong>直接发送这个对象</strong>。假设在32位系统上，<strong>这个对象开始的 4 bytes 是一个虚函数表指针</strong>。因为 <code>Update</code> 方法是虚的，每个对象实例都会存储一个指向虚方法实现位置的表指针（如果看不懂自行搜索虚函数的实现方法）。如果直接发送这个对象，会导致一个问题，那就是<strong>每个不同进程中那张表的位置其实是不一样的</strong>。这段代码，会导致服务器上写入目标的那个 RoboCat 对象的虚函数表指针直接写成一个错的指针。</p>
<p>当然这个例子中还包含别的指针，比如 <code>GameObject * mHomeBase</code>，结合上面的例子很容易就想通：在客户端上一个进程的某一个指针位置，直接发给服务器肯定是荒谬的（一个进程复制一个指针到另一个进程，肯定不能期望对这个指针解引用后还能得到正确的数据）。解决方案其实很容易就能想到，就是<strong>必须对相关的数据进行复制，而不是发送直接的二进制地址。</strong></p>
<p>第二个问题就是对于<code>char name[128];</code>这个对象，如果直接发送整个对象，很明显的一个问题就是这个128字节的数组大多数情况下包含的数据很少，因为这是一个以<code>\0</code>结尾的C字符串，后面的字符都没有意义，<strong>我们应该仅发送那部分有意义的字符来节省网络的带宽。</strong></p>
<p>最后一个问题出现在对于STL中的<code>vector</code>直接复制这样的结构，因为里面一般来说都是会有一些什么指针啊乱七八糟的，所以不清楚直接复制内存中的一个<code>vector</code>的内部字段到另一个进程是否安全（十有八九是不安全的）。<strong>事实上，你应该假定使用任何黑匣子数据结构时复制都会失败，按二进制位复制是不安全的。</strong></p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>解决这个问题的原则是序列化。<strong>序列化是一种将对象从内存中的随机访问格式转化为比特流格式的行为。</strong>也就是收集所有的相关数据到一个缓冲区，然后发送该缓冲区，作为对对象的代表。为此，要引入流的概念。</p>
<p>流在计算机科学中很常见，代表一种数据结构，封装有序的数据元素。</p>
<p>输出流，作为用户数据的输出槽，用户可以顺序插入元素，但不能从中读取。输入流就是可以允许用户提取元素但不允许输入。输入输出流就是既是输入流也是输出流。</p>
<p>序列化，就是用到内存流，封装内存的缓冲区。核心是用动态分配的缓冲区，把数据顺序写入缓冲区，再同时提供对缓冲区本身的访问。用户将数据写入这种对象，再用<code>send</code>发送给另一个系统，就可以解决上述的问题。为什么能够解决呢？使用源对象的各个<strong>值</strong>（而不是地址）来填充缓冲区，给远程主机<strong>发送这个缓冲区</strong>，<strong>顺序提取数据</strong>，再把这些数据<strong>插入到远程主机的进程中一个对象的合适字段里</strong>。规避像虚函数表指针这样的问题，很简单，<strong>不要发送不应该被改变的东西就好了</strong>。</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>工程师要尽可能关注如何高效地使用带宽。能发送更少的字节和比特表示信息，我们就要发送更少。</p>
<p>举例，<code>char name[128];</code> 直接上代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void RoboCat::<span class="constructor">Write(OutputMemoryStream &amp; <span class="params">inStream</span>)</span> const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... other code here</span></span><br><span class="line"></span><br><span class="line">    uint8_t nameLength = static_cast&lt;uint8_t&gt;(strlen(mName));</span><br><span class="line">    inStream.<span class="constructor">Write(<span class="params">nameLength</span>)</span>;</span><br><span class="line">    inStream.<span class="constructor">Write(<span class="params">mName</span>, <span class="params">nameLength</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入数据本身之前，写一个长度n，然后就写那个数组前n个字节，很好又很简洁的方法。</p>
<h3 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h3><p>熵编码是一个术语，指利用数据的不确定性来进行数据压缩。例如 Huffman 编码等就都是这个术语所描述的。</p>
<p>假设，有一个位置字段mPosition，有三个维度X\Y\Z来描述一个Cat的位置，发送这个位置的时候，代码如果这么写：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void OutputMemoryBitStream::<span class="constructor">Write(<span class="params">const</span> Vector3 &amp; <span class="params">mPosition</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">Write(<span class="params">mPosition</span>.<span class="params">mX</span>)</span>;</span><br><span class="line">    <span class="constructor">Write(<span class="params">mPosition</span>.<span class="params">mY</span>)</span>;</span><br><span class="line">    <span class="constructor">Write(<span class="params">mPosition</span>.<span class="params">mZ</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么每次发送一个位置都要用 3*4=12 bytes。下面采纳一个简单的事实：猫常见的情况都是在地面上的，也就是大多数情况下Y都是0，所以我们可以用一个单独的比特来标识猫是在地上还是在天上。如果是在天上，再用4个bytes去存储它在天上的位置。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void OutputMemoryBitStream::<span class="constructor">Write(<span class="params">const</span> Vector3 &amp; <span class="params">mPosition</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">Write(<span class="params">mPosition</span>.<span class="params">mX</span>)</span>;</span><br><span class="line">    <span class="constructor">Write(<span class="params">mPosition</span>.<span class="params">mZ</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mPosition.mY<span class="operator"> == </span><span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="constructor">Write(<span class="params">true</span>)</span>; <span class="comment">// true 是一个bit？学到了。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="constructor">Write(<span class="params">false</span>)</span>;</span><br><span class="line">        <span class="constructor">Write(<span class="params">mPosition</span>.<span class="params">mY</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设玩家的猫90%的时间在地面上，那么本来是一直要用32 bits，现在变为 $ 0.9 <em> 1 + 0.1 </em> 33 = 4.2 bits $ ，每次传输位置都节省了3个多字节。</p>
<p>当然，过分关注带宽效率可能会导致丑陋的代码，所以有的时候为了软件工程方面的考量，需要牺牲一点点效率来换取代码的可读性、可维护性，总之都是tradeoff。</p>
<h1 id="世界状态"><a href="#世界状态" class="headerlink" title="世界状态"></a>世界状态</h1><p>很好理解，比如你在Minecraft开了个门，那么所有在同一个世界（一定范围内的）玩家必须都看到门打开了。所以<strong>世界状态（world state）</strong>就是那个世界中所有游戏对象的状态，所以同步世界状态就是传输每个对象的状态。</p>
<p>这涉及到<strong>对象的复制</strong>。为了成功复制一个游戏对象，一般有三步：</p>
<ol>
<li>标记数据包是包含对象状态的数据包。</li>
<li>唯一标识复制对象。</li>
<li>指明被复制对象的类型。</li>
</ol>
<h2 id="利用MTU"><a href="#利用MTU" class="headerlink" title="利用MTU"></a>利用MTU</h2><p><strong>发送大小与MTU尽可能接近的数据包</strong>是高效的，所以在一个数据包中发送多个对象可以提升效率的。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>每台主机其实都保存了一份世界状态的副本，所以其实没必要在一个数据包中复制整个世界状态。发送方只需要发送那些有发生改变的部分就可以了，用一个状态来表示下面三种复制行为的一种：</p>
<ol>
<li>创建游戏对象</li>
<li>更新游戏对象</li>
<li>销毁游戏对象</li>
</ol>
<p>书中有一个世界状态管理器的实例。</p>
<h1 id="拓扑和同步"><a href="#拓扑和同步" class="headerlink" title="拓扑和同步"></a>拓扑和同步</h1><h2 id="不同的拓扑，适应不同的游戏"><a href="#不同的拓扑，适应不同的游戏" class="headerlink" title="不同的拓扑，适应不同的游戏"></a>不同的拓扑，适应不同的游戏</h2><p>考虑一下网络拓扑。一般有两种主要的拓扑结构需要考虑：C-S和对等网络。</p>
<p><strong>客户端服务器（client-server）拓扑结构</strong>，大部分游戏有一台<strong>权威（authoritative）服务器</strong>，我们认为：<strong>只有服务器上的游戏模拟是正确的</strong>（这很好理解，吧，为了防作弊）。如果客户端发现自己的游戏状态和服务器中的不一致，需要根据服务器发过来的信息更新自己的状态。采用相信权威服务器的策略，就意味着客户端的行为一定会有一定的滞后或延迟。这延迟有很多原因，实际情况中游戏需要使用各种技术来降低（或者隐藏）延迟。</p>
<p><strong>对等网络</strong>，也就是P2P那样的，每个参与者（对等体）都和其他所有参与者都有连接，客户端之间大量数据来回传输。这样的系统比较难实现，这种模式<strong>常见于RTS游戏（real time strategic，即时战略）</strong>。常见的做法是<strong>输入共享模式</strong>，所有的对等体的<strong>互相发送所有动作</strong>，比如《帝国时代》（Age of Empires），游戏以200ms一轮，一轮中的所有命令放到队列中，200ms结束，把这队列中的所有命令都发送到所有对等体中（即时战略一场游戏的玩家数量有限，一般不会超过十多个），然后在每个玩家的电脑上模拟这个游戏。这种<strong>同步</strong>的方式虽然概念上很简单，但实际实现是非常复杂的。其中最重要的是要保证游戏的实现需要非常确定，一组给定的输入必须始终得到同样的输出，为此需要使用例如<strong>校验和</strong>这样的手段来检验对等体之间游戏状态的一致性。对于这种游戏，如果要加入新玩家，一个新的对等体要加入进来，如何让其和每个对等体都建立关系？实际上，可以有一个玩家被选定为所谓的<strong>主机（房主）</strong>，新玩家先与主机建立练习。对于对等网络，由于没有中心服务器，所以不存在由于服务器断网而整个游戏失去连接的情况，有哪位玩家通信中断，其余玩家可以提议暂停游戏或者过一段时间断开这个玩家与主机的连接。</p>
<p>第六章有C-S网络管理器、输入共享模式的命令队列的实现、对等网络的实现。</p>
<h2 id="保持同步"><a href="#保持同步" class="headerlink" title="保持同步"></a>保持同步</h2><p>设计对等体网络游戏，比如即时战略游戏，挑战之一是保存<strong>所有实例的同步</strong>。要做到这一点经常会使用<strong>伪随机数生成器</strong>。有必要保证每隔一段时间（或者每一回合/轮/游戏设计者自行规定的一段指定时间间隔），任意两个对等体总是从一个随机数生成器中输出相同的结果。所以</p>
<ol>
<li>每个对等体的随机数生成器的种子要相同。</li>
<li>每一轮调用相同次数的伪随机数生成，顺序相同，代码位置也相同。</li>
</ol>
<p>书中提出，C语言的<code>rand</code>和<code>srand</code>不是特别适合，<strong>原因是因为这东西不是在C标准中有指定的</strong>，所以不同平台、不同编译器会使用不同的随机数生成算法，因此就算保证了种子相同，也不一定意味着随机数相同。好消息是C++11引入了标准化的生成器，代码在书中有体现。</p>
<p>同步的过程如下：</p>
<ol>
<li>主对等体（主机）生成一个随机数，用作种子，发给所有其他对等体，使得所有对等体的随机数生成器种子相同。</li>
<li>每轮结束时，每个对等体生成一个随机数。作为轮数据包（每一轮结束的时候发一个包）中的一部分数据被发送。</li>
</ol>
<p>另外还有一种方法就是使用<strong>校验和（checksum）</strong>，每一轮结束时，计算游戏状态的校验和。这个过程可以用公开的实现，比如<strong>CRC32</strong>这样的比较知名的算法。校验和放入轮数据包中被发送，若有发现校验和错误的对等体，处理方式可以是将其剔出游戏（反作弊）</p>
<h1 id="延迟、抖动、数据包丢失"><a href="#延迟、抖动、数据包丢失" class="headerlink" title="延迟、抖动、数据包丢失"></a>延迟、抖动、数据包丢失</h1><p><strong>延迟是不可避免的。</strong>（这一点，玩过游戏的都知道），网络在物理传输上肯定是存在延迟的。<strong>但不同游戏类型对与延迟的容忍程度是不同的</strong>（但是这一点，可能不仔细想还真不知道）。例如，VR游戏对延迟是最敏感的，比如，人的头动了一下，我们眼睛就期望看到不同的画面，这个延时需要少于20ms。格斗游戏、射击游戏和其他动作（频繁）游戏是延迟第二敏感的，一般要100ms以内。RTS游戏是对延迟容忍度最高的，可以高达500ms而不影响用户体验。毫无疑问，降低延迟可以提升用户体验，作为学计算机的人，首先要理解延迟来自哪些方面。</p>
<h2 id="非网络延迟"><a href="#非网络延迟" class="headerlink" title="非网络延迟"></a>非网络延迟</h2><p>一般我们玩游戏觉得延迟都会觉得网络是主要的问题，<strong>但其实这是一种误解</strong>，网络延迟绝对不是唯一的延迟来源。</p>
<ol>
<li>输入采样延迟（input sampling latency），简单来说就是<strong>用户按下鼠标、按下键盘到被游戏检测到这个动作输入的时间</strong>可以很长很长。考虑一个游戏以1s60帧运行，1帧大约就是17ms，若用户在某一个完整的帧运行完后2ms后才按下跳远按钮，那么到下一次采样的时间就必然有15ms的延迟。按照平均情况，就是每一个操作都有半帧延迟。</li>
<li>渲染延迟（render），学过图形学，对render这个词也比较眼熟了。<strong>GPU不是CPU一发布命令就开始渲染</strong>，图形驱动程序是把这些命令放入缓冲区，GPU在以后某个时刻再执行这些命令。</li>
<li>垂直同步（VSync）为了避免画面撕裂的手段，做法是仅在显示器的垂直消隐间隙改变图像。怎么理解？显示器上的所有图像都是一线一线的扫描上去的，无论是隔行扫描还是逐行扫描，显示器，都有2种同步参数——水平同步和垂直同步。水平同步信号决定了CRT画出一条横越屏幕线的时间，垂直同步信号决定了CRT从屏幕顶部画到底部，再返回原始位置的时间。<strong>垂直同步代表着显示器的刷新率水平</strong>。主如果我们选择“等待垂直同步信号”（也就是我们平时所说的“垂直同步打开”），那么在游戏中，或许强劲的显卡迅速的绘制完一屏的图像，但是<strong>没有垂直同步信号的到达，显卡无法绘制下一屏</strong>，只有等下一次绘制的信号到达，才可以绘制。例如那些高速运行的游戏，比如实况，FPS游戏，打开垂直同步后能防止游戏画面高速移动时画面撕裂现象，当然打开后如果你的游戏画面FPS数能达到或超过你显示器的刷新率，这时你的游戏画面FPS数被限制为你显示器的刷新率。你会觉得原来移动时的游戏画面是如此舒服，如果达不到会出现不同程度的跳帧现象。显示器就不会同时显示这一阵的部分图像和下一帧的部分图像。垂直同步会造成延迟的原因和渲染延迟类似，如果错过了一次绘制轮次就要等待下一次，也就是额外的一个延迟。</li>
<li>显示延迟（display），显示器在真正显示图像前都会处理输入，这个处理时有时间代价的，比如图像效果处理、视频缩放、降噪、自适应亮度、过滤等</li>
<li>像素相应时间（pixel response），显示屏的像素亮度的改变需要时间，在几毫秒级别。</li>
</ol>
<h2 id="网络延迟"><a href="#网络延迟" class="headerlink" title="网络延迟"></a>网络延迟</h2><p>这部分《计算机网络》上有讲过，当作复习</p>
<ol>
<li>处理延迟（processing delay），router处理数据包检查源地址、确定路由所必要的时间</li>
<li>传输延迟（transmission），指<strong>向物理介质写比特流所必须要花费的写入时间</strong>。我们都知道，物理介质上平均速率的固有限制，例如1MB的以太网连接大约1秒可以写100万bits，若写一个1500bytes的字节的数据包需要12.5ms的时间。</li>
<li>排队延迟（queuing），如果数据包到达的速度比路由器的处理速度快，那么就要进入队列排队。</li>
<li>传播延迟（propagation）无论是什么物理介质，信息传播的速度再怎么样也不会比光快，也就是说<strong>物理上的传输肯定有延迟</strong>，理想状态下（光速），发送数据包的延迟时0.3ns/m乘以数据包传输的空间距离，例如一个数据包横跨美国至少需要12ms。</li>
</ol>
<h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><p>主机到服务器的RTT是可以估计的，必须留意RTT不是一个常数，而是会围绕某一个值进行变化，如果RTT与期望值偏差，这个偏差就被称为抖动（jitter）。作为游戏服务器，要做到：</p>
<ol>
<li>发送尽可能少的数据包保持低流量</li>
<li>把服务器布置在玩家附近来降低出现严重抖动的可能性。</li>
</ol>
<h2 id="数据包丢失"><a href="#数据包丢失" class="headerlink" title="数据包丢失"></a>数据包丢失</h2><ol>
<li>不可靠的物理介质。从根本上说，数据包传输是电磁能量的传输（比如光纤，光是一种电磁波（我们就先忽略波粒二象性：））。宏观的物理问题，如连接松动了，旁边有一台微波炉在工作，都可能导致信号的损坏</li>
<li>链路层和网络层是不可靠的，例如，当链路层信道侦测到冲突的时候，要丢弃正在发送的帧来退避（链路层），路由器队列满了，就只能丢包（网络层）。</li>
</ol>
<h2 id="⭐可靠性：TCP还是UDP"><a href="#⭐可靠性：TCP还是UDP" class="headerlink" title="⭐可靠性：TCP还是UDP"></a>⭐可靠性：TCP还是UDP</h2><p>这是非常有意思的一个章节，学《计算机网络》我们最关注的都是TCP比UDP好在哪里，有那些措施等。但，网络游戏的实际情况下的工程是远远超过教科书上面的那些内容的。</p>
<p>几乎每一个游戏的开发早期都需要面临一个抉择就是使用TCP还是UDP。使用TCP的好处就是，它提供了一个经得起考验的、鲁棒的、稳定的可靠连接实现。保证了所有数据都能到达，而且还能按序到达，还提供了复杂的拥塞控制功能。但是，这<strong>优点其实也是缺点：所有的东西都一定得可靠发送且按顺序处理</strong>，在瞬息万变的游戏世界中，可能会造成如下的问题：</p>
<ol>
<li><strong>低优先级的数据干扰高优先级数据的接受</strong>。例如客户端A的玩家和客户端B的玩家在互相攻击，突然，有一个远处的火箭爆炸，服务器给A发送了这个爆炸的声音。过了一会，B突然跳到A的面前射击，服务器发送一个包含此事件的数据包给玩家A。若此时因为网络问题，内容是火箭爆炸的这个数据包丢失了，<strong>因为TCP按序处理数据包的机制，就算A先收到了B攻击A的数据，但TCP也不会先发送给游戏</strong>。而实际情况是，对于玩家A来说，敌人射击了他是一个优先级更高的事件，甚至这个爆炸其实比较无关紧要。如果使用TCP，那么就要等到服务器重传这个低优先级的火箭爆炸数据包之后，才允许应用层处理高优先级的第二个数据包，毫无疑问这会导致玩家A的体验极差。</li>
<li><strong>多个可靠的有序数据流相互干扰。</strong>就算不是因为优先级的限制，若所有的数据都需要可靠传输，TCP有时也会造成问题。例如游戏中有聊天室，聊天信息应该是需要按序处理的，因为无序的聊天记录会让人看不懂。但是，<strong>聊天信息只需要相对其他聊天信息是有序的就可以了</strong>，如果聊天数据包的丢失影响到了爆头数据包的处理，这肯定不是玩家所希望的。如果使用TCP，可能就会造成这种问题。</li>
<li><strong>过时的重传</strong>。举前面的世界状态为例子，假设玩家B和玩家A在玩吃鸡游戏，B开始的时候在位置x=0，随后的5秒中，B跑到了x=100，假设服务器每一秒都发送一个数据包给A包含B的最新位置。如果用的是TCP，那么这些数据包中的任何一个丢失了，那么都会重传。这意味着，当玩家在x=100的时候，<strong>服务器还可能在重传过时的状态信息</strong>，这会导致A那边计算B的位置是过时的，比如会出现A还没有觉得B接近了自己，而自己却被打死了，这是非常糟糕的。</li>
<li><strong>强制拥塞控制</strong>。尽管拥塞控制算法有利于防止丢包，但有时可能<strong>会导致发送数据包的速度过慢</strong>（Nagle算法）。</li>
</ol>
<p>说完TCP，我们再来说UDP。UDP虽然没有TCP提供的可靠性和流量控制，但是，它实际上就是一张<strong>空白画布</strong>。你可以根据你所设计的游戏的需要来设计一个任何模样的自定义可靠系统。</p>
<ol>
<li>允许发送可靠和不可靠的信息，用某种自定义的手段去标记需要可靠发送的数据包，并让接收端返回确认。</li>
<li>分离可靠有序数据流的交错。</li>
<li>丢失数据包的时候只发送最新的信息而不是重传丢失的数据。</li>
<li>自己管理内存，对数据如何组成数据包进行细粒度的控制。</li>
</ol>
<p>以上都增加了开发和测试的时间，可以使用一些第三方UDP网络库来减少一定这方面的工作量和风险。如RakNet和Photon。</p>
<p>总结，选择哪个传输层协议需要考虑如下问题：</p>
<ol>
<li>游戏发送的每一个数据都必须要被接受吗？</li>
<li>需要以完全有序的方式处理吗？</li>
</ol>
<p>如果两个问题的答案是肯定的，那么确实应该考虑TCP，在回合制游戏中往往是这样的。如果TCP不是绝对完美适合，那么应该使用UDP，这对大多数游戏都是这种情况。</p>
<h2 id="软件工程的测试"><a href="#软件工程的测试" class="headerlink" title="软件工程的测试"></a>软件工程的测试</h2><p>实现这么一个系统的过程中，<strong>创造一个模拟抖动、延迟、丢包的测试环境</strong>是非常重要的，看看你的系统是否可以经受得住这些考验。</p>
<ol>
<li>模拟丢包：当数据包来到，用随机数来决定是否丢弃这个数据包。</li>
<li>模拟延迟和抖动：就是将数据包到达后，不是直接处理，而是将其插入到数据包的有序队列之中的某一个位置。</li>
</ol>
<h1 id="高级的延迟处理技术"><a href="#高级的延迟处理技术" class="headerlink" title="高级的延迟处理技术"></a>高级的延迟处理技术</h1><p>前面我们提到，权威服务器的概念。<strong>服务器是唯一拥有真实和正确游戏状态的主机，服务器是唯一运行最重要模拟的主机。</strong>因此，玩家产生一个动作，到玩家观察到这个动作导致的真实游戏状态，总是有一些延迟。例如：玩家按下跳跃按钮，假设 RTT 是 100ms，且假设往返时间大致是一半一半，服务器是在 50ms 时收到玩家主机发来的数据包，则服务器开始执行对该跳跃动作的模拟，并把新的状态发送回玩家，该数据包就也需要 50ms 才能达到客户端，所以按下跳跃按钮的 100ms 后，玩家才能看到人物跳跃的结果。由于数据包传递是需要时间的，所以运行在服务器的真实模拟总是比玩家能在他们主机上感受到的模拟早半个RTT，这个也比较好理解。</p>
<p>这种客户端被称为<strong>沉默终端（dumb terminal），它们不对游戏的模拟代码有任何了解</strong>，dumb terminal 只是发送输入，接收服务器发来的结果然后渲染给用户看。这种方式叫做<strong>保守算法（conservative algorithm）</strong>，代价是时延，但至少保守算法是绝对正确的。</p>
<h2 id="客户端插值法"><a href="#客户端插值法" class="headerlink" title="客户端插值法"></a>客户端插值法</h2><p>沉默终端存在一个问题，就是不平滑。举一个例子：</p>
<ul>
<li>由于现在的显卡都叼炸天，假设客户端 A 能够以每秒 60 帧的速度运行。</li>
<li>但是，由于服务器和客户端的网络带宽限制，服务器只能以每秒更新 15 次的频率跟客户端通讯。</li>
<li>假设玩家跳跃，是在一秒内向上移动 60 个单位，那么也就是每 1 帧向上移动 1 个单位，如果显卡可以这样渲染，在玩家眼里看起来就是非常平滑的。但是，由于服务器只能以每秒 15 次，也就是每 4 帧才能给客户端发送一个状态，客户端 A 接受到这个状态是 4 帧后的状态。例如，按下跳跃前坐标状态 Y=0，收到的包是 Y=4，按照这个状态去渲染，就是玩家直接感觉到自己的人物跳到了 Y=4，而不是 Y=1,2,3,4 这样平滑地上去的。GPU的性能虽然很高，但是由于网络的限制，玩家只能得到每秒15帧的体验，这让玩家很不愉快。</li>
</ul>
<p><strong>插值法</strong>（interpolation）学过数值分析，看到名字就大概懂了。使用这种方法，<strong>客户端不是自动将对象移动到服务器发来的数据包指示的位置，而是根据时间平滑地插值到这个位置</strong>。</p>
<p>人为规定一个较小的<strong>差值周期IP（interpolation period）</strong>，即从一个状态插值到另一个状态所需要的时间。<strong>PP代表数据包周期</strong>，即服务器相邻的两个数据包之间的时间。根据定义，数据包到达客户端后的IP时间内完成插值。显然，若IP小于PP，则插值完毕后仍没有拿到新的数据包，则玩家仍然会感觉到卡顿，所以应设置 IP ≥ PP。</p>
<p>人为规定一个IP，收到Y=4这个包后，在随后的IP时间内让人物平滑地从Y=0移动到Y=4，这个技术虽然引入了额外的延迟IP，但游戏看起来更平滑了，让玩家体验更好，这个代价就是值得的。</p>
<h2 id="客户端预测法"><a href="#客户端预测法" class="headerlink" title="客户端预测法"></a>客户端预测法</h2><p>虽然插值法可以让体验更加顺滑，但仍然不能让客户端的状态更加接近服务器上的状态。一种<strong>更为主动的想法是从插值转为推测</strong>。<strong>客户端根据接收到的略旧的状态，显示一个推测的状态给玩家。（client prediction）</strong></p>
<p>如果是这样的客户端，就<strong>不是 dumb terminal 了</strong>，因为<strong>客户端上也得有一份与服务器相同的模拟代码</strong>了。预测是这么预测的：</p>
<ul>
<li>根据先前的分析，客户端收到的状态更新是 1/2 RTT 之前的，所以要去估计RTT。估计 RTT 方法很简单，就是发一个带有时间戳的回显包，服务器收到之后立刻返回，客户端收到的时间和这个时间戳一比较就可以得到近似的RTT。</li>
<li>然后，<strong>每当收到一个状态数据包，客户端都再这个包的内容的基础上，再自行运行 1/2 RTT 这么多时间的模拟，显示给玩家这个结果</strong>。</li>
</ul>
<p>举例，当玩家按下一个施放攻击咒语的按钮时候，他希望他的虚拟人物能够立即扔出一个大火球之类的东西。这种预测就比上面的更超前了，即客户端<strong>直接在本地执行适当的模拟</strong>，渲染特效来给玩家的输入提供即使反馈，<strong>同时再等待服务器模拟的返回</strong>。理想状态下，玩家按下施法——客户端直接开始播放施法动画和声音——客户端与此同时发送施法的数据包给服务器——服务器产生火球，复制返回给客户端——客户端正好赶上显示施法结果的时间点，再向前预测 1/2 RTT 的火球抛射轨迹，玩家看起来，从他按下键盘那一刻起，施法，火球形成，火球打向目标，好像没有延迟。当然，这个方法有的时候也可能会有点问题的。比如，在服务器这里，数据库里状态显示该玩家其实是被沉默的（不能施法），但由于网络延迟，通知该玩家被沉默的信息尚未到达客户端，那么玩家就会出现这种情况：玩家感觉自己是没有被沉默的，可以释放火球，但按下施法按钮后，开始了施法动作（手可能在搓）但迟迟没有火球出现，过了一会（沉默的通知数据包到达后）玩家才发现原来自己其实是被沉默的。不过呢，跟这种方法能够提供的好处相比，这个坏处还是可以容忍的。</p>
<h2 id="服务器回退法"><a href="#服务器回退法" class="headerlink" title="服务器回退法"></a>服务器回退法</h2><p>有一种常见的游戏动作是客户端预测法不好处理的：长距离即时射击，假设你是一名配备狙击步枪的反恐精英，你希望你瞄准一名玩家并扣下扳机后，立刻就有完美的命中（比如敌人应声暴毙，右上角出现你击杀成功的信息）。这个问题有一个解决方案，是 Valve 的起源引擎中推广开来的，被《Counter-Strike》游戏采用，其核心是：<strong>当开火时，让服务器状态回退到玩家扣下扳机时感受到的状态</strong>。那么，如果玩家感觉她瞄的很准，那么久可以百发百中。</p>
<ol>
<li>客户端使用客户端插值法，且<strong>IP精确等于PP</strong>，便于服务器的回退。</li>
<li>服务器需要准确地知道客户端玩家在每个时刻看到什么。方法是<strong>发送给服务器的每个移动数据包都保持客户端视角</strong>。例如：客户端在每个发送的数据包中都记录客户端<strong>当前插值的两个帧的ID</strong>，以及<strong>插值进度百分比</strong>。这样就给服务器一个玩家当且所感受到的世界的精确度量。</li>
<li>在服务器端，当传入的客户端输入数据包中包含射击时，查找射击时刻插值的两帧，使用数据包中的插值进度百分比将所有对象<strong>回退到客户端中扣动扳机的那一刻</strong>。然后从客户端的位置采用光线投射法<strong>确定是否击中</strong>。</li>
<li>这一机制保证了<strong>如果客户端精准命中了，那么在服务器端就一定会被命中</strong>。所以这给射击玩家带来了很好的体验。但也有可能让被击杀的人有一些不愉快的体验，例如在网络延迟很大的情况下，玩家B已经觉得自己避开了A的射击躲到了障碍物后面，但过一小会还是被判定被击毙了。其实这是一个tradeoff，需要根据你的游戏的特性来决定是否使用这些技术。</li>
</ol>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>说得好听点叫深度包检测（deep packet inspection），说得难听点就是数据包嗅探（sniffing）。</p>
<h2 id="sniff-amp-man-in-the-middle-attack"><a href="#sniff-amp-man-in-the-middle-attack" class="headerlink" title="sniff &amp; man-in-the-middle attack"></a>sniff &amp; man-in-the-middle attack</h2><p>任何使用不安全、或公共无线网络的计算机都可能被该网络中另一台计算机读取数据包信息。书中说的非常好的一句话，就是<strong>“无论如何你都应该假设玩家总是可以访问网络传输的所有数据”</strong>。这意思其实跟防御性编程差不多，考虑代码中处理输入的部分就是假设用户会输入各种千奇百怪的输入而你的程序都能够相应地handle。</p>
<p>（方法就是加密，公钥加密算法，不多说了）</p>
<p>加密数据其实是一种威慑，而不是万无一失的措施。原因：</p>
<ol>
<li>虽然标准计算机上面没有多项式时间内的整数因子分解算法，但如果目标的价值足够高还是可以引起足够的注意，投入足够多的资源，用足够长的时间去破解。</li>
<li>量子计算机的 shor’s algorithm 是一种可以在量子多项式时间内进行整数因子分解的算法。虽然本书写成时世界上最强的量子计算机也仅仅只能把 21 分解成 3 和 7，但<strong>大多数的密码学家相信 RSA 是有一天会被破解的</strong>，这也是为什么密码学家在积极研究即使是量子计算机也无法在多项式时间内破解的密码系统。</li>
<li>任何平台上的游戏可执行文件都可以破解，<strong>可执行文件中一定有一段代码是加密和解密游戏数据，一旦有人学习到了如何解密数据，那么其实数据就是没有加密一样</strong>。所以，可能需要定期变更密钥或者进行内存的位置布局，或者定期更改网络数据包的格式和顺序，这样为那些不怀好意的人提供一些障碍。</li>
</ol>
<p>无论如何，你都必须接受一个事实，就是你永远无法阻止别有用心的人在主机上 sniffing。</p>
<h2 id="input-validation"><a href="#input-validation" class="headerlink" title="input validation"></a>input validation</h2><p>除了上面那个假设：无论如何你都应该假设玩家总是可以访问网络传输的所有数据，之外呢，还有下面一种假设需要考虑：</p>
<p><strong>你要假设会有坏蛋了解了你的游戏服务器与主机的通讯方式</strong>，然后模仿一个游戏客户端发一个数据包过来，但其实里面的内容是人造的，无效的，非法的或者不公平的。<strong>输入验证（input validation）</strong>也就是<strong>游戏不应该盲目地执行一切网络来源的数据包里的操作</strong>，而是应该先验证这个操作是有效的，是由合法的客户端正常地发出的。</p>
<p>例如，收到一个包叫做玩家A开火，接收端不应该无脑地直接去判断这个子弹有没有打到谁，而是首先应确认：玩家A活着，A有武器，武器里有子弹，玩家当前没有因为什么切换枪支的硬直而无法开火的状态等等，只要有一个条件不满足，都应该认定这个动作无效。如果检测到非法的数据包，可以有理由判定玩家作弊，可以试图踢掉违规的玩家，当然更正确的做法是保守点地直接拒绝无效输入。</p>
<p>不过，有没有可能服务器上有坏数据呢？毕竟，权威服务器模型中只有服务器有权利模拟游戏运行，如果服务器告诉某个客户端说：你死了，那么这个玩家必死无疑，那玩家怎么样才会保证我是真的死了而不是因为什么人为因素（比方说，某程序员改数据）而暴毙？唯一的一个解决方法就是：<strong>不让人来主持游戏。</strong></p>
<h2 id="VAC-amp-Warden"><a href="#VAC-amp-Warden" class="headerlink" title="VAC &amp; Warden"></a>VAC &amp; Warden</h2><p>书中还提到了战争迷雾的作弊（俗称<strong>开图</strong>，看到这里的时候我惊了，这书这么屌的么），例如像魔兽争霸这样的RTS游戏的战争迷雾，是把某一方的单位从另一方的视野里抹去，回想之前说到的对等体网络拓扑，那么每个游戏单位的位置信息状态应该是存储在所有对等体内的，因此<strong>战争迷雾是在本地的可执行程序中实现的</strong>，因此可以通过编写开图软件的方法取消战争迷雾。而<strong>被动的防御方法很难发现这一作弊</strong>，因为数据包的内容可能都是正常的，就需要软件作弊检测了。</p>
<p>上面说到的防御都是比较被动性的，下面介绍一种作为游戏进程的一部分或游戏进程以外的软件，<strong>更主动地</strong>检测游戏状态完整性，检测是否有作弊软件在运行的<strong>软件作弊检测系统（software cheat detection）</strong>，例如 Valve 的 <strong>VAC（Valve Anti-Cheat）</strong>和暴雪的 <strong>Warden（典狱长）</strong>。</p>
<p>VAC 为每个 steam 游戏都维护一个被禁用户的列表（给卢姥爷上柱香），当被禁用的用户尝试连接 steam 游戏的时候就会被拒绝连接。作弊的大多数方法都是在客户端上运行游戏进程之外，再运行一个作弊软件。诸如：<strong>重写游戏的内存、修改游戏使用的数据文件、发自定义内容的作弊数据包</strong>。基于此，检测作弊的方法就是扫描游戏进程的内存，看是否有别的进程进行了非法的读写。<strong>如果检测到有用户在作弊，通常不会被立刻禁止</strong>，因为立即禁止很显然就会表明这个作弊手段被发现了以后就不能再用了，VAC 就是把这些用户保持起来，然后在将来的某一个时刻一次性封禁他们，这样子可以抓到尽可能多的用这种手段作弊的玩家。（666）</p>
<p>Warden 是暴雪（Blizzard Entertainment）的作弊检测系统，用在所有的暴雪游戏上。与 VAC 类似，Warden 也扫描计算机的内存来检测已知的作弊程序，如果检测到作弊也会返回到 Warden 服务器，用户会在未来的某个时间点被封号。<strong>Warden 特别强大的方面是游戏运行时的动态更新功能</strong>。因为作弊的用户都清楚，在游戏补丁刚发布的时候最好不要作弊，因为有可能反作弊程序也更新了，因此作弊程序可能就不好使了，或者以前不会被抓现在会被抓。但是，Warden 可以游戏在进行的时候更新反作弊系统，所以当 Warden 更新时可能会抓到没有意识到 Warden 更新的作弊用户（666）。</p>
<p>显而易见，关于 VAC 和 Warden 的公开的信息很少。实现这种系统，需要大量的<strong>底层操作系统、逆向工程</strong>的知识。即使是最好的反作弊系统，都有可能被攻破或避开，也就是所谓道高一尺魔高一丈，所以要不断的更新反作弊系统，保持比任何作弊程序都要先进。</p>
<h2 id="服务器防御"><a href="#服务器防御" class="headerlink" title="服务器防御"></a>服务器防御</h2><p>网络游戏安全的另一个重要方面是保护服务器不被攻击。假定又来了，<strong>你一定要假定你的服务器易受攻击且有不怀好意的人伺机想要攻击你的服务器</strong>，因此你必须做一些防护手段。</p>
<h3 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h3><p>几乎每一个主流的网络游戏都遭受过 DDoS。</p>
<p>防御这种攻击的工作一般可以交给云服务提供商，具体的内容就不在此记录了，简单来说就是四个字负载均衡。</p>
<h3 id="坏数据"><a href="#坏数据" class="headerlink" title="坏数据"></a>坏数据</h3><p>应该<strong>假定，恶意用户可能会给服务器发送数据格式不正确或不合适的数据包</strong>，更阴险的用户也许可以通过构造数据包来达到服务器上缓冲区溢出之类的攻击（可以类比SQL注入）。因此可以采用<strong>模糊测试（fuzz）</strong>的方法，可以写一个类似于代码生成器的东西，构造大量非结构化数据、或者结构化但内容特定的数据，发送给自己的服务器来看是否会让服务器奔溃。</p>
<h3 id="时序攻击"><a href="#时序攻击" class="headerlink" title="时序攻击"></a>时序攻击</h3><p>例如，假设你比较两个数组，来确定他们是否相等，数组a代表用户的证书，数组b代表正确的证书，如果函数是这样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> a[<span class="number">8</span>], <span class="type">int</span> b[<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提前return false看起来好像是一个无伤大雅的性能优化，毕竟如果前面的就不同后面似乎的确没有继续比较的必要。但这会导致不正确的值输入会让函数返回地更快。<strong>恶意用户可以通过尝试每个可能的b[0]，测试哪个值会让 Compare 函数返回时间更长，就可以确定正确的值</strong>。解决方案如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="constructor">Compare(<span class="params">int</span> <span class="params">a</span>[8], <span class="params">int</span> <span class="params">b</span>[8])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret <span class="pattern-match">|= a[i] ^ b[i];</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    return (ret <span class="operator">==</span> 0);</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="入侵"><a href="#入侵" class="headerlink" title="入侵"></a>入侵</h3><p>恶意用户闯入服务器是最大的恶梦，要非常慎重认真地对待这一问题。入侵的常见途径是首先闯入有权限访问中央服务器的个人机器，以此为跳板进入服务器系统。这被称为<strong>鱼叉式钓鱼攻击（spear phishing attack）</strong>，因此，所有开发人员的机器的操作系统、访问 Internet 的任何软件如浏览器等，始终应该保持更新。</p>
<p><strong>假设</strong>又来了：<strong>你应该假设你的服务器很容易收到高级黑客的攻击，要确保任何敏感数据尽可能安全。</strong>例如，不要把用户密码保存成明文（说实话这谁都知道），<strong>但也不要仅仅只用简单的哈希算法</strong>例如SHA-256过一遍就把hash value存入数据库，因为一些简单的密码例如123456的哈希值还是可以找到那么一些总是这么粗心设置密码的人。而是应该使用诸如河豚加密算法，（或者我知道的，带盐的哈希算法等）。</p>
<p>下面摘抄一段原文的话：P270 </p>
<p>“近年来的新闻显示，<strong>服务器安全的最大威胁往往不是外部用户，而可能是一个心怀不满的员工。</strong>这样的员工可能试图访问或传播他们不应该访问的数据。为了解决这个问题，一个全面的<strong>日志和审计制度</strong>是非常重要的。如果发生了这样的事情，既可以起到威慑的作用，也可以提供证明犯罪行为的证据。最后，所有的数据都应该定期备份到线下的物理设备上，即使最差的情况下，数据库被完全删除，你仍然可以恢复，虽然这个情况很不好，但总比永远失去所有游戏数据要好得多。”</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>（做这篇博文后面这部分的时候，B站的后端代码被人传到了 GitHub 上。说实在话由于肯定有备份，“删库跑路”其实公司不是很怕的，从删库跑路进化到开源跑路那是真的牛批。我本人是谴责这一违法行为的，但这些代码已经覆水难收，B站虽然联系了GitHub 紧急 takedown 了那个页面，但也我发现的时候也已经有了 6000 多个 fork，像 V2EX 这种论坛都是各种求代码的，没办法，毕竟是能看B站的产品代码啊。最严密的堡垒都是从内部攻破的，审计确实蛮有用的，学到了，除此之外希望互联网公司都注重权限管理）</p>
]]></content>
      <categories>
        <category>ReadingNote</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之多重继承</title>
    <url>/2017/06/07/Multiple-Inheritance/</url>
    <content><![CDATA[<h1 id="多重继承定义"><a href="#多重继承定义" class="headerlink" title="多重继承定义"></a>多重继承定义</h1><p>多重继承，multiple inheritance，简称MI。在现实中，也许某种事物具有两种或以上的种类的事物的基础属性，所以C++中有多重继承这种手段来解决这种问题。即允许一个派生类指定多个基类。例如下面这个类，从侍者类公有继承，从歌手类私有继承，得到一个“会唱歌的侍者”类：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">singingwaiter</span> : <span class="symbol">public</span> <span class="symbol">waiter, <span class="symbol">singer</span></span> //<span class="symbol">singer</span> <span class="symbol">is</span> <span class="symbol">private</span></span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>必须为每个类添加限定符，如果没有，默认是私有继承。</p>
<p>MI会给程序员<strong>带来很多编程问题</strong>。因此许多人反对MI，甚至希望删除MI；但对于喜欢MI的人来说，MI很有用，用得好能大大缩减代码量，甚至对于特殊工程来说MI是必不可少的；也有一些人建议谨慎使用MI。主要的两个问题是：从两个不同的基类继承同名方法；从两个或更多的相关基类那里继承同一个类的多个实例。</p>
<h1 id="多重继承可能存在的问题"><a href="#多重继承可能存在的问题" class="headerlink" title="多重继承可能存在的问题"></a>多重继承可能存在的问题</h1><h2 id="继承同名类方法的二义性错误解决"><a href="#继承同名类方法的二义性错误解决" class="headerlink" title="继承同名类方法的二义性错误解决"></a>继承同名类方法的二义性错误解决</h2><p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170608085906668-993821047.png" alt=""></p>
<p>水陆两用汽车（amphibiancar）具有小汽车和小船两种属性，所以由小汽车类和小船类共同派生出一个水陆两用汽车类。那么假设这么一个问题，交通工具就认为它是抽象基类吧，有一个虚函数<code>show()</code>，大概就是显示一些信息之类的，小汽车当然就继承了<code>car::show()</code>，小船则是<code>boat::show()</code>。<br>那么面对两个同名类方法，并且在这里假如在水陆两用汽车类中没有重新定义该方法，那到底继承的是什么呢？或者说，在水陆两用汽车类中调用<code>AmphibianCar::show()</code>，那么这明显是有问题的有<strong>二义性错误</strong>（ambiguous） 。当然，也有两个<code>setweight()</code>的错误</p>
<p>有以下解决方法：比如使用作用域解析运算符直接调用，如果有一个<code>amphibiancar</code>对象<code>a</code>，那么调用<code>a.car::show();</code>。更好的方法就是编写成员函数，直接指出使用哪个<code>show</code>，或者重新定义<code>show</code><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">void amphibiancar:: <span class="built_in">show</span>()</span><br><span class="line">&#123;</span><br><span class="line">	car::<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承多个同名基类对象，需要用到虚基类"><a href="#继承多个同名基类对象，需要用到虚基类" class="headerlink" title="继承多个同名基类对象，需要用到虚基类"></a>继承多个同名基类对象，需要用到虚基类</h2><p>因为抽象基类：交通工具有一个<code>weight</code>，小汽车和小船都从交通工具那儿<strong>各自</strong>继承了一个<code>weight</code>组件，<strong>因此水陆两用汽车将会包含两个weight组件</strong>，这会引发一系列问题。</p>
<p>例如常见的派生类对象（的地址）可以赋给基类（指针）引用，但现在将出现二义性。原理是这种赋值是把基类指针设置为派生类对象中基类对象的地址。但现在派生类含有两个<code>weight</code>对象，所以：<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">amphibiancar(...) a;</span><br><span class="line">vehicle * p1 = <span class="meta">&amp; a; <span class="comment">//这里出现二义性错误</span></span></span><br><span class="line"></span><br><span class="line">vehicle * p2 = (car *) <span class="meta">&amp; a;</span></span><br><span class="line">vehicle * p3 = (boat *) <span class="meta">&amp; a;</span></span><br></pre></td></tr></table></figure></p>
<p>是不是很蛋疼？说明这种同名对象的继承会影响多态性的复杂。实际上这里的水陆两用汽车不需要两个weight成员，（虽说有的时候还真的可以继承多个同名成员）所以真正的问题是我们<strong>只需要一个变量来描述重量</strong>就可以了。C++引入了<strong>虚基类</strong>（virtual base class）来解决问题。</p>
<h3 id="虚基类语法"><a href="#虚基类语法" class="headerlink" title="虚基类语法"></a>虚基类语法</h3><p>虚基类使得从多个类（它们基类相同）派生出来的类，只继承一个基类对象。在类声明的派生中添加关键字<code>virtual</code>。<code>virtua</code>l和<code>public</code>的顺序不关紧要。<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">class <span class="type">Car</span> : virtual public <span class="type">Vehicle</span><span class="meta">&#123;...&#125;</span>;</span><br><span class="line">class <span class="type">Boat</span> : virtual public <span class="type">Vehicle</span><span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure><br>如果这样做，那么<code>amphibiancar</code>类将只包含<code>vehicle</code>对象的一个副本，从本质上来说，继承<code>car</code>和<code>boat</code>类共享一个<code>vehicle</code>对象，而不是各自引入一个。</p>
<h2 id="新的构造函数规则"><a href="#新的构造函数规则" class="headerlink" title="新的构造函数规则"></a>新的构造函数规则</h2><p>用到虚基类时，需要对类构造函数使用一种新的方法。对于非虚基类，出现在初始化列表的构造函数 是 <strong>即时基类</strong>的构造函数。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     A(<span class="built_in">int</span> n = <span class="number">0</span>): a(n)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">B</span> :<span class="symbol">public</span> <span class="symbol">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B(<span class="built_in">int</span> m = <span class="number">0</span>, <span class="built_in">int</span> n = <span class="number">0</span>):A(n) , b(m) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">C</span> :<span class="symbol">public</span> <span class="symbol">B</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	c(<span class="built_in">int</span> q = <span class="number">0</span>, <span class="built_in">int</span> m = <span class="number">0</span>, <span class="built_in">int</span> n = <span class="number">0</span>): B(m, n), c(q)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>C</code>类的构造函数只能调用<code>B</code>类的构造函数，<code>B</code>类的构造函数只能调用<code>A</code>类的构造函数。<code>c</code>的构造函数使用值<code>q</code>，并将<code>m</code>和<code>n</code>传递给<code>B</code>的构造函数，<code>B</code>使用<code>m</code>，将<code>n</code>传递给<code>A</code>的构造函数。</p>
<p><strong>如果vehicle是虚基类，这种自动传递信息则不再起作用</strong>，例如在上面的多重继承条件下有这样的构造函数：</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170608085908887-666750778.png" alt=""></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">amphibiancar</span><span class="params">(const vehicle &amp; v, int air = <span class="number">0</span>, int ton = <span class="number">0</span>)</span></span>::<span class="built_in">car</span>(v,air),<span class="built_in">boat</span>(v,ton) &#123;&#125;<span class="comment">//failed</span></span><br></pre></td></tr></table></figure>
<p>会出错。原因是：自动传递信息时，将通过两条不同的途径（car or boat）将<code>v</code>传递给<code>vehicle</code>。为避免这种冲突，C++在基类是虚基类时，<strong>禁止信息通过中间类自动传递给基类</strong>。然而，编译器仍然需要保证派生类对象生成之前先调用基类构造函数组件，因此需要显式调用（基类构造函数），因此正确的构造函数应该是这样：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">amphibiancar</span><span class="params">(const vehicle &amp; v, int air = <span class="number">0</span>, int ton = <span class="number">0</span>)</span></span>::<span class="built_in">vehicle</span>(v),<span class="built_in">car</span>(v,air),<span class="built_in">boat</span>(v,ton) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码显示调用构造函数<code>vehicle(const vehicle &amp;)</code>。请注意！这种用法是合法的，而且对于虚基类来说，必须这样做。但对于非虚基类，这是非法的。</p>
<h1 id="MI小结"><a href="#MI小结" class="headerlink" title="MI小结"></a>MI小结</h1><ul>
<li>不使用虚基类的MI：这种方式不会引入新的规则。例如：</li>
</ul>
<p><code>class Student :private std::string, private std::valarray&lt;double&gt;</code></p>
<ul>
<li><p>如果一个类从两个不同的类哪里继承了两个同名的成员（通常原因是有共同祖先啦）则需要额外做一些编程工作。如果是同名方法，需要使用作用域解析运算符来说明到底是使用哪一个方法，或者重新编写方法。否则 会有二义性错误。</p>
</li>
<li><p>如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例。</p>
</li>
<li><p>当派生类使用关键字virtual来指示派生时，基类成为虚基类：</p>
</li>
</ul>
<p><code>class Car : virtual public Vehicle&#123;...&#125;;//vehicle成为虚基类</code></p>
<ul>
<li><p>主要变化（同时也是使用虚基类的原因）是：从虚基类的一个或多个实例派生而来的类将只继承一个基类对象。为了实现这种特性，需要做的其他工作有：</p>
<p>  • 有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数。这对间接非虚基类来说是非法的。<br>  • 优先规则解决名称二义性</p>
</li>
</ul>
<p>最后总结，综上所述，MI会增加编程复杂程度。主要是由于派生类通过多种途径继承了同一个基类所引起的。</p>
<hr>
<p>参考链接</p>
<p>-<a href="http://blog.sina.com.cn/s/blog_44c488680101745i.html">多重继承</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>思考生死议题 My Thoughts on Life and Death</title>
    <url>/2021/07/13/My-Thoughts-On-Life-And-Death/</url>
    <content><![CDATA[<p>我为什么会开始看耶鲁大学死亡哲学这个视频课程呢，是因为我的祖父母他们年纪也大了，我还不清楚地知道要以什么样的态度去面对他们（将来）的死亡。我有一个好朋友曾经在去年问过我，“如何接受生老病死是人生的常态？” 因为那个时候他住院了，隔壁床住着一个老教授，一开始情况还不错，后面渐渐病情恶化逐渐不能自理。他的提问的问法——“如何接受生老病死”，而不是“如何看待”生老病死——让我觉得，我的朋友从某种意义上还觉得没办法很好地接受这一既定事实，即我们的亲人和我们自己都有一天终将死去，并且暗示着我们对死亡是惧怕的。生离死别是人生的常态，这其实是成立的；医院的墙壁比教堂聆听了更多的祈祷和叹息。但是，似乎我们还不知道怎么去接受它，没有思考过死亡这一话题。我们又探讨了“人可不可以体面地离去？” 引发了一个关于安乐死的探讨。而至于这个话题，我想我是有一个明确的答案的。</p>
<p>我母亲有一位好朋友在几年前过世，我从她的过世中得到的一种理解是电影里《后会无期》中的那一句台词：“告别的时候要用力一点，因为这一次有可能是最后一次”。在她还在世的时候，每每讨论到我母亲的这位朋友，我都会觉得她有很多性格的缺点导致了她命运的不幸。但是当听到她突然得上恶性肿瘤去世了之后，我只会觉得她命苦。“噢，她终于解脱了！” 就是她死了之后，她生前那些造成她不幸生活的缺点似乎又变得无所谓了。我突然希望，生活已经对她不是很善良，为什么我作为她身边的人，不能对她善良一点？所以，我和我爷爷也闹过矛盾，那么当他总有一天会去世的时候，我是不是也会这么想呢？</p>
<p>什么是死亡？死亡的本质是什么？</p>
<p>苏格拉底为什么不惧怕死亡？归根结底还是因为他认为灵魂是不朽的。不过，以下的文字都从一个 physicalist，物理主义者的视角出发——认为生命没有非物质的组成部分，也就是没有所谓的“灵魂”，也没有永生，没有转世。当人死亡的时候，万事休矣。</p>
<p>人什么时候才算是“死亡”？death of personality or death of body? 我个人是倾向认为是 personality 观点的（“那个之前的我不存在了”）。我认同脑死亡应该算是临床和法律意义上死亡该采取的标准（而不是心跳或呼吸）；我不赞同不顾一切手段的临终抢救；我赞成在病人在医生指导下的了解和知情同意下的安乐死合法化；我赞成提前和家人亲属讨论对死亡的看法，提前立遗嘱等等；我虽然认为器官捐献是一个好事，但是这必须出于自愿，不然是不道德的。</p>
<p>对死亡缺乏思考、讨论和理解是一个普遍现象。甚至在很多人谈到“死”这个字的时候，其他人会认为这是一件忌讳的事情。人之所以会这样，是因为直面死亡是一件痛苦的事情，不如将其暂时放在一旁，束之高阁。或许其中也有文化和历史因素把死亡神秘化。不过，在善于思考的人看来，这种想法未免有些不妥，这不是面对死亡的正确态度——甚至不是正确面对任何事情的态度，毕竟 an unexamined life is not worth living. <strong>无法真诚地直面生命的尽头，生命本身也会变得缥缈虚无。</strong>除了这些形而上的说法之外，我们到底希望怎样度过我们自己的最后一段时光，则是一个非常现实的问题了。如果临终前遇到了非常重大的疾病（如心肌梗死），是否要靠生命维持系统继续抢救，还是采取安乐死让亲人体面地走完最后的一段路程？这个问题不那么容易回答，但是如果我们把这个问题跟我们的亲人进行过讨论，那么将会有非常大的好处：在这种情况下，病人的家人必须代替病人做出决定，决定我们接受什么样的医疗。如果他们不确定自己是否为所爱的人做出了正确的选择，这可能会导致伦理选择的两难，如面临人财两空，或者就算救下来了，亲人也要忍受一直插管、预后不好的巨大痛苦。而且，这种场景也不一定只发生在年迈的老年人身上，就算是年轻健康的我们，也有可能遭遇飞来横祸，你永远不知道明天和意外哪一个先来，我们的亲人也有可能要为我们做出重大决定。</p>
<p><strong>一个简单的事实是，我们都会死去，而且我们中的大多数人都会在有生之年失去我们所爱和关心的人。</strong>如果我们可以和关心的人提前进行一次“死亡谈话”，让我们能够深入思考我们的选择，与家人、朋友和医生等人协商，能够让我决定我自己生命的最后接采取什么样的临终关怀和治疗手段，我觉得这是一件非常好的事情。</p>
<p><strong>请相信你会死去。我们总有一天会离开这个世界，我们总有一天会死。</strong>不过，不少人不曾好好思考过这一点。而且，就算是表面上认可这句话的人，深层次的潜意识却不相信这句话。举一个例子就能明白了，真正拥有极其接近死亡却侥幸存活、起死回生体验的人，多多少少都改变了他们生命中的优先级。例如真的遭遇过很严重的车祸，然后抢救过来的人，他们大多会说类似 “我不要再干什么干什么了，我要去做真正有意义的事情，我要和家人和朋友表达我爱他们”，等等。和死亡擦肩而过，让他们获得了这种新知。这说明一件事，<strong>如果你真的相信自己会死，你确实会变得不一样</strong>。比如我，就算“知道”总有一天我会死，但是我却没有做到他们那样的事情，也其实说明我心里不是真的明白这句话，只是表面上说“我知道啊”，但是潜意识里并不真的了解其中的意义。<strong>而真正地去思考死亡，会让你思考你究竟要怎样地活着。</strong></p>
<p>死亡到底为什么让人害怕？课程里给出了一个极其简短美妙的证明，证明“死亡本身” death itself 并不可怕。因为</p>
<ol>
<li>当我们还存在的时候，死亡并没有降临</li>
<li>当死亡降临，我们就不存在了，也就无所谓害不害怕了</li>
<li>所以死亡本身并不可怕。</li>
</ol>
<p>说实话，当我第一次听到这个论述，我觉得很奇怪，但是我细细思考，又觉得它说的是有道理的。然后接下来，老师抛出了一个句子，“死亡本身并不可怕，可怕的是与死亡随之而来的那些东西”。</p>
<p>第一，如果某个人死了，我们就不再拥有他，也失去了他对于我们的独特角色，例如失去亲人、伴侣。这是死亡会带给其他人而不是死者本人的痛苦体会之一。第二，如果某个人死了，他就不再存在了，他就被剥夺了享受他死亡之后的一切美好的事情的可能性，这叫剥夺性解释(deprivation)，也是死亡之坏处的最有说服力的解释。第三，死亡是给我们设置了一个终点，所有的人都只有这短短的一生。如果有很长很长的时间，我们确实可以虚度光阴也无所谓，因为我们总可以在某一个时刻再去开始做想做的事情或者有意义的事情。但是如果这一切都只是有期限的，那么一切都变得不那么从容，变得紧张了，需要我们小心谨慎了。如果我们真的游手好闲，到头来我们真的很有可能一事无成，而生活中值得我们做或需要我们去做的事情有那么多。而且每一项值得追求的成绩或成就，都需要花费时间和精力，这就不得不要求我们必须谨慎，不能那么恣意妄为。</p>
<p>如果有限的生命让人感到紧张，死亡剥夺了未来的美好的事物而让人感到害怕和痛苦，<strong>那么永生(immortality)是否就是一件好事呢？</strong>“如果我能永远活着就好了！” 其实也不然。根据剥夺性解释，死亡是一件坏事，当且仅当未来的生活给我们提供了死掉之后不能享受的好事。但是，如果未来的生活只有一成不变，那么永生或许就变成了折磨和诅咒。例如有一种说法是，死亡是一种祝福，因为它结束了折磨我们的年老体弱、痛苦和悲伤。许诺永生的宗教，也无法描绘永恒的景象。毕竟，如果真的能够描绘出来，那么永恒可能就不那么吸引人了——大家都变成天使在天堂上永远地唱歌？请问，可不可以想象，永远地(forever)过一种什么样的生活，会是一件好事情？forever，不是几百年也不是几万年，而是 forever，eternity，是永远持续下去的。我们都很熟悉边际效益递减理论，第一颗糖是如此的香甜，但是第十颗糖我们就不那么想要，第一百颗糖强迫我们吃都有可能会吐出来。那么，有很大的概率是，没有任何生活，会具有永远的吸引力。每种生活，如果时间足够长，都会到最后变得极度单调乏味和痛苦。每一种生活到最后，都会是你想要摆脱的生活。<strong>永恒，不是美好的事情，而是一件可怕的事情</strong>。这也是为什么，在很多故事设定中，eternity 都是一种诅咒 curse，而不是祝福 blessing。随着时间的进展，我渐渐地有可能会变得和之前的我不一样，“我成为了我最讨厌的人”，你能想象五百年后的自己吗！所以说，永生不死，仔细想想也是很可怕的。当一切都熟悉过后，日复一日的无聊会让人难以忍受。最后，如果真的陷入到永生的期望中，请好好思考一下，你希望永远过一种怎么样的生活？永生不等于长寿，不是活很长的时间，而是永远地活着。这么分析下来，当大家口头上说着这种话的时候，其实只是渴求“我想活得足够长”，而并不是真心觉得“如果能永远活着就好了”！</p>
<p>当我们惧怕死亡的时候，我们惧怕的是什么？Shelly 教授认为，恐惧(be afraid of, scare) 作为一种情绪，能够合理的原因有三条。一，这件事是件坏事 bad thing；我们不害怕好事发生。二，这件事有不可否认的会发生的可能性 即 possibility to happen inevitably；我们不害怕几乎不会发生的坏事。三，这件事有不确定性 uncertainty。那么，当我们惧怕死亡，我们究竟是在害怕什么呢？有可能是：一、惧怕死亡的过程。对痛苦地死去的恐惧，这是合理的。二、惧怕死亡本身，afraid of death itself。教授认为，如果是惧怕死亡，那么并不符合能使这个恐惧心理合理的三个要素。首先，<strong>死亡毕竟是一件确定的事情</strong>——因为大家都终有一死！每个人都是要死的，我们每个人都只是这个地球上的匆匆过客，相聚就是缘分。死亡是我们生命旅途的终点，<strong>难道说我们生命旅途中的每一天，都要为了最后的终点而忧心忡忡吗？</strong>其实这种恐惧是不合理的，我们应该享受沿途的风景。根据剥夺性解释，你还有可能害怕死的太早，英年早逝，因而会无法得到更多的美好的事物而感到沮丧。这个确实是有可能的，但是几率并不是很高，因此不用过于担惊受怕。看来，在还没有仔细思考死亡究竟是怎么一回事前，有一层神秘的面纱罩在死亡上。<strong>经过缜密的对死亡的思考过后，死亡也变得不那么可怖。</strong></p>
<p>我们不应该惧怕死亡。那么，<strong>鉴于我终有一死，这将如何改变我看待别的事物的看法？意识到自己必有一死，会怎样影响到我们的生活方式？</strong></p>
<p>我们可以换一种思考的角度——<strong>我已经是如此地幸运，能够享受到现在我能享受的东西和幸福。</strong>所有组成我的原子，逆熵增定律，组成了我，我现在是一个活着的人类，本身就是一个奇迹。在教授看来，似乎对待死亡正确的看法不应该是恐惧、抱怨、沮丧，而是感恩我们能够拥有生命！学会感恩，生命就会变得通透和明亮。</p>
<p><strong>与其考虑，“我要怎么样才能活下去”，不如考虑，“到底什么才使生活有意义？”。</strong>因为从逻辑上讲，人不仅仅活着就够了，如果失去了生命中有意义的东西，的确会有“生不如死”的情况存在。所以，尽管人生到底有什么意义的问题——What makes my life meaningful? What is the meaning of life?——有的时候令人感到迷茫和痛苦，但确实是需要去思考的：<strong>从思考如何面对死亡，转换为思考怎样才算是活着，转换为思考怎样活才算是真正的、精彩的生活</strong>。于是乎，面对死亡的思考，就可以是这样的线条：死亡是不可避免的，人总有一死——思考要怎么样活着才是有价值的一生——去做那些让生命变得有价值的事情。生命的价值，等于数量（时长）乘以质量。也许有的人认为，生命的质量就已经是足够值得追求的唯一标准了——“朝闻道，夕死可矣”。这种思考路径，起码是隐含了肯定了生命本身是有价值的观点。相反，例如佛教，认为生命本身就是一种苦行和磨难，于是通过某些手段（例如冥想、降低欲望等）让我们尝试从这种折磨中获得解脱和宁静。不过我们在这里还是不愿意就下此定论，我们还是认为生命之中有值得为之一搏的东西的。不过，至于究竟什么是生命中值得追求的事情？生活的意义到底在哪里？这又是另一个哲学难题了。</p>
<p><strong>除了生命的长度和质量，生命的曲线走向也是一个非常重要的考量因素。</strong>我们都希望我们的生命随着事件进展都能够取得一个积极向上的发展态势。我们都被“出生一穷二白、白手起家、最后通过勤奋和努力实现人生梦想”的故事所吸引着。我们也不希望一个红楼梦式的，开始时“鲜花著锦，烈火烹油”，结尾是“白茫茫大地真干净”的故事会降临到自己头上。如果人生巅峰和功成名就来得太早，或许后面就是平庸单调无聊乏味的生活。有一类英年早逝的天才式的人物，例如肖邦或者张国荣，他们的生命停留在那个壮年，没有老去后带来的无可避免的衰老和乏味，<strong>似乎他们的生命力也永远留在了巅峰，这也许多多少少添加了浪漫主义色彩</strong>。或许这也是为什么有的人认为“我想活多久就能活多久，当我不想活的时候还可以随时结束”是一个浪漫的、有吸引力的想法的原因。</p>
<p>Death is inevitable and universal. 如果说有一个东西是无可避免的，那么我们会减轻那种悲伤和失望，毕竟，我们无力改变这一个事实。<strong>“别为打翻的牛奶哭泣”</strong>。如果是有一个东西是人人平等的，那么应该是死亡。人生而不平等，人因死而平等，所以我们会内心会有一种平等的感觉——不是只有我会死。就好像夜晚的派对到了凌晨两三点要散场，拦也是拦不住的。如果对这一点思考透彻后，感觉整个人会想的特开。</p>
<p>Death is unpredictable. 死亡的不可预测性就带来了额外的损害，这样我们无法预测人生，无法做周密而准确的计划。你永远不知道意外和明天哪一个会先来。虽然 death is unpredictable 会让我们感到不舒服，但是，如果 death is predictable 像是我们每个人出生的时候，真的有一本生死簿上记载了你某天某月某日就一定会死去，那样就会好吗？如果你真的相信死亡就是最终的终点，那么，come on，其实死亡没有什么好怕的！如果你是有神论者，担心自己死后会不会下地狱（换言之，死亡不是最终的终点，你死后还要接受审判），那你的担心，还算是有些道理呢！</p>
<p>我们可以是 hedonism 今朝有酒今朝醉，you only live once——既然每一个明天我们都有可能死去，那么我们要尽情地享受当下，没有什么比快乐更加重要。所以我们要把生活的目标尽可能地放在能够把握住的快乐上，然后尽情地享受它们。这种观点有可能妨碍我们取得更大的成就，因为通常那些随手可得的快乐会无助于我们取得更大的进步，而那些伟大成就无一例外地都需要延迟满足的努力和艰辛的付出。取得伟大的成就，足以让人青史留名，那是另一种的永生——我虽然死了，但是我创造的东西依然在我死后存在。例如我在哲学、数学上的杰出研究让几百年后的人依旧在讨论我，或者是一个艺术家，又或者例如我创造了一家伟大的公司、建造了一栋伟大的建筑、写出一本传世的小说，或者抚养了一个家庭，为社会培养了合格的公民、杰出的人才等等，这些都是不那么轻易能达到的成就，都是值得为之付出努力的事业。不过，高回报就意味着高风险，我经商就有可能失败破产；我写小说、玩音乐，有可能用了十年、二十年，都没有写出来；或许我终于知道了我自己只是平庸之才、普通人，或许平安快乐地过完一生，也不需要“赢得生前身后名”也不错！所以，这里可能需要采取混合比例了——“既要仰望星空，也要脚踏实地”，至于这个比例究竟是怎样，还是留给大家自己决定吧！</p>
<p>写到这里，这堂课也从头到尾看的差不多了。似乎，对于死亡本身，以及如何看待“自己终有一死”，已经思考得很通透了。但还缺少了开头提问自己的那个问题——如何看待自己的父母、亲属、长辈终有一天会离开自己？如何看待至亲的死亡？思考了一会儿，我觉得我的看法更加地清晰——因为我终有一天会死，所以要开始认真思考我想怎么活；我的父母和长辈终有一天会死，而且这一天大概率来的比我的死亡要早，所以我要认真地思考我要怎么和他们相处，我想要什么样的亲子关系，我要和他们一起做什么事情、跟他们说什么话、……这真是一个自然而然的想法。</p>
<p>人到这个世界上，逐渐地要离开父母，父母永远地也离开自己，最后自己也要永远地离开这个世界。终有一天是要说再见的，那个时候再怎么挽留和后悔都是没用了。<strong>与其这样，不如当他们还健在时，好好思考要和他们度过怎样的一生，怎么和他们培育关系、做朋友。</strong>不如，现在就和他们说一声，“我爱你”、“你是我的骄傲”。人生在世，不过短短七八十年。开头二十年懵懵懂懂、浑浑噩噩，结尾二十年老态龙钟、老年痴呆，人生过得精彩的部分，不过三十四年。一年52周、365天，三十年也只有区区一万多日！家长和子女，只能相陪人生半程路——父母的前半生，子女未到世上；子女的后半生，作父母的亦不能经历。彼此只能在这短暂的缘分中相伴，彼此只有这短短的半生缘！每当我想到这里，我都会很珍惜和父母的半生缘。如果到了临别时才依依不舍痛苦万分，后悔该做什么却没有做到，我觉得那才真是永远的遗憾，加深了离别的痛苦啊！</p>
<p>在长辈的生前，我们应该积极努力地不留遗憾。等到长辈去世之后，我们还可以做许多事情来纪念他们：</p>
<ol>
<li>哀悼他们的离去，不回避悲伤，是一种健康应对死亡的方式；</li>
<li>和别人谈起他对你的影响；</li>
<li>铭记你和他的故事，铭记他对你的教诲，努力去记住他是如何影响了你的生活；</li>
<li>过一种能够延续他们的使命的生活；</li>
<li>继续在内心和他们交谈，相信他们仍然在看着你，指导你，祝福你。</li>
</ol>
<p>如果真的把这些都做到的话，真等到那一天，做子女的也可以更加安心地说再见吧！做长辈的也可以更加潇洒地离开这世界。挥挥手，不带走一片云彩！</p>
]]></content>
  </entry>
  <entry>
    <title>The Road to SDN, An Interllectual History of Programmable Networks</title>
    <url>/2017/12/03/Nick-Feamster-The-Road-To-SDN/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>软件定义网络（SDN）是一项激动人心的技术，可以帮助我们设计和管理网络。 <strong>虽然这项技术似乎突然出现，但SDN是使计算机网络更具可编程性的悠久历史的一部分。</strong> 在本文中，我们追踪可编程网络的智能历史，包括<strong>主动网络，早期分离控制和数据平面的工作，以及最近在OpenFlow和网络操作系统方面的工作</strong>。 我们强调关键概念，以及推动每项创新的技术推动和应用拉动。 一路走来，揭开了关于技术的常见误区和误区，明确了SDN和网络虚拟化等相关技术之间的关系。</p>
<h1 id="The-Road-to-SDN"><a href="#The-Road-to-SDN" class="headerlink" title="The Road to SDN"></a>The Road to SDN</h1><p>传统网络是非常复杂，且难以管理的：</p>
<ol>
<li>设备种类繁杂（路由器、交换机、各种middlebox）</li>
<li>设备上运行的分布式控制软件通常是专有且封闭的。</li>
<li>底层协议要标准化需要经过多年的时间，来实践互操作性等。</li>
<li>配置网络需要通过一些配置接口或者软件，这些接口和软件在不同的硬件提供商之间差别很大，不兼容。</li>
</ol>
<p>这就导致了增加了网络的复杂性，降低了网络研发的创新速度。SDN 作为一种设计和管理网络的新思路，主要有两个特点：</p>
<ol>
<li>分离数据和控制平面。</li>
<li>巩固控制平面，一个单独的软件控制器通过 API 控制多个数据平面元素。OpenFlow 就是其中一种 API。</li>
</ol>
<p>今天，SDN 在变得越来越重要，不过，它背后的一些思想甚至已经经历了 20 多年的成长和进化。SDN 在某种程度上就是回顾了这些早期的思想，作为一个集大成者，将控制平面和数据平面进行清晰的分离，来简化网络管理，简化配置。</p>
<blockquote>
<p>we caution the reader that any history is incomplete and more nuanced than a single storyline might suggest. 我们需要提醒读者的是，任何一段历史都是不完整的，但能比单一的一段故事所描述的更细致。</p>
</blockquote>
<h1 id="Active-Network-the-mid-1990s-to-the-early-2000s"><a href="#Active-Network-the-mid-1990s-to-the-early-2000s" class="headerlink" title="Active Network (the mid 1990s to the early 2000s)"></a>Active Network (the mid 1990s to the early 2000s)</h1><p>对于网络，研究人员的测试、配置新 idea 的开发流程通常是：</p>
<ol>
<li>设计好新的协议，并在实验室小规模范围实验。</li>
<li>在更大的网络上做模拟（比如校园网）</li>
<li>如果效果好、资金等方面都到位，就可以通过 IETF 等组织来标准化这个协议。<strong>这个过程通常耗时非常久，使很多研究人员疲惫。</strong></li>
</ol>
<p>一些研究人员想要改变这个情况，他们追求一种能够打开网络控制的手段，因为其实从各种意义上来讲，传统网络是不可编程的。</p>
<p>Active Network 基本思路：</p>
<p>展现一个可编程接口（Network API），暴露各种单独网络节点的各种资源（处理进程、存储器、包队列等），还可以通过自定义功能来实现对经过这个节点的分组进行某种处理。</p>
<p>Active Network 使用两种编程模型：</p>
<ol>
<li>胶囊。在分组中携带可以执行的代码，也就是说分组运行执行自定义操作。</li>
<li>可编程路由器和交换机，强调的是由可编程的交换机根据分组中的代码，执行不同的操作。</li>
</ol>
<p>为什么成为了历史尘埃：</p>
<ol>
<li>虽然进行了初步的网络可编程功能的探索，但是对象是<strong>数据平面的可编程性</strong>。数据平面的“杀手级”应用是非常少，或者说很难构想的。</li>
<li>对 active Network 的应用，需要引入了非常多 middlebox，这意味着不同硬件厂商提供的是不兼容的编程模型。也就是说虽然开放了可编程接口，但不同厂商的设备之间还是封闭的。</li>
<li>这种直接打开一个 API 暴露硬件内部处理细节的方式，目的是为了让实验人员的开发更方便，但这种方式不一定讨硬件供货商的喜。</li>
<li>对于一些紧迫的问题，也没有引人注目的解决效果。比如，还是不容易部署；没有进一步实现控制和数据平面的解耦合等。</li>
</ol>
<p>虽然如此，但 Active Network 的初步尝试中，蕴含着 SDN 至今沿用的思想：</p>
<ol>
<li>为了方便配置新的机器，方便研发</li>
<li>对网络行为的细粒度控制</li>
<li>方便研究人员进行研发的需求</li>
</ol>
<p>对未来研究的智力贡献有：</p>
<ol>
<li>可编程网络功能的思想。</li>
<li>对报头的解复用能力。</li>
<li>提供一个愿景——对 middlebox 的一种统一的架构</li>
</ol>
<h1 id="Control-and-Data-Plane-Separation-around-2001-to-2007"><a href="#Control-and-Data-Plane-Separation-around-2001-to-2007" class="headerlink" title="Control and Data Plane Separation (around 2001 to 2007)"></a>Control and Data Plane Separation (around 2001 to 2007)</h1><p>到了二十一世纪，急速增加的网络流量对网络提出了可靠性、可预测性、性能的新要求。网络管理员寻求更好的管理网络的办法，以及想要实现一些新的功能。</p>
<p>传统的交换机和路由器体现了一种控制与数据平面的紧耦合，这使得一些对网络的 configuration debug、预测、控制路由行为等操作非常的具有挑战性。ISP 也为了管理范围越来越大的网络头疼，这需要更好的可靠性，需要更多的服务。这些驱动了这种创新：</p>
<ol>
<li>在控制平面和数据平面之间有一个开放的接口。例如：ForCES（Forwarding and Control Separation）</li>
<li>对网络的一种逻辑上中心控制。(logical centralized control of the network)</li>
</ol>
<p>与 Active Network 着眼点就有所不同了：</p>
<ol>
<li>分离控制与数据平面的创新主要是由网络管理员来推动的，而 Active Network 主要是由终端用户和网络协议研究人员推动的。</li>
<li>前者主要注重控制平面的可编程性，而后者着重数据平面可编程性。</li>
<li>前者希望有一个对网络范围的清晰视线，后者只在设备配置这个层次。</li>
</ol>
<blockquote>
<p>Forces Protocol，是第一个将控制通道从分组交换网络中分离出来的协议，最早标准化于2003年。协议允许许多控制元素（control element，CE）去控制传输元素（forwarding element，FE）。也就是说，交换机、各种 FE，由一个叫 forces interface 的标准化的控制通道来控制。在forces interface 之上，又有各种控制器来控制 FE 的具体行为。这也是有一点像 OpenFlow 的模型。但这种方法存在一个问题：需要采取由供应商提供的标准、并配置新硬件。引入新的控制时很困难。这些障碍与早期的一些工作遇到的障碍是一样的，例如 Active Network。</p>
</blockquote>
<p>为什么 ForCES 成为了历史尘埃：</p>
<ol>
<li>对其有一些主要的争论是是否违反了 fate-sharing 原则</li>
<li>vendor 还是不愿意开放接口。这是 OpenFlow 解决得较好的一个方面，使用 OpenFlow，硬件供货商无需暴露硬件内部细节。</li>
<li>对数据平面的控制还要依赖与现有协议，而没有提供更宽广范围的可编程性。对现有协议的依赖也限制了控制器提供的应用。因此也限制了 ForCES 的大规模应用。</li>
</ol>
<p>但也是有着 SDN 思想：</p>
<ol>
<li>有一个逻辑上处于中心的控制器，使用接口 API 来控制数据平面。</li>
<li>分布式状态管理。</li>
</ol>
<h1 id="OpenFlow-API-and-Network-Operating-System-around-2007-to-2010"><a href="#OpenFlow-API-and-Network-Operating-System-around-2007-to-2010" class="headerlink" title="OpenFlow API and Network Operating System (around 2007 to 2010)"></a>OpenFlow API and Network Operating System (around 2007 to 2010)</h1><hr>
]]></content>
      <categories>
        <category>paper-reading</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之 Object Oriented</title>
    <url>/2017/06/07/Object-Oriented/</url>
    <content><![CDATA[<h1 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h1><p>面对对象编程（Object Oriented Programming）是一种特殊的设计程序的概念性方法，C++就是通过一些特性的修改，改进了C语言，使得应用这种方法更加简便。下面是最重要的OOP特性：</p>
<p>1。 抽象<br>2。 封装和数据隐藏<br>3。 多态<br>4。 继承<br>5。 代码的可重用性</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>面向对象程序设计的基本要素是抽象，程序员通过抽象来管理复杂性。 </p>
<p>管理抽象的有效方法是使用层次式的分类特性，这种方法允许用户根据物理含义<strong>分解一个复杂的系统</strong>，把它划分成更容易管理的块。例如，一个计算机系统是一个独立的对象。而在计算机系统内部由几个子系统组成:显示器，键盘，硬盘驱动器，DVD-ROM，软盘，音响等，这些子系统每个又由专门的部件组成。关键是需要使用层次抽象来管理计算机系统(或其他任何复杂系统)的复杂性。 </p>
<p>面向对象程序设计的本质:这些抽象的对象可以被看作具体的实体，这些实体对用来告诉我们作什么的消息进行响应。 </p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是一种<strong>把代码和代码所操作的数据捆绑在一起，使这两者不受外界干扰和误用的机制</strong>。封装可被理解为一种用做保护的包装器，以防止代码和数据被包装器外部所定义的其他代码任意访问。对包装器内部代码与数据的访问通过一个明确定义的接口来控制。封装代码的好处是<strong>每个人都知道怎样访问代码，进而无需考虑实现细节就能直接使用它，同时不用担心不可预料的副作用</strong>。 </p>
<p>在定义一个类时，需要指定构成该类的代码与数据。特别是，类所定义的对象叫做<strong>成员变量</strong>或实例变量。操作数据的代码叫做成员<strong>方法</strong>。方法定义怎样使用成员变量，这意味着类的行为和接口要由操作实例数据的方法来定义。 </p>
<p>由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。所以C++提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西。私有的方法数据只能通过该类的成员代码来访问。这就可以确保不会发生不希望的事情。 </p>
<p>C语言函数不是也是封装吗？</p>
<p>按照软件工程的要求，程序是要强调<strong>“强内聚”和“弱耦合”</strong>的，简单地说，就是强调封装，封装好了易于重用; C语言其实也强调封装，就比如函数就是C语言的一种封装机制，但<strong>函数的封装能力非常有限</strong>，只能封装某个功能，保持合理的封装无法靠机制来实现，只能靠程序员的自觉。C++正是因为C语言的封装能力不足，才产生的，C++从机制上就保证了封装的必然性，一个对象可以有多种行为，可以把相关的一组行为封装在一起，而<strong>把不相关的行为彻底与它分开</strong>。这样做从机制上保证了封装的必然性，减少了随意性。当然只有用封装的思维去使用它，C++的优势才能充分发挥。封装和重用是面向对象的核心目的，其他特点都是为这两者服务的。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>继承是指一个对象从另一个对象中获得属性的过程。</strong>是面向对象程序设计的三大原则之二，它支持按层次分类的概念。例如，波斯猫是猫的一种，猫又是哺乳动物的一种，哺乳动物又是动物的一种。如果不使用层次的概念，每个对象需要明确定义各自的全部特征。通过层次分类方式，一个对象只需要在它的类中定义是它成为唯一的 各个属性，然后从父类中继承它的通用属性。因此，正是由于继承机制，才使得一个对象可以成为一个通用类的一个特定实例。一个深度继承的子类将继承它在类层次中的每个祖先的所有属性。 </p>
<p>继承与封装可以互相作用。<strong>如果一个给定的类封装了某些属性，它的任何子类将会含有同样得属性，另加各个子类所有得属性。</strong>这是面向对象程序在复杂性上呈线性而非几何增长的一个重要概念。新的子类继承其所有祖先的所有属性。子类和系统中的其他代码不会产生无法预料的交互作用。 </p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>多态是指一个方法只能有一个名称，但可以有许多形态</strong>，也就是程序中可以定义多个同名的方法，用”一个接口，多个方法”来描述。可以通过方法的参数和类型引用。 </p>
<h1 id="面对过程和面对对象的比较"><a href="#面对过程和面对对象的比较" class="headerlink" title="面对过程和面对对象的比较"></a>面对过程和面对对象的比较</h1><h2 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h2><p>面向过程编程是一种以过程为中心的编程思想，分析出解决问题的步骤，然后用函数把这些步骤一步一步实现。面向过程编程，数据和对数据的操作是分离的。</p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象编程是将事物对象化，通过对象通信来解决问题。面向对象编程，数据和对数据的操作是绑定在一起的。封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的类。它们的目的都是为了代码重用。而多态则是为了实现接口重用。面向对象的代码更加支持重用，能降低软件开发和维护的成本，提高软件的质量。掌握面向对象的困难之处在于思路的转换。我们通常习惯于考虑解决问题的方法，而不是考虑将问题抽象成对象再去解决它。</p>
<p>从两个简单的例子来理解两者的区别。</p>
<p>第一个简单的例子：编写一个驾驶汽车的方法</p>
<p>面向过程的程序设计：<br>编写一个方法，<code>void drivecar();</code><br>面向对象的程序设计：<br>将一辆汽车看成一个对象，将所有汽车对象的共性抽取出来，设计一个类<code>Car</code>，类中有一个方法<code>void drive()</code>，用Car这个类实例化一个具体的<code>对象car</code>，调用：<code>car。drive()</code></p>
<p>第二个简单的例子：求一个长方形的周长和面积。<br>面向过程的程序设计方式：<br>1、确定长方形周长和面积的算法。<br>2、编写两个方法（函数）分别计算长方形的周长和面积。<br>3、求周长的方法（函数）和求面积的方法（函数）需要两个参数，分别是长方形的长和宽。</p>
<p>面向对象的程序设计方式：<br>1、一个长方形可以看成一个长方形对象。<br>2、一个长方形对象有两个状态（长和宽）和两个行为（求周长和求面积）。<br>3、将所有长方形的共性抽取出来，设计一个长方形类。<br>4、通过长方形对象的行为，就可以求出某个具体的长方形对象的周长和面积。</p>
<p>面向过程就是分析出解决问题所需要的<strong>步骤</strong>，然后用函数把这些步骤<strong>一步一步实现</strong>，使用的时候一个一个依次调用就可以了。 </p>
<p>面向对象是把构成问题事务<strong>分解成各个对象</strong>，建立对象的<strong>目的不是为了完成一个步骤</strong>，而是为了<strong>描叙</strong>某个事物在整个解决问题的步骤中的<strong>行为</strong>。 </p>
<p>例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用分别的函数来实现，问题就解决了。</p>
<p>而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为 1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的i变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。 </p>
<p>可以明显地看出，<strong>面向对象是以功能来划分问题，而不是步骤</strong>。同样是绘制棋局，这样的行为在面向过程的设计中分散在了总多步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。 </p>
<p>功能上的统一保证了面向对象设计的可扩展性。比如我<strong>要加入悔棋</strong>的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行<strong>大规模调整</strong>。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。 </p>
<p>再比如我要把这个五子棋游戏改为围棋游戏，如果你是面向过程设计，那么五子棋的规则就分布在了你的程序的每一个角落，要改动还不如重写。但是如果你当初就是面向对象的设计，那么你只用改动规则对象就可以了，五子棋和围棋的区别不就是规则吗？（当然棋盘大小好像也不一样，但是你会觉得这是一个难题吗？直接在棋盘对象中进行一番小改动就可以了。）而下棋的大致步骤从面向对象的角度来看没有任何变化。</p>
<p>当然，要达到改动只是局部的需要设计的人有足够的经验，<strong>使用对象不能保证你的程序就是面向对象</strong>（C with class），初学者或者很蹩脚的程序员很可能以面向对象之虚而行面向过程之实，这样设计出来的所谓面向对象的程序很难有良好的可移植性和可扩展性。</p>
<p>但我觉得，初学者不必着急，就算是C with class，也不用担心，只要用心体会面向对象编程的思想，勤加练习，有一天也能写出很好的面向对象思想的程序来。（打算法题就是用C with STL我会乱说吗？）</p>
<h1 id="抽象、类型、接口"><a href="#抽象、类型、接口" class="headerlink" title="抽象、类型、接口"></a>抽象、类型、接口</h1><h2 id="抽象是什么？"><a href="#抽象是什么？" class="headerlink" title="抽象是什么？"></a>抽象是什么？</h2><p>生活中充满复杂性，处理复杂性的一种方法就是<strong>简化和抽象</strong>。在计算中，为了根据信息与用户之间的接口来表示它，抽象是至关重要的。也就是说，把问题的本质抽象出来，根据特征来描述解决方案。抽象是通往用户定义类型的捷径，用户定义类型指的是实现抽象接口的类设计。</p>
<h2 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h2><p>类（class）是面向对象程序设计的核心，它实际是一种<strong>新的数据类型</strong>，也是实现抽象类型的工具，因为类是通过抽象数据类型的方法来实现的一种数据类型。类是对某一类对象的抽象；而对象是某一种类的实例，因此，<strong>类和对象是密切相关的</strong>。没有脱离对象的类，也没有不依赖于类的对象。</p>
<p>类是一种复杂的数据类型，它是将不同类型的数据和与这些数据相关的操作封装在一起的集合体。这有点像C语言中的结构，唯一不同的就是结构没有定义所说的“数据相关的操作”，“数据相关的操作”就是我们平常经常看到的“方法”，因此，类具有更高的抽象性，类中的数据具有隐藏性，类还具有封装性。</p>
<p>类的结构(也即类的组成)是用来确定一类对象的行为的，而这些行为是通过类的内部数据结构和相关的操作来确定的。这些行为是通过一种操作<strong>接口</strong>来描述的(也即平时我们所看到的类的成员函数)，使用者只关心的是接口的功能(也就是我们只关心类的各个成员函数的功能)，对它是如何实现的并不感兴趣。而操作接口又被称为这类对象向其他对象所提供的服务。</p>
<h2 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h2><p>接口（interface）是一个共享框架，供两个系统（例如计算机和打印机之间、用户和计算机程序之间）交互时使用。</p>
<p>对于类，就是我们说的公共接口。交互系统由类对象构成，而接口由编写类的人提供的方法组成。接口能让程序员编写类与对象交互的代码，从而让程序能够使用类对象。例如要计算string类对象包含多少个字符，就无需打开对象，只需要使用string类提供的<code>size()</code>方法。</p>
<p>类设计禁止公共用户直接访问类，但可以使用方法，例如<code>size()</code>等等。方法<code>size()</code>就是用户和string类直接的公共接口的一个组成部分。还有例如方法<code>getline()</code>是istream类的一个接口，使用<code>cin</code>的程序，不是直接与cin对象内部进行交互来读取一行输入，而是使用<code>getline()</code>。</p>
<p>要使用某个类，必须了解其接口；要编写类，就必须为其创建接口。</p>
<p>例如你编写C++程序时，将类声明和类方法放到.h文件中，而.cpp文件中是接口的具体实现，但你只把编译好的.obj文件和.h文件发给你的用户。用户只需通过.h文件知道接口如何调用即可，不需要知道是怎么实现的。同时也防止了用户在外部对其进行修改。</p>
<hr>
<p>参考链接</p>
<ul>
<li><a href="http://blog。csdn。net/sxhlovehmm/article/details/45082605">面向过程编程和面向对象编程的区别</a></li>
<li><a href="http://www。cnblogs。com/mr-wid/archive/2013/02/18/2916309。html">学习C++ -&gt; 类(Classes)的定义与实现</a></li>
<li><a href="http://www。yesky。com/22/194022。shtml">C++ 类和类的定义</a></li>
<li><a href="http://blog。csdn。net/chaoguodong/article/details/6935524">C++接口定义及实现举例</a></li>
</ul>
<p>拓展阅读：</p>
<ul>
<li><a href="https://www。zhihu。com/question/20275578/answer/26690018">面对对象编程的弊端是什么</a></li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>约翰·密尔《论自由》读书笔记</title>
    <url>/2019/12/28/On-Liberty/</url>
    <content><![CDATA[<p>出版于1859年的古典自由主义的经典著作，作者约翰·斯图尔特·密尔 (John Stuart Mill)，英国著名哲学家和经济学家，19世纪影响力很大的古典自由主义思想家。本书的写作目的，被认为是对十九世纪维多利亚社会中弥漫着的强制性道德主义的反抗，在充斥着宗教不容忍与如影随形的伪善的维多利亚社会里，为个人抵御这些压迫势力提供一些保护。《论自由》被誉为“肯定人类个体的个性不可泯灭的价值最优雅，意义最重大，影响最为深远的宣言”。这本书被评价为“如果现代世界要承认某一本书设定了自由主义的根本道德基础，这本书很可能是《论自由》”。</p>
<p>看完这本书，我对思想自由 (freedom of thought)、言论和表达自由 (freedom of speech)、个性(personality or individuality)、多元性（diversity）的重要性有了更深入的理解，所以故作此读书记录推荐给大家。</p>
<h1 id="论思想自由和讨论自由"><a href="#论思想自由和讨论自由" class="headerlink" title="论思想自由和讨论自由"></a>论思想自由和讨论自由</h1><p>在第一章，作者用严密的逻辑思路论证了思想自由和讨论自由是人类不可剥夺的自由。</p>
<h2 id="人的有限性、绝对确定性的错误"><a href="#人的有限性、绝对确定性的错误" class="headerlink" title="人的有限性、绝对确定性的错误"></a>人的有限性、绝对确定性的错误</h2><p>首先，我们作为人类，我们永远了解到的都是这个世界的一部分，我们永远都只是在追求真理的道路上的无知的人。正如苏格拉底的名言所说，我唯一知道的就是我什么都不知道 (I know nothing except the fact of my ignorance)，这就是人的有限性。<strong>所以我们永远不知道，我们尝试剥夺其言论自由的那个人所说的那些话，是否可能是真确的</strong>。人是有限的，这一点是不言自明的，历史上已经有无数的例子证明了某个时代的天才的真知灼见并不为当代社会和当代人所容；同样，每个时代都曾流行着许多由后人看来是荒谬的意见和思想；这就可知，现在所流行的意见当中必有一部分必为将来所排斥，而未来的真理就暗藏在当今社会的某个角落中。这就是说，<strong>我们永远不能假定一个意见是绝对错误的</strong>，这就是犯了<strong>绝对确定性的错误</strong>。在禁止某意见的发表的时候，若我们没有意识到将要禁止的这条意见有可能是正确的，那我们就犯了绝对确定性的错误。</p>
<p>绝对确定性是一个每个人都会不经意间常犯的错误，每个人并不深知这一点：<strong>自己并不认识到自己有可能会犯错误，却常常假定他人的对错是绝对的</strong>。有的时候，我们会用某些手段逃避我们本应当负起的对自己意见的不可能错误性的裁判者的责任，就比如，作者点明了另一种错误：<strong>冒认性不可能错误</strong>，也就是<strong>代替他人判定那个问题，而没有允许他人听一听相反方面能够说出的意见</strong>。只要有人追求一私判断的同时，阻挡别人听到那些对于该意见的辩护，他就犯了冒认不可能错误性。这种错误的危险性并不见得比绝对确定性的危险性要少。这里可以举苏格拉底作为例子，苏格拉底是经过法院的裁判，认定不敬神（否认希腊当时信奉的神——括号内为本博文作者注，下同）和不道德（所谓败坏青年），就这样把一个伟大的哲学家处死了（虽然苏格拉底是欣然赴死）。所以，本书作者想要警告的是，把绝对确定性责任丢给其他人就高枕无忧的人，轻易的就接受他人观点的时候，正是远离真理的时候。所以，当我们面对消息和意见时，要做的是 critical thinking 和 fact check，而不是无脑地轻信和一概接受，尤其是当该消息来源有意屏蔽讨论，那就不能作为可信的信息源。</p>
<h2 id="思想的市场"><a href="#思想的市场" class="headerlink" title="思想的市场"></a>思想的市场</h2><p>下面来说说<strong>讨论和辩论的重要性</strong>。这里我借用一下美国最高法院法官奥利弗·霍姆斯对于言论自由的定义，我觉得这个定义很是精妙恰当，他说，<strong>“言论自由的唯一意义，是指每一个信仰，哪怕是最不受欢迎的思想和信仰，的鼓吹者和提倡者，都有权在广大的‘思想的市场’上去尝试说服公众接受他们的主张”</strong>。（好好揣摩一下这句话吧）。在这里我想到一个很好的问题，我们需不需要禁止谎言和谬误？我想是不需要的，正因为真理是愈辩愈明的，真理是不怕谎言的，前提就是要保证各种思想和言论能够在广大的“思想的市场”上进行畅通无阻的辩论。一个人能够掌握一个题目的全面，唯一途径就是聆听各种不同意见的人关于这个问题的看法和观点，并研究各种不同的结论。一个人要变得智慧，也需要借着他人的意见来校正自己得以改正和完备。一个人对一件事若仅仅知道他自己的那一方，那他对这个事情就知之甚少。一个真正理性的人，不会只去寻找那些符合他观点的论据（先开枪再画靶）。如果不能驳倒对方，或者对对方的理由所知甚少，没有根据多方意见有所择取的话，那么合理的立场应该是把判断悬置起来。若做不到这样，那就不理性，要么被情绪带着走，要么被权威带着走。即使是最正确的言论，也需要放到公众前面审核。任何信条，没有什么可靠的保护，只有一份对全世界的长期请柬来邀请大家都来证明这个信条是真确的。这就算是尽到了人类理智现状所需可的最大努力，因为如果还有更好的真理，到了人类心灵能发现时就会把它找到，而不会因为<strong>既定意见的沉睡</strong>而让真理蒙尘。在作者看来，对世界发现出一些与它深切相关而目前为世所不知的事务，向世界指正重大议题上曾有误解，这乃是一个人力所能及的对同胞的重大服务，我深表认同。</p>
<p>请问，<strong>如果说真理胜过谎言，是胜在什么地方呢？真理就一定胜过谎言吗？那其实未必</strong>。历史上谬误迫害真理而得胜的事例也是常有的，就算最后人类改邪归正，也足以让真理倒退若干世纪。显而易见，真理面对迫害、监狱、酷刑不会自动胜出，使用足量的法律或者惩罚，足以成功地制止真理的传播和使人们噤声。本书作者认为，真理所享有的真正优越之处在于：一个意见只要是正确的，尽管可以一次或多次地被压制，但在悠悠岁月中一般总会有人不断地重新发现它，直到某一次的重现时，情况有利，恰好逃过迫害，随即在世人面前展露，获得能够抵挡随后的任何再试图压制它的行为的能力。社会对不同意见的不宽容、诋毁、处罚、迫害，会导致<strong>寒蝉效应</strong>，这是使得一个国度不能真正精神自由的关键所在。<strong>寒蝉效应有什么坏处？</strong></p>
<ol>
<li>得势意见外表上看来支持者甚多，代价是牺牲了人类心灵的道德勇敢，对于最高问题的自由而勇敢的思想被放弃了。</li>
<li>出现滥调的应声虫，这种人发言的一切目的是为了听众或社会环境，而不是自己真正信服的东西。知识分子不敢追随自己思想独立的结果。</li>
<li>“异端”意见永远得不到公平透彻的讨论，或者大行其道的永远是对“异端”意见的驳斥。虽然遏制了讨论，但反对意见却不会就此消失。</li>
<li>人们即使不持“异端”意见，但是出于对迫害的害怕，他们的整个精神发展都被限制，不敢“胡思乱想”，就好像穿了三寸金莲的女人的脚一样。</li>
</ol>
<p>总结：再也不会有伟大的思想家，也不会有智力活跃的人民。</p>
<h2 id="即使公意是对的，不允许反对依然有损于真理"><a href="#即使公意是对的，不允许反对依然有损于真理" class="headerlink" title="即使公意是对的，不允许反对依然有损于真理"></a>即使公意是对的，不允许反对依然有损于真理</h2><p>以上，作者从人类的有限性和任何既定意见都可能是谬误为出发点，论证了思想和讨论自由的必要性。接下来作者转入论证的第二部分，<strong>不再假定任何既定意见都可能有谬误，而是一概假定它们都是真确的</strong>。作者依旧证明了，在这个情况下，依然要维护言论自由。这是我对作者佩服的地方，论证逻辑非常完整。</p>
<p>作者是这么发问的：<strong>如果所有既定意见或者观点都是好的，不需要承认其有谬误的可能，直接教导给人们叫他们遵从，怎么样</strong>？作者认为，这是十分有害的。若出现这种情况，那么人们所被灌输而形成的观点，只是死的教条，而不是活的真理。作者认为，<strong>人类的逻辑、理智、智力和判断力，都是需要培养和锻炼的。当人们不需要经过思辨，只要接受观点和意见就可以，那么就是思维能力退化的时候</strong>。作者提出，如果一个人选择相信什么，那么这个人必须至少有能力可以为针对这种观点的普通的反驳作基本的辩护。若只是被灌输的、没有经过思考就接受的人，对该观点的反对、背面，是一无所知的，也不能替它在最肤浅的反驳前辩护。人们若只是因为领教到权威的力量而选择相信教条，没有坚定的信念作为基础，那么<strong>这不是有知于真理，只不过是迷信假借真理之名大行其道</strong>。即使是公众普遍认为的真理，若不允许它遭受质疑或争议，那么多数接收者认同这个真理的时候其实是像认同一个偏见一样，对其的理性依据就会减少。我们可以想象，若有一个意见，被灌输是绝对正确的，而且不允许任何的质疑和辩论，那么接受他的人，必然对该观点的理解就是片面和不够深刻的。若后来的几代人都是这种情况，那么人们对于这些问题的态度就是付以麻木而淡漠的同意，只是一味地承袭了它而不是理性地采纳了它，接受这些意见是被动而不是主动。他们不再需要面对反对者发出的挑战而自卫，也不需要尝试在思想的市场上说服其他人。直到最后，就出现了“<strong>既定意见的沉睡</strong>”——思想的战场上没有了敌人，学生和教授都只需要去睡觉了。</p>
<p><strong>不仅对接受这种思想的人们的智力水平是有害的，对这个思想本身也是有害的</strong>。该思想得势成为普遍的意见，是通过迫害不同的反对意见，人们接受该“正统思想”也只是出于对于“正端”的臣服和对“异端”的迫害的唯恐避之不及。<strong>对于一个意见，在各种辩论中未被驳倒而被认定为真确，和不许对它驳辩而假定其正确性，这是两个有巨大区别的情况</strong>，后者已经从意见上升至“教条”。关于该意见的争论因为被压制而逐渐消失，该意见的得势会让得势意见本身停止前进，失去进步的动力。由于力图保持已经得到的地位，会进一步制止别人的反对和辩论。这会有什么坏处呢？看书看到这里，我就想到一个例子，春秋战国的百家争鸣时期是中国思想学术最活跃、各种学说层出不穷的一个时代。罢黜百家独尊儒术之后，儒学得到了正统治国思想之地位，但是千百年来儒家思想就再也没能更进一步了，然后其中糟粕在后来的时代中就愈发地暴露明显。对于追求真理来说，这是百害而无一利的。教条的存在，就像是一个哨兵，监守人的思想和心灵，防着人类有什么“奇思妙想”，把人的心灵僵化，抵挡住了人自由发展的本性。</p>
<p>有人要问了，<strong>为什么一定要允许反对意见的存在</strong>？难道真确的意见不应该就是所有人都一致认同吗？难道说如果一个真理被人类一致接受它就不是真理了吗？不得不说，这是一个好问题！作者是这样回答的：<strong>在人类进步的历史进程中，人类福祉正是要用无可争辩的真理的数量和重量来衡量的</strong>。在每一段历史的进程中，都有这一历史时期悬而未决、需要讨论的重大问题。对于这些问题的争论，在历史的发展中，就逐渐形成定论并确定下来，这就是所谓的<strong>意见凝固化</strong>，这是必然的过程。<strong>真理的凝固化的确是社会进步的体现，但是在错误意见方面的凝固化同样是非常危险和极其有害的</strong>。从长的时间跨度来看，意见的凝固化是有必然性的，但是我们并不能认为所带来的一切结果都是有益的。<strong>使一个真理确定其普遍性所带来的好处，并不会消弭压制真理而让谎言大行其道所带来的坏处</strong>。如果有人在法律和舆论许可的情况下对公认的意见提出质疑，作为人类的同类我们着实要感谢他们，敞开心扉倾听他们，因为他们替我们做了我们作为人类的一份子应当做，且做起来相当费力的事情。提出质疑，是追求真理的道路上的一件大好事，关于怎么做到这一点，柏拉图对话和苏格拉底式雄辩已经给我们做了极好的示范。</p>
<h2 id="拒绝二元对立，不要非黑即白"><a href="#拒绝二元对立，不要非黑即白" class="headerlink" title="拒绝二元对立，不要非黑即白"></a>拒绝二元对立，不要非黑即白</h2><p>到现在为止，我们考虑了两种可能性：一种假定已有的公认意见为谬误，而企图压制的其他意见可能为真理；另一种假定已有的公认意见为真确，那么灌输和被动的接纳，相比理性的接受，会让思想本身褪色、人类的智力水平退化，针对该意见的辩论可以助其更好的发展。我本以为到这里论证就已经相当圆满了，然而接下来，本书作者为我们展示了最为公允、全面的思考方式。作者继续点明了更为重要的一点：<strong>拒绝二元对立，不要非黑即白</strong>。两种冲突的意见，往往并不是非此即彼的，不一定是此方一定为真确，彼方一定为谬误，一般来说更有可能的情况往往是存在共同介于二者之间的真理。<strong>流行的意见一般是真确的，可是它们往往只是真理的一部分。异端的意见有可能错误，但往往也包含着被压制、被忽视的另一部分真理</strong>。流行的公意面对被压制的异议，一般不会思考异议者所说的是否有其道理，或者是否有蕴含的一部分真理，而是直接把他置于敌对地位，以排他性确立自己为绝对真理。这一现象屡见不鲜，是因为就人类心灵而言，片面性占多数，而多面性则是例外。时代的前进，只不过是新的一个偏而不全的真理替代另一个偏而不全的真理罢了，进步之处主要在于后一个偏颇的真理比前一个更适合于时代的需要。所以我们必须要珍视凡为当前通行意见所忽略的，而其中却又多少体现部分真理的其他意见，因为它们之中就包含着对我们可能已经犯下的错误的指正。在人类现有智力水平下，只有通过意见分歧才能使真理的各个部分得到公平比赛的机会，即使当下的人们认为他们再怎么正确也不过分，<strong>若不让少数异议者说话，那么真理就会有所损失的</strong>。</p>
<blockquote>
<p>群众从未渴求过真理，他们对不合口味的证据视而不见。假如谬误对他们有诱惑力，他们更愿意崇拜谬误。谁向他们提供幻觉，谁就可以轻易地成为他们的主人；谁摧毁他们的幻觉，谁就会成为他们的牺牲品。——《乌合之众》</p>
</blockquote>
<p>本书第一章就结束了，总结一下作者所论证的思想自由和发表思想的自由重要性的三点根据：</p>
<ol>
<li>当前流行的公意有可能是谬误，企图压制的言论有可能是真理。若否认这一点，则犯了绝对确定性的错误。</li>
<li>纵使当前流行的公意是真确的，一般而且常常只是部分真理，包含一部分谬误。被迫缄默的反对言论可能是错误的，但是它也可能，而且通常，包含部分真理。只有在冲突和辩论中，所遗失的真理才有机会得到补足。</li>
<li>即使当前流行的公意是绝对全部真理，若不容许质疑且灌输教导使所有人遵从服从，则该意见上升到了教义的高度。则接受者的智力水平会下降，该教义本身也有丧失意义和进步性的危险。</li>
</ol>
<h1 id="论人类福祉的因素之一——个性"><a href="#论人类福祉的因素之一——个性" class="headerlink" title="论人类福祉的因素之一——个性"></a>论人类福祉的因素之一——个性</h1><p>如前所述，人类应当有自由去形成自己的意见并可以毫无保留地发表，若这个自由得不到承认，那么无论是在人的智性、德性还是思想本身的意义方面都会遭到重大损失。个人的自由的界限，就是不使自己成为别人的妨碍，个人的自由的边界就是他人的自由。<strong>既然说在人类未臻完善的时候，鼓励不同意见的存在是大有益处的，那么同样可以说，在生活方面的多姿多彩也同样是大有益处的；对于各种各样的个性，只要没有对他人造成损害，那么就应当给予自由发展的余地</strong>。不同的个性和生活方式的价值应当给以实践的权利，在这一点上，<strong>个性的多样化和言论自由对于人类社会的价值是相似的</strong>。</p>
<h2 id="个性使人类高贵而美丽"><a href="#个性使人类高贵而美丽" class="headerlink" title="个性使人类高贵而美丽"></a>个性使人类高贵而美丽</h2><p>在某些道德卫士的心目中，个性在嫉恨的眼光之下被看成一种麻烦的叛逆性障碍物，妨碍着他所断言之事被人类普遍接受。<strong>如果不允许个性的存在，用盲从和照抄取而代之，社会凌驾于个人，要求每个个体必须遵从其规定的条条框框和道德限制，这会有什么坏处</strong>？作者点明了这一点：一个人在他的能力成熟的时候，按照他个人的个性去理解、解释、运用经验，这是人的天性和特权。没有人会抱着这样的想法：所有的美德只是互相照抄而来。不允许人们在各种生活方式和与自己有关的行为上有自己的判断或者个性的一点痕迹，是荒谬的。他人留下的习俗本质上只是表明了这个经验曾经验证过他们经历的什么东西，至于这个经验中有哪一部分适用于后来者完全是需要后来者们去寻找并加以判断的。首先，经验有可能是错的；其次，就算是对的，也可能不适合于某个个体；人类的感知力、判断力、智力活动、道德取舍等都是需要在实际运用中才能得到锻炼，而凡事都照着习俗办事的人则不加任何选择，因而他的这些机能得不到锻炼，这就会减弱他的理性，使他的情感和性格趋向于怠惰和迟钝，而不是活跃且富有精力。个性的自由发展乃是人类福祉的重要要素之一，追求个性、由自己选择生活方案的人，要孜孜不倦地使用他的所有智慧：用观察力去了解其他人的经验；用推断力和判断力去预测好坏；用行动力去搜集资料；用思辨力去做出决定；做出决定之后还要用毅力和自制力去坚持自己考虑周详后得出的决定。而随大流、不需要独立思考的人，完全不需要经过上述过程。</p>
<p>下面这段话是作者说给人性本恶论支持者听的。<strong>人类要成为思考中高贵而美丽的对象，不能靠着把自身中一切个性的东西都磨成一律，而要把个性培养并发扬出来，只需在不侵犯他人权利的限度之内</strong>。人不是机器，不能按照一个模型铸造出来，开动他的目的也不能是去分毫不差地完成一个规定好的工作。在人类完善并美化其生命的所有工作中，当之无愧处于最重要地位的就是发展人自己本身。发展人类的个性，人也就变得丰富、多样、有生气、能够供给高超思想和高尚情感丰富的养料。欲望和冲动是一个完善的人类的构成部分，与约束和自省是居于同等地位的。所谓强烈的冲动具有危险性，只在它没有得到恰当的平衡的时候。人们做出恶劣的行为，不是因为他欲望强，而是他们的良心弱。说某一个人比另一个人有更多的冲动和欲望，意思是说他有更多的人性原料。他可能做更多的祸害，但他的确更有能力做较多的好事。冲动实际上就是精力，一个富有精力的人永远比一个无精神无感觉的人更可以培养出最强烈的有情感有教养的人性，这是最热烈的美德和最严肃的自我节制的生命力源泉。如果人生活在充满敌意的目光的审查之下，那么他们可贵的欲望和冲动就会消磨殆尽。<strong>一个人，欲望和冲动是他自己的，然后可以经过他自己的教养加以发展和校改，这才称之为具有性格；一个人，欲望和冲动不是自己的，那么就没有性格，如同一架蒸汽机之没有性格</strong>。凡认为对欲望和冲动应该压制而不应加以鼓励而展开的人，也就是认为社会不需要强有力的人性，也认为富有性格并不见得是好事，也认为高度的精力水平是无足取的。他们想让别人除了趋向于合乎习俗的事情之外，最好什么欲望都不要有；除开向上帝投降的能力之外，人甚至不需要其他能力。这样，人的心灵就屈服于枷锁之下了：在玩乐的事情上，在欢喜的人群中，他们首先想到的是投众和时；趣味上的独特、行为上的怪癖，是唯恐避之不及的；由于不允许他们追寻本性，他们就渐渐地丧失追寻本性的能力，甚至到最后连本性都没有了；没有能力再有任何强烈的愿望和与生俱来的快乐了；没有各人各自生长、本属于个人的意见和情感；可以说，他们的人类性能枯萎了。这种由人性本恶论出发的得来的情况，是可取还是不可取呢？在任何时代里，只要仅仅是不屑苟同的例子，只要仅仅是拒绝向习俗卑躬屈膝的例子，这本身就是贡献。凡是性格力量丰足的时代，怪癖性也就丰足，天才秉异、精神力量、道德勇气的数量也成正比。敢于特立独行的人变少，正是时代危险的标志。</p>
<p><strong>要想给人的本性公平发展的机会，最重要的事情就是容许不同的人过不同的生活。在任何时代里，只要看这一项独立自由被运用到怎样的程度，就相应地可以知道那个时代怎样地值得为后代所注视。就算是专制制度，也不算产生了最坏的后果，只要人的个性在它下面还存在一天；反之，凡是压制毁灭人的个性的都是专制，不论它叫什么名字，也不论它自称是执行上帝的意志还是执行人们的命令</strong>。读到这里我想到的最好的例子就是唐朝的开元盛世，以下摘自于<a href="https://www.ximalaya.com/lishi/23136114/179721314">《百家讲坛——长恨歌》蒙曼</a>，从 14:10 开始的内容。</p>
<blockquote>
<p>在唐玄宗的开元年间，人的精神可以做到活泼开朗，人的个性可以自由奔放，很大的一个原因就是那个时代给人的发展提供了比较广阔和合理的空间。对比另外两个盛世，汉武盛世和康乾盛世。汉朝时代做官，若你没有好爹，也没钱也不会打仗的话，这辈子你就没希望了，这对人来说是很不公平的。康熙雍正乾隆时期，科举制度已经堕落成八股取士，对人的精神是极大的限制和禁锢，只能顺着别人的意思来而不能有自己的思想（文字狱），对人的智力也是很大的羞辱，想一想范进中举的那种愚昧和疯狂。唐朝科举制度刚刚完善，对人的精神上的鼓舞是无与伦比的。唐朝的唐诗，本质就是自由和激情（安能摧眉折腰事权贵，使我不得开心颜？）。在这个时代培养起来的人，那个时代的诗人、艺人、读书人，精神能不开朗向上、自信、风流吗？社会能不风雅和谐吗？</p>
</blockquote>
<h2 id="个性是首创性的来源，是天才生存的土壤"><a href="#个性是首创性的来源，是天才生存的土壤" class="headerlink" title="个性是首创性的来源，是天才生存的土壤"></a>个性是首创性的来源，是天才生存的土壤</h2><p>接下来，作者从天才的特质这一方面来论证这一观点，只有培养个性、允许个性的自由发展，才能使人类发展得好。经过简单的思考就能的出一个结论，<strong>首创性</strong>是人类事务中一个非常有价值的因素。首创性这个东西的重要性，是庸才的心灵所不能感受到其用处的。永远需要有人发现新的真理，或者点明什么时候有的真理已不再是真理，或者在人类生活中开创新的做法，或者能够欣赏前人所不能欣赏的更高水平的美学价值、做出更开明的行为、达到更好的知趣和品味。首创性就是把人们的眼打开，让他们了解到新的世界，更重要的是，让更多人能意识到自己可以有机会成为具有首创性的人。<strong>人们要记住，没有一件事不是有某一个人第一个做出来的</strong>；现有一切美好事物都是首创性的成果。然而，与整个人类相比，永远只有少数人在进行新的试验，尝试在行之有素的做法上试图做出一点什么改进。这些少数人，就是靠他们来倡导前所未有的好事务，没有他们，人类文明就变成一潭死水。如果说没有新的事物需要探索，不就是说人类智慧已经再无必要了吗？<strong>有天才的人，现在是，也永远会是极少的少数，为了使人类能够拥有他们，就必须维护能够让他们生存的土壤</strong>。天才只能在自由的空气中自由地呼吸。有天才的人，在字面意义上就是必然比普通人有更多的个性的，正因为如此，天才如果去经历一遍那些社会为了磨灭个性而准备的模子，他们受到的压迫和伤害会比普通人更甚，这也就是人类的损失了。因此，就请大家以足够的谦虚理由来相信，人类还远远不够圆满，还有很多事情需要首创性去完成，所以我们还缺乏很多首创性，因此更要为来之不易的首创性涵养他们生存的土壤。</p>
<p>一个人只要保有一些说得过去的常识和经验，除此之外，不妨碍他人的情况下，他自己规划其生存的方式就是最好的。同一个事物，我之蜜糖，却有可能是彼之砒霜。人类在快乐的来源，在痛苦的感受，在不同事物的评价有如此多般的不同。这样看来，<strong>为什么允许仅仅因为依附者人多势众就要强加给剩下的少数人勉从多数人的生活嗜好和方式呢</strong>？当前时代公众意见的方向有一个特点，就是对于个性的任何显著表现不能宽容，并力图让每个人都适合被认可的既定标准。人类中一般的中材不仅在智力上是平庸的，而且在嗜好、情感、愿望上的能力也是平庸的，以至于他们不向往做一些什么不平常的事，因而进一步他们也不理解有那类愿望和嗜好的人，然后把他们统统归为桀骜难驯和不知节制的一类来鄙视。他们的标准，明言昭示也好，不言而喻也好，就是对任何事物都不存在强烈的欲望，理想的性格就是没有任何显著的性格，像旧中国妇女裹脚那样把人性中有任何突出特立的部分都造成碌碌的凡庸之辈。<strong>习俗的专制在任何地方对于人类的前进是一个持久的障碍，进步的唯一可靠而永久的源泉还是自由</strong>，因为有了自由，有多少个个人可能有多少个独立的进步中心。</p>
<p>这位十九世纪的英国作者是这样型容中国的：“我们要以中国为前车之鉴，那个民族曾经是世界上最伟大最有势力的国族。他们的子民不是在世界舞台上一出场的时候就是最富庶而又有文化，又精于生活艺术的，这一切都是他们自己做出来的，他们必定一度有过最为出色的首创性。他们有着难得的国运，竟然在非常早期就有一套特别好的道德习俗（儒家文化），这即使是欧洲人也认为是必须被尊称为圣人们才能做出的事功。他们又有一套精良的工具（科举制）能够把这一最好智慧深印于群体中的每一心灵，并且保证最具此智慧的人能担任最有权力和荣誉的职位。能做到这个地步的人民当之无愧地可以说已经发现了人类前进的奥秘，长此以往必将稳稳地站在世界前列。与此相反，他们却变为静止，几千年来原封不动（独尊儒术、八股取士）。欧洲若效仿，也将趋于变成另一个中国。” 肺腑之言，真知灼见！</p>
<p><strong>自由和多样化，是人类发展的必要条件</strong>。托克维尔在《旧制度与大革命》中曾评论法国人比起前一代怎样变得更加相似了。曾几何时，人们彼此上有显著差异，他们走在各种各样的道路上，通往不同的有价值的东西。行走在不同道路上的人们并不彼此宽容，心想若能强迫其他人也走上我自己这条道路是再好不过的事情了。时代的一切发展，教育、商业、制造业、公众意见，都在促进同化。所有这些因素结合在一起，形成了一个与个性为敌的强大力量，以至于看不出个性有任何的胜算和生存空间。<strong>个性要保留其生存土壤，有越来越大的困难，除非我们人类意识到，个性的价值，多样性的好处</strong>。凡是对侵蚀做抵抗，要在较早阶段才容易获得成功，如果等到几乎把所有人类都磨成一致的时候再来进行就来不及了。为了压制其他人的思想和个性，随意斥之以不道德，可以说是最坏的事情之一。那时，一切的个性都被扣上不敬神、不道德、怪异、违反本性的帽子，以至于很快的到最后就连奇异的想法也不会再有了。</p>
<h1 id="论社会凌驾于个人的权威的限度"><a href="#论社会凌驾于个人的权威的限度" class="headerlink" title="论社会凌驾于个人的权威的限度"></a>论社会凌驾于个人的权威的限度</h1><p>看完上一章精彩的论述之后，接下来的问题是，人类生活中多少属于个人自由的范围内，有多少归派于个性所能决定的自由发展的部分，又有多少部分要归派于社会，社会的权威从何而来。By the way，1903年严复翻译本书，书名译为《群己权界论》，就是本章标题的文言文。</p>
<h2 id="群己权界论"><a href="#群己权界论" class="headerlink" title="群己权界论"></a>群己权界论</h2><p>总结一下就是这三点：</p>
<ol>
<li>个人和社会不得侵犯他人的权益和自由；</li>
<li>个人不得逃避自己的责任和义务；</li>
<li>若只是不道德的行为而没有犯法，就只收舆论批评而不受法律处罚。</li>
</ol>
<p>本章要帮助人们解决的问题就是<strong>分清个人自由、法律权利和义务、道德舆论的所辖范围的区别和各自的作用</strong>。</p>
<p>社会契约论演绎出权利、义务和法律。每个人生活在社会上，受着社会的保护，所以每个人对于社会应该有一种报答，例如保卫社会或付出劳动等（义务）。社会中所有人对其他人也得遵守某种行为准绳，有些被确定为法律，是不可侵犯的权利和法益。若侵犯这种权利，社会就有理由去强制实施制裁的。而有些行为，仅仅不道德，而没有到侵犯法益的层面，因此不会应该受到法律惩罚，但是会受到舆论和道德上的鄙弃。</p>
<p>在人们彼此发生联系的行为中，契约规律必须得到注意和遵守；但是在每人只涉及自己的事情上，他的个人自由有权得到保障。一个人不听劝告，执意去做一些事情而犯了错误，和他容忍其他人逼他去做“其他人认为的对他有好处的事情”，在古典自由主义者看来，后者所可能蕴含的罪恶比前者还要大得多。没有一个人会因为喝醉了酒而受到处罚，但是一个战时的士兵或者正在执行任务的警察喝醉了酒就会受到处罚。一个事情应当受到处罚，必须是指这个事情已经超出了个人自由的范围之外，纳入了法律管辖的范围之内，有了确定的损害的时候。</p>
<p>关于道德舆论的作用，作者认为，一个人若能老老实实向另一个人说出他有着错误和缺点，又不至于被认为是冒犯和无礼，那实在是很好的事情。我们能做到对他最坏程度的对待其实是随他自己去。运用我们自己的个性的同时，不至于压制他的个性。我们并不是非要与他合群不可，我们有权利不与他合群，甚至和公众说与他合群的坏处。我们不高兴，我们有权利表达我们的厌恶，但是我们不会认为，我们就因此有使命要把他的生活弄的不舒服，弄得让他丧失个性。我们会思考到，他已经受到或即将受到他的过失的惩罚。他在我们面前可以是怜悯的对象，可以是不喜欢的对象，但不会成为愤怒或愤慨的对象。</p>
<h2 id="古典自由主义"><a href="#古典自由主义" class="headerlink" title="古典自由主义"></a>古典自由主义</h2><p>最后，<strong>古典自由主义</strong>的核心思想体现如下：</p>
<ol>
<li><strong>若一个人的行为并不影响自己以外的任何人的利益，那在一切这类事情上，每个人应当享有实行行动并承担其法律上和社会上的后果的完全自由。简单地说就是所谓，每个人自由的边界是他人的自由</strong>。</li>
<li><strong>人类自由的适当领域包括：</strong><ul>
<li><strong>最广义的良心自由；(Freedom of conscience)</strong></li>
<li><strong>思想和感想的自由；(Freedom of thought and feeling)</strong></li>
<li><strong>一切题目上意见和情操的绝对自由；(Freedom of opinion)</strong></li>
<li><strong>发表和刊见意见的自由；(Freedom of speech, expressing and publishing)</strong></li>
<li><strong>和其他个人之间相互联合的自由；(Freedom of association and assembly)</strong></li>
<li><strong>趣味、知趣和追求的自由；(Liberty of tastes and pursuits)</strong></li>
<li><strong>有自由订定自己的生活计划以顺应自己的性格；有自由照自己所喜欢的去做，当然也不会规避随后的结果。(Liberty of framing the plan of our life to suit our own character; of doing as we like, subject to such consequences as may follow)</strong></li>
</ul>
</li>
<li><strong>这些自由，只要我们的所作所为并无害于我们的同胞，就不应遭到他们的妨碍</strong>。<strong>任何一个社会，若是上述这些自由在那里不受尊重、那就不算自由，不论其政府形式怎样；任何一个社会，若是上述自由在那里的存在不是绝对的和没有规限的，那就不算完全自由</strong>。<strong>唯一名副其实的自由，乃是按照我们自己的道路去追求我们自己的好处的自由，只要我们不试图剥夺他人的这种自由</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>ReadingNote</category>
      </categories>
  </entry>
  <entry>
    <title>拿到驾照，上路前总结一些道路经验</title>
    <url>/2017/06/06/OldDriver/</url>
    <content><![CDATA[<h1 id="老司机修炼"><a href="#老司机修炼" class="headerlink" title="老司机修炼"></a>老司机修炼</h1><p>本文是在观看bilibili up主<a href="http://space.bilibili.com/28152409#!/">交通事故video</a>的一系列每天十分钟（开车慢又耸）的交通事故的录像视频时整理而来。在看了很多期之后，突然有一天觉得这些视频不能白白看了，学到什么东西要记录下来。。。emmmm，有一句说一句，确实很多东西没看这个up主的视频之前我是真的不知道，血淋淋的车祸现场惨况录像也对人有很好的警示作用，感谢一下up主。</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170606203013872-1469870485.png" alt=""></p>
<p>很好的频道，推荐大家观看。本文也会时常更新新的东西，也欢迎大家提出自己意见。</p>
<h2 id="司机篇"><a href="#司机篇" class="headerlink" title="司机篇"></a>司机篇</h2><ol>
<li>超车对象是公交车或大车时，一定要确保视野清晰的情况下才能超车（例如路较为宽大，没有别的路口）。以防因为大车阻挡视野而导致意外。不要在红绿灯路口超大车。</li>
<li>不能跟正在超车的 车 ，或者一起超车，一旦发生追尾是很危险的。</li>
<li>如果被对面的远光灯闪了，自己也要闪远光灯。第一个是为了示意对面关掉，第二个是在自己被闪的情况下，开远光能看清点。（好像是老爹的经验）</li>
<li>高速路口错过了出口一定不能掉头或者倒车。</li>
<li>行车让行，让速不让道。握紧方向盘。（防加塞狗）<a href="http://www.bilibili.com/video/av9502712/">av9502712</a>  9分40秒</li>
<li>不能连续变道，这很作死。</li>
<li>上坡不要紧紧跟着前车，前车溜车你就拉闸了。</li>
<li>大车的右边是死亡地带 不能去  如果大车没副驾驶，驾驶员有时候很难或无法知晓右边的情况。</li>
<li>高速上视野远的车 例如大客车 货车 突然减速 就要小心了。update：有经验的大车会在前方出事的时候打双闪提示后面视野不远的小车。如果车流好好的没事，但大车突然双闪，也要留意了 可能前面有事故。   </li>
<li>高速上刹车（例如突然冲出行人），看后视镜吧，如果没车就急刹车（得有abs），如果有车就轻点踩，不能打方向盘，会有更大伤害。让速不让道。 </li>
<li>上车前一定要四周看一圈，不然有什么小屁孩在车前玩耍就拉闸。（这个我真的觉得有时候很无解，求比较好的方法）</li>
<li>不要与大车（并道）一起转弯，转弯半径不一样，很容易拉闸。自己开车规矩点，不要拉着别人还作死。</li>
<li>高速路上不要随意下车，不要站在中间护栏附近，出事故了只要车能动的，拍好照片后把车挪到应急车道上。不要大半夜熄火下车什么也不做，后面来的车就是看到了也来不及刹车的。</li>
<li>如果说左道很多车在等红灯，直行道畅通，也不能直接开太快过路口，以防有行人闯红灯，而你被左拐道的车堵住视线，把闯红灯的路人撞了。不管怎么说，过路口带一下刹车吧。</li>
<li>侧方停车：<a href="http://www.bilibili.com/video/av9502712/">av9502712</a>开头，说实话我考完科二就忘了，几乎不怎么侧方停车，所以mark一下。</li>
<li>不要拿车门当扇子。。。。。。。这是真的很尴尬，贼尴尬，你要开就开，不开就不要来回拉车门。。。后面的人又不知道你是想开还是不想开。</li>
<li>堤防“鬼探头” 各种行人、电动车突然冒出来横穿马路那种。类似的是14点。</li>
<li>紧急情况下车打双闪。如果在高速路上要远离道路，在150米后放警示牌。</li>
<li>下车关门好习惯。。。<a href="http://www.bilibili.com/video/av9599240/">av9599240</a>-10分21秒： 车子在高速路上行驶过程中着火了，交警在后面追赶，提示后司机把车停在应急车道后，司机下车逃命，此刻司机还不忘关车门。</li>
<li>山体会车，不靠山体的一侧先行。</li>
<li>进环岛的要让出环岛的先行。</li>
<li>出事了一定不要傻傻站在车旁边。。。。。例如山区弯道出车祸，如果站在车旁边报警，后面的车根本不知道前面出了事，<a href="http://www.bilibili.com/video/av9424809">av9424809</a>高能</li>
<li>行车时看到用简单绳索捆绑货物的大车，要注意货物掉落可能。</li>
<li>最后一个事故警示各位，左转弯应提前驶入最左侧车道。这么多期看下来，发现很多车都是在紧急情况向即将被撞车辆的车头方向避让，行人也是，问题是很多时候这些车辆或者行人无法及时停下来，甚至是不知情的，也使得很多时候真的就“精准制导”了。<a href="http://www.bilibili.com/video/av11108884/">av11108884</a></li>
</ol>
<h2 id="行人篇"><a href="#行人篇" class="headerlink" title="行人篇"></a>行人篇</h2><ol>
<li>不要横穿马路，或者横穿围栏。因为车认为不会有行人出现，所以你突然出现在马路中，突然出现在本来认为不会有行人的司机眼里时，司机并不一定能保证不撞到你。</li>
<li>过马路请提醒吊胆一点快步走，不要玩手机走的慢慢的。</li>
<li>马路是你家？<a href="http://www.bilibili.com/video/av9502712/">av9502712</a>-12分43秒。<a href="http://www.bilibili.com/video/avav9493121/">av9493121</a>-8分11秒</li>
<li>如果不是在红绿灯路口过马路，请不要在车跟前过马路，别的车道会被这个车挡住视野。</li>
<li><a href="http://www.bilibili.com/video/av9462946/">av9462946</a>，倒数第三个事故，学生，不管怎么样，出车祸都是非机动车相对吃亏，受伤更严重，抛开责任不谈，尽力遵守交通规则之外，还要多注意别人可能违反交通规则，虽然麻烦一点点，但安全总归是自己的。  </li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>竟然看到了惠州仲恺大道。。那mark一下。。<a href="http://www.bilibili.com/video/av99547766/">av9547766</a></li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>OpenFlow-Enabling-Innovation-in-Campus-Networks</title>
    <url>/2017/11/17/OpenFlow-Enabling-Innovation-in-Campus-Networks/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本白皮书提出OpenFlow：研究人员在他们每天使用的网络中<strong>运行实验协议</strong>的一种方法。 OpenFlow基于，具有内部流程表和用于添加和删除流条目的标准化接口。我们的目标是鼓励网络供应商将OpenFlow添加到他们的交换机产品中，以部署在大学校园骨干网和配线室中。我们认为，OpenFlow是一个务实的妥协：一方面，它允许研究人员<strong>以统一的方式在异构交换机上</strong>以线速率和高速运行实验。而另一方面，<strong>供应商不需要暴露交换机的内部工作</strong>。除了允许研究人员在实际交通环境中评估他们的想法之外，OpenFlow还可以在像GENI这样的大型测试平台中成为有用的校园组件。斯坦福大学的两座建筑将很快运行OpenFlow网络，使用商用以太网交换机和路由器。我们将努力鼓励其他学校的部署;我们鼓励您考虑在您的大学网络中部署OpenFlow。</p>
<p>基于以太网交换机，具有：</p>
<ul>
<li>internal flow-table</li>
<li>a standardized interface to add and remove flow entries.</li>
</ul>
<p>pragmatic compromise：</p>
<ul>
<li>run experiments on heterogeneous switches in a uniform way  </li>
<li>vendors do not need to expose the internal workings of their switches.</li>
</ul>
<h1 id="可编程网络的需求？"><a href="#可编程网络的需求？" class="headerlink" title="可编程网络的需求？"></a>可编程网络的需求？</h1><ul>
<li>创新因为<strong>既有的巨量已安装的基础设施、已有协议、以及不愿意产生实际流量</strong>变得非常困难。</li>
<li>许多 new idea 是 untried、untested</li>
<li><p>Network：ossified（僵死、保守）</p>
</li>
<li><p>GENI 研究可编程网络架构、虚拟化、网络分片 slice）的实验室</p>
</li>
<li>Virtualized programmable networks could lower the barrier to entry for new ideas。but ambitious and costly。</li>
</ul>
<p>本文提出的问题是：</p>
<p>As researchers, how can we run experiments in our campus networks?</p>
<ul>
<li>早期实验人员是怎么把网络设备部署在实验网络的？</li>
<li>实验人员是怎么使用部分网络而不影响其他使用这个网络的人的？</li>
<li>实验用交换机有什么功能需求？</li>
</ul>
<p>Our goal here： to propose a <strong>new switch feature</strong> that can <strong>help extend programmability</strong> into the wiring closet（配线间） of college campuses.</p>
<p>一些弃用的方法：说服有名的厂商为它们的路由器交换机开发一个可编程平台。</p>
<ul>
<li>接口很狭窄（narrow）</li>
<li>内部灵活性（internal flexiblity）被隐藏</li>
<li>differ from vendor to vendor</li>
<li>vender 不愿开放接口（害怕既有网络被颠覆、害怕潜在的竞争者等等</li>
</ul>
<p>还有一些现有市面上的软件平台，不过被弃用了，主要原因是 bad <strong>performance</strong> ，需要 <strong>specialized hardware</strong>（part of the<br>Linux distribution, or from XORP）。或者是<strong>贵</strong>（ATCA-based virtualized programmable router）、<strong>规模小</strong>（NetFPGA，只有四个接口）。</p>
<p>OpenFlow 要：</p>
<ul>
<li>适合<strong>高性能和低成本</strong>的实现，<strong>灵活性</strong>。</li>
<li>适合用来做<strong>广范围的研究</strong></li>
<li><strong>保证实验流量可以和现实流量分开</strong></li>
<li>符合供应商对封闭平台的需求。</li>
</ul>
<p>OpenFlow Switch — a specification that is an initial attempt to meet these four goals.</p>
<h1 id="OpenFlow-交换机"><a href="#OpenFlow-交换机" class="headerlink" title="OpenFlow 交换机"></a>OpenFlow 交换机</h1><p>对象是交换机、路由器中运用的最多的<strong>流表</strong>。</p>
<p>OpenFlow provides an open protocol to program the flowtable in different switches and routers. </p>
<p>研究人员可以通过选择数据包的路由和接收的处理控制自己的流量，由此可以做新的路由协议的实验、新寻址方法、尝试 IP的替代方案等等、</p>
<p>OpenFlow Switch consists of a Flow Table, an action(extensible, but there is a minimum reqirement) associated with each flow entry. </p>
<p>action的设计因为要达到低花费、高性能、灵活性的要求，这意味着放弃指定任意处理每个数据包的能力，并寻求更有限但仍然有用的行动范围。</p>
<p>OpenFlow 交换机包括至少三个部分：</p>
<ul>
<li><strong>流表</strong>  an action associated with each flow entry, to tell the switch how to process the flow,</li>
<li><strong>安全通道</strong>  connects the switch to a remote control process(called the controller) </li>
<li><strong>OpenFlow Protocol</strong> provides an open and standardway for a controller to communicate with a switch.</li>
</ul>
<p>OpenFlow Protocol 提供标准外部接口，可以让控制器下发流表。</p>
<p>将交换机归类为不支持正常的第2层和第3层处理的<strong>专用OpenFlow交换机</strong>（Dedicated OpenFlow switches），以及<strong>支持OpenFlow的通用商用以太网交换机</strong>和路由器（OpenFlow-enabled switches，OpenFlow协议和接口已添加为新功能）是非常有用的。</p>
<h2 id="专用OpenFlow交换机"><a href="#专用OpenFlow交换机" class="headerlink" title="专用OpenFlow交换机"></a>专用OpenFlow交换机</h2><p>专用的OpenFlow交换机是一个哑数据路径元素，在远程控制器进程定义的端口之间转发数据包。</p>
<ul>
<li><strong>flows</strong> are broadly defined, （Flow 的定义）</li>
</ul>
<p>could be a TCP connection, or all packets from a particular MAC address or IP address, or all packets with the same VLAN tag, or all packets from the same switch port. For experiments involving non-IPv4 packets, a flow could be defined as all packets matching a specific (but non-standard) header.</p>
<p>流表的每一个项目里有一个 action 对应，最基础的三个是：</p>
<ol>
<li>Forward(to a given port or ports)</li>
<li>发送到控制器。(through Secure Channel)</li>
<li>Drop</li>
</ol>
<p>流表项的三个字段：（1）一个 header 定义流，（2）定义如何处理包的动作，（3）跟踪每个流的包和字节数的统计，以及 自上次数据包匹配流程以来的时间（以帮助删除不活动的流量）。</p>
<h2 id="支持OpenFlow的通用商用以太网交换机"><a href="#支持OpenFlow的通用商用以太网交换机" class="headerlink" title="支持OpenFlow的通用商用以太网交换机"></a>支持OpenFlow的通用商用以太网交换机</h2><p>商用的路由器、交换机、接入点等等可以通过升级，使其支持流表功能、安全通道、OpenFlow 协议。</p>
<p>为了赢得网络管理员的信任，启用OpenFlow的交换机必须将实验流量（由流量表处理）与生产流量隔离，生产流量将由交换机的正常的第2层和第3层流水线处理。（方法有 VLAN、或者加入一种新的 action，就是按照正常的流水线发送此包）</p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>控制器代表实验添加和删除流表中的流入口。</p>
<ul>
<li>might be a simple application running on a PC to statically establish flows to interconnect a set of test computers for the duration of an experiment. </li>
<li>Viewed this way, OpenFlow is a generalization of VLANs.</li>
</ul>
<h1 id="使用-OpenFlow"><a href="#使用-OpenFlow" class="headerlink" title="使用 OpenFlow"></a>使用 OpenFlow</h1><blockquote>
<p>As a simple example of how an OpenFlow Switch might be used imagine that Amy (a researcher) invented Amy-OSPF as a new routing protocol to replace OSPF. She wants to try her protocol in a network of OpenFlow Switches, without changing any end-host software. Amy-OSPF will run in a controller; each time a new application flow starts AmyOSPF picks a route through a series of OpenFlow Switches, and adds a flow- entry in each switch along the path. In her experiment, Amy decides to use Amy-OSPF for the traffic entering the OpenFlow network from her own desktop PC— so she doesn’t disrupt the network for others. To do this, she defines one flow to be all the traffic entering the OpenFlow switch through the switch port her PC is connected to, and adds a flow-entry with the action “Encapsulate and forward all packets to a controller”. When her packets reach a controller, her new protocol chooses a route and adds a new flow-entry (for the application flow) to every switch along the chosen path. When subsequent packets arrive at a switch, they are processed quickly (and at line-rate) by the Flow Table.</p>
</blockquote>
<p><strong>很自然而然的</strong>，我们会对这种中心控制器模型的<strong>性能、可靠性、可扩展性</strong>提出问题：</p>
<ol>
<li>fast enough？</li>
<li>controller fails？</li>
</ol>
<p>Ethane prototype: Preliminary(初期) results suggested that an Ethane controller based on a low-cost desktop PC could process over 10,000 new flows per second</p>
<p>还列了几个实验的例子。</p>
<ul>
<li>Network Management and Access Control</li>
</ul>
<blockquote>
<p> A controller checks a new flow against a set of rules, such as “Guests can communicate using HTTP, but only via a web proxy” or “VoIP phones are not allowed to communicate with laptops.” — it essentially takes over DNS, DHCP and authenticates all users when they join, keeping track of which switch port (or access point) they are connected to.</p>
</blockquote>
<ul>
<li>VLANs. </li>
</ul>
<blockquote>
<p>OpenFlow can easily provide users with their own isolated network, just as VLANs do.</p>
</blockquote>
<ul>
<li><p>Mobile wireless VOIP clients.</p>
</li>
<li><p>A non-IP network. </p>
</li>
</ul>
<blockquote>
<p>OpenFlow doesn’t require packets to be of any one format ——  so long as the Flow Table is able to match on the packet header 。This would allow experiments using new naming, addressing and routing schemes</p>
</blockquote>
<ul>
<li>Processing packets rather than flows. every packet to be processed.</li>
</ul>
<blockquote>
<p>For example, an intrusion detection system that inspects every packet, an explicit congestion control mechanism, or when modifying the contents of packets, such as when converting packets from one protocol format to another.</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们相信OpenFlow是一个务实的妥协方案，可以让研究人员以统一的方式在异构交换机和路由器上运行实验，而无需供应商公开其产品的内部工作，或研究人员编写供应商特定的控制软件。</p>
<p>如果我们在我们的园区成功部署OpenFlow网络，我们希望OpenFlow将在其他大学逐渐流行起来，增加支持实验的网络数量。 我们希望新一代的控制软件能够出现，使研究人员能够重新使用控制器和实验，并在别人的工作基础上继续努力。 随着时间的推移，我们希望不同大学的OpenFlow网络将通过隧道和覆盖网络相互连接，也许可以通过运行在连接大学的骨干网上的新的OpenFlow网络来实现。</p>
<h1 id="阅读感想"><a href="#阅读感想" class="headerlink" title="阅读感想"></a>阅读感想</h1><p>本篇论文可以说是 OpenFlow 和 SDN 的开山之作。提出了 OpenFlow 的创新源泉在于网络协议开发者的痛点：开发新的网络协议的困难之处。着眼点在于实现一个统一的方法方便网络创新实验，对无论是硬件从业人员（做交换机）还是软件开发人员（写控制器、开发新协议）都有好处。介绍了流表表项的机制。OpenFlow的特色：性能好，扩展性，实验的前景。可以实现实验流量和现实流量的分离这点我觉得挺不错的。值得一提的是，和互联网在刚开始的时候只是政府支持的一个小项目，也是以学校为起点，最终成长为今天这样一个强大的工具。而在这点上 OpenFlow 是和 Internet 是一样的。</p>
]]></content>
      <categories>
        <category>paper-reading</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之运算符重载</title>
    <url>/2017/06/07/Operator-overload/</url>
    <content><![CDATA[<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>C++类特性丰富、复杂、功能强大。</p>
<p>学习C++的难点之一是要记住大量的东西，但在拥有丰富的实践经验前，是很难全部记住这些东西的。学习这种语言最好的方法，就是在开发自己的C++程序时，使用其中的新特性。对这些新特性有了充分的认识和了解之后再去添加其他的C++特性。</p>
<p>下面介绍一种使对象操作更美观的操作。</p>
<p>运算符重载是一种<strong>C++多态</strong>，是C++使用户能够定义多个名称相同但是特征标（参数列表）不同的函数。这被称为<strong>函数重载</strong>或<strong>函数多态</strong>，旨在让用户可以使用同名的函数来完成相同的基本操作。</p>
<p>想象一些，对于相同的操作，但是对于不同的物体，一定要用不同的英文单词，那会多么笨拙（抬起脚：lift_foot，抬起汤勺：lift_sp，对于抬起，我们希望只用一个单词lift就表示所有对象的抬起动作）运用运算符重载将重载的概念扩展到运算符上，赋予运算符多重含义。</p>
<p>实际上（包括在C语言里）已经有许多运算符被重载，例如<code>*</code>可以是间接寻址运算符，也可以是乘法运算符。C++允许重载扩展到用户定义的类型，例如允许用<code>+</code>将两个对象相加。重载运算符可以让代码看起来更自然。例如将两个同类型的数组相加是一种很常用的运算，通常需要用到如下for循环：<br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; 20; i++)</span><br><span class="line">	c<span class="comment">[i]</span> = a<span class="comment">[i]</span> + b<span class="comment">[i]</span>;</span><br></pre></td></tr></table></figure><br>但在C++中，如果定义了数组的类，可以重载+运算符，可以有这样的语句：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">c</span> = a + b<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>这样简单的加法隐藏了内部机理，强调了操作实质，是OOP的另一个目标。当然，C++也有对运算符重载做出了一些限制。</p>
<h1 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h1><p>设计一个 Time 类：<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">int</span> hours;</span><br><span class="line">	<span class="built_in">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Time()&#123;hours = <span class="number">0</span>; minutes = <span class="number">0</span>;&#125;</span><br><span class="line">	Time(<span class="built_in">int</span> h, <span class="built_in">int</span> m = <span class="number">0</span>);</span><br><span class="line">    Time Sum(<span class="keyword">const</span> Time &amp; t)<span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Time Time::Sum(<span class="keyword">const</span> Time &amp; t)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time <span class="keyword">sum</span>;</span><br><span class="line">	<span class="keyword">sum</span>.minutes = minutes + t.minutes;</span><br><span class="line">	<span class="keyword">sum</span>.hours = hours + t.hours + <span class="keyword">sum</span>.minutes / <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">sum</span>.minutes %= <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将Time类转换为重载的加法运算符，只要把<code>Sum()</code>的名称改为 <code>operator+()</code>。即：把运算符（这里是加号）放到operator的后面，然后将结果用作方法名即可。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Time</span> operator+(const <span class="keyword">Time</span> &amp; t) const;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Time</span> <span class="keyword">Time</span>::operator+(const <span class="keyword">Time</span> &amp; t)const</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">Time</span> <span class="built_in">sum</span>;</span><br><span class="line">	<span class="built_in">sum</span>.minutes = minutes + t.minutes;</span><br><span class="line">	<span class="built_in">sum</span>.hours = hours + t.hours + <span class="built_in">sum</span>.minutes / <span class="number">60</span>;</span><br><span class="line">	<span class="built_in">sum</span>.minutes %= <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意参数是引用，目的是为了提高效率。如果按值传递Time对象，代码功能相同，但传递引用速度将更快，使用内存更少。</p>
<p>注意<strong>返回值不能是引用</strong>，因为函数将在函数内创建一个新的对象sum，如果返回类型是Time &amp;，则引用的将是sum对象，但sum是局部变量，函数结束时将删除，因此引用将指向一个不存在的对象。<strong>不要返回指向局部变量或临时变量的引用！</strong></p>
<p>和Sum()一样，operator+()也是由Time对象调用的，<br>它会把第二个Time对象作为参数，返回一个Time对象。</p>
<p>首先可以像Sum()一样调用operator+()方法：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">c</span> = a.operator+(b)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>但方法命名为operator+()之后，可以使用运算符表示法：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">c</span> = a + b<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>运算符左侧的对象（这里是a）是调用对象，右边的对象（这里是b）是作为参数被传递的对象。</p>
<p>编译器将根据操作数的类型来决定如何做。<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">int a, b, c;</span><br><span class="line">Time A, B, C;</span><br><span class="line">c = a + b;    <span class="regexp">//i</span>nt型加法</span><br><span class="line">C = A + B;    <span class="regexp">//</span>加号被认为是Time对象</span><br></pre></td></tr></table></figure><br>可以这样做吗：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">t4</span> = <span class="built_in">t1</span> + <span class="built_in">t2</span> + <span class="built_in">t3</span>;</span><br></pre></td></tr></table></figure><br>为了回答这个问题，我们可以考虑转换成函数调用形式：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">t4</span> = <span class="built_in">t1</span>.operator+(<span class="built_in">t2</span> + <span class="built_in">t3</span>);</span><br><span class="line"><span class="built_in">t4</span> = <span class="built_in">t1</span>.operator+(<span class="built_in">t2</span>.operator+(<span class="built_in">t3</span>));</span><br></pre></td></tr></table></figure></p>
<p><code>t2.operator+(t3)</code>返回一个对象是t2和t3的和，再去作为<code>t1.operator+()</code>的参数，就能返回t1、t2、t3之和，是我们想要的结果。</p>
<h1 id="重载限制"><a href="#重载限制" class="headerlink" title="重载限制"></a>重载限制</h1><p>多数C++运算符都可以以这样的方式重载。重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是用户定义的类型。下面详细介绍各种运算符限制重载：</p>
<ol>
<li>重载后的运算符<strong>至少有一个操作数</strong>是用户定义的类型。这将防止用户为标准类型重载运算符。例如：不能将减法运算符重载为计算两个int值的和。这样确保程序可以正常运行。</li>
<li>使用运算符的时候不能违反原来的句法规则。例如不能将运算符重载为只使用一个操作数。</li>
<li>不能修改运算符的优先级。如果将加号运算符重载成两个类相加，则新的运算符和原来的加号具有相同优先级。</li>
<li>不能创建新的运算符，例如不能定义operator**()来求幂。</li>
<li>不能重载如下运算符：</li>
</ol>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sizeof</td>
<td>sizeof运算符</td>
</tr>
<tr>
<td>.</td>
<td>成员运算符</td>
</tr>
<tr>
<td>.*</td>
<td>成员指针运算符</td>
</tr>
<tr>
<td>::</td>
<td>作用域解析运算符</td>
</tr>
<tr>
<td>?:</td>
<td>条件运算符</td>
</tr>
<tr>
<td>typeid</td>
<td>一个RTTI运算符</td>
</tr>
<tr>
<td>const_cast</td>
<td>强制类型转换运算符</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>强制类型转换运算符</td>
</tr>
<tr>
<td>reienterpret_cast</td>
<td>强制类型转换运算符</td>
</tr>
<tr>
<td>static_cast</td>
<td>强制类型转换运算符</td>
</tr>
</tbody>
</table>
<p>可重载的运算符（部分）：</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170607175701325-1367142462.png" alt=""></p>
<p>大多数运算符都可以通过成员或非成员进行重载，但以下的运算符只能通过成员函数重载：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>()</td>
<td>函数调用运算符</td>
</tr>
<tr>
<td>[]</td>
<td>下标运算符</td>
</tr>
<tr>
<td>-&gt;</td>
<td>通过指针访问类成员运算符</td>
</tr>
</tbody>
</table>
<p>除了这些正式限制之外，还应该在使用运算符重载时遵循一些明智的限制：例如：不要把*重载为交换两个对象的数据，这种运算符的表示法并没有标明可以完成这样的工作。因此最好定义一个具有说明性的类方法：<code>Swap()</code></p>
<p>（不要无脑重载运算符这样不吼啊！~）</p>
<h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>现在我们知道，C++会限制对类对象私有部分的访问。通常，公有类方法提供唯一的途径访问，但是有时候这种限制太严格，以致不适合特定的编程问题。在这种情况下，C++提供了另一种形式的访问权限：<strong>友元</strong>。友元有三种：</p>
<p>• 友元函数<br>• 友元类<br>• 友元成员函数</p>
<p>下面介绍友元函数，剩下的两种之后会介绍。通过让函数成为类的友元，可以<strong>赋予</strong>该函数与类成员函数相同的访问权限。</p>
<h2 id="为何需要友元？"><a href="#为何需要友元？" class="headerlink" title="为何需要友元？"></a>为何需要友元？</h2><p><strong>重载二元运算符</strong>（带两个参数的运算符）常常需要友元。例如Time对象的<code>operator*()</code>重载就属于这种情况。乘法运算时将一个Time类对象与一个double值结合在一起，记住：运算符左侧是调用对象，右侧是参数。所以下面的语句：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">A</span> <span class="operator">=</span> B * <span class="number">0.75</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>是可行的，但是下面的语句呢？<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">A</span> <span class="operator">=</span> <span class="number">0.75</span> * B<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>从概念上说两个语句理应是一样的，但第二个表达式就不对应成员函数了，因为0.75不是Time类对象。如何实现让<code>0.75 * B</code>这样的语句也能顺利实现乘法的功能呢？</p>
<p>有一个方法就是写新的非成员函数。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">Time</span> <span class="keyword">operator</span>*(<span class="type">double</span> m, const <span class="type">Time</span> &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> t * m;    //use t.<span class="keyword">operator</span>*(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非成员函数不是对象调用的，所有参数都使用显示参数，写这样的函数就可以使<code>A = 0.75 * B;</code>这种非友元函数语句能工作。但这么做也是有问题的，非成员函数不能直接访问类的私有数据。然而有一种特殊的非成员函数可以访问类私有成员，它们就是<strong>友元函数</strong>。</p>
<h2 id="创建友元"><a href="#创建友元" class="headerlink" title="创建友元"></a>创建友元</h2><p>友元函数的原型要放在类声明里，在原型声明前加上关键字<strong>friend</strong>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="type">double</span> m, <span class="type">const</span> Time &amp; t);</span><br></pre></td></tr></table></figure></p>
<p>该原型意味着以下两点：<br>• 友元函数不是成员函数，不能使用成员运算符调用。<br>• 虽然不是成员函数，但与成员函数的访问权限相同。</p>
<p>编写函数定义时，因为它不是成员函数，请不要使用Time::限定符，不要添加关键词friend。如下：<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">Time</span> operator*(double m, <span class="keyword">const</span> <span class="type">Time</span> &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">Time</span> <span class="built_in">result</span>;	</span><br><span class="line">	long totalminutes = t.hours* m * <span class="number">60</span> + t.minutes*mult;</span><br><span class="line">	<span class="built_in">result</span>.minutes = totalminutes / <span class="number">60</span>;</span><br><span class="line">	<span class="built_in">result</span>.hours = totalminutes % <span class="number">60</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="友元是否有悖于OOP？"><a href="#友元是否有悖于OOP？" class="headerlink" title="友元是否有悖于OOP？"></a>友元是否有悖于OOP？</h2><p>乍一看友元违背了OOP数据隐藏的原则，实际上这个观点太片面了。应该将友元看做类的扩展接口的组成部分。例如，double乘以Time和Time乘以double概念是完全相同的，但前一个要求必须使用友元函数，这只是C++句法的区别。</p>
<p>总之，类方法和友元只是表达类接口的两种不同机制。</p>
<h1 id="重载-lt-lt-运算符"><a href="#重载-lt-lt-运算符" class="headerlink" title="重载 &lt;&lt; 运算符"></a>重载 &lt;&lt; 运算符</h1><p>一个很有用的类特性：对<code>&lt;&lt;</code>进行重载，使之能与<code>cout</code>一起来用于显示对象的内容。假如有一个Time对象a，我们设计的显示对象内容类方法是<code>show()</code>。然而，如果能像下面这样显示，会更好的吧：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; a<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code>也是一个能被重载的运算符。实际上它已经被重载过很多次了，在原本的C语言里它是位运算符（左移）。<code>ostream</code>将其重载成为一个输出工具。</p>
<p>tips：cout是一个ostream对象，它是智能的，能识别所有的C++基本类型，是因为对于每种类型，ostream类声明都包含了相对应的&lt;&lt;重载定义。所以为了让cout能识别Time对象，我们可以对Time类声明进行修改来让Time类知道如何使用cout。</p>
<h2 id="重载版本1"><a href="#重载版本1" class="headerlink" title="重载版本1"></a>重载版本1</h2><p>必须使用友元函数。原因是（还是那句话）运算符左侧是调用对象，右侧是参数。<code>cout</code>是<code>ostream</code>类对象不是Time类对象，如果不使用友元，则必须这样使用<code>&lt;&lt;</code>:<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">a &lt;&lt; cout; <span class="regexp">//</span>很怪异对不对。。。</span><br></pre></td></tr></table></figure></p>
<p>因此，第一个重载版本出来了：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> Time &amp;t);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> Time &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用cout应该调用cout本身，而不是他的拷贝，因此函数按引用而不是按值传递该对象。表达式<code>cout &lt;&lt; a</code>将导致os是cout的一个别名。</p>
<h2 id="重载版本2"><a href="#重载版本2" class="headerlink" title="重载版本2"></a>重载版本2</h2><p>版本1有一个问题就是不允许像通常那样将重新定义的&lt;&lt;运算符于cout一起使用：<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;a time: &quot;</span>&lt;&lt; a &lt;&lt; endl; //can<span class="symbol">&#x27;t</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure></p>
<p>要理解为什么这样做不行的原因是需要了解一些关于cout操作的知识，看下面的代码：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int a <span class="operator">=</span> <span class="number">5</span><span class="comment">;</span></span><br><span class="line">int b <span class="operator">=</span> <span class="number">8</span><span class="comment">;</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; b<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其实第三行相当于</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">(cout &lt;&lt; <span class="selector-tag">a</span>) &lt;&lt; <span class="selector-tag">b</span>;</span><br></pre></td></tr></table></figure>
<p><code>iostream</code>定义<code>&lt;&lt;</code>运算符的左边是一个<code>ostream对象</code>。首先<code>cout</code>是<code>ostream对象</code>，所以<code>cout &lt;&lt; a</code>是符合要求的，然后<code>(cout &lt;&lt; a)</code>这个整体也在一个<code>&lt;&lt;</code>运算符的左边，所以也要求这个整体也是一个<code>ostream对象</code>。因此，<code>ostream</code>类把<code>operator&lt;&lt;()</code>函数的<strong>返回</strong>设置为一个<strong>指向ostream对象的引用</strong>。所以据此我们也对自己的函数进行修改，让其返回对ostream对象的引用即可。</p>
<p>第二个重载版本如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> Time &amp;t);</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> Time &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二义性：使用成员函数还是非成员函数？"><a href="#二义性：使用成员函数还是非成员函数？" class="headerlink" title="二义性：使用成员函数还是非成员函数？"></a>二义性：使用成员函数还是非成员函数？</h2><p>加法运算符重载函数声明：</p>
<p>1.类成员函数重载加法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp; t)<span class="type">const</span>;</span><br></pre></td></tr></table></figure><br>2.友元函数重载加法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp; t1, <span class="type">const</span> Time &amp; t2);</span><br></pre></td></tr></table></figure></p>
<p>差别：</p>
<ol>
<li>对于成员函数来说，一个操作数通过this指针隐式传递，另一个操作数作为函数参数显示传递。</li>
<li>对于友元函数来说，两个操作数都是作为参数传递。</li>
</ol>
<p>编译器会将下面的语句：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">T1</span> = T2 + T3<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>分别对应转换为：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">T1</span> = T2.operator+(T3)<span class="comment">;</span></span><br><span class="line"><span class="attr">T1</span> = operator+(T2,T3)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>所以，在定义运算符时，必须选择其中一种格式，而<strong>不能同时选择这两种格式</strong>，因为这两种格式都与同一个表达式匹配，同时定义<strong>会导致二义性错误</strong>。</p>
<p>到底哪个好呢？对于某些运算符来说，成员函数是唯一合法的选择（见重载限制）。在其他情况下，没有太大差别。有时根据类设计，非成员函数版本可能更好。</p>
<h1 id="一个重载练习：矢量类"><a href="#一个重载练习：矢量类" class="headerlink" title="一个重载练习：矢量类"></a>一个重载练习：矢量类</h1><p>可复制编译。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vect.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VECTOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECTOR_H_</span></span><br><span class="line"><span class="keyword">namespace</span> VECTOR</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">enum</span> <span class="title class_">Mode</span> &#123; RECT, POL &#125;;<span class="comment">//RECT：直角坐标系，</span></span><br><span class="line">								<span class="comment">// POL：极坐标系。</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">double</span> x;		<span class="comment">//横坐标x</span></span><br><span class="line">		<span class="type">double</span> y;		<span class="comment">//纵坐标y</span></span><br><span class="line">		<span class="type">double</span> mag;		<span class="comment">//向量的长度</span></span><br><span class="line">		<span class="type">double</span> ang;		<span class="comment">//角度</span></span><br><span class="line">		Mode mode;		<span class="comment">//何种坐标系</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设定值的私有方法</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_mag</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_ang</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_y</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Vector</span>();</span><br><span class="line">		<span class="built_in">Vector</span>(<span class="type">double</span> n1, <span class="type">double</span> n2, Mode form = RECT);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2, Mode form = RECT)</span></span>;</span><br><span class="line">		~<span class="built_in">Vector</span>();</span><br><span class="line">		<span class="comment">//用于报告各种值的内联函数</span></span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">xval</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">yval</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">magval</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> mag; &#125;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">angval</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> ang; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">polar_mode</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">rect_mode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//运算符重载</span></span><br><span class="line">		Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector &amp; b)<span class="type">const</span>;</span><br><span class="line">		Vector <span class="keyword">operator</span>-(<span class="type">const</span> Vector &amp; b)<span class="type">const</span>;</span><br><span class="line">		Vector <span class="keyword">operator</span>-()<span class="type">const</span>;</span><br><span class="line">		Vector <span class="keyword">operator</span>*(<span class="type">double</span> n)<span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//友元</span></span><br><span class="line">		<span class="keyword">friend</span> Vector <span class="keyword">operator</span>*(<span class="type">double</span> n, <span class="type">const</span> Vector &amp; a);</span><br><span class="line">		<span class="keyword">friend</span> std::ostream &amp;</span><br><span class="line">			<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> Vector &amp; v);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;<span class="comment">//end namespace VECTOR</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vect.cpp -- 方法定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;vect.h&quot;</span></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"><span class="keyword">using</span> std::sin;</span><br><span class="line"><span class="keyword">using</span> std::cos;</span><br><span class="line"><span class="keyword">using</span> std::atan;</span><br><span class="line"><span class="keyword">using</span> std::atan2;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> VECTOR</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//斜率转换到角度，粗略值为57.2957795130823</span></span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> Rad_to_deg = <span class="number">45.0</span> / <span class="built_in">atan</span>(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直角坐标转极坐标</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::set_mag</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mag = <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::set_ang</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="number">0.0</span>&amp;&amp;y == <span class="number">0.0</span>)</span><br><span class="line">			ang = <span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ang = <span class="built_in">atan2</span>(y, x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//极坐标转直角坐标</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::set_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x = mag*<span class="built_in">cos</span>(ang);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::set_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		y = mag*<span class="built_in">sin</span>(ang);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//公有方法</span></span><br><span class="line">	Vector::<span class="built_in">Vector</span>()<span class="comment">//默认构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">		mode = RECT;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//当选择特定坐标系时的构造函数</span></span><br><span class="line">	Vector::<span class="built_in">Vector</span>(<span class="type">double</span> n1, <span class="type">double</span> n2, Mode form)</span><br><span class="line">	&#123;</span><br><span class="line">		mode = form;</span><br><span class="line">		<span class="keyword">if</span> (form == RECT)</span><br><span class="line">		&#123;</span><br><span class="line">			x = n1;</span><br><span class="line">			y = n2;</span><br><span class="line">			<span class="built_in">set_mag</span>();</span><br><span class="line">			<span class="built_in">set_ang</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (form == POL)</span><br><span class="line">		&#123;</span><br><span class="line">			mag = n1;</span><br><span class="line">			ang = n2 / Rad_to_deg;</span><br><span class="line">			<span class="built_in">set_x</span>();</span><br><span class="line">			<span class="built_in">set_y</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Incorrect 3rd argument to Vector()&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Vector set to 0.\n&quot;</span>;</span><br><span class="line">			x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">			mode = RECT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::reset</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2, Mode form)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mode = form;</span><br><span class="line">		<span class="keyword">if</span> (form == RECT)</span><br><span class="line">		&#123;</span><br><span class="line">			x = n1;</span><br><span class="line">			y = n2;</span><br><span class="line">			<span class="built_in">set_mag</span>();</span><br><span class="line">			<span class="built_in">set_ang</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (form == POL)</span><br><span class="line">		&#123;</span><br><span class="line">			mag = n1;</span><br><span class="line">			ang = n2 / Rad_to_deg;</span><br><span class="line">			<span class="built_in">set_x</span>();</span><br><span class="line">			<span class="built_in">set_y</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Incorrect 3rd argument to Vector()&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Vector set to 0.\n&quot;</span>;</span><br><span class="line">			x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">			mode = RECT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector::~<span class="built_in">Vector</span>()<span class="comment">//析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//切换坐标系</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::polar_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mode = POL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::rect_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mode = RECT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	Vector Vector::<span class="keyword">operator</span>+(<span class="type">const</span> Vector &amp; b)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector</span>(x + b.x, y + b.y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector Vector::<span class="keyword">operator</span>-(<span class="type">const</span> Vector &amp; b)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector</span>(x - b.x, y - b.y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector Vector::<span class="keyword">operator</span>-()<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector</span>(-x, -y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector Vector::<span class="keyword">operator</span>*(<span class="type">double</span> n)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector</span>(n*x, n*y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//友元函数</span></span><br><span class="line">	Vector <span class="keyword">operator</span>*(<span class="type">double</span> n, <span class="type">const</span> Vector &amp;a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a*n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> Vector &amp;v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (v.mode == Vector::RECT)</span><br><span class="line">			os &lt;&lt; <span class="string">&quot;(x,y) = (&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (v.mode == Vector::POL)</span><br><span class="line">		&#123;</span><br><span class="line">			os &lt;&lt; <span class="string">&quot;(m,a)=(&quot;</span> &lt;&lt; v.mag &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v.ang*Rad_to_deg &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			os &lt;&lt; <span class="string">&quot;Vector object mode is invalid&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//end namespace VECTOR</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络的服务质量(QoS) 学习记录</title>
    <url>/2018/07/31/Qos-in-computer-networks/</url>
    <content><![CDATA[<p>QoS入门，为了进一步学习DPDK上的QoS</p>
<p>《计算机网络的服务质量(QoS)》 林闯，单志广，任丰原 著</p>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>Internet的传统分组交换网络是面向非实时数据通信而设计的，典型应用例如FTP和Email。IP协议是典型的Best-effort，尽力而为的服务，TCP这类可靠的传输层协议被设计出来是为了缓解严重的网络拥塞，优化网络的数据吞吐量，最重要的是保证数据通信的可靠性。随着网络的发展，人们对于网络的要求越来越高，Internet上也从单一的数据传输变为数据、语音、图像、视频等多媒体的传输。多媒体信息对网络的带宽要求很高，而且要求信息传输延迟低，但能够容忍一定的错误率和丢失率（本书作于2003年，关于流量类型的着眼点在于多媒体）。现如今又出现了datacenter，以及云计算、大数据、IoT等大流量的传输要求，或是实时对战游戏、直播平台、自动驾驶这一类对时延、抖动要求极高的网络应用。Internet与生俱来的Best-effort特点，无法满足现如今越发多样化的网络应用以及用户对网络传输质量的不同要求。在此背景下，人们致力提高整个计算机网络系统的服务性能和质量，以期为下一代网络应用、为用户提供更高质量的网络传输。以上就是计算机网络QoS的诞生背景。</p>
<p>对QoS的研究可以追溯到上世纪八十年代，当时已经有一些具有远见的研究者认识到了服务质量的重要性，但很长的一段时间内，整个Internet的性能和规模有限，QoS并未获得大多数人的重视。直到网络规模的不断扩大以及多媒体应用的增加，研究者才开始了对QoS的系统性研究。最主要的是IETF在1997年9月开始制定一系列与QoS有关的RFC标准，典型的有【RFC 2215】综合服务（integrated services, IntServ, IS）和【RFC 2474】区分服务（differentiated services, DiffServ, DS）。我也重点看的是这两个。</p>
<h1 id="Definition-amp-Terminology"><a href="#Definition-amp-Terminology" class="headerlink" title="Definition &amp; Terminology"></a>Definition &amp; Terminology</h1><p>QoS的定义：</p>
<ul>
<li>QoS是网络在传输数据流时要满足一系列服务请求，具体可以量化为带宽、时延、抖动、丢失率、吞吐量等性能指标。</li>
<li>QoS是用户和服务网络之间关于信息传输质量的约定。</li>
<li>QoS的目标是为Internet应用提供服务区分和性能保证：服务区分是指网络能根据不同的应用的需求，为其提供不同的网络服务；性能保证则要解决带宽、丢失、延迟、抖动等性能问题，QoS的设计需以提高网络性能为目的。</li>
</ul>
<p>从QoS的目标来看，以整个计算机网络庞大的体量，QoS绝不是网络中某个个体元素的行为，不是在某一台主机、某一台路由器上稍作修改即可达到的目的，而是涉及到用户与网络、网络内部节点的一种整体行为。</p>
<p>【RFC 2216】是IETF对QoS做的一系列定义，其中有如下术语：</p>
<table>
<thead>
<tr>
<th>Terminology</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>QoS</td>
<td>用带宽、分组延时、分组丢失率等参数描述的关于分组传输网的质量</td>
</tr>
<tr>
<td>网络元素（Element）</td>
<td>任何一个可以在Internet中处理packet的构件。当用element描述时，表示它具有数据通过时对其进行QoS控制的能力</td>
</tr>
<tr>
<td>流（Flow）</td>
<td>相同QoS要求，服从统一QoS控制方法的，通过某一网络元素的packet集合。一个流的packet可以来自不同的应用。</td>
</tr>
<tr>
<td>服务（service）</td>
<td>描述网络元素的控制能力</td>
</tr>
<tr>
<td>行为（behavior）</td>
<td>应用直接可见的，由服务提供的最终结果</td>
</tr>
<tr>
<td>流量规范（traffic specification，TSpec）</td>
<td>流、网络元素、服务，三者之间的合同</td>
</tr>
</tbody>
</table>
<p>基于上述术语，IETF将QoS定义成二维空间：<code>&lt;服务类型&gt;、&lt;参数类型&gt;</code></p>
<p>用户需要与网络系统进行协商。协商就是用户之间/用户与网络之间就QoS要求进行交互，最后确定QoS的过程。用户可以表达的QoS描述包括：</p>
<ul>
<li>信息流特征。例如，信息流产生的峰值速率和平均速率等，以及五元组等网络数据。体现用户让网络知晓自己的特定的流量特征，需要QoS服务。</li>
<li>信息流的性能要求、同步要求。如吞吐量、延迟、抖动、丢包率的各种要求。</li>
<li>服务层次。例如想要可控负载型服务、保证性服务、还是尽力而为服务。</li>
</ul>
<p>当用户与网络系统达成QoS约定之后，网络系统就要提供基于QoS信息的流量实时控制了。包括几个重要的术语：</p>
<table>
<thead>
<tr>
<th>Terminology</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>整型 meter</td>
<td>调节流量速率，例如令牌桶算法。数学上证明了如果在网络边缘进行整型，在网络中采取适当的调度策略，可以为应用提供非常好的QoS[1]</td>
</tr>
<tr>
<td>调度 schedule</td>
<td>每个网络元素对packet进行排队时要根据QoS要求所赋予的相应优先级，调度网络资源（带宽、缓存、CPU、队列、线程等）来执行</td>
</tr>
<tr>
<td>监控 monitor</td>
<td>监视是否提供了预先约定的QoS，当无法提供时，提醒用户，协商降低QoS级别</td>
</tr>
<tr>
<td>控制 Control</td>
<td>开环和闭环两种模式。开环：只要开始QoS控制后，允许发送方一直按照一个速率发送数据。闭环：发送方还是要根据反馈信息调整发送速率。</td>
</tr>
<tr>
<td>同步 Synchronize</td>
<td>控制事件顺序和应用交互行为的精确时间先后顺序定义</td>
</tr>
</tbody>
</table>
<h1 id="IntServ"><a href="#IntServ" class="headerlink" title="IntServ"></a>IntServ</h1><p>IETF先后提出两种QoS体系结构，集成服务IntServ是第一种。特点是：需要所有的路由器在控制路径上处理每个流的消息，维护每个流的路径状态和资源预留状态，在路径上执行基于流的分类、调度、管理。技术上，基于资源预留协议RSVP；逐节点建立或拆除流的状态和资源预留状态；判断资源是否满足用户需求；根据流的状态进行QoS路由，传输控制等措施。IntServ的基石就是：资源预分配、全局流状态、传输控制。</p>
<h1 id="DiffServ"><a href="#DiffServ" class="headerlink" title="DiffServ"></a>DiffServ</h1><p>看了上面那段话也知道IntServ想在网络层建立太过复杂的逻辑而失败。于是DiffServ应运而生了。</p>
<ul>
<li>目标：简单有效、可扩展</li>
<li>内部节点只进行根据DS头部的简单转发</li>
<li>在边界节点进行流状态信息的保持和实现</li>
</ul>
<p>具体来讲：边界节点根据约定好的QoS规定，把将要进入网络的流量分类成不同的流。流的聚集信息用IP头部的DS field来标识，DS field 里的内容叫做DSCP（codepoint）。内部节点在调度这种包的时候，就是简单的根据不同的DSCP选择特定的调度和转发服务即可。</p>
<p>element 在收到包之后，要做的事情是：</p>
<ul>
<li>分流 classify，根据预先预定的规则，例如DSCP值、五元组等等。将包划到某一流的类别。</li>
<li>调节，包括 meter（限速）、mark（修改DSCP值）、drop（丢包）、shaping（整型，修改包的其他内容）、计量器（计数、记录流量速率等）、经过令牌桶算法调整速率等。</li>
<li>调度，发包。element实现一组PHB（per-hop-behavior，逐跳行为），就根据IP包的DSCP选取特定的PHB，执行特定的动作。</li>
</ul>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>[1] - Parekh A, Gallager R G. A generalized processor sharing approach to flow contol in integrated service networks - the multiple node case. IEEE INFOCOM’93. April 1993. 521~530</p>
<p><a href="https://en.wikipedia.org/wiki/Differentiated_services">wiki - DS</a></p>
]]></content>
      <categories>
        <category>TCP-IP</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之传递和返回对象</title>
    <url>/2017/06/07/Passing-and-Returing-Objects/</url>
    <content><![CDATA[<p>当编写成员函数或独立函数返回对象时，通常有这几种选择：返回指向对象的引用、返回指向对象的const引用、返回对象、返回const对象。下面进行讨论。</p>
<h1 id="返回指向const对象的引用"><a href="#返回指向const对象的引用" class="headerlink" title="返回指向const对象的引用"></a>返回指向const对象的引用</h1><p>使用const引用的常见原因是提高效率。是因为能返回对象的引用的函数，也可以返回对象来实现。返回对象会导致调用复制构造函数，而返回引用就不会。因此，返回引用做的工作更少，效率更高。</p>
<p>返回指向对象的引用有一个要求，就是指向的对象应该在函数执行期间存在。例如对Vector类编写一个函数Max()，返回两个Vector对象中比较大的一个。则下面两种方法都可行，但第二个版本比较好。<br><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Vector Max(const Vector &amp; v1,<span class="built_in"> const </span>Vector &amp; v2)</span><br><span class="line">&#123;</span><br><span class="line">	if(v1.magval() &gt; v2.magval())</span><br><span class="line">	<span class="built_in">	return </span>v1;</span><br><span class="line">	else</span><br><span class="line">	<span class="built_in">	return </span>v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">//better<span class="built_in"></span></span><br><span class="line"><span class="built_in">const </span>Vector &amp; Max(const Vector &amp; v1,<span class="built_in"> const </span>Vector &amp; v2)</span><br><span class="line">&#123;</span><br><span class="line">	if(v1.magval() &gt; v2.magval())</span><br><span class="line">	<span class="built_in">	return </span>v1;</span><br><span class="line">	else</span><br><span class="line">	<span class="built_in">	return </span>v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="按值传递or按引用传递？"><a href="#按值传递or按引用传递？" class="headerlink" title="按值传递or按引用传递？"></a>按值传递or按引用传递？</h1><p>编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。</p>
<p>原因之一是提高效率，跟返回同样的，如果按值传递对象会涉及到生成临时拷贝、调用复制构造函数、析构函数的步骤，如果按引用传递会使时间的花费少很多。如果函数不修改对象，则应声明参数为const对象引用。</p>
<p>另外一个原因是如果定义为接受基类引用参数的函数，还能接受派生类引用。</p>
<h1 id="返回指向非const对象的引用"><a href="#返回指向非const对象的引用" class="headerlink" title="返回指向非const对象的引用"></a>返回指向非const对象的引用</h1><p>两种常见的情形：重载赋值运算符、重载与<code>cout</code>一起使用的<code>&lt;&lt;</code>运算符。前者这样做旨在提高效率，后者则必须这样做。</p>
<p><code>operator=()</code>的返回值用于连续赋值的话，则返回对象和返回引用都是可行的。但和上面的例子一样，如果返回引用可以免去调用复制构造函数的工作。</p>
<p><code>operator&lt;&lt;()</code>的返回值用于串接输出，因此返回值必须是一个<code>ostream</code>对象。所以返回值必须是<code>ostream &amp;</code>。如果返回值是<code>ostream</code>，则会要求调用<code>ostream</code>类的复制构造函数，但<code>ostream</code>没有共有的复制构造函数。</p>
<h1 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h1><p>如果返回的对象是被调用函数中的<strong>局部变量</strong>，则<strong>不应按引用方式返回它</strong>，因为被调用函数执行完毕后，局部对象会调用析构函数，控制权回到调用函数时，引用指向的对象将不复存在。通常，被重载的算术运算符属于这种情况。</p>
<p>Vector类加法：<br><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Vector</span> <span class="built_in">Vector</span>::operator+(<span class="keyword">const</span> <span class="built_in">Vector</span> &amp; b)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Vector</span>(x + b.x, y + b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vector</span> force1(<span class="number">50</span>,<span class="number">60</span>);</span><br><span class="line"><span class="built_in">Vector</span> force2(<span class="number">10</span>,<span class="number">70</span>);</span><br><span class="line"><span class="built_in">Vector</span> force3;</span><br><span class="line">force3 = force1 + force2;</span><br></pre></td></tr></table></figure><br>这里返回的不是<code>force1</code>和<code>force2</code>，因为<code>force1</code>和<code>force2</code>在相加的过程中应该本身保持不变，而是返回两个对象的和。函数中应设置一个局部变量来存储计算结果，所以不应该返回指向该临时对象的引用，应该返回对象。</p>
<h1 id="返回const对象"><a href="#返回const对象" class="headerlink" title="返回const对象"></a>返回const对象</h1><p>可以把<code>Vector::operator+()</code>的返回类型声明为<code>const Vector</code>。这样可以防止错误的使用。比如下面三条错误的写法：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">force1 + force2 = force3;</span><br><span class="line">cout&lt;&lt;<span class="params">(force1 + <span class="attr">force2</span> = force3)</span><span class="string">.magval</span><span class="params">()</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span><span class="params">(force1 + <span class="attr">force2</span> = force3)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>• 通常，编写使用对象作为参数的函数，应按照引用传递。<br>• 如果方法或函数需要返回局部对象，则应返回对象<br>• 如果方法或函数需要返回一个没有公有复制构造函数的类（如ostream），则必须返回指向对象的引用<br>• 有些方法和函数既可以返回对象，也可以返回引用，则出于效率方面的考虑应首选返回引用。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>最近的思考 —— 2023 年 8 月</title>
    <url>/2023/08/20/Recent-thoughts-2023-Aug/</url>
    <content><![CDATA[<p>我找工作的时候，我只投了苏州微软这一个职位。现在回想，简直觉得那个时候的自己非常的 bold。哪有人找工作只投递一家公司的？要是 fail 了怎么办？当时也有很多的别的公司例如阿里、华为的 HR 在 LinkedIn 上看到我的简历就邀请我投递申请，但我对他们都是无动于衷。仔细回想，我这么做的理由有两个：</p>
<ol>
<li>我 19 年在 Microsoft 实习过，在那个时候让我对这家公司有了极大的尊重，很好的文化和同事。所以我找工作的时候还是第一时间想回到微软。Microsoft 校招的流程又很长，我投简历到拿到 offer 花了四五个月吧，估计一些国内公司可能几周就搞定了。我当时心里就想，我就是想去 Microsoft，如果别的公司下了 offer，在没有得到 Microsoft 的最终结果（无论是 offer 还是 fail）之前，我都是不可能接的。</li>
<li>外企和国内企业的面试风格是不同的，外企主要偏重考察算法、leetcode，而国内公司还会考八股文。如果我要同时投递多家公司，我就要分出我的精力去准备八股文，也就是准备我并不是最想去的公司的面试，这必然要占据我的精力。既然我想明白了第一点，那不如就全力以赴准备微软面试考察的算法，而不准备八股文面试。至于有没有考虑过如果没过 Microsoft 的面试怎么办？说实话，现在回想起来，我当时是真的没有多虑这件事，而只是全力以赴地准备面试。如果真的挂了，大概就是挂了之后再开始找其他公司的机会吧。</li>
</ol>
<p>谈谈晋升和职位级别这件事吧。决定一个人是否能得到 promote，取决于很多的因素。首先是你自己的 impact，工作的影响力；然后还有公司的 budget（这个可以说是最重要的）；以及和别的 competitor，也就是同一轮竞争晋升的别的 candidate，你要在他们之中还能脱颖而出。这我就列了三个因素，其中自己工作的 impact 这件事情，我是有办法控制的；而其余的像 budget、其他 candidate 的情况，这都是在我控制之外的事情，out of my control. 所以说，能不能晋升，我所能控制的部分有限，并不是我能完全决定的。我对目前晋升的速度感觉到满意，59-&gt;60 1 year, 60-&gt;61 我觉得1.5 years, or 2 years 都是可以的。相反，觉得某种年限就要到达某个 level，或者说，“TA的年限比我低，为什么TA比我先升职，这不公平”，我觉得这种观点是错误的，为什么一定要论资排辈呢？如果年轻人做得更好，他当然可以升职。这种想法体现了一种狭隘的竞争观念。</p>
<p>我现在思考我的工作和生活，我觉得我太幸福了。在微软的工作，公司文化和同事们都超级棒，不需赘述。做的工作是自己喜欢的事情，从事的也是自己喜欢的专业，能在工作中得到技能和职业方面的进步，还有体面的工资，健康的工作时长。和同事、上级的都关系融洽，工作上合作亲密无间，生活中的私交也不错。七月的某一周，我花了三天时间参与了一个内部志愿项目来改造一个内部使用的网站，那三天我没有做本职工作，而是全心全意扑在那个业余项目上。那几天让我感觉到了写代码竟然还可以有钱拿的那种快乐。工作日的工作有效率且有条不紊，下班之后有各种各样的活动安排了我的业余时间——健身运动、做饭、打扫卫生、徒步、旅游、去别的城市见老朋友、打牌娱乐消遣…… 这种生活简直就是在天堂。而且现在中国的年轻人找工作非常难，16-24岁的青年失业率已经达到20%. 马克思说工作是一种剥削，现在多少人求一个被剥削的机会都没有？还有，单就在中国做一个程序员可以不用 996 这件事，简直难以想象，让我觉得我简直像是在活在梦里了。目前二十六岁的我，没有结婚没有小孩，爸爸妈妈也没有要我的钱，我要给钱给他们他们还不要，就是一个一人吃饱全家不饿的状态。我真的觉得我现在的生活非常幸福，我非常感恩。如果在 Microsoft 还感受不到一种幸福感，那究竟怎样才能幸福？究竟要怎样才能获得内心的平静？</p>
<p>我也在思考我在这个世界的所处的位置这么一个问题。我有体面的工作，我赚的比一些人多，但是这并不意味着，我就高人一等。更客观地说，这意味着，我更适应这套资本主义公司的系统，我在这个系统之下，会比别人获得了更多的资源倾斜和机会分配。一个人能获得多少金钱取决于什么？在这套体系下的个人的幸福又是什么，等同于金钱吗？比方说，我喜欢编程这件事情，那完全就是天注定，毕竟每个人的兴趣是不一样的。程序员在市场经济中取得的报价，是市场和软件行业本身创造的经济价值所共同决定的。如前所述，某人能得到晋升是由于很多因素共同决定，其中的多数因素并非此人本身就能控制；类似地，某个人在资本主义经济体系里可以挣到多少钱，这不消说也同样是由非常多的因素共同决定，其中也必定有很多例如经济周期、行业利润率等等，远非人力所能单独改变之因素。我不用像很多中国本土程序员 996，也是得益于美国企业将其工作外包到中国本土来的这么一个商业决策，而并不是所谓简单的一句“我很努力，我很优秀”就足够解释。这也许就是所谓的“谋事在人，成事在天”。Man propose, God dispose. 金钱由这么多的因素共同决定，而能获得多少金钱的又取决于很多尤其是在人本身的控制范围之外的事。如果只是把幸福简单地建立在金钱上，或者任何单一的价值尺度上，那种无法全盘掌控的无力感必会让人们感受到一种人性本身的软弱，即无法实现人生目标、找不到生活的意义，甚至走向虚无。</p>
<p>我的一个埋藏在心里的 concern 是，我真的不想 update my resume 在走一遍找工作的过程。那件事情让我觉得真的非常非常无聊和枯燥。如果有任何的原因未来我需要做这件事的话，我觉得现在我有点被 Microsoft spoil，惯坏了。比方说，面试不用准备八股文这种事。有的人会说，在大公司做的都是螺丝丁，微软的技术栈封闭，出去不好面试不好跳槽。我觉得相对应的解决方案是，在工作中注意培养所谓 transferrable - 可迁移性的技能。具体在大公司要怎么做呢，…… 先不展开了。</p>
]]></content>
  </entry>
  <entry>
    <title>“我们本可以拥有一切，如今却只能在深渊里挣扎”</title>
    <url>/2019/07/05/Rolling-in-the-Deep/</url>
    <content><![CDATA[<p>Thanks to Rsmiao…</p>
<hr>
<p>今天写下这篇文章，是因为在刷微博的时候看到了非常有感触的一组图。在此我会写下我的感想与你分享，但是我也希望阅读这篇文章的你在品味我的文字之前，也可以自己去体会欣赏绘画作品这个过程，希望你能够仔细品味五张作品。若能自己还没仔细看两眼就阅读了别人嚼碎的东西，未免少了点什么~</p>
<p>用的是 sm.ms 做图床，可能访问速度不是特别快……原微博地址在此：<a href="https://weibo.com/1971029173/HC211ve1I?type=comment#_rnd1562330450976">点击这里</a></p>
<p>下面是原图，一共五张：（画师：じょろり） ​</p>
<p><img src="https://i.loli.net/2019/07/05/5d1f44f586a5f93408.jpg" alt=""></p>
<p><img src="https://i.loli.net/2019/07/05/5d1f44eee457b32717.jpg" alt=""></p>
<p><img src="https://i.loli.net/2019/07/05/5d1f44efd0a7522395.jpg" alt=""></p>
<p><img src="https://i.loli.net/2019/07/05/5d1f44f11e22e33938.jpg" alt=""></p>
<p><img src="https://i.loli.net/2019/07/05/5d1f44f2f16b179681.jpg" alt=""></p>
<p><del>我是分割线</del></p>
<hr>
<p>其实在整个故事线里是有五种主要的人：</p>
<p><img src="https://i.loli.net/2019/07/05/5d1f44f670f4217015.jpg" alt=""></p>
<ol>
<li><strong>男主</strong></li>
<li><strong>女1</strong>，就是短发女</li>
<li><strong>女2</strong>，马尾女</li>
<li>一共有三个路人的出现，但明显其中一个有画眼睛和面部表情，另外两个没有画。所以这个这位脸上有创可贴的男生我称之为是<strong>高级路人男</strong></li>
<li>另外两位是真正的一般通过路人。</li>
</ol>
<p>在第一次浏览过五张图后我被这个粗看很白学的故事吸引了，但这一次我并不是像往常那样只用一瞬看完一张图就关掉，继续刷别的微博，而是有一些思绪涌现。点下转发和点赞按钮后，我又拿着手机把五张图看了好久，发现，其中的关联性故事性好完整。季节，氛围，景，路人，时间迁移的安排都好棒。作者的构思真的非常用心。</p>
<p>对于每一张图我都从这以下几个方面来分析吧：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>季节&amp;时间：</span><br><span class="line"><span class="bullet">- </span>氛围&amp;景：</span><br><span class="line"><span class="bullet">- </span>三位主人公心情：</span><br><span class="line"><span class="bullet">- </span>高级路人的心情：</span><br></pre></td></tr></table></figure>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="第一张图"><a href="#第一张图" class="headerlink" title="第一张图"></a>第一张图</h2><p><img src="https://i.loli.net/2019/07/05/5d1f44f586a5f93408.jpg" alt=""></p>
<ul>
<li>季节&amp;时间：春的白天</li>
<li>氛围&amp;景：开满樱花的季节，空中飘扬着樱花瓣，显然是最令人舒适的春季。</li>
<li>三位主人公心情：两小无猜的阶段，很明显是在非常的纯洁的童年，是纯洁的童年友谊.</li>
<li>高级路人的心情：说实话看不太清楚是怎么想的，但是可能已经有了懵懂的情愫，眼神中有比较迷茫的执拗。伏笔埋得很早。</li>
<li>Rs：春天也象征着故事的起点</li>
</ul>
<h2 id="第二张图"><a href="#第二张图" class="headerlink" title="第二张图"></a>第二张图</h2><p><img src="https://i.loli.net/2019/07/05/5d1f44eee457b32717.jpg" alt=""></p>
<ul>
<li>季节&amp;时间：夏季午后</li>
<li>氛围&amp;景：树荫下三位坐在楼梯上畅谈。路人是放到比较远的秋千上活动，路人的描绘不是很清楚，是绝对的突出主角们的一幕。</li>
<li>三位主人公心情：小学或初中阶段。他们现在是很好的朋友，但是最令人瞩目的就是女1这个时候看待男主的描绘种，眼睛里很明显有了爱情。</li>
<li>高级路人的心情：无</li>
</ul>
<h2 id="第三张图"><a href="#第三张图" class="headerlink" title="第三张图"></a>第三张图</h2><p><img src="https://i.loli.net/2019/07/05/5d1f44efd0a7522395.jpg" alt=""></p>
<ul>
<li>季节&amp;时间：秋季的夜晚</li>
<li>氛围&amp;景：我觉得构思最巧妙的一图——远远看过去的黑夜，建筑内的灯光意味着夜晚已经降临。近处的台灯有一个更亮的光影效果，和远处建筑物内的黯淡灯光形成了一个对比。路边停着三辆自行车，很明显是主角们要骑的。而且这三辆电动车占据了图上右下角的篇幅，是一个很重要的部分。将这些东西联系一下：秋天凉爽的黑夜，三个人步伐匆匆，奔向自行车——就好像主角们要开始在一条非常有趣的冒险旅途上探索一样。</li>
<li>三位主人公心情：男主拉着女1的手，女1的眼神和男主有很强的互动，且明显脸红，这意味着女1是什么想法我不用多说了吧。女2像是专注在下楼梯的表情，看似和男主没有什么联系，但反而埋下了伏笔——男主这个时候其实并不是对女1是有爱情的，这时候男主应该还没有恋爱的意识。</li>
<li>高级路人的心情：这是最后一次高级路人出现在画面中，可以看到，他是以比较落寞的眼神（一只眼睛，侧脸，还有一贯的创口贴）望着主角三人的，所以他应该是已经认为他喜欢的女1和男主的关系更好，而失落。从图4他没有出现这一点来看，就可以得出他是败犬结论。</li>
</ul>
<h2 id="第四张图"><a href="#第四张图" class="headerlink" title="第四张图"></a>第四张图</h2><p><img src="https://i.loli.net/2019/07/05/5d1f44f11e22e33938.jpg" alt=""></p>
<ul>
<li>季节&amp;时间：寒风萧瑟的冬天</li>
<li>氛围&amp;景：近景：女1手上拿着想要跟男主表白的情书和小礼物，画的比较清楚，远景：男主和女2在拥吻，比较远所以画的比较模糊的轮廓，这形成了一种对比。</li>
<li>三位主人公心情：男主和女2就不用分析了，他们下一张图不出场了。地板上没有春天的樱花瓣（代表故事的起点），墙壁上也没有夏天的知了（代表令人愉快的相处时光），秋千上也没有人在玩了，树叶都光秃秃了，只剩下树干和树枝。在这么个萧瑟肃杀的景色种，观众能感受到（用黑色的线条绘画的）光秃秃的树干树枝显得很扎眼，这就好像男主和女2在亲吻这一幕，在女1看起来也是非常扎眼的。可能就算周遭有什么东西，也没有办法能够去注意了吧。</li>
<li>高级路人的心情：无</li>
<li>Rs：其实第四张也并不是故意要设置一个这么有戏剧性的场景（想要告白结果发现…也太巧合了）可能只是想把整个阶段的事情概括在一张图里</li>
</ul>
<h2 id="第五张图："><a href="#第五张图：" class="headerlink" title="第五张图："></a>第五张图：</h2><p><img src="https://i.loli.net/2019/07/05/5d1f44f2f16b179681.jpg" alt=""></p>
<ul>
<li>季节&amp;时间：下大雪的冬天</li>
<li>氛围&amp;景&amp;主人公心情：地上有积雪，女1很明显内心非常难过，坐在这里悲伤，脸上也有泪花。从头发上和衣服上的积雪厚度来看伤心的程度还是比较重的。手里还是捏着告白的情书，但是揉皱了，代表着虽然不能和男主成为情侣但内心还是非常喜欢。礼物倒在地上，和她有一定的距离，也反映了她内心的难过。但在时间上图4和图5肯定有所间隔，但女1并没有丢掉礼物，说明她真的爱着男主，而且爱的很深，起码从图2就开始了。</li>
<li>高级路人的心情：可以从发型得知撑着伞的这位是高级路人男。不知道高级路人男在之前的剧情中有没有和女1表过白，还是说只是因为看到她和男1走得近就默默的离开（不过这已经不重要了）。很明显，雨伞上也有很多积雪了，说明高级路人男发现情况，然后过来陪她不是短短一阵子了，而女1很明显还陷入“明明是我先为何这样”的苦闷中还不可解脱。虽然高级路人男此时希望表白女1然后女1和自己在一起，但实际上，普通高中生的对待感情的成熟程度已经注定了高级路人男和女1都得不到幸福。</li>
<li>Rsmiao: 不过我觉得4-5 可能也是同一天，可能看到那个场景 之后就开始下雪…</li>
</ul>
<p>完</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>在高中，我就是高级路人男，而且剧情和上面的我写的一样一样的，所以我才会看了之后那么有感触，艺术果然是来源于生活又高于生活，爱情就是这么的残酷，但这就是青春 :) 后来有朋友跟我说这个画师就是非常擅长画着种细节丰富、故事性极强的套图，令我赞叹不已，要上推特上关注一下。</p>
<p>我倾向图4和图5不是发生在同一天的事，甚至是整整一个冬季。比如图4是刚刚掉光叶子的初冬，而图5是深冬，以此表现悲情和痛苦的持续时间之长。这令我想到我非常痛苦，花了非常大力气才走出的暗恋表白被拒经历：在课间，无意之中看见她的身影，可以自闭到难受一整天缓不过来；在放学后寂静的校园和楼道，内心是无力的，仿佛自己身体的移动都变得特别慢；下雨天，空旷的操场，会逼迫自己放肆的奔跑，淋得浑身湿；看到别的情侣，就会想，为什么人家已经在天堂了，而我还在地狱挣扎……不过，就算是经历了这样的彻骨之痛，还是没有丢掉情书和手工做的小饼干，所以这不就证明，这痛苦是多么迷人和令人陶醉呀！所以就算是在冰天雪地，还是会想坐在这里痛哭！为什么我会这么笃定呢？因为作为高级路人男的我在高中给女1准备的小礼物，没有送出去，就一直放在我的箱子里的一个地方，保持没有拆开的那个样子，一直放着，我既不想送给别人，也不想自己用，也不想拿去丢掉，只会每次打开箱子拿出来看一下又原封不动地放回去。这大概就是一段我想要永远封存的记忆吧……</p>
<p>我想到一个很简单的词组，那是一首歌的名字，只有四个单词，但是胜过千言万语，能够把所有的感情囊括进去——</p>
<p>Rolling in the Deep.</p>
<p>这就是为什么我如此迷恋 Adele Adkins.</p>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之简单的公有继承</title>
    <url>/2017/06/07/Simple-Public-Inheritance/</url>
    <content><![CDATA[<h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++ 继承"></a>C++ 继承</h1><p>面向对象编程的主要目的之一是提供可重用的代码。开发新项目时，尤其当项目特别庞大时，重用已经测试的代码比重新编写新的代码要好的多。C语言中，有传统的C函数库、预定义、预编译的函数、专用的C库。C++类提供了更高层次的重用性，提供了比修改代码更好的方法来扩展和修改类——类继承。它能够从已有的类派生成新的类，而派生类继承了原有类的特征，包括方法。</p>
<p>下面是可以通过继承完成的工作：</p>
<p>• 可以在已有类的基础上添加功能。例如对于数组类，添加数据数学运算。<br>• 可以给类添加数据。例如对字符串类，派生出指定字符串显示颜色的数据成员。<br>• 可以修改类方法的行为。例如对于飞机上的乘客passenger类，派生出更高级别服务的FirstClassPassenger类。</p>
<p>从一个类派生出另一个类时，原始类被称为<strong>基类</strong>，继承类被称为<strong>派生类</strong>。</p>
<h1 id="继承的三种方式"><a href="#继承的三种方式" class="headerlink" title="继承的三种方式"></a>继承的三种方式</h1><p>派生类和基类的特殊关系是基于C++继承的底层模型的。C++有三种继承方式：<strong>公有继承、保护继承和私有继承</strong></p>
<p><strong>公有继承</strong>是最常用的方式，它建立的是一种<code>is-a</code>关系，这种关系就是is a kind of（是一种）。所有使用公有继承派生的派生类需要符合is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的操作，也可以对派生类对象执行。例如有一个Fruit类，由于香蕉是一种水果，所以可以从Fruit类派生出Banana类。新的Banana类可以添加专门用于香蕉的成员。</p>
<p>下面是不符合is-a关系的例子：</p>
<p>公有继承不确定<code>has-a</code>关系。例如午餐包括水果，但午餐不是一种水果，这里Lunch和Fruit不是is-a关系，所以不能从Fruit类使用公有继承派生出Lunch类。在午餐中添加水果的正确方法是has-a关系：午餐有水果。比较好的方法就是在Lunch类中包含一个Fruit类成员。</p>
<p>公有继承不确定<code>is-like-a</code>关系，即：它不采用比喻。人们说，女人像老虎，但女人实际上不是老虎。所以不应该从Tiger类通过公有继承派生Women类。即：公有继承是在基类的基础上添加属性，但不能删除基类的属性。对于这种情况的解决方法是使用抽象基类，后面会介绍。</p>
<p>公有继承不建立<code>is-implemented-as-a</code>（作为……来实现）的关系。例如可以用数组来实现栈，但从Array类派生出Stack类是不合适的。正确的方式是：让栈包含一个私有Array对象来隐藏数组实现。</p>
<p>公有继承不建立<code>use-a</code>关系，例如计算机可以使用打印机，但无论是从Computer派生Printer还是反之都是没有意义的。正确的方式是：通过友元函数或类来处理Printer对象和Computer对象之间的通信。</p>
<p>如果用公有继承来实现上述4种例子通常会出现编程方面的问题，所以还是坚持公有继承只用于实现<code>is-a</code>关系吧！</p>
<h1 id="简单的基类和派生类"><a href="#简单的基类和派生类" class="headerlink" title="简单的基类和派生类"></a>简单的基类和派生类</h1><p>如果某健身俱乐部需要一个程序跟踪乒乓球会员，先需要设计基类TableTennisPlayer。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tabtenn0.h -- a tabletennis base class</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TableTennisPlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string firstname;</span><br><span class="line">	string lastname;</span><br><span class="line">	<span class="type">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TableTennisPlayer</span>(<span class="type">const</span> string &amp;fn = <span class="string">&quot;none&quot;</span>, <span class="type">const</span> string &amp;ln = <span class="string">&quot;none&quot;</span>, <span class="type">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Name</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">HasTable</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetTable</span><span class="params">(<span class="type">bool</span> v)</span> </span>&#123; hasTable = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tabtenn0.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">TableTennisPlayer::<span class="built_in">TableTennisPlayer</span>(<span class="type">const</span> string &amp;fn,</span><br><span class="line">	<span class="type">const</span> string&amp;ln, <span class="type">bool</span> ht) :<span class="built_in">firstname</span>(fn),</span><br><span class="line">	<span class="built_in">lastname</span>(ln), <span class="built_in">hasTable</span>(ht) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableTennisPlayer::Name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生一个类。俱乐部里的一些成员参加过当地锦标赛，所有在比赛中有过比分。与其从零开始设计新的类，不如从TableTennisPlayer中派生一个类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RatedPlayer</span> : <span class="keyword">public</span> TableTennisPlayer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r = <span class="number">0</span>, <span class="type">const</span> string &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">		<span class="type">const</span> string &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="type">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r, <span class="type">const</span> TableTennisPlayer &amp; tp);</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Rating</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetRating</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> r)</span> </span>&#123; rating = r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RatedPlayer::<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r, <span class="type">const</span> string &amp; fn,</span><br><span class="line">	<span class="type">const</span> string &amp; ln, <span class="type">bool</span> ht) : <span class="built_in">TableTennisPlayer</span>(fn, ln, ht)</span><br><span class="line">&#123;</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RatedPlayer::<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r, <span class="type">const</span> TableTennisPlayer &amp; tp)</span><br><span class="line">	: <span class="built_in">TableTennisPlayer</span>(tp), <span class="built_in">rating</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒号指出<code>RatedPlayer</code>的基类是<code>TableTennisPlayer</code>。这种特殊的声明头表示TableTennisPlayer是一个<strong>公有基类</strong>，这被称为<strong>公有派生</strong>。</p>
<h2 id="继承了什么？"><a href="#继承了什么？" class="headerlink" title="继承了什么？"></a>继承了什么？</h2><p>使用公有派生，<strong>基类的公有成员将成为派生类的公有成员</strong>，基类的<strong>私有部分成为派生类的一部分</strong>，但<strong>只能通过基类的公有和保护方法访问</strong>。</p>
<p>派生类类声明代码做的工作：<br>    • 派生类对象存储了基类的数据成员（派生类继承基类的实现）<br>    • 派生类对象可以使用基类的方法（派生类继承基类的接口）</p>
<p>派生类需要在继承特性中添加：<br>    • 派生类需要自己的构造函数。<br>    • 派生类可以根据需要添加额外的数据成员和成员函数。</p>
<h2 id="初始化列表——关于派生类构造函数的考量"><a href="#初始化列表——关于派生类构造函数的考量" class="headerlink" title="初始化列表——关于派生类构造函数的考量"></a>初始化列表——关于派生类构造函数的考量</h2><p>派生类不能直接访问基类的私有成员，<strong>必须通过基类方法进行访问</strong>。创建派生类对象时，程序首先创建基类对象。这意味着基类对象应当在程序进入派生类构造函数之前被创建，C++使用成员<strong>初始化列表语法</strong>完成这种工作。</p>
<p>如果不使用成员初始化列表，由于必须首先创建基类对象，程序就使用默认的基类构造函数。</p>
<p>第二个构造函数是用基类对象引用作为参数的派生类构造函数。tp类型是TableTennisPlayer &amp; ，因此这里调用的是默认复制构造函数。</p>
<p>有关派生类构造函数的要点如下：<br>    • 首先创建基类对象。<br>    • 派生类构造函数应该通过成员初始化列表将基类信息传递给基类构造函数。<br>    • 派生类构造函数还应初始化新增的数据成员。</p>
<h2 id="派生类和基类的关系"><a href="#派生类和基类的关系" class="headerlink" title="派生类和基类的关系"></a>派生类和基类的关系</h2><ol>
<li>派生类兑现可以使用基类的方法，条件是方法不是私有的。</li>
<li>基类指针可以在不进行显示转换的情况下指向派生类对象。</li>
<li>基类引用可以在不进行显示转换的情况下引用派生类对象。</li>
<li>不可以将基类的对象和地址赋给派生类引用和指针。</li>
</ol>
<p>基类引用和指针指向/引用派生类对象。如果有方法的形参是基类引用，就可以指定基类对象或者派生类对象。如果形参是指向基类的指针的，就可以使用基类对象的地址或派生类对象的地址作为实参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tabtenn1.h -- a tabletennis base class</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TABTENN0_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABTENN0_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TableTennisPlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string firstname;</span><br><span class="line">	string lastname;</span><br><span class="line">	<span class="type">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TableTennisPlayer</span>(<span class="type">const</span> string &amp;fn = <span class="string">&quot;none&quot;</span>, <span class="type">const</span> string &amp;ln = <span class="string">&quot;none&quot;</span>, <span class="type">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Name</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">HasTable</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetTable</span><span class="params">(<span class="type">bool</span> v)</span> </span>&#123; hasTable = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RatedPlayer</span> : <span class="keyword">public</span> TableTennisPlayer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r = <span class="number">0</span>, <span class="type">const</span> string &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">		<span class="type">const</span> string &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="type">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r, <span class="type">const</span> TableTennisPlayer &amp; tp);</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Rating</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetRating</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> r)</span> </span>&#123; rating = r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//tabtenn1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">TableTennisPlayer::<span class="built_in">TableTennisPlayer</span>(<span class="type">const</span> string &amp;fn,</span><br><span class="line">	<span class="type">const</span> string&amp;ln, <span class="type">bool</span> ht) :<span class="built_in">firstname</span>(fn),</span><br><span class="line">	<span class="built_in">lastname</span>(ln), <span class="built_in">hasTable</span>(ht) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableTennisPlayer::Name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RatedPlayer::<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r, <span class="type">const</span> string &amp; fn,</span><br><span class="line">	<span class="type">const</span> string &amp; ln, <span class="type">bool</span> ht) : <span class="built_in">TableTennisPlayer</span>(fn, ln, ht)</span><br><span class="line">&#123;</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RatedPlayer::<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r, <span class="type">const</span> TableTennisPlayer &amp; tp)</span><br><span class="line">	: <span class="built_in">TableTennisPlayer</span>(tp), <span class="built_in">rating</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usett1.cpp -- using base clase and derived class</span></span><br><span class="line"><span class="comment">//#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &quot;tabtenn1.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> std::endl;</span><br><span class="line">	<span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="string">&quot;Benjamin&quot;</span>, <span class="string">&quot;Wandering&quot;</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Chang&quot;</span>, <span class="string">&quot;Zhao&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">	rplayer1.<span class="built_in">Name</span>();<span class="comment">//派生类可以使用基类的公有方法</span></span><br><span class="line">	<span class="keyword">if</span> (rplayer1.<span class="built_in">HasTable</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;: has a table.\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;: hasn&#x27;t a table.\n&quot;</span>;</span><br><span class="line">	player1.<span class="built_in">Name</span>();<span class="comment">//派生类可以使用基类的公有方法</span></span><br><span class="line">	<span class="keyword">if</span> (player1.<span class="built_in">HasTable</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;: has a table.\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;: hasn&#x27;t a table.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">	rplayer1.<span class="built_in">Name</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer1.<span class="built_in">Rating</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用基类对象初始化派生类对象</span></span><br><span class="line">	<span class="function">RatedPlayer <span class="title">rplayer2</span><span class="params">(<span class="number">1212</span>, player1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">	rplayer2.<span class="built_in">Name</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer2.<span class="built_in">Rating</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>苏格拉底怀疑论 - 未检视的生活是不值得过的</title>
    <url>/2019/08/24/Skepticism/</url>
    <content><![CDATA[<blockquote>
<p><strong>The unexamined life is not worth living. —— Socrates</strong><br>未检视的生活是不值得过的——古希腊哲学家苏格拉底</p>
</blockquote>
<h1 id="怀疑论简介"><a href="#怀疑论简介" class="headerlink" title="怀疑论简介"></a>怀疑论简介</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%80%80%E7%96%91%E8%AE%BA">怀疑论 - 维基百科，自由的百科全书</a></li>
</ul>
<p>在古往今来的哲学中，怀疑论 (Skepticism) 有举足轻重的地位，是一种强大的哲学立场。除了苏格拉底，还有笛卡尔、休谟是怀疑论者。他们也对怀疑论提出了更多的不同于苏格拉底的内涵。本文是学习国立台湾大学哲学系苑舉正教授主讲的哲学课之苏格拉底怀疑论的学习笔记。</p>
<p>日常使用的情况下，怀疑论可以指：</p>
<ul>
<li>一种态度或倾向。普遍怀疑 (Globe doubt)，或者对某些具体的对象进行怀疑。</li>
<li>一些信条，声称真知识或某些具体知识时的不确定。</li>
<li>一种方法，包括悬置判断，具体怀疑，或有怀疑特色地批判 (critical thinking)。</li>
</ul>
<p>在哲学上，怀疑论可以指：</p>
<ul>
<li>问询的方式，强调彻底而批判地审查，小心谨慎，以及智力上的严密。</li>
<li>一种方法，通过系统怀疑和持续测试来获取知识。</li>
<li>一些断言，关于人类知识的界限，以及对这些界限正确的回应。</li>
</ul>
<hr>
<p>苏格拉底怀疑论的出发点：承认自己是有限的，但以积极的态度探索，认为知识是可达的，为了达到更完美的人生。<strong>怀疑论是认为生命需要不断的被检验，而不是拿“怀疑”当作一切事情的基本立场</strong>。学会怀疑是为了让你学会更好地去思辨和学习。</p>
<p><strong>人是有限的，无法了解无限的东西</strong>（焦虑可能来源于此），他的认知受到自己环境的影响。eg：牛顿的理论被爱因斯坦推翻。</p>
<p>苏格拉底的理性就是从这一点出发，否定每一个判断然后持续调查。<strong>如果有人否定你然后还能把你说服，这种人就是恩师啊</strong>（你要做痛苦的苏格拉底，还是做快乐的猪？）</p>
<p>以下是苏格拉底怀疑论中的一些基本信念：</p>
<ol>
<li><strong>没有经过检验的人生是不值得过的人生。</strong></li>
<li>客观真理是存在的（“哲學懷疑論者並非主張真理是不可能存在的（因這本身將是一個真理宣稱）”）。知识是可达的。（你只要提前一步先他人努力，学习很痛苦，学完真的很爽啊，怀疑论就是积极乐观的学习</li>
<li>真理在每个人心中，每个人都有自己的真理，但如果你不说出来，就完全是属于个人，没有价值。</li>
<li><strong>以发问的方式，让对话人和旁观者知道，什么叫做思想和对错。以发问的方式，逼迫他人展开批判和检验和探索。</strong>（“有美玉于斯，待价而沽”。fine，你完全可以这么想，但如果有一天你把你的想法拿出来没有人喜欢的话你不要哭，因为你从来没有和别人沟通过）</li>
</ol>
<p>否定和怀疑为什么能够上升到哲学高度？原因就是，否定可以让人受到刺激，面对拒绝，我们想要进行自我探索和批判。试想，如果我们所说的话，从来都是受到褒奖，我们听到的也从来都是想听到的话，久而久之，我们一定会肯定自己的所思所想，深信不疑，感到相当自满。</p>
<p>反例：“害怕出错，永远不出错”。（坐最后一排 “还好老师提问没有叫到我”）</p>
<p>这边老师插了一嘴评论了一下关于大学阶段相对高中的自由：自由很好，但是如果不懂得自律，那么自由也是地狱，你浪费了自由的环境，不懂得自由的珍贵。</p>
<p>此外，问题也是有分类的。不是所有的问题都有哲学意义。</p>
<h1 id="苏格拉底式的对话"><a href="#苏格拉底式的对话" class="headerlink" title="苏格拉底式的对话"></a>苏格拉底式的对话</h1><blockquote>
<p><strong>I know nothing except the fact of my ignorance. —— Socrates</strong><br>我唯一知道的就是我的无知 —— 苏格拉底</p>
</blockquote>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E5%BC%8F%E7%9A%84%E8%B4%A8%E7%96%91">苏格拉底式的质疑 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%98%87%E6%A0%BC%E6%8B%89%E5%BA%95%E5%8F%8D%E8%A9%B0%E6%B3%95">蘇格拉底反詰法 - 维基百科，自由的百科全书</a></li>
</ul>
<p>柏拉图有一个名篇叫做《对话录》，apology 辩护篇，其内容的形式是记录苏格拉底和某人的一问一答。为什么这样子形式的记录这么有意义呢？我们发现，<strong>两个人一问一答，受益的是所有的 audience</strong>。<strong>对话有教育效果，周遭的所有人在听，在听的所有人都受益</strong>。不过我们的社会崇尚沉默是金，鄙视口若悬河的人。“十年寒窗苦读无人问，一朝成名天下知”，这是常态吗？</p>
<p><strong>要能够通过别人的语病，通过自己理性的思考，得到辩论上的制高点，这是很难的</strong>。这是苏格拉底式质疑法（或称苏格拉底反诘法、苏格拉底式的对话）为我们所揭示的道理。我们在中学和大学的教育方式根本是出错了的：老师一个人表演，周遭同学根本没有 engage 的想法，完全没有对话和思考碰撞。我们的教育，不兴问答，所以要求教师本身的“表演欲望”。苑举正老师举了一个例子，他在美国访学，只是简单地讲了两句，然后提问 “Any question？” 大家的讨论非常积极。讨论到下课铃一响走光了。国内是什么情况就不多加描述了……</p>
<p>下面举三个苏格拉底式对话的例子：</p>
<p>例子1：</p>
<blockquote>
<p>某人说：“你不爱读书。”</p>
<p>另一个人这样回应：<br>请你定义：你说的是什么书？还是说是一个范围，包括哪些书？<br>请你定义你所说的感情：什么是爱？</p>
</blockquote>
<p>例子2：</p>
<blockquote>
<p>老爸：你自从上了大学之后，每天一大堆活动，都不回来了啊<br>儿子：哪有，我上礼拜日有回来啊<br>老爸：啊对啊，那只有一天啊<br>儿子：对啊，但是你刚刚说的是“都不回来啊”<br>老爸：对啦，不过现在重点是你现在学会顶我的嘴啦，我送你去读大学，不是让你回家来顶我的嘴的。孩子就是不听话了。<br>儿子：孩子听话不听话的标准是你父母定义的吗？如果是这样的话，那孩子就永远不要成长了啊，小baby阶段最听话了啊，话都不会讲。</p>
</blockquote>
<p>例子3：蘇格拉底與歐諦德謨對談（出自色诺芬《回忆录》）</p>
<blockquote>
<p>蘇：虛偽屬於正義，還是非正義？<br>歐：非正義。<br>蘇：偷盜、欺騙、奴役等，屬於正義，還是非正義？<br>歐：非正義。<br>蘇：對於那些極大損害了國家利益的敵人，一個將軍懲罰了他們，並對他們加以奴役，屬於正義，還是非正義？<br>歐：正義。<br>蘇：將軍偷走了敵兵的財物，或者戰鬥中欺敵呢？<br>歐：這當然屬於正義，但我是說欺騙朋友。<br>蘇：一位元帥，因為士兵們士氣不振而精神崩潰，他欺騙部下「援軍很快到來」以激勵士氣呢？<br>歐：應該也是正義吧。<br>蘇：一個生病又不肯服藥的孩子，父親說「藥不苦、很好吃」，騙孩子吞了下去，病也好了。屬於正義，還是非正義？<br>歐：正義。<br>蘇：一個發了瘋的人，他的朋友怕他自殘，偷走了他的刀子與利刃，這屬於正義，還是非正義？<br>歐：是，應屬正義。<br>蘇：你不是說，朋友之間不能欺騙嗎？<br>歐：請允許我收回我剛說的話。</p>
</blockquote>
<p>怀疑论不是学“怀疑”的。怀疑论不是教辩论技巧的，<strong>而是：当有人觉得自己很正确，说出一句很激动很明显很有证据的话，会突然发现，经过对方用逻辑和理性的诘问，自己原本以为很正确的思想会软化，甚至产生矛盾。</strong></p>
<p>在对话中，苏格拉底显现的，不是哲学原则、理念和系统，而是<strong>一种相信理性的乐观主义，一种通过平易自然语言就能检验错误的立场，还包含一种自我觉醒的反问态度</strong>。</p>
<p>这三点就是苏格拉底在哲学领域的最佳示范——<strong>上天给我们最好的礼物：思考和表达的能力，不能违反逻辑，不能制造矛盾。在我们表达观点的过程中，一定要用思考来支持我们，不断修正里面的矛盾、不一致、不理性之处，自我觉醒。这是一种，对观点的审慎态度。</strong></p>
<p>反例：大家彼此都看不顺眼，你也没有办法拿我怎么样，我也没有办法拿你怎么样，我认为你也没有比我高到哪里去；“话不投机半句多，酒逢知己千杯少”。错了！怀疑论是积极的人生态度。不愿意将自己的观点拿出来检视，不愿意和反对你的人辩论，不愿意面对批评捍卫自己的观点，只愿意和聊得来的人聊，这是一种智力上的懒惰。</p>
<p>怀疑论的积极观：真理呈现的过程，就是来自于这一来一往的过程。一个人如何获得真理呢？——既可以是诚恳地邀请他人来检视自己的观点，也可以是自我对话来模拟辩论、对可能的攻击捍卫自己的观点、发现自己观点逻辑上的不完满后自我启发的过程。学习的过程，你是选择让老师灌输给你，你就会了，还是你自己阅读、思考、自己教会自己呢？</p>
<p>对话：相信理性的乐观立场，语言能够检验错误的立场，自我觉醒的反问态度。思考和表达的能力，是人类最宝贵的财富。思考的过程中，不能够违反逻辑，不能制造矛盾，所有你可以常常通过理性来修缮自己，自我觉醒。说话不要怕那种感到难堪的情况，讲话需要勇气，但是讲话不是抛弃理性和修养，不是忘掉礼貌和表达方式的高雅。言谈之间，你的对手、周围的听众，能够体会到你的受教育程度。</p>
<ul>
<li>提问的目的是什么：对话交流</li>
<li>提问的意义是什么：捍卫对抗</li>
<li>提问的效用是什么：启发</li>
<li>提问的结果是什么：承认无知（“刚刚我以为我知道什么，但实际上我并不清楚”）</li>
</ul>
<p>这个循环就是苏格拉底认为的学习的过程。苏格拉底并不是只想让我们承认无知（他的目的不是驳倒谁），而是希望通过对话展示认知的方式，让我们发觉，原来每一个人都可以怀疑别人认为的铮铮有声的观点。同时，让别人来怀疑自己，也是学习的过程，接近真理的过程，获得更美好人生的过程。</p>
<blockquote>
<p>蘇格拉底反詰法，是一種哲學質詢的形式。通常有兩個人在對話，其中一個帶領整個討論，另一個因為同意或否定另一人而提出一些假定。</p>
<p>蘇格拉底方法包括諷刺（不斷提出問题使对方陷入矛盾之中，并迫使其承认自己的无知）、催生（启发、引导学生，使学生通过自己的思考，得出结论）、归纳和定义（使学生逐步掌握明确的定义和概念）等步骤。</p>
<p>蘇格拉底式提問基於思維具有結構化邏輯的基礎，並且可以讓潛在的思想受到質疑。蘇格拉底反詰法是一種有結構的質疑方式，可用於探索許多方面的思想，包括探索複雜的想法、了解事物的真相、解決問題和問題、揭示假設、分析概念、區分我們所知道的和我們不知道的東西、跟踪思想的邏輯含義或控制討論。</p>
<p>蘇格拉底式提問藝術與批判性思維密切相關，因為提問藝術對卓越思想非常重要。批判性思維和蘇格拉底式提問都尋求意義和真理。批判性思維提供了合理的工具來監督，評估，或許重新構思或重新引導我們的思想和行動。</p>
</blockquote>
<h1 id="诡辩学派（sophists）"><a href="#诡辩学派（sophists）" class="headerlink" title="诡辩学派（sophists）"></a>诡辩学派（sophists）</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BE%AF%E5%A3%AB%E5%AD%B8%E6%B4%BE">辯士學派 - 维基百科，自由的百科全书</a></li>
</ul>
<p>诡辩可以表达为着两种截然不同的定义：在现代，诡辩是一个用于欺骗别人的混淆或不合逻辑的论点，也就是外表上、形式上好像是运用正确的推理手段，实际上违反逻辑规律，做出似是而非的推理。在古希腊，诡辩者们是一群哲学和修辞学的教师，又称辩士学派。</p>
<p>联系之前讲过的“有限的人不能知道无限的事”，思考一下：<strong>我们的认知是不是都是别人讲出来的？</strong>还有一个问题：一个人说话掷地有声令人信服重要（会说话的人，说的就是真理）（文字代表一切）？还是它本身的话要接近客观真理重要，哪怕讲的不是那么有理有据（讲的话里面就要是包含真理）（真理代表一切）？了解了怀疑论，如果无法从对话中直接获得真理，那么我们要求的就必然是：“感觉”。</p>
<p>——辯士們以雅典為中心，周遊希臘各地，對青年進行<strong>修辭、論辯和演說等知識技能</strong>的訓練，教授參政治國、處理公共事務的本領。收取费用（不会羞于谈论金钱），却不在乎“真理为何”的“补习班老师”（法律系）。他们不同于先苏哲学家，因为他怀疑知识的价值（怀疑论的重大突破）诡辩学派<strong>让后人注意到语言和感觉的关系，并因此有重要的哲学贡献</strong>。柏拉图对其有重大批评（不道德，不追求真理等）——哲学的伟大：其他课很少有出现 两个完全冲突的理念，同时都具有巨大的价值。</p>
<p>history（三国志） &lt;-&gt; story（三国演义）<br>（法文是同一个词噢）（易中天：历史，故事也）</p>
<p>与苏格拉底的不同：</p>
<p>知识论的不同：真理 vs 修辞/演讲/辩论<br>形上学的不同：启发 vs 争执/冲突<br>伦理学的不同：免费 vs 收费</p>
<p>（价值观问题）例子：翘课是因为学费便宜，学费贵不敢翘课；老师布置软性作业基本没有人做，考试划重点学生趋之若鹜；</p>
<p>to be is reasonable vs 道德&amp; 教条</p>
<p>人会读书就是因为“禁书”。</p>
<p>怀疑论第一个重点，人在时空条件下，人要承认自己的有限的，limited。人在追求真理的过程中是有条件限制的。怀疑论的精髓就在于此，你应该高兴，你应该高兴你知道自己是有限的。和别人讨论，知道自己的有利条件、不利条件。不过人常常会有很好的梦想。在这个年龄可能会觉得什么事情都可能，只要我努力没什么不可能的，就算失败也可以重来，时间也是站在我这边的。……当你的理想、幻想，很想实现，但无法实现的时候，不会走死胡同。“没有真理我就死给你看”，不对的，要有点弹性。想要得到真理是如此的困难，在不断追求真理的道路上，要面对各式各样的哲学论证，你就会注意到自己遇到诸多限制，但在这样的“吾将上下而求索”的过程中你就会得到很大的好处。</p>
<p>上大学，配上大学是因为主动学习，如果不会主动学习，那就不配叫做大学生。学生自己会去学，而不是只等着老师去填充你的脑子。学一下怀疑论，看一下苏格拉底，用最平实的语言，所有你认为是真实的东西，都可以被颠覆。这一点非常重要。在高中的时候，我们不是这样学习的。在教育上，最大的影响就是高中和大学的gap。在高中，什么都不要怀疑，好好背书做题好好考试，一到了大学叫你统统怀疑。高中让你当哑巴，大学让你滔滔不绝。所以很多人到了大学一下子不晓得怎么学习了，不习惯这样的读书。一生就是为了考试？“我怀疑我自己相信的一切真理！”</p>
<h1 id="诡辩学派：相对主义"><a href="#诡辩学派：相对主义" class="headerlink" title="诡辩学派：相对主义"></a>诡辩学派：相对主义</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%9B%B8%E5%B0%8D%E4%B8%BB%E7%BE%A9">相對主義 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E7%BD%97%E6%B3%B0%E6%88%88%E6%8B%89">普罗泰戈拉 - 维基百科，自由的百科全书</a></li>
</ul>
<p>相对主义 (relativism) 的魔力：</p>
<ul>
<li>各国国情不同，请不要干涉他国内政</li>
<li>没有绝对的对，也没有绝对的错</li>
<li>数学/英语/……以后又用不到，为什么上课要学，考试要考？</li>
</ul>
<p>wiki：相对主义是一種<strong>主張沒有絕對，只有相對的理論類型</strong>。其共同的主题是：经验、思想、价值，甚至是实在之中的<strong>一些主要方面总是相对于其他东西而成立的，但原因却不清楚</strong>。例如，<strong>正当理由、道德准则或真理的标准</strong>有时是相对于语言、文化或生物构成的。尽管相对主义的思想系统往往会导出难以置信的结论，但这些结论中总是有点诱人的东西，因而使很多背景迥异的思想家为之着迷。</p>
<p>只有相对主义是不用读书的，因为没有一个人是没有自己的价值观的。相对主义就是：<strong>我所接受的价值和标准，完全相较于他人而言，在我内心中蕴育而生的这些价值和标准，完全在我内心中自我养成的，是我认知为真的唯一对象，而不是别人在别的情况下可以理解的</strong>。“每一个人都是天生的哲学家”，这句话讲的就是相对主义。相对主义就是因为不用读书的缘故，所以就做成了很大的麻烦，很多人<strong>自以为是</strong>，<strong>我认为对的就是对的</strong>，“我认为这是很好的，但你拒绝我的建议”。</p>
<p>这就是相对主义。柏拉图批判，相对主义在哲学中是一个<strong>最大的恶</strong>，因为它<strong>拒绝沟通</strong>。但是，把日常生活中的经验判断当作理性的对象去对待，不一定是恶。这是为什么？我们可以想一想这个问题：肯定日常生活就不是理性吗？号称拥有放之四海而皆准的知识的专家们的话、规定、决策、办法，就一定都是对的吗？这个问题是一个大问题。就好像大学生和老师，如果两者对于教育的目的和看法都相同，那么老师就继续可以在讲台上照本宣科，同学们继续浑浑噩噩。如果有不同，<strong>你一定要说出来啊！</strong>对不对？老师也可能出错。相对主义：“这些老师可以扮演神的角色吗？凭什么他要让我学这个/凭什么他用这种讲课方式/学了有什么用？”。诡辩学派的所作所为给我们一个思考：教育是授业解惑的堡垒，如果大学都一样的话，你来大学干什么？完全不质疑“专家”，那就不是教育，叫教训、教条。（过度质疑也不好）</p>
<p>除了偏好抽象思维的人之外，大多数人是肯定日常生活，并以此依附的常识作为生活标准。“人是万物的尺度”——普罗泰戈拉就是其中的一员，重视生活感觉的哲学家。他认为，我们依靠着信念、感觉、常识、生活经验活着，没有任何事情比活着更真实。“他说是真的就是真的，他说假的就是假的”。“所有的人，我们看到的世界，都是人衡量出来的”。“世界上没有客观真理，除了人说的才算”。柏拉图将普罗泰戈拉归类于相对主义哲学家和诡辩学派。</p>
<p>怀疑论教你做一个敢跟他人唱反调的人。普罗泰戈拉说，做一个更受欢迎的人更重要，甚至还有人认为在和别人辩论之前要和别人交朋友才有交谈的机会。……人为什么不是衡量万物的标准？如果对此还有疑惑，怀疑论还没学到家啊！“不怕被别人讨厌的人”——苏格拉底，是唯一反抗这个的人。人云亦云非常舒服啊，和大家一起，做一个从众的人，做一个大家都喜欢的人有什么不好？——我们会失去真理。真理是客观的，有绝对的真理，不是人规定出来的。</p>
<p>这个社会是多元且复杂的，人针对世界中什么为真什么为假，有自己的看法。这些看法有差异，但不是人类的缺点，只反映人人都有自己的偏见、价值、看法、见识。相对主义的价值：你没有先承认社会是多元的前提，就没有沟通的机会，就永远不会了解别人，了解别人是一件非常重要的事情。</p>
<h1 id="实用主义"><a href="#实用主义" class="headerlink" title="实用主义"></a>实用主义</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E7%94%A8%E4%B8%BB%E4%B9%89">实用主义 - 维基百科，自由的百科全书</a></li>
</ul>
<blockquote>
<p>实用主义 (Pragmatism) 产生于19世纪70年代的现代哲学派别，在20世纪的美国成为一种主流思潮。对法律、政治、教育、社会、宗教和艺术的研究产生了很大的影响。</p>
</blockquote>
<ul>
<li>强调<strong>知识是控制现实的工具</strong>，现实是可以改变的；</li>
<li>强调<strong>实际经验是最重要的</strong>，原则和推理是次要的；</li>
<li><strong>信仰和观念是否真实在于它们是否能带来实际效果</strong>；</li>
<li>真理是思想的有成就的活动；</li>
<li>理论只是对行为结果的假定总结，是一种工具，是否有价值取决于是否能使行动成功；</li>
<li>人<strong>对现实的解释，完全取决于现实对他的利益有什麽效果</strong>；</li>
<li>強調行動優於教條，經驗優於僵化的原則；</li>
<li>主張概念的意義來自其結果，真理的意義來自於應證。</li>
</ul>
<p>不见容于当代的人，永远都得不到而后的平凡吗？历史上有太多的例子证明，不见容于当代的人，其实是具有远见，甚至对现世感到失望的人。面对历史的时候，完全不是当下能够做判断的，起码也要一两百年。普罗泰戈拉的策略就是实用主义，不高调，也不降低水准。过度高调，则曲高和寡，无从吸引人，尤其是年轻人。水准过低，庸俗难耐，无法吸引精英的眼光。</p>
<p>总而言之，目前的道德有可能以后就是不道德的，道德是会变的，而对真理的追求是不会变的。知识是随时求真的，所以可以用实用的精神对待知识。对于知识的态度，实用主义是大多数大学生的看法。</p>
<h1 id="辩士：高尔吉亚"><a href="#辩士：高尔吉亚" class="headerlink" title="辩士：高尔吉亚"></a>辩士：高尔吉亚</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%88%BE%E5%90%89%E4%BA%9E">高爾吉亞 - 维基百科，自由的百科全书</a></li>
</ul>
<p>除了普罗泰戈拉之外，最有名的辩士学派的人士，高尔吉亚。除此之外，他还是修辞学之父。</p>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>《教育漫话》by 约翰·洛克 摘抄</title>
    <url>/2020/12/03/Some-Thoughts-Concerning-Education-by-John-Locke/</url>
    <content><![CDATA[<h1 id="教育的作用"><a href="#教育的作用" class="headerlink" title="教育的作用"></a>教育的作用</h1><p>1.<strong>健全的心智寓于健康的身体，是对于人生幸福的一个简短而又充分的描述。</strong>凡是身体和心智都健全的人就不必再有什么别的奢望了。身体或心智如果有一方面不健全，那么即便得到了别的种种也是枉然。<strong>人们的幸福或苦难，大部分是自己造成的。</strong>心智不明的人做事情不能遵循正确的途径，身体衰弱的人即使有了正确的途径也无法取得进展。我承认，有些人生来就有聪慧的心灵和健康的身体而不用别人多少帮助，他们凭借天赋的才能，从很小的时候就能向着最好的境界去发展。凭借超人的体质，生来就能创造奇迹。但这样的人原本就很少。<strong>我敢说，在我们平常所见的人当中，之所以有好有坏，有用或无用，十有八九都是由他们所受的教育决定的。人与人之间所以有千差万别，都是出于教育的不同。在我们幼小的时候得到的印象，哪怕极其微小，小到几乎觉察不到，都会对一生产生长久而深远的影响</strong>。就像江河的源头，水性很柔，用一点点人力就能将其引向别处，使河流的方向发生根本的改变。从根源上这么引导一下，河流就有了不同的趋向，最后就流到十分遥远的地方去了。</p>
<h1 id="健康教育"><a href="#健康教育" class="headerlink" title="健康教育"></a>健康教育</h1><p>对于我们人生的工作与幸福，健康何等重要；而一个人为了出类拔萃，功成名就，必须忍受艰辛和疲乏，因此对强健的体魄提出了很高的要求，其中的道理一目了然，无须证明。</p>
<h1 id="道德教育"><a href="#道德教育" class="headerlink" title="道德教育"></a>道德教育</h1><h2 id="一、重视儿童的精神形成以及德行的原则"><a href="#一、重视儿童的精神形成以及德行的原则" class="headerlink" title="一、重视儿童的精神形成以及德行的原则"></a>一、重视儿童的精神形成以及德行的原则</h2><p>32.我在本文一开始就说，人们的言谈举止和做事能力之所以千差万别，教育所起的作用要远胜过其他任何事物。如果这种说法的确像我所相信的那样完全正确，那么我们就有理由得出下面的主张：<strong>我们应对孩子精神方面的形成给以重视，而且应当及早开始，因为那会影响他们的一生一世。无论他们做事是好是坏，人们对此是赞扬还是责备，都和他们所受的教育紧密相连。当他们做错了什么事情时，人们便会说，那跟他们的教养有关。</strong></p>
<p>正如身体强健的标准主要在于能够吃苦耐劳，精神的强健标准也同样如此。<strong>一切德行和价值的重要原则和基础就在于：一个人要能够克制自己的欲望，能够不顾自己的自然倾向而纯粹遵从理性所认为的最好的指导，尽管与欲望背道而驰。</strong></p>
<h2 id="二、教育不当（溺爱）的危害"><a href="#二、教育不当（溺爱）的危害" class="headerlink" title="二、教育不当（溺爱）的危害"></a>二、教育不当（溺爱）的危害</h2><p>34.在我看来，<strong>一般人在教养子女方面有个重大的错误，而且对这一点没有给予及时和充分的注意，那就是没有在孩子的精神最柔弱、最易于支配的时候使其遵从约束、服从理性</strong>。出于自然的本能，做父母的都会很爱自己的子女，但如果这种自然的爱脱离了理性的严密监视，<strong>就很容易转变成溺爱</strong>。<strong>父母爱自己的子女原本是一种义务和责任，但他们却常常因此而放纵子女的过错</strong>。当然，做父母的可以说，对子女的行为最好别横加干涉，应当允许他们在各项事务中运用自己的意志。而且孩子的年纪还小，也做不出什么太过分的坏事，所以做父母的可以任由子女放纵自己的行为，觉得这没什么危险，甚至认为孩子的任性是很符合他们的纯真年龄的。但是，对一个溺爱子女、对子女的恶作剧视而不见，不去纠正，一味地原谅，说那是无关紧要的小事的父母，梭伦的回答很精彩：“不错，可是习惯却是一件大事啊。”</p>
<p>35.被宠坏了的孩子定然能学会打人骂人，他想要的东西，哭着闹着也一定要得到，他想做的事情也一定会去做。<strong>由于父母在孩子幼小的时候就骄纵放任，把孩子的本性给败坏了，这就等于是他们自己污染了源泉，以后喝到了苦水，却又觉得奇怪</strong>。因为，当孩子长大以后，这些恶习也已经形成，而此时孩子已经长大，父母不能再把他们当作玩物了，于是就开始抱怨孩子太随心所欲，太不成器。这时做父母的才对孩子的任性感到愤怒，才为他们亲自给孩子养成的那些劣习所困扰。而此时，要想拔除他们亲手种下的杂草，恐怕已经为时太晚，因为这些杂草现在已是根深蒂固，不容易根除了。<strong>既然孩子在还穿着童装的时候，就习惯了目中无人，支配一切，现在长大了，穿上了短裤，仍然想要随心所欲，这又有什么可奇怪的呢？</strong></p>
<p>36.我们对待动物的办法一般来说都很聪明。想要让其成为有用的动物或者能有某种用途，我们在它们很小的时候就会进行及时的训练。但唯有对自己的后代，我们却忽略了这一点，结果培养出了劣迹斑斑的孩子，却又愚蠢地希望他们成为善良之辈。因为，假如孩子想吃葡萄或是小糖果时，为了不让那可怜的孩子哭闹或者不高兴，大人就一定会满足他的要求。那为什么当他长大成人了，想要喝喝酒、玩弄一下女人，就不能如愿以偿呢？这些符合年龄较大的人的欲求，与小孩子哭泣所求的东西合乎儿童的欲求没有什么不同。<strong>不同年龄的人在不同阶段有着不同的欲望，这没什么不对，错误之处在于没有让这些欲望接受理性的规范和束缚。这里的区别不在于有没有欲望，而在于能不能控制和约束欲望。一个人如果在小时候不习惯让自己的意志去服从别人的理性，那么等到他能够自己运用理性的时候，也不会去听从。这样的孩子长大后会成为哪一种人，是不难预料的。</strong></p>
<h2 id="三、教育儿童用理智克服欲望"><a href="#三、教育儿童用理智克服欲望" class="headerlink" title="三、教育儿童用理智克服欲望"></a>三、教育儿童用理智克服欲望</h2><p>38.在我看来，有一件事是显而易见的，那就是一切德行与美善的原则在于：当欲望得不到理智的认同时，我们要具有克制理智所不允许的欲望的能力。这种能力的获得和改进要靠习惯，而要想熟练地发挥这种能力则要靠及早实践。如果大家相信我的话，我建议大家采取一种与常见的做法相反的办法，那就是<strong>让孩子从婴儿时期就开始克制自己的欲望，不要让这种欲望变成渴望</strong>。<strong>他们应当学会懂得的第一件事情就是，他们之所以得到了某个东西，不是因为这东西能让他们喜欢，而是因为适合他们获得</strong>。如果能给予他们所需要的东西，从来不要因为他们的哭泣和恳求而让他们得到，那么他们就能学会不无理取闹，就不会大声哭叫、纠缠不休地非得到所要的东西不可，也绝不会闹得鸡犬不宁，因为从一开始他们就没有被这样对待过。假如他们从来就没有因吵闹而使自己的欲望得到过满足，他们就不会哭着去要求什么，正如他们不会哭闹着去要天上的月亮一样。</p>
<p>39.<strong>我的意思并不是说，孩子们在任何事情上都不能放纵，也不希望他们的言行举止像议员那样充满理性、循规蹈矩。我知道孩子就是孩子，应当得到温和的对待，应该做游戏，应该拥有玩具。我只是想说，孩子们想要得到的东西或者是想做什么事儿，如果不适合他们，就不该因为他们年龄还小而获得允许。无论他们怎么纠缠不休，也不能答应。而且就因为他们纠缠，所以就更不应该让他们得到</strong>。我见过有的孩子在吃饭时，无论餐桌上放了什么都不去要，只吃属于自己的一份就够了。而在别的地方，我看到有些孩子看见什么就哭闹着要什么，每份菜都要吃，还得先吃。是什么原因造成了两种孩子这么大的区别呢？原因就在于后者习惯了得到所要求的或哭着要求的东西，而前者则没有这种习惯。我认为，孩子的年龄越小，他们的任性就越要给予控制，少去满足。孩子越缺乏理性，管教者就越应当给他绝对的约束。所以我觉得，只有言语谨慎的人才能在孩子周围。如果社会上通行的做法与此相反，我也无可奈何。我所说的是我认为的值得奉行的做法，假如这种做法早已通行，那我也就不用在这里谈论这个话题了。不过我确信，在这个问题上一定会有人赞同我的见解，认为对孩子进行这样的教育越早，孩子和管教者就越会感到轻松愉快。人们应该把这种做法当作一句不可违背的格言来严格遵守，那就是：<strong>无论什么东西，只要拒绝给孩子，就千万不要因为他们哭泣恳求而给予，除非你是有意教他们变得没有耐心和令人厌烦</strong>。</p>
<h2 id="四、亲子关系"><a href="#四、亲子关系" class="headerlink" title="四、亲子关系"></a>四、亲子关系</h2><p>40.<strong>凡是有心管教孩子的人，应该在孩子很小的时候就开始管教</strong>，使他们能绝对服从父母的意志。如果你想让孩子在过了儿童时代之后仍然服从你，那么就一定要在他刚刚懂得服从，知道自己归谁管教时就树立起父亲的权威。<strong>如果你希望他敬畏你，就应该在他婴儿时期打下基础。随着他慢慢长大，再慢慢与他越来越亲近。这样，就可以让他在小时候成为顺从你的臣仆，这在当时是很合适的，而长大后就可以成为你亲密又贴心的朋友了</strong>。</p>
<p><strong>在我看来，许多人在对待孩子方面，方法很不正确。在子女幼小的时候，任其放纵，跟他们不分彼此，等子女长大之后却又对他们正颜厉色，与其保持距离</strong>。<strong>事实上，自由和放纵对孩子的确没有什么好处</strong>，他们还缺乏判断能力，因此需要有人进行约束和管教。<strong>相反，成年人做事可以靠理性来指导自己，用专制和严厉来对待他们就是错误的</strong>。除非你存心让孩子长大之后厌恶你，希望他们在心里叨咕：“爸爸，你什么时候才会死呢？”</p>
<p>41.我想，人们对这种看法都会觉得很合理：<strong>子女在幼小的时候应当敬畏父母</strong>，把他们看做是君主，也就是拥有绝对权力的统治者。<strong>而当子女长大之后，则应当把父母看做是最可靠的唯一可信赖的朋友</strong>，去敬爱他们。如果我没弄错的话，上面我所叙述的方法就是实现这一目标的唯一途径。<strong>当子女长大成人之后，我们一定要把他们当成我们自己一样去看待，因为他们具有和我们一样的情感和欲望。我们希望自己被看做有理性的人，希望拥有自由，不喜欢时时受人指责，看人脸色，也不愿意受别人的奚落和冷淡。任何一个成年人如果被这样对待，都会去另寻伙伴和朋友以及谈话对象，以求得轻松愉快</strong>。如果孩子从一开始就受到严格的管教，那么他们在小时候就会乖巧听话，安静随和，服从管教，因为那时的他们除了顺从，不知道还有别的方法。<strong>随着年龄的增长，能够逐渐运用理性之后，对他们进行的严格管教也应该慢慢放松。父亲要更加和蔼可亲，父子间的距离逐渐缩短，那么此时，父亲以往的管教反而会增进他们对父亲的敬爱，因为他们已经明白，这种管教是出于对他们的关心和爱护，目的在于使他们值得受父母的关爱以及他人的尊重。</strong></p>
<p>42.关于如何在子女心目中树立威信，我已经说得很多了。<strong>首先，你应该凭借他们对你的敬畏来获得支配他们精神的力量，等孩子慢慢长大，再用爱和友谊来维系这种力量。因为总有一天，棍棒和惩罚都会无济于事</strong>。到那时，如果你的爱不能让他们对你恭敬、孝顺，如果对德行和名誉的重视不能让他们走上正途，那么我要问，你还有什么办法能让他们走上光明大道呢？当然，<strong>由于担心得不到你的喜爱，会少分得遗产，他们也许能让自己成为你的财产的奴隶，但在私下里他们的生活仍然会是邪恶的，而且这种约束也很难持久。每个人总有一天要完全依靠自己，依靠自己的行为，一个善良的、有德行和能干的人是需要从内部去塑造的。所以，他应当及时地受到应受的教育，及时地获得影响自身生活的力量。这是一种植入他们天性中的习惯，而不是因为害怕惹父亲生气，丧失继承权所伪装出来的行为和外表。</strong></p>
<h1 id="对于道德教育的具体意见"><a href="#对于道德教育的具体意见" class="headerlink" title="对于道德教育的具体意见"></a>对于道德教育的具体意见</h1><h2 id="一、怎么管教儿童"><a href="#一、怎么管教儿童" class="headerlink" title="一、怎么管教儿童"></a>一、怎么管教儿童</h2><h3 id="棍棒教育的缺陷"><a href="#棍棒教育的缺陷" class="headerlink" title="棍棒教育的缺陷"></a>棍棒教育的缺陷</h3><p>43.关于管教的一般原则我们已经说完了，现在应该更进一步考虑一下更为详细的管教方法了。我之前一再谈到应该对孩子严加管教，也许大家会认为我没有充分地考虑到孩子幼小的年龄和娇弱的身体所应得到的对待。不过你们只要再听我说几句，这样的误解就会消除了。因为我也觉得，<strong>对孩子进行过分严厉的惩罚没有什么好处，不，或者应该说这样做在教育方面的害处还很大，并且我也相信，受到最严厉惩罚的孩子长大后很少能成为优秀的人才</strong>。到目前为止我所主张的只是说，<strong>无论需要怎样严格的管教，在孩子越小的时候越应该多用，一旦运用得当，取得了效果，就应该放松，改用比较温和的管教方式。</strong></p>
<p><strong>第一，凡是不能控制自己的嗜好，不知道听从理智的指导去抵制当下的快乐或痛苦的纠缠的人，就是缺乏德行和勤劳的真正原则，就有陷入一无所能的危险。这种自制的品质与人桀骜不驯的本性是完全不一样的，所以应该及早培养。</strong>同时，这种习惯也是未来的能力和幸福的真正基础，所以应尽早，在孩子刚能懂事的时候就灌输到孩子的心里。任何一个对孩子负有教育责任的人，都应想尽一切方法，让孩子养成这种习惯。</p>
<p>46.<strong>第二，另一方面，如果孩子的精神受到过分的压抑，如果由于管教太严而使其精神遭到过多的打击，他们就会失去活力和勤奋，这种情形比前一种情形更糟糕</strong>。因为任性放纵的青年通常都是生龙活虎，富有活力，一旦走上正轨，往往会成为能干的、杰出的人物。而心情沮丧的人就不是这样了，他们胆小羞怯、郁郁寡欢，很难振作起来，难以成就事业。要避免上述这两方面的问题，可真需要高超的技巧。<strong>在我看来，如果有谁能找到一种方法，既能让孩子的精神保持舒畅、积极、自由，又能使他克制住自己对许多事物的欲望而接近不那么感兴趣的事物，他就能调和这些表面的矛盾，掌握教育的真正秘诀。</strong></p>
<p>47.<strong>一般的老师所知道或想到的管教孩子的唯一方法就是通过惩罚和棍棒</strong>，这是人们在惩罚孩子时通常所采用的简单粗暴的方法，<strong>但其实是最不适合在教育中采用的方法</strong>，因为它存在着两种弊端，正如我们已经表明的那样，这两种弊端会让人们对其进退两难，最终使这种方法失去效用。</p>
<p>48.<strong>第一，我们人类的本性倾向于迷恋肉体的与现实的快乐，而极力避免一切痛苦，但体罚不仅不能控制这种倾向，反而会给予其鼓励</strong>，使其增强作用于我们身上的力量，那是产生一切邪恶和罪过的根源。<strong>一个孩子本来不喜欢念书，现在因为怕挨打而刻苦攻读；本来爱吃不卫生的水果，现在因为怕挨打也不吃了，这种行为不就是因为贪恋肌体的快乐，害怕受鞭挞而避免遭受痛苦吗？</strong>他这样做只不过是为了获得更大的肉体快乐，避免更大的肉体痛苦而已。用这样的动机去管束和指导孩子的行为，结果会怎么样呢？要我说，<strong>除了在他身上培养起我们本该让他们根除并摧毁的本能之外，还有什么呢？</strong>所以我觉得，对于孩子的任何惩罚，如果不能让他为做错了事而感到羞愧，而只是令他感到肉体上的痛苦，那是没有什么用处的。</p>
<p>49.<strong>第二，这种鞭打的惩罚自然会使孩子对教师希望他们爱好的事物产生厌恶的心理。</strong>这是显而易见的。孩子们对于某些事物本来是可以接受的，但当他们因为这些事物而受到鞭打和责骂后，就对这些事物产生了痛恨。对于在孩子身上出现的这种情形，这是很自然的，因为即便是成年人，也不能用这种方法来让他们爱好任何事物。无论是哪种正当的娱乐活动，<strong>假如他没有兴趣，没有心思去玩，却有人用棍棒去打他，用恶毒的言语去骂他，非要强迫他玩，或者是正在玩的时候，因为一点小事就经常被人这样对待，难道不会让他对那种娱乐感到厌恶吗？答案当然是肯定的。</strong></p>
<p>50.<strong>第三，这种奴隶式的管教所养成的也只能是一种奴隶式的性情。在棍棒的威逼之下，孩子是会屈服，会假装服从的，可是一旦不用棍棒，没人看见，知道不会受惩罚时，他就会放任自己的天性。这种天性不会由于体罚而有所收敛，有所改变，相反会在他身上不断增长。而且，经过这种约束之后，一旦爆发出来，往往会更加凶猛。</strong></p>
<p>51.<strong>第四，如果这种管教严厉到极点，虽然也能治好目前任性的毛病，但由于它会让人精神颓丧，随之而来的就将会是一种更糟糕更危险的毛病。那时，就等于将一个放荡不羁的青年换成了一个心神沮丧的家伙，他那违反天性的拘谨状态的确可以让那些傻瓜们高兴，因为他们就喜欢训练死板的孩子，因为这种孩子不吵不闹，不会给他们带来任何麻烦。然而最终，这种孩子可能也不会使朋友们感到舒服，正如他们终其一生也不会对自己和别人有什么用处。</strong></p>
<h3 id="关于奖惩应当持有的正确观点"><a href="#关于奖惩应当持有的正确观点" class="headerlink" title="关于奖惩应当持有的正确观点"></a>关于奖惩应当持有的正确观点</h3><p>52.<strong>所以，要想让孩子变成聪明、正直、机灵的人，用棍棒以及其他种种奴隶性的体罚就不是合适的管教方法，这种方法在万不得已和极端的情形之下才能偶尔用用。另外，用孩子喜欢的事物去奖励他们，博取他们的欢心，也同样要小心避免。</strong>父母如果用苹果、小糖果或其他一些为孩子所喜欢的东西来督促他念书，那就是在认可孩子对快乐的爱恋，就是在纵容孩子身上危险的本性，而这种本性父母是本应该尽全力去消除的。<strong>对于孩子的嗜好，一方面加以管制，另一方面却给予满足，那么，想让他学会克制自己的欲望，是肯定没有希望的。</strong>为了让自己以后能成为一个贤良的、聪明的、有德行的人，孩子们应该学会克制自己的欲望，在遇到理智的反对和责任的要求时，他应该抑制自己对于物质财富、精美服饰以及美味佳肴等事物的欲望。<strong>可是，当你要他去做该做的事时，用钱来做报酬，看到他读书，就用好吃的来犒劳他</strong>，要他做一些很小的事，就承诺给他镶有花边的颈巾和漂亮的新衣服，那么，<strong>你提出这种种报酬，不就等于你认为这些东西是好的，是他应该追求的目标，从而鼓励他去向往，使他习惯于把自己置身于快乐中吗</strong>？人们为了让孩子努力学习文法、舞蹈以及其他各种对于他们的幸福或利益并没有多大帮助的东西，<strong>不恰当地使用奖励与惩罚的方法，结果牺牲了他们的德行，颠倒了他们的教育，等于是把奢侈、骄傲和贪婪教给了他们。因为不良的喜好本来是应该加以约束和压制的，现在却等于受到了鼓励，这样一来，就为未来的邪恶奠定了基础</strong>，而那些邪恶，我们要是不克制自己的欲望，并及早使它们受到理智的约束，是没有办法避免的。</p>
<p>53.我的意思并不是说，我不想让孩子们享受一切无碍健康，无损德行的舒适和快乐。恰恰相反，<strong>我主张孩子们充分享受各种正当的快乐，使他们的生活尽可能地舒适和愉快</strong>。不过有一点要注意，那就是<strong>他们获得的那些快乐，只能是父母和教师对他们的重视和表扬的结果，千万不能因为他们不愿意去做某件事情或是没有某种诱惑就不想专心去做，就对这种或那种特殊表现给予奖赏</strong>。</p>
<p>55.<strong>我承认，如果我们想要教育孩子，就应该对其进行奖励和惩罚。但错误之处在于，人们通常所用的奖惩办法都是选择不当的</strong>。我觉得如果<strong>把肉体的快乐和痛苦当作奖励和惩罚，用于孩子身上，是不会获得好的结果的</strong>。…… <strong>假如你要让孩子打消某种使其快乐的欲望，却又让他获得另一种快乐的欲望作为补偿，这会让他养成怎样的道德习惯呢？</strong>这只会扩大他的欲望，使其误入歧途……</p>
<h3 id="给孩子树立尊重和耻辱的观念"><a href="#给孩子树立尊重和耻辱的观念" class="headerlink" title="给孩子树立尊重和耻辱的观念"></a>给孩子树立尊重和耻辱的观念</h3><p>56.……<strong>孩子们一旦明白了尊重(Esteem)和耻辱(Disgrace)的含义，那么这二者对于他们的心灵就是一种最为有力的刺激。如果你能让孩子们热爱荣誉(Credit)，对羞愧和耻辱有所理解，就等于让他们掌握了一个真正的、会永远发挥作用的原则，这个原则会令他们走上正道。</strong></p>
<p>57.<strong>第一，孩子们（也许比我们想到的还早）对于表扬和称赞是极为敏感的。当受到别人，尤其是父母与自己所依赖的人的尊重和赞誉时，他们会觉得这是一种快乐。所以，假如父亲看见子女的行为优秀就给予赞扬，看见子女的行为不好就表现得恼怒和冷淡，同时母亲以及孩子身边的人也用同样的态度去对待他们，那么，要不了多久，孩子就能感觉到其中的差异。这种办法如果能坚持执行下去，我相信它的作用一定比恐吓或者鞭打要大得多</strong>，况且这两种办法如果用得太多就会失去威慑力，如果不能因此而让孩子感到羞耻，那就没什么作用。所以，除了后面所说的万不得已的情况之外，还是应该禁止使用的。</p>
<p>58.第二……用这种方法对待孩子，就能<strong>让他们明白，凡是因行为良好而受人尊重、获得赞扬的人，一定会得到他人的喜爱，也自然会得到其他种种美好的事物。反之，凡是因行为不端而被人瞧不起、不爱惜自己名誉的人，就不可避免地要遭受别人的冷淡和轻视</strong>。…… 用这种办法可以从一开始就能让孩子获得一种稳定的经验，让他们明白，<strong>自己钟爱的东西，只有名誉良好才能得到和享受。这样，他们的欲望反而有助于他们的德行</strong>。如果你能借助这些方法让孩子们为自己的错误行为感到羞耻（除此之外，我希望不用惩罚），<strong>使他们能热爱自己的名誉并为此感到快乐</strong>，这样，你就可以随意地支配他们，<strong>而他们也会爱上一切美德</strong>。</p>
<p>60.所以说，经常打骂孩子的行为是应当谨慎避免的，…… <strong>棍棒所带来的痛苦只能是一种不完善的治疗。看起来只是对创伤作了暂时的处理，使伤口表面结了一层痂，但并没有触及痛苦的根源。只有发自内心的羞耻心和不愿再惹人讨厌的畏惧心，才能成为真正的约束</strong>。只有这两者结合，才能有所驾驭，使孩子从此走上正道。<strong>如果体罚过于频繁，也必然会失去作用，让孩子的羞耻心逐渐消失</strong>。…… <strong>做父母的首先应该考虑清楚，究竟是孩子的哪些过失才值得他们生气</strong>。可是一旦发怒了，对孩子实施了惩罚后，就不该马上收起怒容，而应想尽办法去恢复孩子原有的美德，一直要等到他真正服从了，比平时表现得更好了，彻底弥补了所犯的错误，才能完全恢复原来的态度。否则，惩罚用得太多就成了家常便饭，就会完全失去作用。孩子犯了错，就受到惩罚，然后又被原谅，结果他们就会把这看成是一种自然而然的事儿了，就好像昼夜交替那样。</p>
<p>62.我们上面提到的这种考虑可以指导做父母的，让他们明白自己应该怎样去责备或表扬自己的孩子。当孩子犯错时，就不能姑息纵容，一定要加以斥责，<strong>不过在斥责时，用语要冷静严肃，不受情绪支配，并且应该背着他人在私下里进行。但是当孩子应该受到赞扬时，就一定要当着别人的面去赞扬</strong>。孩子在受到赞扬之后，再经过大家的一番传播，那么奖励的意义就更大了。而父母对孩子的过错不去宣扬，就会让孩子更加看重自己的名誉，他们觉得名誉没有受到损失，就会更加小心地维护别人对自己的好评。如果你在大庭广众之下揭露他们的过失，令他们感到无地自容，他们就会大失所望，而制裁他们的工具同时也就失去了。他们越是觉得自己的名誉已经受到了损害，就越没有心思再去想办法维护别人的好评。</p>
<ol>
<li>如果能用正确的办法对孩子进行管教，那么我们设想的在一般的实践中已经确立的奖励与惩罚就没有必要多用了。因为，只要能够尊重在场的其他人，<strong>他们所做的一切天真的傻事、游戏以及幼稚的行为就都可以完全任其自由，不加丝毫约束，而且不妨给他们最大程度的宽容。这些儿童时期所具有的而不是由儿童本身所产生的过失，最好随着时间的流逝，等到他们学会模仿，在成熟的年岁里再加以改正</strong>，这样他们便可以免受许多误用的、无益的惩罚。如果惩罚很频繁，却没有什么作用，并不能掌控孩子在这一时期的本性，那么当以后遇到其他必须加以惩罚的情况时，惩罚的作用就会大大减弱。如果惩罚的力度很大，以致压服了孩子在儿童时期的快乐本性，就会损害孩子的身心。</li>
</ol>
<h3 id="不要让孩子去记住规则，而是帮孩子培养习惯"><a href="#不要让孩子去记住规则，而是帮孩子培养习惯" class="headerlink" title="不要让孩子去记住规则，而是帮孩子培养习惯"></a>不要让孩子去记住规则，而是帮孩子培养习惯</h3><p>64.说到这里，我要提一个在<strong>普通教育方法上的错误，那就是让孩子时时刻刻都牢记许多规则和教训</strong>，而对这些他们常常是不能理解其中的含义的，总是听过后就忘记了。<strong>其实，如果你想要孩子做某件事，或者想让他们在做事时换个方法，结果他们还是忘了做或是做得不好时，你就应该让他们反复去做，直到做好为止</strong>。采用这种办法有两层好处。</p>
<p>第一，你可以借此知道某件事情孩子是否有能力去做，是否能对他们抱有期望。因为有时候我们吩咐孩子去做某些事，<strong>在试过之后才知道原来他们并没有做那些事的能力，事先需要加以教导和练习才能让他们去做</strong>。但对教师来说，下命令可比进行教导要容易得多。<strong>第二，这种办法还有一个好处，就是一种动作经过多次练习，可以使其在孩子身上变成习惯，这样就不用再靠记忆与思考，自然而然就能做出来了</strong>。要知道记忆和思考不是童年的伴随物，而是深谋远虑和成熟的伴随物。例如有人向他致礼，他应鞠躬作答，有人跟他说话，他应注视对方的面孔。由于经常应用的缘故，<strong>这对教养良好的人来说简直像呼吸空气一样自然</strong>，用不着思考，也用不着回忆。用这种方法把孩子的任何过失都改正之后，那就算是永远地改正了。<strong>这样一件件地改正下去，就可以把他的过失全部根除，在他身上养成你所喜爱的任何习惯。</strong></p>
<p>65.<strong>我看到有些做父母的把成堆的规则加在孩子身上，而可怜的孩子连那些规则的十分之一都记不住，更不用说去实行了。可如果他们违反了这又多又杂的，通常来说又不是十分恰当的规则，就会受到打骂</strong>。这样做导致的后果就是，孩子知道自己的注意力分散，很难记住大人所说的话，很难不违反大人们定下的各种规则，于是干脆就不去理会各种条条框框了。</p>
<p><strong>所以，你给孩子定的规则应该越少越好</strong>，要比表面上看去好像绝对不能少的还要少。因为，如果你定的规则太多，让他难以承受，结果就不外乎两种：要么是，孩子肯定会经常受到惩罚，而惩罚得太多，效果肯定就不会好。要么是，<strong>孩子违反了某些规则而你却不给予处罚，这样他一定会轻视这些规则</strong>，从而使你在他心目中的威信也随之降低。<strong>所以说，规则应该少定，一旦定下就要让孩子严格遵守。对孩子来说，年龄越小，所需的规则也越少</strong>。<strong>随着他年龄的增长</strong>，当一种规则经过练习，具备了一定的基础之后，<strong>就可以再去增加另外一种规则</strong>。</p>
<h2 id="二、通过练习培养习惯"><a href="#二、通过练习培养习惯" class="headerlink" title="二、通过练习培养习惯"></a>二、通过练习培养习惯</h2><p>66.但是请记住，<strong>对孩子来说，不是单用规则就可以教育得好</strong>，因为规则早晚会被他们忘掉。<strong>如果你觉得有什么是他们必须做的，就应该利用一切机会，甚至在可能的时候创造机会，给他们进行不可缺少的练习，使其在他们身上固定下来。这就可以让他们养成一种习惯</strong>，这种习惯一旦养成之后，用不着再借助记忆，就能自然而然地起作用了。不过我在这里还有两点要提醒：</p>
<p>第一，在让他们通过练习来培养要形成的习惯时，<strong>最好是和颜悦色地进行劝导和提醒，而不是进行严厉的指责</strong>，好像他们有意违抗似的。</p>
<p>第二，还要注意的一件事就是，<strong>不要一下子培养过多的习惯</strong>，否则花样太多，把他们弄得昏头涨脑，反而会一无所成。要等到一种习惯通过经常的练习后，变得容易自然，孩子能够不假思索地做出来之后，才可以再去培养另外一种习惯。</p>
<h2 id="四、礼貌的培养"><a href="#四、礼貌的培养" class="headerlink" title="四、礼貌的培养"></a>四、礼貌的培养</h2><h2 id="七、父母应为子女树立榜样"><a href="#七、父母应为子女树立榜样" class="headerlink" title="七、父母应为子女树立榜样"></a>七、父母应为子女树立榜样</h2><h2 id="八、惩罚儿童"><a href="#八、惩罚儿童" class="headerlink" title="八、惩罚儿童"></a>八、惩罚儿童</h2><h2 id="九、老师的地位"><a href="#九、老师的地位" class="headerlink" title="九、老师的地位"></a>九、老师的地位</h2><h2 id="十、正确的父亲教子方法和父子关系"><a href="#十、正确的父亲教子方法和父子关系" class="headerlink" title="十、正确的父亲教子方法和父子关系"></a>十、正确的父亲教子方法和父子关系</h2><h2 id="十一、儿童的自然倾向、合理与不合理的表现以及应对策略"><a href="#十一、儿童的自然倾向、合理与不合理的表现以及应对策略" class="headerlink" title="十一、儿童的自然倾向、合理与不合理的表现以及应对策略"></a>十一、儿童的自然倾向、合理与不合理的表现以及应对策略</h2><h2 id="十二、怎样看待孩子的好奇心"><a href="#十二、怎样看待孩子的好奇心" class="headerlink" title="十二、怎样看待孩子的好奇心"></a>十二、怎样看待孩子的好奇心</h2><h2 id="十三、怎样迎对孩子的闲荡"><a href="#十三、怎样迎对孩子的闲荡" class="headerlink" title="十三、怎样迎对孩子的闲荡"></a>十三、怎样迎对孩子的闲荡</h2><h2 id="十六、儿童撒谎和对策"><a href="#十六、儿童撒谎和对策" class="headerlink" title="十六、儿童撒谎和对策"></a>十六、儿童撒谎和对策</h2><h2 id="十七、绅士应具备的品质"><a href="#十七、绅士应具备的品质" class="headerlink" title="十七、绅士应具备的品质"></a>十七、绅士应具备的品质</h2><p>德行、智慧、教养和学问</p>
<h1 id="学问教育"><a href="#学问教育" class="headerlink" title="学问教育"></a>学问教育</h1><h2 id="学问的地位在教育中最不重要"><a href="#学问的地位在教育中最不重要" class="headerlink" title="学问的地位在教育中最不重要"></a>学问的地位在教育中最不重要</h2><h2 id="一、如何诱导儿童学习"><a href="#一、如何诱导儿童学习" class="headerlink" title="一、如何诱导儿童学习"></a>一、如何诱导儿童学习</h2><h2 id="二、正确的学习方法"><a href="#二、正确的学习方法" class="headerlink" title="二、正确的学习方法"></a>二、正确的学习方法</h2><h2 id="四、学习外语的意见"><a href="#四、学习外语的意见" class="headerlink" title="四、学习外语的意见"></a>四、学习外语的意见</h2><h2 id="五、教师的教学方法"><a href="#五、教师的教学方法" class="headerlink" title="五、教师的教学方法"></a>五、教师的教学方法</h2><h2 id="六、对学习外语传统方法的批评"><a href="#六、对学习外语传统方法的批评" class="headerlink" title="六、对学习外语传统方法的批评"></a>六、对学习外语传统方法的批评</h2><h2 id="七、一般文化课的设置"><a href="#七、一般文化课的设置" class="headerlink" title="七、一般文化课的设置"></a>七、一般文化课的设置</h2><h2 id="八、口头和书面能力培养"><a href="#八、口头和书面能力培养" class="headerlink" title="八、口头和书面能力培养"></a>八、口头和书面能力培养</h2><h1 id="技能教育"><a href="#技能教育" class="headerlink" title="技能教育"></a>技能教育</h1><h2 id="一、技能教育和技艺的意义"><a href="#一、技能教育和技艺的意义" class="headerlink" title="一、技能教育和技艺的意义"></a>一、技能教育和技艺的意义</h2><h2 id="三、怎么看待娱乐-amp-可以学习的技艺"><a href="#三、怎么看待娱乐-amp-可以学习的技艺" class="headerlink" title="三、怎么看待娱乐 &amp; 可以学习的技艺"></a>三、怎么看待娱乐 &amp; 可以学习的技艺</h2><h2 id="五、学会记账"><a href="#五、学会记账" class="headerlink" title="五、学会记账"></a>五、学会记账</h2><h2 id="六、儿童旅行"><a href="#六、儿童旅行" class="headerlink" title="六、儿童旅行"></a>六、儿童旅行</h2>]]></content>
  </entry>
  <entry>
    <title>旅游签被拒后的感想</title>
    <url>/2023/06/12/Some-Thoughts-May-2023/</url>
    <content><![CDATA[<p>At least I tried.<br>我一直在人生中努力，但是现在越来越有一种清晰的感觉，我似乎到了一个certain level，我逐渐发现，有一些东西确实不是我想要得到就能得到的。</p>
<p>我对此的初体验是，在北京微软实习的时候，我托福考了101分就觉得很满意了，还沾沾自喜觉得自己考的不错。和我同一个组认识另一个美本实习生，Wisconsin Madison 的。他说他考了116还想再考一次，想考118。我当下听到这话就清晰的觉得，原来这就是两个世界的人，这感觉直到过去了四年后的今天还是依旧很 fresh。还有一个同组的实习生是清华本科，哈佛 Design School graduate 的，家里非常非常有钱，住二环四合院；还认识了一个去 Boston 读艺术和历史学位的。据我所知，能读这种人文社科专业而且顶尖私立学校的学费真的不低。那个时候我和他们是天天在一起上下班一起去食堂吃饭的，物理上跟他们很近很熟，但是心理上我知道我们的差距不是一点半点，虽然我们都在 Microsoft 实习。所以我开始觉得这就是阶级差距、开始有了imposter syndrome。这里有意思的地方是我感受到的是imposter syndrome 而不是 peer pressure，因为我打心底里就不把他们当成是我的 peer。我会对我的一个大学同学有 peer pressure，而面对我在微软认识的人我就会觉得“我是怎么混进来的，我的背景和学校这么普通”。“要是微软苏州那些年不扩招我肯定是进不来的”，诸如此类的想法。</p>
<p>我当时和我的一个朋友说了我在北京见识到的阶级差距。他回复我说，你这辈子是没机会体验他们的人生了，但是如果你在微软一直干下去你可以成为他们的父母辈那个阶级地位。我认识一位在微软工作二十多年的老师，他就拿了美国国籍，女儿读的哥大，自己也回北京office当principal manager。我在苏州微软的一个老板无锡人也是在微软工作了二十多年，美国国籍，女儿在CMU。综合这些，我当时觉得，他说的确实有一定道理。过了四年，我也全职工作了两年，觉得这目标依旧很遥远。我爸二十五岁的时候已经生了我，我二十五岁的时候还是单身。</p>
<p>还是19年和我一起进来实习的一个女生，现在已经在美国微软了，还在美国结婚买了房。哪怕19年当时我觉得我各个方面条件都和她很接近，但是其实那也是不太准确的感觉，是一种错觉。我来自不是那么富裕的地方，她是上海人；我因为covid放弃了出国读硕士的机会，她在covid前就在国外念书…… 所以何苦和那些比我厉害很多的人比较呢？和他们 compare 的意义确实没有很大。比方说之前的那几位微软的经理，他们是八十年代的清华北大毕业生，我才工作两年，怎么和工作二十年的人相提并论？</p>
<p>随着年龄渐长我知道我知道的真的少之又少，我知道了我是多么的无知。但是这又怎样呢？这并不意味着我是不幸福的，我很感恩现在的生活。继续在人生的旅途中努力吧！</p>
<p>今天面试美国旅游签证没有成功，但是至少我可以说 at least I tried. 就行了！Getting a visa is a privilege, not a right I am entitled to. 如果我真的不买演唱会门票、机票、不填表提交签证申请，我不会知道这些体验的感受。</p>
<p>愿上帝赐予我力量，让我去做我能做到的事；赐予我平静，接受我做不到的事情；赐予我智慧，能分辨这两者的不同。</p>
]]></content>
  </entry>
  <entry>
    <title>与父母二三事</title>
    <url>/2023/08/06/Some-memory-with-parents/</url>
    <content><![CDATA[<p>当我二十六岁的时候，我觉得我的父母真的是非常好的父母。</p>
<p>先说爸爸。首先，我特别佩服我爸爸。我爸是一个生活居家型经济适用男。比方说他平时没事干的时候喜欢做一些把客厅茶几挪开，然后擦一下茶几下面的地板之类的事情。我爸爸家里可以用一尘不染来形容，这儿我真的是没有一点夸张。他叠的衣服整整齐齐，厨房的用具摆放的一丝不苟。这可能和他当过文艺兵的经历有影响？在这点上我非常佩服他，我一直在向他学习，养成良好的卫生和生活习惯。跟他在一起的时候，我感到无比的舒心。我曾经读到一个圣经的一段话[1]，它是表明人和上帝的关系好像是羊和牧羊人：有牧者看护的羊，可以放心地在草原上吃喝；没有牧者的羊，无论吃草还是睡觉，都要随时提高警惕，防止四周有危险来临。可能这样子有点夸张了，但是我心想，有牧羊人在，所以可以无忧无虑地在草原上打滚的羊，这不就是我见到我爸爸时候的感觉吗？见到他，我就可以都不用操心的安心感。</p>
<p>我是离异家庭的孩子，抚养权归我妈。简而言之，爸爸在我的童年总体来说是一个缺失的角色，但是他会在某些关键节点出现一下，然后每次出现都给我带来深刻的影响。在中考前，他有到泉州过来一趟见到我，说如果我考上泉州的一所好高中，就给我买一台笔记本电脑。这对我来说确实是一个激励。我考上了，虽然他没有给我买笔记本电脑，但是他给我托人到香港买了一台 iPhone 4S，那是 2012 年，我的第一台智能手机。</p>
<p>大一我读的是电子系，由于发现自己不喜欢焊电子元器件而更喜欢打代码，于是动了转到计算机系的念头。某天晚上凌晨，我突然打电话给他。我记不太清了，为什么那么晚突然给他打电话，但我依稀记得，其实我已经下定了念头，打电话给他，或许是需要一个他的肯定和支持。他接了电话，我可以听出来他应该睡下了，他清了清嗓子就开始跟我聊天。我把我想转专业，以及还想再多读一年大一的计划托盘而出，但是我也表达了这多的一年会不会是一种浪费的顾虑。他对我说，儿子，你老爸今年四十多岁了。如果你老爸能够花一年的时间，来找到自己真正喜欢的东西是什么，那么我觉得这一年依旧是非常值得的。而你今年才十八岁，那肯定是没有什么问题的。这通电话对那时的我来说，真是一个 huge inspiration. </p>
<p>我爷爷属于比较传统的家长，有一次他觉得我爸爸做家务做得太多了，嫌弃他儿媳做的不够，觉得我爸亏了云云。我在餐桌上引用了一句话“子非鱼焉知鱼之乐”，爷爷你并不知道我爸爸其实真的是享受其中的。过了一段时间，我爸和我聊起这件事，说，“儿子，你太懂我了。你说出了我说不出来的感受。”</p>
<p>2020 年春节，疫情。我申请到美国读研的 offer 下来了。我跟他坦露了我的心声——我觉得我到美国去读书，很费他的钱。他说，儿子，我能供你去美国读书，是我的骄傲。你这些年读书都是自己一个人，家里也没有帮过你。如果你是一个不学无术的泼皮无赖呢？或者吃喝嫖赌的，那我还不是要花钱给你擦屁股？所以花钱供你出国去，那真的不是一种负担。而且教育是投资呀……</p>
<p>那四下静寂的夜晚，父子两个在家里共处一室，彼此谈心——人的一生能有多少个类似的印象深刻的夜晚？</p>
<p>有的时候遇到一些事情，我会这样想：“如果是我爸爸，他会怎么做？”</p>
<p>我在写下这篇回忆录的时候，我在惊奇，我的父亲，仅有初中学历，世俗意义上的“文化水平不高”的人。他为什么能够说出这么简单平静又如此鼓励人心的话语呢？</p>
<p>我的妈妈，作为一个单亲母亲，把我一路拉扯大，她的辛苦之处，我都看在眼里。我与父母的关系是非常好的，好到见了面会拥抱，要离开的时候会说“我爱你”等等，应该说在中国这是非常不典型的亲子关系。</p>
<p>我有一些朋友会说，“我回家呆了三天我就呆不下去了！” 这是因为他们的父母可能会对他们的生活习惯看不顺眼，说一些“你怎么还不起床/你怎么还睡懒觉/你怎么只知道躺着玩手机/你跟着我去走亲戚”，诸如此类的话。</p>
<p>我这边想说的一件事。我 2020 年上半年在家度过了大学的最后一个学期，下半年在家待业找工作。2020 年一整年我都呆在家里。这一年是我有机会能够陪伴她度过的非常长的一段时间。事后回想，我发现，这和我的那些在家里呆不下去三天的朋友相比，真的是一个奇迹。我妈妈从来没有说过哪怕一句上面那种类似的会制造紧张气氛的话。我妈妈就是给我做饭，帮我洗衣服…… 我 2020 年 6 月毕业之后，她也从来没有过分地询问我找工作的进展和情况。我在紧锣密鼓地制作简历、准备面试，她从来不对我在家待业这件事情有过什么不满意。相反，她觉得我想在家里呆多久就呆多久。我会在某一天跟她说“妈妈，我明天的几点几点有一个面试”，她说“好的，加油噢，那我那段时间不打扰你。明天要不要我叫你起床？” …… 如果有什么东西能让我相信这个世界上存在 unconditional love, 那会是我妈妈。我扪心自问，如果我是作父母的，我或许做不到她这样。</p>
<p>以至于 2022 年的春天我开始自己学着做饭，某两天连续做了两顿饭把自己给累着了。我回家的时候当面给我妈妈说，自从我自己开始做饭以后，我觉得吃你给我做的饭很 guilty —— 我自己试着做了两天就累得不想做了，但是我妈妈给我做了二十多年的饭。妈妈是很高兴地笑了，安慰我说，她很会做，所以不会累。 :)</p>
<p>我有一次超然、超现实的体验。2020 年，我过着上面描述的那种有老妈照顾的平静的幸福生活。不知道是某一天的什么时候，我从睡梦中醒来，但似乎是那种半梦半醒。我看到窗帘透射出来的天是一种蒙蒙的红，我的胸脯贴在床垫上，我感受得到心跳的声音。我似乎不是我，而是变成了一个在我身后，能够看得见我的漂浮的幽灵。突然很惊醒地，一个想法进入了我的脑袋：这种生活，总有结束，总有一天这一切会结束。一想到这个，我就有一种非常不真实的感受，我感觉这一切都是虚幻的。说实话，还真的挺快就要结束的，那个时候我已经找到工作，很快就要到外地上班了。有一天你会离开家人，他们有一天会离开你——这一天是突然意识到了这个事实。这会怎么改变和家人的相处方式？有了这次体验，我一下就懂了。我的做法是，给我妈妈一个拥抱，说我爱她。</p>
<hr>
<p>[1]：出自《诗篇》23 —— 耶和华是我的牧者，我必不致缺乏。他使我躺卧在青草地上，领我在可安歇的水边。他使我的灵魂苏醒，为自己的名引导我走义路。<a href="http://www.zgaxr.com/book/008/019/26.htm">参见</a></p>
]]></content>
  </entry>
  <entry>
    <title>两个月学习一个月备考托福101分攻略</title>
    <url>/2019/07/06/TOEFL/</url>
    <content><![CDATA[<p>在某东方学习了两个月的托福（4月到五月底每周末到某东方去上上课），五月份开始备考，6月15日首考成绩是101（R29+L25+S22+W25）。分数不是特别高，但是对我来说也已经够用了，而且最好的事情就是不用一直一直去考（考一次也是要两千多大洋的啊！）</p>
<p>我个人的情况是大一四级530分，大二六级557分。总体感受下来，最重要就是<strong>托福的确是一个测试你 overall English skills 的考试</strong>，而不是一个单纯靠练习和堆砌考试技巧就可以通过的考试，所以准备托福的同学们要切实关注提高自己的总体的英语水平。</p>
<p>写这一篇总结，是因为我有一个基友虽然不考托福，但是他把学习英语的目标设置成了“能达到托福100水平”……实话实说我觉得是一个好目标，因为按照学习托福的方法去学习是可以提高综合英语水平的，而且听说读写技能的锻炼不会只是像在高中、大学的之前几个阶段的英语学习那样，只是为了应试，而是在实际工作中有用的。很多人就算不出国，也为了提升英语水平来学托福。本篇攻略也不是流水账而是大方向上的方法论，不讲太细微之处，例如具体怎么背单词怎么做题，那种太细节的东西因人而异所以也没有讲的必要；也不讲诸如什么评分标准和做题技巧，那些你自己去看书看 Official Guideline 或者看网课都讲的比我全，也都能找得到。</p>
<h1 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h1><p>一是 vocabulary，托福要比六级还要多两三千个单词，我用百词斩背过一遍之后，又买了某东方的绿宝书完整地过了一遍词汇。听力词汇方面，某东方的老师整理了各个学科的词汇，我看了起码四五遍以上。词汇是很重要的，词汇量上去了，你再去刷听力和阅读的题目，对于做题的技巧，才会有锻炼的效果。托福刷题都是到网站上刷 TPO（TOEFL Practice Online），这是一整套托福考试的模拟题，一共有几十套，都是免费的（中国特色网络模式）。</p>
<p>对于口语，我练习的方法是参加FZU里开设的由外教教授的英语课，在课堂上多开口。还有就是平时自己也多使用英语进行表达（比如说一件今天发生的事情，或者表达一种观点等），考前再自己看点题目积累一些素材。考前研究题型就是看某一本书《托福口语看这本就够了_张涵》。</p>
<p>作文我没怎么准备……（逃）作文最重要的是需要理解考试要求的文章的格式和逻辑结构，这些可以通过看官方的 Offical Guideline 或者各种免费的托福网课来了解。这其实不仅仅是应试，而是去习惯西方的逻辑思维和推理的一套，我觉得这是最重要也很有用的。我考前分给作文的时间不多，自己就写过三篇。考试的时候运气很好罢了。作文和口语主要是overall English skill 的体现，需要长期的积累。</p>
<h1 id="运气也是实力的一部分"><a href="#运气也是实力的一部分" class="headerlink" title="运气也是实力的一部分"></a>运气也是实力的一部分</h1><p><del>根据考场协议不可以泄露题目，希望大家都做有契约精神的人</del></p>
<p>我一次能上百，运气也是十分好的：</p>
<ol>
<li>4篇阅读有一篇自我感觉做的非常差，做的最差的那篇阅读应该是加试的了，加试不算分。</li>
<li>口语的生活话题问的是“？？？？？？？？？？”，恰好的是，我刚经历过？？？？？。</li>
<li>作文题目是，？？？？？？？？？？？。刚好作为？？？？的我非常有话讲，比如？？？？？之类的随便提一提，随随便便就写了500+words。</li>
</ol>
<p>有朋友问我，如果没有这些运气，能考多少？</p>
<ul>
<li>这一篇阅读不是加试，那假设我阅读只能考 26</li>
<li>口语的话，其实三个 fair 还是不难达到的，应该还是 22</li>
<li>作文如果没有素材熟悉度的加成，算一个 23 分吧。</li>
</ul>
<p>那我还是可以考 101 - 3 - 2 = 96 分。所以还是我刚刚说的那样，托福确实还是能反应你的 overall English skills 的。虽然首战上百有运气成分，但不是完全靠运气，你的实力也是要在线才可以的。</p>
<h1 id="工时估计"><a href="#工时估计" class="headerlink" title="工时估计"></a>工时估计</h1><h2 id="vocabulary"><a href="#vocabulary" class="headerlink" title="vocabulary"></a>vocabulary</h2><p>背单词阶段一天要两个小时，时间因各人背单词的方法而异。如果你词汇量没有达到要求，投入词汇量的时间要雷打不动的。</p>
<h2 id="听说读写练习"><a href="#听说读写练习" class="headerlink" title="听说读写练习"></a>听说读写练习</h2><ul>
<li>刷一套听力是需要两个小时的（练习 + 精听，精听很花时间，但是对于提升听力水平很有用），所以一开始的时候不要一次性做一整套TPO做6题，可以半套半套做。我考前听力一共做了10套左右。一大早起来头脑最清醒，做一套听力。我从不在早上之外的时间做听力，因为效果很差。</li>
<li>刷阅读要一个半小时（三篇刚好一小时），剩下半小时查单词 + 看错题。考前5天有专门做某东方整理的词汇题。（就他们什么都给你整理好这一点我还是推荐去某东方的，不算特别贵，虽然我考后觉得托福完全可以自己找攻略学是完全没问题的）我阅读一共做了5套TPO。可以在下午或者晚上找一个半小时做一套阅读。</li>
<li>作文：【读范文，学表达，仿写一篇作文】算是一个完整的流程，需要一个半小时左右。我考前写了三篇。</li>
<li>口语的练习，我考前就做过两套。是用微信录音录下来的，主要是习惯对于电子设备讲话的考试形式。</li>
</ul>
<h2 id="strategy"><a href="#strategy" class="headerlink" title="strategy"></a>strategy</h2><p><strong>我考前听说读写的时间投入是6比0.25比3比0.75</strong></p>
<p>你可以看到在应考的时候，有一定的策略是很重要的，就好像TPO也不是一套从头听说读写刷到尾，而你能看到我每一个部分投入的时间、做的训练量是不同的。听力是最重要的，因为托福考试除了阅读之外的部分都有涉及听力，比如说写作的综合写作，口语的除了前两题之外的题目如果说你听力好基本上都是送分。虽然听力只有25，但是你练习听力会提高你口语和写作的分数。导致你只要花三成的时间去做阅读你就可以阅读29，同时不怎么要花时间口语和写作分数就可以凑合。这就是分清楚整个考试的轻重缓急。虽说，托福100的分型是（R28/L25/S22/W25）也可以算是中国人传统艺能了，是最经典的分布，但是这是很符合国情的。像我这种时间安排，在这么紧张的时间内，怎么练口语更高到25？不现实的事情。所以对于考试的策略也是很重要的一方面，弄明白目标，想清楚任务的优先级，这样才能有比较高的效率，而不是单纯的堆时间，这样可以让你在有限的时间内达到最好的效果。而且如果你到什么留学论坛之类的地方看托福经验帖，大部分人都不是会花大块的时间去弄这个的，这也是比较合理的。</p>
<p>考前3个月和考前1个月和考前两周要做的事情的重点是不同的：</p>
<ul>
<li>考前3个月你好好背单词就是了</li>
<li>考前1个月要有计划的刷听力和阅读提高硬实力</li>
<li>考前两周你就别临时抱佛脚了，熟悉熟悉题型好好休息等着考试吧。说实话考前一周我做的题目总量加起来没有一整套完整的TPO</li>
<li>我在一天之内【背单词、一套或半套听力、一套阅读】三件事最多做到其中两件。都做是真的很累的……以前我曾经幻想说什么“一天一套TPO”后来发现根本不现实，而且没必要~</li>
</ul>
<p>最后总结一下，在我看来，主要是三点：时间+练习+态度。一，规划好时间，最好留出考前一个月的时间，就要开始有意识地整套刷 TPO。二、最重要的是多加练习，阅读的话就一次连续练三篇，注意时间的把控；听力的话就是要不断地精听，练习听力的能力，积累学科词汇。三，就是托福是测试一个人英语总体水平的考试，临时抱佛脚是不可行的，所以态度要端正。最后，平常心非常重要。到最后关头，到了考场上，紧张，心跳加速，是必然的（想想恋恋的无意识能力吧）。你越是紧张，你就越容易失误（比如听力和口语环节）。保持平常心，相信你所付出的努力，相信你的身体能把你调整到最完美的状态，你一定会成功的。</p>
<p>有需要应考资料的都可以直接联系我。</p>
<p><del>如果有资深东方众看到最后一段话应该会会心一笑吧（</del></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之模板</title>
    <url>/2017/06/07/Template-and-Conclusion/</url>
    <content><![CDATA[<h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>继承（公有、私有、保护）和包含，并不总能够满足重用代码的需要。</p>
<p>有一种概念，叫做<strong>容器</strong>（container class）。例如<code>Stack</code>、<code>Queue</code>。容器是用来设计存储各种对象和数据类型的。但之前提到的ADT中，我们把<code>Stack</code>设计成只能存储<code>unsigned long</code> 值。如果我们想建立保存<code>double</code>、或<code>string</code>对象的<code>stack</code>，那么要专门定义新的<code>stack</code>。除了保存对象的类型不同，这两种<code>stack</code>的其他代码应该是相同的。与其再编写一遍重复性很高的代码，不如编写一个<strong>泛型（generic）</strong>（意思是：独立于类型的）栈。对于泛型的栈，我们将具体的类型作为参数传递给这个类，这样就可以通过使用通用的代码，实现一个栈，能存储不同类型的值。</p>
<p><code>typedef</code> 可以实现这种需求，然而，typedef有两个缺点：</p>
<ul>
<li>每次修改类型都要编辑源代码。</li>
<li>在每个程序中只能用这种技术同时生成一种栈。即你不能让typedef同时代表两种不同的类型。</li>
</ul>
<p>C++的类模板为生成通用的类声明提供了可靠的方法。模板提供<strong>参数化类型</strong>（parameterized），即能够将类型传递给接收方来建立类or函数。</p>
<p>泛型编程（Generic Programming）最初提出时的动机很简单直接：发明一种语言机制，能够帮助实现一个通用的标准容器库。所谓通用的标准容器库，就是要能够做到，比如用一个List类存放所有可能类型的对象这样的事；泛型编程让你编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。泛型即是指具有在多种数据类型上皆可操作的含义，与模板有些相似。STL巨大，而且可以扩充，它包含很多计算机基本算法和数据结构，而且将算法与数据结构完全分离，其中算法是泛型的，不与任何特定数据结构或对象类型系在一起。</p>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h2><p>这次的目标，就是写一个Stack模板类。定义模板时，以这样的代码开头：<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>关键字<code>template</code>告诉编译器，将要定义一个模板。尖括号内的内容看做是一个参数列表。<code>type</code>是类型名称。<br><code>Type</code>并不一定是一个类，这里表明<code>Type</code>是一个通用的类型说明符。较新的C++允许用不太容易混淆的关键字<code>typename</code>来代替。</p>
<p>泛型标识符——这里的Type——叫做类型参数（type parameter），意味着他们也和变量一样，但赋给他们的是类型。当模板被调用时，Type将被具体的类型值（int、string、等等）所取代。用模板成员函数替代原有类的类方法，每个函数头都要以相同的模板声明打头。此外，需要将类限定符从<code>Stack::</code> 改成<code>Stack&lt;Type&gt;::</code> 。模板的具体使用被称为实例化（instantiation）或者具体化（specialization）。不能将模板函数放在独立实现的文件中。由于模板不是函数，它们不能单独编译。模板必须与特定的模板实例化请求一起使用。</p>
<h2 id="使用类模板"><a href="#使用类模板" class="headerlink" title="使用类模板"></a>使用类模板</h2><p>仅在程序包含模板时，不能生成模板类。必须请求实例化。需要声明一个类型为模板类的对象。方法是用所需的类型名替代泛型名。例如：<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stack</span>&lt;int&gt; kernels;</span><br><span class="line"><span class="built_in">Stack</span>&lt;<span class="built_in">string</span>&gt; colonels;</span><br></pre></td></tr></table></figure><br><code>Stack&lt;int&gt;</code>会用int替代模板中的所有Type，string也会如此做。</p>
<p>下面是Stack模板类的完整代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stack.h -- class defination for the Stack ADT</span></span><br><span class="line">#ifndef STACK_H_</span><br><span class="line">#define STACK_H_</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef unsigned long Item; 学泛型了，typedef guna</span></span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; MAX = <span class="number">100</span> &#125;;</span><br><span class="line">	T items[MAX];</span><br><span class="line">	<span class="built_in">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stack();</span><br><span class="line">	<span class="built_in">bool</span> isempty() <span class="keyword">const</span>;</span><br><span class="line">	<span class="built_in">bool</span> isfull() <span class="keyword">const</span>;</span><br><span class="line">	<span class="built_in">bool</span> push(<span class="keyword">const</span> T &amp; item);</span><br><span class="line">	<span class="built_in">bool</span> pop(T &amp; item);</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack.cpp -- Stack member functions</span></span><br><span class="line"><span class="comment">//#include &quot;stack.h&quot;</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">Stack</span>()</span><br><span class="line">&#123;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">isempty</span>()<span class="symbol">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">isfull</span>()<span class="symbol">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">push</span>(<span class="symbol">const</span> <span class="symbol">T</span> &amp; <span class="symbol">item</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &lt; MAX)</span><br><span class="line">	&#123;</span><br><span class="line">		items[top++] = item;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">pop</span>(<span class="symbol">T</span> &amp; <span class="symbol">item</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		item = items[--top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="深入讨论模板类"><a href="#深入讨论模板类" class="headerlink" title="深入讨论模板类"></a>深入讨论模板类</h1><p>可以将内置类型或类作为模板<code>Stack&lt;T&gt;</code>的类型。指针可以吗？比方说，不用<code>string</code>对象，用C风格字符串处理方式——<code>char *</code> 作为参数。答案是：可以这么创建，但如果不对程序做重大修改，将无法很好的工作。接下来介绍原因，然后介绍一个指针栈的例子。</p>
<p>设计模板时应牢记的教训——<strong>切记盲目地使用模板</strong>。（你的代码，真的有对泛型的需求吗？）</p>
<p>这里用完全正确的Stack<T>做示例：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Stack</span>&lt;<span class="keyword">char</span> *&gt;<span class="keyword">st</span>; <span class="comment">//create a stack for pointers-to-char</span></span><br></pre></td></tr></table></figure></T></p>
<h2 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> * <span class="built_in">str</span>;</span><br><span class="line">cin&gt;&gt;<span class="built_in">str</span>;</span><br></pre></td></tr></table></figure>
<p>用<code>char *</code> 而不是<code>string</code>对象来接受键盘输入。这种方法很快就失败了，因为仅仅创建了指针，没有为保存输入字符串而开辟空间。</p>
<h2 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> <span class="built_in">str</span>[<span class="number">40</span>];</span><br><span class="line">cin&gt;&gt;<span class="built_in">str</span>;</span><br></pre></td></tr></table></figure>
<p>这里开辟了空间，<code>str</code>的类型是<code>char *</code>，也可以放在栈中。但在栈内的操作，会与我们假设的相冲突。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">pop</span>(<span class="symbol">T</span> &amp; <span class="symbol">item</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		item = items[--top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>item</code> 要必须引用某种类型的左值，而不是数组名。</p>
<h2 id="版本三"><a href="#版本三" class="headerlink" title="版本三"></a>版本三</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> *<span class="built_in">str</span> = <span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">40</span>];</span><br></pre></td></tr></table></figure>
<p>好似解决了上述问题，但又有新的问题：只有一个<code>str</code> 变量，而这个变量只会指向相同的内存单元。每当读取新的字符串时，内存的内容都发生改变，但执行压入操作的时候，加入到栈的地址都相同。因此，<code>pop</code>时弹出的都是相同的地址，结果总是最后一个输入的字符串。总之，这样的栈没有任何用途。</p>
<h2 id="正确的指针栈"><a href="#正确的指针栈" class="headerlink" title="正确的指针栈"></a>正确的指针栈</h2><p>提供一个指针数组，每个指针指向不同的字符串，把（指向不同内存空间的）指针放到栈中是有意义的。创建不同的指针，不是栈的职责，这点要搞清楚，栈是管理指针，而不是创建指针。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; SIZE = <span class="number">10</span> &#125;;</span><br><span class="line">	<span class="built_in">int</span> size;</span><br><span class="line">	T *items;</span><br><span class="line">	<span class="built_in">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//新的构造函数，用栈大小size做参数，而且必须显示调用，有默认参数。</span></span><br><span class="line">	<span class="keyword">explicit</span> Stack(<span class="built_in">int</span> ss = SIZE) &#123; top = <span class="number">0</span>; size = ss; items = new T[size]; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//动态数组所需要的显示复制构造函数、析构函数、赋值运算符。</span></span><br><span class="line">	Stack(<span class="keyword">const</span> Stack &amp;st);</span><br><span class="line">	~Stack() &#123; delete[]items; &#125;</span><br><span class="line">	Stack &amp; operator=(<span class="keyword">const</span> Stack &amp;st);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bool</span> isempty() <span class="keyword">const</span>;</span><br><span class="line">	<span class="built_in">bool</span> isfull() <span class="keyword">const</span>;</span><br><span class="line">	<span class="built_in">bool</span> push(<span class="keyword">const</span> T &amp; item);</span><br><span class="line">	<span class="built_in">bool</span> pop(T &amp; item);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">Stack</span>(<span class="symbol">const</span> <span class="symbol">Stack</span> &amp;<span class="symbol">st</span>)</span><br><span class="line">&#123;</span><br><span class="line">	size = st.size;</span><br><span class="line">	top = st.top;</span><br><span class="line">	items = new T[size];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">		items[i] = st.items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt; &amp; <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">operator</span>=(<span class="symbol">const</span> <span class="symbol">Stack</span> &amp;<span class="symbol">st</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;st)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//avoid assign to itself</span></span><br><span class="line">	delete[] items;</span><br><span class="line">	size = st.size;</span><br><span class="line">	top = st.top;</span><br><span class="line">	items = new T[size];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">		items[i] = st.items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的没有改变。</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">isempty</span>()<span class="symbol">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">isfull</span>()<span class="symbol">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">push</span>(<span class="symbol">const</span> <span class="symbol">T</span> &amp; <span class="symbol">item</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &lt; MAX)</span><br><span class="line">	&#123;</span><br><span class="line">		items[top++] = item;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">Stack</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">pop</span>(<span class="symbol">T</span> &amp; <span class="symbol">item</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		item = items[--top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="简单的数组模板"><a href="#简单的数组模板" class="headerlink" title="简单的数组模板"></a>简单的数组模板</h1><p>模板常用作容器类，因为类型参数的概念非常适合将相同的存储方案用于不同的类型。为容器提供可重用代码是引入模板的重要动机。下面是一个允许指定数组大小的简单数组模板。C++11新增模板array就是这么做的。</p>
<p>这里特别关注一下模板头：<br><code>template&lt;class T, int n&gt;</code></p>
<p>关键字<code>class</code>指明<code>T</code>是类型参数，<code>int</code>指出<code>n</code>为一个<code>int</code>型的参数。这种在模板头中出现的参数（特定类型而不是泛型名）称为非类型（non-type）或者表达式参数（expression）。</p>
<p>表达式参数有一些限制：</p>
<ul>
<li>表达式参数可以是整型、枚举、指针、引用。因此<code>double n</code>是不合法的，但<code>double *n</code> 合法</li>
<li>模板代码不能修改表达式参数的参数值，不能使用表达式参数的地址。也就是说在ArrayTP中不能出现如<code>n++</code>或者<code>&amp;n</code>的表达式。</li>
<li>实例化模板时，用作表达式参数的值必须为常量表达式。</li>
</ul>
<p>与<code>Stack</code>中的构造函数相比：</p>
<p><code>stack</code>使用的动态分配管理的<strong>堆内存</strong>，<strong>表达式</strong>参数使用的是栈内存，执行速度快一点。表达式参数的主要缺点是，每种数组大小都将生成一个类。也就是说，下面的类会生成两个类声明；<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ArrayTB&lt;<span class="built_in">double</span>, <span class="number">12</span>&gt; a1;</span><br><span class="line">ArrayTB&lt;<span class="built_in">double</span>, <span class="number">13</span>&gt; a2;</span><br></pre></td></tr></table></figure><br>而下面的两条声明只会有一个类声明<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Stack&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="function">Stack&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(<span class="number">13</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>下面是简单的数组模板代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T, <span class="symbol">int</span></span> <span class="symbol">n</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">ArrayTP</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T ar[n];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ArrayTP() &#123;&#125;;</span><br><span class="line">	<span class="keyword">explicit</span> ArrayTP(<span class="keyword">const</span> T &amp;v);</span><br><span class="line">	virtual T &amp; operator[](<span class="built_in">int</span> i);</span><br><span class="line">	virtual T operator[](<span class="built_in">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T, <span class="symbol">int</span></span> <span class="symbol">n</span>&gt;</span><br><span class="line"><span class="symbol">ArrayTP</span>&lt;<span class="symbol">T, <span class="symbol">n</span></span>&gt;::<span class="symbol">ArrayTP</span>(<span class="symbol">const</span> <span class="symbol">T</span> &amp;<span class="symbol">v</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		ar[i] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T, <span class="symbol">int</span></span> <span class="symbol">n</span>&gt;</span><br><span class="line"><span class="symbol">T</span> &amp; <span class="symbol">ArrayTP</span>&lt;<span class="symbol">T, <span class="symbol">n</span></span>&gt;::<span class="symbol">operator</span>[](<span class="symbol">int</span> <span class="symbol">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Error in array limits: &quot;</span> &lt;&lt; i </span><br><span class="line">			&lt;&lt; <span class="string">&quot; is out of range\n&quot;</span>;</span><br><span class="line">		std::exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ar[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T, <span class="symbol">int</span></span> <span class="symbol">n</span>&gt;</span><br><span class="line"><span class="symbol">T</span> <span class="symbol">ArrayTP</span>&lt;<span class="symbol">T, <span class="symbol">n</span></span>&gt;::<span class="symbol">operator</span>[](<span class="symbol">int</span> <span class="symbol">i</span>)<span class="symbol">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Error in array limits: &quot;</span> &lt;&lt; i </span><br><span class="line">			&lt;&lt; <span class="string">&quot; is out of range\n&quot;</span>;</span><br><span class="line">		std::exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ar[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多功能的模板"><a href="#多功能的模板" class="headerlink" title="多功能的模板"></a>多功能的模板</h1><p>模板能作为基类、组件类、作为其他模板的类型参数</p>
<h2 id="模板类用作基类"><a href="#模板类用作基类" class="headerlink" title="模板类用作基类"></a>模板类用作基类</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T entry;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">GrowArray</span> : <span class="symbol">public</span> <span class="symbol">Array</span>&lt;<span class="symbol">T</span>&gt;&#123;...&#125;;<span class="comment">//作为基类</span></span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">Tp</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">	Array&lt;Tp&gt; ar; <span class="comment">//作为组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归使用模板"><a href="#递归使用模板" class="headerlink" title="递归使用模板"></a>递归使用模板</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ArrayTP</span>&lt; ArrayTP&lt;int, <span class="number">5</span>&gt; , <span class="number">10</span>&gt; a;</span><br></pre></td></tr></table></figure>
<p>a是一个包含10个元素的数组，每个元素是一个包含5个int元素的数组</p>
<p>等价于 <code>int a[10][5];</code>。模板语法中，维的顺序与等价的二位数组相反。</p>
<h2 id="使用多个类型参数。希望模板可以保持两种（或多种）类型"><a href="#使用多个类型参数。希望模板可以保持两种（或多种）类型" class="headerlink" title="使用多个类型参数。希望模板可以保持两种（或多种）类型"></a>使用多个类型参数。希望模板可以保持两种（或多种）类型</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T1, <span class="symbol">class</span></span> <span class="symbol">T2</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">Pair</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 a;</span><br><span class="line">	T2 b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 &amp; first();</span><br><span class="line">	T2 &amp; second();</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Pair</code>类可以保存两个不同的值。STL有类似的模板，名叫<code>pair</code></p>
<h2 id="默认类型模板参数"><a href="#默认类型模板参数" class="headerlink" title="默认类型模板参数"></a>默认类型模板参数</h2><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">T1</span>, class <span class="type">T2</span> = <span class="type">int</span>&gt;</span><br><span class="line">class <span class="type">XXX</span><span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure>
<p>这样，如果在传参数时省略<code>T2</code>，将默认使用<code>int</code><br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">XXX&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;m1; //<span class="keyword">double</span> <span class="keyword">double</span></span><br><span class="line">XXX&lt;<span class="keyword">double</span>&gt;m2;        //<span class="keyword">double</span> <span class="built_in">int</span> </span><br></pre></td></tr></table></figure></p>
<p>STL经常使用该特性。</p>
<p>不可以为函数模板提供参数默认值。可以为非类型参数提供默认值。</p>
<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><p>模板可用作结构、类、模板类的成员。STL的实现必须使用这项特性</p>
<h2 id="将模板作为参数"><a href="#将模板作为参数" class="headerlink" title="将模板作为参数"></a>将模板作为参数</h2><p>模板可包含类型参数（class T）、非类型参数（int n），模板还可以包含本身就是模板的参数。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template&lt;template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt; <span class="symbol">class</span> <span class="symbol">Thing</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">Crab</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Thing&lt;<span class="built_in">int</span>&gt; s1;</span><br><span class="line">	Thing&lt;<span class="built_in">double</span>&gt; s2;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>template</code>里面有一个类型参数。这里的类型参数为<code>template &lt;class T&gt; class Thing</code> 。参数中<code>template &lt;class T&gt; class</code>是类型，表示传进来的是一个模板类。<code>Thing</code>是模板类名字。</p>
<p>例如如下的声明：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Crab&lt;King&gt; legs<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>这种声明要生效，模板参数<code>King</code>必须是一个模板类。<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class T&gt;</span><br><span class="line">class <span class="type">King</span><span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>Crab</code>中的两个私有对象，由<code>King&lt;double&gt;</code>和<code>King&lt;int&gt;</code>替代。</p>
<h1 id="C-代码重用总结"><a href="#C-代码重用总结" class="headerlink" title="C++代码重用总结"></a>C++代码重用总结</h1><p>C++提供几种代码重用的手段。</p>
<p>代码重用机制是为了让程序员能够重用经过测试的代码，而不用手工复制它们。这样可以简化编程工作，提供程序的可靠性。</p>
<p>公有继承建立<code>is-a</code>关系，派生类可以重用基类的代码。</p>
<p>私有继承和保护继承建立的是<code>has-a</code>关系，基类的公有接口都将成为派生类的内部接口。这被称为继承，但不继承接口，因此派生类对象不能显示使用基类接口。因此不能像公有继承那样将派生类对象看成是一种基类对象。在不进行显示类型转换的情况下，基类指针或引用将不能指向派生类对象。</p>
<p>包含是一种比较常用的实现<code>has-a</code>关系的手段，与私有继承和保护继承相比，更加容易使用。</p>
<p>私有继承和保护继承有一些不同的功能。例如继承允许派生类访问基类的保护成员。还允许派生类重新定义从基类那儿继承的虚函数。包含是不能使用这些功能的。</p>
<p>多重继承。私有MI和保护MI建立<code>has-a</code>关系，公有MI建立<code>is-a</code>关系。MI会带来一些问题：多次定义同一个名称、继承多个基类对象。可以用类限定符来解决名称二义性的问题，可以用虚基类来避免继承多个基类对象的问题。但使用虚基类后，要编写新的构造函数初始化列表以解决二义性问题。</p>
<p>类模板是一种典型的泛型编程例子。模板要以一句template打头，告诉编译器要定义一个模板。涉及到的知识点：类型参数、表达式参数、实例化、默认参数、模板做参数、成员……等等</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>叔本华《人生的智慧》摘抄 The Wisdom of Life, Schopenhauer</title>
    <url>/2022/04/01/The-Wisdom-of-Life-Schopenhauer/</url>
    <content><![CDATA[<h1 id="《人生的智慧》叔本华"><a href="#《人生的智慧》叔本华" class="headerlink" title="《人生的智慧》叔本华"></a>《人生的智慧》叔本华</h1><h2 id="论不要太在意别人的看法"><a href="#论不要太在意别人的看法" class="headerlink" title="论不要太在意别人的看法"></a>论不要太在意别人的看法</h2><p>我们所展现的表象，也就是我们的存在在他人心目中的样子，出于我们人性的一个特殊弱点的原因，通常都被我们过分看重，虽然稍作简单的思考我们就可以知道，<strong>他人的看法就其本身来说，对我们的幸福并不至关重要。</strong>……对于人自身的幸福而言，尤其是对于与幸福密切相关的平和心境和独立自主而言，这种荣誉感更多地产生出扰乱和不良的作用，而不是有益的效果。因此，从增进幸福的观点出发，我们应该抑制这一人性弱点；应该细致考虑和恰如其分地评估它的真正价值，<strong>尽量减低我们对待别人意见的敏感程度，无论我们在受到别人意见的爱抚抑或伤害时都应如此，否则，人们就只能成为他人的看法和意见的奴隶。</strong></p>
<p>别人的看法对于我们的确并不直接存在，而只是间接地存在，只要别人对我们的行为并没有受到这些看法的影响和支配。只有当别人的看法对某事某物产生了影响，从而使我们自身也因此受到影响的时候，它们才值得我们考虑。……并且，当我们终于清楚地了解到：在大多数人的头脑里面都是些肤浅的思想和渺小的念头；这些人目光狭窄，情操低下；他们的见解谬误百出、是非颠倒； 到了这时候，我们就会逐渐对他人的评论淡然处之了。……我们也就会知道，要是太过于看重别人的看法，那就是抬举他们了。</p>
<h2 id="论独处"><a href="#论独处" class="headerlink" title="论独处"></a>论独处</h2><p>能够自得其乐，感觉到万物皆备于我，并可以说出这样的话：<strong>我的拥有就在我身</strong>——这是有助于我们幸福的最有用的素质。</p>
<p>只有当一个人独处的时候，他才可以完全成为自己。谁要是不热爱独处，那他也就是不热爱自由，因为只有当一个人独处的时候，他才是自由的。……<strong>进一步而言，一个人在大自然的级别中所处的位置越高，那他就越孤独</strong>，这是根本的，同时也是必然的。……社会约束我们对愚蠢、呆笨和反常表现出没完没了的耐性，但具有优越个性的人却必须请求别人对自己的原谅；所以，在这种社交场合要取悦他人，就绝对有必要把自己变得平庸和狭窄。因此，我们为达到与他人相像、投契的目的就只能拒绝大部分的自我。当然，为此代价，我们获得了他人的好感。但一个人越有价值，那他就越会发现自己这样做实在是得不偿失，这根本就是一桩赔本的买卖。</p>
<p>青年人首要学习的一课，就是承受孤独，因为孤独是幸福、安乐的源泉。据此可知，只有那些依靠自己，能从一切事物当中体会到自身的人才是处境最妙的人。所以，西塞罗说过，“一个完全依靠自己，一切称得上属于他的东西都存在于他的自身的人是不可能不幸福的。”除此之外，一个人的自身拥有越多，那么，别人能够给予他的也就越少。正是这一自身充足的感觉使具有内在丰富价值的人不愿为了与他人的交往而作出必需的、显而易见的牺牲；他们更不可能会主动寻求这些交往而否定自我。相比之下，由于欠缺自身内在，平庸的人喜好与人交往，喜欢迁就别人。这是因为他们忍受别人要比忍受他们自己来得更加容易。此外，在这世上，真正具备价值的东西并不会受到人们的注意，受人注意的东西却往往缺乏价值。每一个有价值的、出类拔萃的人都宁愿引退归隐这就是上述事实的证明和结果。据此，对于一个具备自身价值的人来说，如果他懂得尽量减少自己的需求以保存、或者扩大自己的自由，尽量少因为在这世上人是无法避免与其同类打交道的与他的同类接触，那么，这个人也就具备了真正的人生智慧。</p>
<p>谁要是在早年就能适应独处，并且喜欢独处，那他就不啻获得了一个金矿。……在这世上，除了极稀少的例外，我们其实只有两种选择：要么是孤独，要么就是庸俗。</p>
<p>对这一命运他们有时会嘘唏不已，但是他们总是两害相权取其轻地选择了孤独。</p>
<p>我给予这种人的建议就是养成这样的习惯：把部分的孤独带进社会人群中去，学会在人群中保持一定程度上的孤独。这样，他就要学会不要把自己随时随地的想法马上告诉别人；另外，对别人所说的话千万不要太过当真。他不能对别人有太多的期待，无论在道德上抑或在思想上。对于别人的看法，他应锻炼出一副淡漠、无动于衷的态度，因为这是培养值得称道的宽容的一个最切实可行的手段。虽然生活在众人之中，但他不可以完全成为众人的一分子；他与众人应该保持一种尽量客观的联系。这样会使他避免与社会人群有太过紧密的联系，这也就保护自己免遭别人的中伤和污辱。</p>
<h2 id="论用决定论的眼光来看待他人"><a href="#论用决定论的眼光来看待他人" class="headerlink" title="论用决定论的眼光来看待他人"></a>论用决定论的眼光来看待他人</h2><p>在这世界上生存，具备一定的预见能力和宽恕能力合乎我们争取幸福的目的：前者帮助我们避免受到伤害和损失，后者则为我们免除了人事纷争和吵闹。谁要是生活在人群当中，那他就绝对不应该摒弃任何人，只要这个人是大自然安排和产生的作品，哪怕这个人是一个最卑劣、最可笑的人。我们应该把这样一个人视为既成的事实和无法改变：这个人遵循一条永恒的、形而上的规律，只能表现出他的这个样子。如果我们碰到一些糟糕透顶的人，那就要记住这一句话：“林子里总少不了一些怪鸟”。</p>
<p>要在人群当中生存，我们就必须容许别人以既定的自身个性存在，不管这种个性是什么。我们关心的只是如何使一个人以本性的内容和特质所允许的方式发挥他的本性的作用，既不应该希望改变、也不可以干脆谴责别人的本性。这就是“生活，也让别人生活”这条格言的含意。这种做法虽然合乎理性，但具体实施却并不容易。</p>
<p>要学会容忍别人，我们不妨……让自己习惯于这样的看法：别人拂逆我们的心意，妨碍我们的行动，但他们这样做完全是出于一种严格的、发自他们本性的必然性，它与物体活动所根据的必然性一般无异。所以，针对别人的行为动怒就跟向一块我们前进路上的石头大发脾气同等的愚蠢。对于许多人，我们最聪明的想法就是：“我不准备改变他们，我要利用他们。”</p>
<p>每一个人都不可能看到自身之外的东西我的意思是：每一个人在他人身上所看到的与这个人的自身相等，因为每个人只能根据自己的思想智力去明白和理解他人。如果这个人的智力素质属于低级的一类，那么，别人的思想、智慧，甚至最伟大的天赋智力，都无法对他产生效果，他对别人拥有的思想水平也一无所觉。……高级的精神能力对他而言就犹如色、影对于一个瞎子一样，都是不存在的。一个缺乏精神思想的人无法看见他人拥有的精神思想。由此可以推断：我们在跟别人说话时，也就把自己降至别人的水平，因为我们相对拥有的优势都消失了，甚至自己作出的必要的屈就也不为人知。既然大多数人的素质都是那样低级，因而是那样的庸俗，那我们就可以知道：我们跟他们谈话时，自己不在同时变得平凡庸俗简直就是不可能的事情。这时，我们就能完全明白“屈尊、降格”这些词的真正含意。其实，我们也巴不得避开所有这些人。</p>
<h2 id="论不安全、高敏感度的人"><a href="#论不安全、高敏感度的人" class="headerlink" title="论不安全、高敏感度的人"></a>论不安全、高敏感度的人</h2><p>大部分人都是主观的，归根到底，除了对他们自己，他们不会对别的事情感到兴趣。由此产生了这样的结果：别人所说的话马上就让他们联想到自己，别人无意中说的一句话，只要稍微涉及他们个人自身，就能吸引他们的全部注意和占据他们的全副精神；他们也就再没有剩余精力去理解谈话的客观内容。同样，推理、辩论一旦与他们的利益和虚荣心相抵触，那就再不会产生任何效果。因此，这些人的注意力容易分散；他们轻易就会觉得受到别人的侮辱和伤害。与这些人客观讨论事情的时候，我们必须尽可能地小心谨慎，千万要避免在谈话里面牵涉任何可能与我们面前那位尊贵和敏感的人有关的事情，或者提及或许对他有所不利的内容，因为他们把这些话，也只有把这些话放在心里。虽然他们对于别人谈话中的真知灼见、妙语警句和优美细腻之处一无所觉和一无所知，但对于一切会伤及他们脆弱虚荣心的话语虽然那只是相当间接地、甚至两者几乎拉不上关联和一切能够显示出他们所珍视的自我的不良一面的谈论，他们却极度敏感。他们敏感和容易受伤的样子，活生生就像我们一不小心轻踩了脚爪的小狗；这样，我们也就不得不忍受它的一番吠叫了。又或者，他们好比一个全身满是伤口和肿块的病人，我们只能小心翼翼、避免触碰他们。某些人甚至发展到了这样的地步：如果有人在谈话中表现出理解力和思想，或者没有完全藏起这些东西，那他们就会觉得受到了侮辱。不过，他们会在当时掩饰起自己的感情。事后，那个缺少生活经验的人就只能徒劳无功地苦思冥想自己招致这些人怨恨的原因。不过，基于同样的原因，要奉承和赢取这些人的欢心也是一件很容易的事情。因此，在大多数的情况下，这些人的判断力都糟糕透顶，那不过是偏袒他们的政党或者阶层的某种言论、表白而已，根本谈不上客观和公正。这些都归之于这一事实：意欲在这些人的身上远远地压倒了认识力，他们微弱的智力完全服务于意欲，甚至片刻也摆脱不了意欲的控制。</p>
<h2 id="论面对他人的愚蠢"><a href="#论面对他人的愚蠢" class="headerlink" title="论面对他人的愚蠢"></a>论面对他人的愚蠢</h2><p>通常，那些具有高贵本性和出众思想禀赋的人，会令人吃惊地暴露出缺乏对人情世故的了解，尤其在他们年轻的时候。</p>
<p>在莎翁和歌德的作品里面，每一个人物哪怕那是个魔鬼一旦站在那里说话，那么，说出的话都是恰如其分，合乎情理的。……所以，谁要是以为会在这世上看见头上长角的魔鬼或者身挂铃铛的傻瓜，那他就会永远成为他们的猎物和玩物。无论如何，对一个我们刚刚认识不久的人，都应注意不要评估太高。否则，十之八九我们都会失望、羞愧，甚至招来祸殃。</p>
<p>原谅和忘记就意味着扔掉我们获得的昂贵经验。如果某一个与我们有交往和关联的人暴露出某种令人不快或者令人恼火的行为，那么，我们就要问一问自己：这个人真的这样有价值，以致我们愿意忍受他的行为吗？因为这同样的行为必将一而再、再而三地变本加厉地发生。如果答案是肯定的，那么，我们就不用对此行为多说什么，因为说话是没有什么用处的。这样，我们就对他稍加劝告，或者干脆不加劝告，让事情过去就算了。但是，我们必须意识到，这样一来我们随时有可能再次遭受他给予的同样麻烦。但如果问题的答案是否定的，那么，我们就只能马上并且永远地和这位宝贝朋友断绝交往。……他的本性性格是绝对无法改正的，因为人的所有行事都出自一条内在的原则；根据这一条内在的原则，在相类似的处境之下，一个人只能永远做出同样的事情，而不可能是别的。</p>
<p>对于在现实生活中或者在书本文学中碰到的人的卑鄙和愚蠢，我们可不要生气、动怒。我们应该把人的这些特性纯粹作为我们认识的材料，把它们视为人的某种特性的又一标本，并把它记录下来。我们就好像一个矿物学家偶然发现了某种矿物的典型标本。当然，例外也是有的，甚至是差异很大的特殊例子。人与人之间的差别是非常巨大的。但是总的说来，就像我很早就说过的，这个世界沉浸在罪恶之中：野蛮人互相吞吃对方，文明人则互相欺骗对方，这就是所谓的世道方式。</p>
<p>正如一个人背负着自己的身体，而对此重负一无所觉，但在移动他人的身体时，他却感觉到了重量，同理，他不会注意到自己身上的缺点和恶习，而只会留意他人的这些东西。因此，每个人都应该以他人为镜，从这面镜子可以清楚地看到自己的缺点、恶行及其他的不好之处。但在大多数情况下，人们却像一只对着镜子咆哮的狗它以为镜子里面的是另外一只狗，殊不知它看到的正是它自己。</p>
<p>眼睛的本质就是往外看的，它并不能看到眼睛自身，所以，注意和批评别人的缺点是使我们意识到自己不足的一个相当有效的方法。我们需要一面镜子去改善自己。</p>
<h2 id="论虚假的友谊和礼貌"><a href="#论虚假的友谊和礼貌" class="headerlink" title="论虚假的友谊和礼貌"></a>论虚假的友谊和礼貌</h2><p>正如流通的是纸钞，而不是真金白银，同样，在这个世界上，流行的不是发自内心的尊重和真正的友谊，而只是做得尽量逼真和自然地显示尊重和友谊的表面工夫。</p>
<p>如果一个人以为通过显示自己的聪明和思想就能博得社交人群的欢迎，那么他就的确是个不谙世故的毛头小子！事实恰恰相反：对绝大多数人来说，一个人表现出聪明和思想只能激起人们对他的憎恨和反感……显示自己的聪明智慧其实就是间接地指责别人愚蠢和无能。并且，一个本性庸俗的人，在面对自己的对立面时，内心会产生抵触情绪，而秘密煽起这股情绪的就是他的嫉妒。</p>
<p>所以，在社会上，地位和财富可以期望获得人们的尊崇和爱戴，但精神的优势却永远不可以期望得到这种待遇。……就算采用最谦卑的举止行为也难以成功地使众人原谅自己在思想智力上的优势。……相比之下，表现出低劣的精神思想确实是值得推荐的行为。</p>
<p>中国人把礼貌奉为首要的美德的原因之一……礼貌就是我们订下的一条闭嘴保持沉默的协议：我们都将互相忽略和避免责备对方在道德上和智力上的缺陷。这样一来，我们的缺陷就不会轻易暴露出来，这对大家彼此都有好处。保持礼貌是一种明智的做法，因此，不礼貌的言行就是愚蠢的了。随意地和不必要地以不礼貌的方式对待别人而因此与人结下怨仇就犹如自己放火烧掉自己的房子一般的疯狂。礼貌的言行就像假币，在使用假币时也吝啬、小气就是不智的表现，而慷慨施予则是聪明的做法。</p>
<h2 id="论不应该驳斥他人看法"><a href="#论不应该驳斥他人看法" class="headerlink" title="论不应该驳斥他人看法"></a>论不应该驳斥他人看法</h2><p>我们不应该驳斥别人的意见，而应该记住，如果试图使一个人放弃他的看法中的种种荒谬之处，那么，我们就算有玛土撒拉的寿命，也不会完成任务。</p>
<p>另外，在与别人谈话时，我们不要试图矫正别人，尽管我们所说的话出于善意；因为冒犯和得罪别人是很容易的，但要对此作出弥补，如果不是不可能的话，也是相当困难的。</p>
<p>如果我们碰巧听到别人说出的荒谬言论开始让我们生气，我们就要想象这只是一部喜剧中的两个愚人之间的对话。这一事实久经证明：谁来到这个世上，一本正经地在最重要的问题上教育人们，那么，如果他能全身而退就已经是万幸的了。</p>
<h2 id="论沉默"><a href="#论沉默" class="headerlink" title="论沉默"></a>论沉默</h2><p><strong>我们更应该通过沉默而不是说话来显示我们的明白。</strong>选择前者是聪明的，而采用后者则是虚荣心使然。我们通常为求得到瞬间的快意而选择后者，不惜舍弃前者所带给我们的永久的好处。……如果我们是精明的话，我们就会在思想和说话之间保留相当的距离。</p>
<p>“如果对我的秘密保持沉默，那么，这个秘密就是我看管的囚徒；如果失口说出了这个秘密，那我就变成了它的囚徒。”</p>
<p>“沉默之树结出安宁之果。”</p>
<p>我们要尽可能地避免对他人怀有敌意，但我们却必须注意每一个人的行为表现，并把它牢记在心，因为以此可以确定这个人的价值至少是他对于我的价值，并据此制定出对这个人所应采取的态度和行为。必须永远记住：人的性格是不会改变的。无论何时，把一个人的性格中的劣性忘掉就跟扔掉了我们千辛万苦挣得的金钱一样。只有这样我们才不会与人过分亲密和与人结下愚蠢的友谊。“不爱也不恨”包含了全部世俗智慧的一半，“不要说话也不要相信”则包含了另一半的人生智慧。</p>
<p>在言词或者表情流露出愤怒和憎恨是徒劳无益的，既不智和危险，又可笑和流于俗套。所以，除了通过行动，我们永远不要以任何其他方式表现出憎恨或者愤怒。</p>
]]></content>
  </entry>
  <entry>
    <title>本科阶段学习总结和科研踩过的坑</title>
    <url>/2019/06/06/The-end-of-SRTP/</url>
    <content><![CDATA[<p>今天下午，终于结束了 SRTP（Student Research Training Program，本科生科研训练计划）的结题答辩，写一篇文章记录一下整个过程，也算是我本科生阶段关于学习、科研的一个回顾。部分摘抄自和 zsx 的对话，非常感谢他，开导了我很多。</p>
<p>在开始之前，推一个东西就是我的书单，我都收藏在豆瓣里了，<a href="https://www.douban.com/people/154633051/">点击这里</a>。我有个习惯就是在豆瓣上记录这些。书单就大致能反映我的学习路径。我是大学才接触计算机的，大一我还在电子系，起手开团姿势是 C 语言。但我在开学前的寒假，神奇般地觉得，大学了，寒假应该学点东西，不应该像中学那样假期只是用来放松。可以说这次神奇的自学很影响我。所以我买了一本刘汝佳的紫书来入门 C（很神奇的姿势）。由于寒假期间的自学，所以一入学我就比周围的同学稍微厉害那么点，下学期开学的时候我教了我的舍友们怎么写 helloworld。上了一个月课，我直接要来所有ppt，寻思学校教的东西是不是有点捞？我为什么不自学？然后我就买了一本《C Primer Plus》。这是我第一本看完的大部头，这个时候我特别喜欢啃书，照着敲代码。就是得益于寒假的提前自学，我发现了计算机专业中特别重要的能力——自学能力。</p>
<p>然后这个时候我加入计算机实验班也开始写博客，大一的寒假我看了《C++ Primer Plus》的大部分内容。所以 C++ 这门课在大学的授课内容对我来说也是 completed 了。看出什么门道没有？下学期要学什么课，我在上个学期或者寒暑假假期中我就会提前找到对应的国外的好的教材和教科书自学，避免了国内大学落后的教育和质量堪忧的教科书和 PPT 的荼毒，接收到了高质量的计算机科学教育。然后我是在大一下，开始推 <a href="https://book.douban.com/subject/5333562/">CSAPP</a>（《Computer Systems: A Programmer’s Perspective》，中文译名：《深入理解计算机系统》）副本，我看这本书，是因为知乎、豆瓣以及很多博客大神推荐的加成，在<a href="https://www.cnblogs.com/ZCplayground/p/6551581.html">我的读书笔记和书评</a>里都有写原因。大一下，别人在上C++ 课，我在看 CSAPP。以及很多什么政治课、校选课的时间都被我利用起来了。我花了三个月，从头到尾啃了一遍，暑假打了代码验证里面的知识点，还写了博客总结。可以说这段时光回想起来是真的很快乐的学习过程，而且 CSAPP 是非常好的书，让我建立了对计算机科学全局的视野，而且在以后的学习过程中我也不会再对大部头有畏难情绪。大一下的暑假，我在看<a href="https://book.douban.com/subject/1885170/">算法导论</a>，回想当初，技术水平还太差，看课后题如看天书。啃算法导论是真的很有意思，暑假的时候我每天窝在卧室看书，配套看 Bilibili 上 MIT 的授课视频。学校教的那点算法，不行的，太少了，而且训练强度完全不够。所以说，我大多数的课程，走的路，学的方法和内容，都是 hard 模式。</p>
<p>这个时候实验班班主任，觉得我不错主动找我的，吸纳我进了他的实验室，我非常感谢他。这个实验室是搞网络的（剧透 其实这段经历目前来看有点 bad ending）。进了一个搞网络的实验室，而<strong>此时的我连网络协议是什么也不知道</strong>，于是，我抱着一本<a href="https://book.douban.com/subject/4707725/">《TCP/IP详解 卷1：协议》</a>就又开始了。这一次，我花了三个月看完了整个TCPIP详解卷1，而且是 completely，我completely 到什么程度，我 completely 到 ip header 的一个 checksum 是怎么算的，里面数学证明我都自己去推导了一遍，博客在<a href="https://www.zcplayground.cc/2018/02/10/Internet-Checksum-and-Abel-Group/">这里</a>。我这里想说什么呢，就是想说，<strong>我当时看书非常非常细</strong>。但我在这里不是自夸，这个说来是优点也是缺点，而且对于科研来说，更多来说是一个缺点，坏处的占比更大。因为我当时算是，<strong>陷入了细节</strong>，而<strong>陷入细节其实在进入新的领域时其实是一件不好的事情，这一点直到我进入实验室以后非常久才明白</strong>。因为急需广泛的总揽全局，我这样是只见树叶不见森林，花了很多时间（关于这方面的论述，我推荐你们看看周志华老师西瓜书的前言）。进实验室这期间我个人感觉在实验室存在感不高，因为我还在学基础知识，没办法做什么事情。</p>
<p>在大二暑假，我刚看完 TCPIP，前沿的 paper 还没看几篇，实验室打一个全国性的网络竞赛组队要组五个人，带上了我。项目和论文的 idea 是大三的组长提的，还有两个大三的、一个大四的，再加上大二的我，这就是五个人的 team。三个大三的实现了这个系统，大四写 paperwork，我负责……理解这个系统做了一个 ppt。。。那个时候我不会 python 语法的情况下，组长给我一做解释这个系统，我一边做答辩演示的 ppt 动画。从现在开始，我这个人的学习习惯开始成为科研路上的缺点和绊脚石，就是过于关注细节了。比如这个 python 语法吧，起码当时的我，不找本书来从头看到尾真的是不舒服的（这个方法不是很好，请朋友们谨慎模仿）。</p>
<p>时间来到大二下，导师给我弄了个 SRTP，一年期嘛，让我去报名。就是本科生科研计划，导师给我指定了课题，让我去研究那个。大二下课很多，而我又计划未来要出国，所以学习成绩和课业我不敢怠慢（相比，组内有人是不怎么顾课业甚至可以翘课来做科研，成绩刚好通过即可，我和他完全比不了）。当时其他实验室成员、学长们都有事要干，所以我就加了三个新人组队……三个同级（都是大二下）选手。就是他们直接和我组队，然后直接相当于进了实验室。然后到了去开题答辩的日子，我X？竟然评了国家级项目？我成了国家级大学生创新训练计划项目的负责人？说句实话，<strong>我是真的内心没感受到一丝喜悦</strong>，因为到那个时候为止，我是完全没有项目成功经历的。</p>
<p>然后大二下就这么过去了，暑假了，看起来 SRTP 这个事情是个事儿，在大二下和大三上课太多没时间做，那只能暑假留下来干吧。我留下来了。暑假开始了，我在实验室看了一周的源代码和 api 手册，（不吐槽这个学习方法了，实话实说我不知道有没有问题，不过学习记录都放在博客里了）大概弄懂了我要做的是什么东西。那东西很低层，设计到很多 os、kernel、网络的东西，就是纯 C 语言。刚开始的一周多后，我开了个会，给我的三个队友讲了讲，我看手册、看代码学到了什么，因为感觉他们在这一两周好像没有跟着我前进……I feel like I am alone. 在这个国家级项目中，我感觉我是真真的败犬。我开会是把他们三人叫来，讲了很多手册上的东西、程序、代码、api、怎么做实验等等……他们会上都在点头，但我相信如果听进去能有百分之十就谢天谢地了。虽然我的工作方式有问题，但是当时 too young 的我也只能那么做。会后我稍微规划了一下合理的进展目标——我说 谁谁 你帮我做一下这个东西 有搞头。另外两谁谁 做那个啥啥啥吧，啊你说不行啊？那你就先熟悉这个框架吧，就按照我今天说的来，散会……散会了，对，其实我是 team leader 了（虽然说从立项一开始我就是负责人，但这次开会才体现出实际的领导作用）。散会之后，我继续研究这个东西。<strong>但其他人其实好像没有实质性进展</strong>（我非常主观的感受，有可能有错误）。我问那个我布置任务的人，做了吗？他说：我安装这个环境的这一步报了这个错了，我 google 到现在没成果。我凭借我可悲的领导力，说要不你 mail list 问一下吧，他说好，三天过去，他说，我照着某个人的回复做了，但还是不行。那个时候我真的不想自己接手我布置给他的任务从头做，因为我这边看代码看的也真的头大。我是希望他这个任务搞定之后我直接抛代码给他 可以开始跑实验，然后我把这事问了下导师，导师给了一个比较暧昧的回复，因为导师也不会直接帮你的，说 ok 那就先不做这个吧。我当时布置这个是觉得这个做出来的确对项目进展很有利，然后我就确实不知道该怎么办了。</p>
<p>这时候我大二下。</p>
<p>我觉得我是leader，但自己的技术不够好，团队也不是良性团队，因为一旦我再布置任务肯定会像上次一样，而且，叫其他人去熟悉系统，肯定也是摸了。我就继续看代码和手册，跑了几个实验。我不知道是约束力不足还是我的领导力不足，还是客观条件确实有问题，还是什么别的。关于这个，我现在有答案了，放到之后再讲。</p>
<p><strong>突然有一天，我有了一个 idea</strong>（这个也是我在上一篇文章“Why I dislike research”中吐槽过的一个点），和导师汇报，导师觉得可以做。当然这个时候，我感觉：“团队 = 我”，我没有队友。时间大概是暑假8月初，有一天我要做实验的时候，我突然发现我这台机子上的硬件配置不对。询问之，是我组内某位同学说，我做个实验，没有网卡，就挪过来用用。我当时心态有点炸裂。但是当时我，没有生气，我就只是觉得我很难受，<strong>我甚至没有意识到我可以跟他说，你赶紧给我装回来</strong>。我就过了两天。直接回家了……是真的，而且也没有和导师讲过。大概就是自闭，哀莫大于心死。（其实就是当时还不成熟）<strong>回想起这段经历的时候，其实觉得自己当时还是太不成熟了</strong>，完全可以直接要求同学赶紧复原硬件，因为不经过同意拿走了别人的东西，甚至还没发现你拿走，直到我要用，完全可以进行沟通。但当时的自己的确没有很好的办法来解决这个问题，由于自身性格还不够成熟的原因。</p>
<p>回家了之后，导师说，你把你的 idea 先写一个 patent 吧。我说，我还没实现，就可以写专利？why？导师说 都是这样的，还发了几个例子给我，我就开始研究。写 patent 得先上网站搜有没有类似的已有 patent，搜了下我的 idea 好在没有什么雷同的。但是。看了一阵和我研究课题有关的 patent 之后，我觉得小部分 patent 还有点意思，大部分……（一言难尽），因为我看过手册看过源代码，而且还算看得比较细，<strong>我甚至发现有的 patent 的内容就其实是机翻手册。。</strong>（我满脸黑人问号，这明明是人家公司写出来的手册公开到网上的，怎么被你拿来当专利）。可以说，<strong>经过这次的经验之后，我对于专利、论文，就再也没有迷信了</strong>（此处的迷信是指，我不再会因为一个人仅仅有专利有论文我就会下意识地觉得这个人水平非常优秀，而是要实际地去考察了）。<strong>我觉得我追求的是，我能做出来东西就好，而不想水这些文字材料</strong>。我找了实验室学长倾诉我这个困惑，他说，对啊 patent就是水的。。。。。学长说完，我也就没什么困惑了。</p>
<p>我就开始照猫画虎地写，写了一稿给导师，导师说：创新不足。我真的满脑子浆糊……因为： 我，还，没有！实现！！<strong>所以我现在其实，就是在瞎写，跟我一贯的性格和学习习惯真的已经有很大的违背了。</strong>二稿写出来，丢过去，导师丢回给我一个用机器学习搞网络策略的论文，问我能不能往这个方向靠，这样更有可能专利会投中。我看了这个论文 ojbk，还不错的 paper，<strong>但是我tm这个时候还不会 machine learning 啊！！！！</strong>我说 导师 给我点时间学一下？（你也知道我的学“一下”要多久），导师说，可以，于是。。。</p>
<p><strong>我的 patent 到现在再也没动过笔。</strong></p>
<p>大三上也是课非常多的，但是毕竟国家级项目有一年嘛，我就说，课太多了，我不太想再来实验室了，顾不过来。我也就先隐形了，先好好上课，冲学分。这个时候，我上了一门<strong>软件工程课，这个课程需要同学们组队，完成一个有实际意义和真实用户的软件</strong>。我作为 leader 找齐一个团队，这个项目还算是成功，合作非常愉快，队友虽然技术力不高，但是在课程上的压迫感，大家的合作意愿摆出来了。然后我感觉我是在带领他们，我发现这个软工课程的 team 和国家级项目的 team 有很大的不同，最大的不同，就是我们始终在一起战斗。说说刚才的话题，为什么这个team领导不起来？是团队缺少一个目标的情况下又缺少压力。不过，我不想只这么简单地下一个结论。从逻辑学角度来说：<strong>从一个错误的前提出发，什么谬误都可以推导出来</strong>。比如刚才提到的：自我驱动、约束力？领导力不足？<strong>也许都不是问题的重点，而是在一开始就有错误，在一开始这个 team 就不够好，不像软工团队那么好</strong>。国创的团队，像是随机拼凑的，而我在挑软工团队时，我发了个招聘启事来仔细寻找队友。我深夜debug时是三个人一起的，跑通一个测试，是三个人一起欢欣雀跃。我为什么自闭还有一个原因就是，这一年我这个项目的进行过程中，我的导师刚好到美国去访学一年，我真的觉得我缺乏指导，然后team里又我一个人孤军奋战，和软工团队一比，实在是让人难受，差不多就是除却巫山不是云的心态。这种感觉很重要，不是我自闭前行，然后还发现自己的硬件被队友搬走。突然有一天，我想起来这事，我问队员说，你网卡用完了么，装回来我要跑一下。他说好。过两天，他说装好了，我却一点儿再去做那个实验动力都没有了。本来暑假的事情拖了这么久，你想想我自闭到了什么程度。从大二下暑假到大三下开学的很久一段时间我都没怎么和导师交流了，也没有参加过实验室的组会。<strong>我真的大部分时间都在自责，我觉得我自己做的不好，我觉得我辜负了我导师的期望。我觉得我的学习方法不适合科研，我始终想改，但好像没办法有根本性的改变。我依然乐忠于啃书。</strong>贴上 zsx 安慰我的话，在这里我想表达对他最真诚的感谢：</p>
<blockquote>
<p>如果Team里面有成员对Team有一些想法，就很容易造成很大的麻烦……<strong>虽然有点伤人，我觉得你的导师本身对本科生期望就不高，他的目的是让你有一个更高的平台和更广阔的视野，而不是让你做出什么成绩。</strong></p>
</blockquote>
<p>悲伤的故事基本上讲完了。在项目的后期，我甚至没跟队员说我的idea、和我在写 patent 的事。事实也证明，我的队友之后的时候也开始写 paper，他们做的研究、在做什么事情、在看什么 paper，其实都没有和组内的其他人有过任何交流。和队员之间我是已经完全自闭，我真的和他们打照面我都不知道怎么和他们聊天，甚至我个人私下觉得我和他们的关系已经无法调和。队员甲，那个搬我硬件的队员，我当时觉得和他性格不合，有时候说话甚至有火药味。队员乙，考试时被我看到作弊，我是一个很讨厌学术不端的人，我和他摊牌了，我说你作弊就别和我在一个组里呆。他给我道歉了，说以后不会了，求我不要追究，我同意了，但到结题之前我都心存芥蒂。</p>
<p>不过，我对这些事情的看法的改变，源自于最近我看的<a href="https://zh.wikipedia.org/wiki/%E8%AA%8D%E7%9F%A5%E5%81%8F%E8%AA%A4%E5%88%97%E8%A1%A8">认识偏差(cognitive bias)</a>这个有意思的心理学话题，其中有几个条目是这样的：</p>
<blockquote>
<p>极端预期    Exaggerated expectation    实际上的情况通常不如我们所预期的极端。</p>
<p>鸵鸟效应    Ostrich effect    忽视明显的（负面）情况。</p>
</blockquote>
<p>在结合《人月神话》中说的，软件开发从业者往往会对项目进展情况有过分乐观的估计，导致乐观主义的弥漫，然后项目遇到困难后延期或一蹶不振。通过上述的观点，我得到了一种启发，就是：一件事情的好与坏的程度，其实也类似于正态分布，非常好的事情和极端坏的事情，其实占比都是非常少的。但我们人类由于 cognitive bias 会像人月神话中说到的软件开发危机那样过分乐观，也可能会过分悲观或过分极端，认为问题就无法解决，矛盾就无法调和了。大部分的事情的好坏程度，其实既没有那么好也没有那么差。想到这里，我也开始说服自己，摆脱了之前项目进展过程中不顺利的影响，也不再觉得和队友是一句话都不能说的。到了项目的末期，我们几个队友还是老老实实地把最后的材料完成，并且通过了结题答辩，并没有落到最后连答辩都去不了或是团队解散的程度。</p>
<p>刚刚结题答辩结束的时候，仿佛卸下带在身上的一个沉重的枷锁，虽然我不认为这是一个很好的过程，但自觉也对得起实验室和导师（申请的课题带来了经费），感谢队友。如果问我大学一定不要干什么，我说一定不要报SRTP。结题答辩的时候，几位老师绝对不会关心你做了啥，估计也不是我们院的，而会只问你有没有专利有没有竞赛获奖有没有论文。没有导师问项目相关的东西，比如在我们前面上台答辩的各组，当老师问有没有成果的时候，这些同学说没有写专利没有写论文没有参加比赛，老师们会发出叹息之声，频频摇头。而当我递上去我们组的专利和论文复印稿的时候（虽然我心里觉得是一堆nonsense），他们欣喜若狂地问这问那，发表了没有？过审了没有？在什么阶段？……我心里觉得，他们其实也清楚，学校批给 SRTP 的钱就是拿去买 paper publication 的。</p>
<p>……</p>
<p>好像写到这里就没什么想写下去的了，不如就到此结束吧。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>两场反乌托邦梦境</title>
    <url>/2019/10/14/Two-Dreams-of-Dystopia/</url>
    <content><![CDATA[<h1 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h1><p>19年9月5日，刚补完 psycho pass（心理测量者）这部番之后做的</p>
<p>我来机场坐飞机。我生活在一个未来社会中，这个社会应该已经发达到有那种机器人装了人工智能芯片来当服务员，机场辞退了很多人类，服务员不是特别多。而且好像整体人类的道德水平也败坏了，大家都很不近人情。我来到机场，过安检之后，我竟然要在候机室上面的传送带上自己找自己的行李！！！？？？然后那个地方的机场工作人员就一个大叔，而且特别的谔谔，想来一定是那种人工智能机器人。我费了九牛二虎之力地找也找不到，然后（要和我一起坐飞机回老家的）我基友跟我说，来机场的时候是很费力的，现在根本没有回家里去的途径，如果找不到行李坐不了飞机，天寒地冻，必定冻死在外面不可。我只能继续埋头找，不知道找了多久，终于找到了自己的行李。然后我基友突然说要给女朋友买纪念品，然后我等了半天他也没买好。但是不知怎么的他就突然在机场发现了自己女朋友真实情况是一个参加过上一次世界大战的机器人的炮友（可能军人地位很高），他自己被绿了，一气之下他就不坐飞机了，直接离开了机场。机场候机室里空空荡荡的没有什么人，我走到一个卖衣服的店旁边，里面没有服务员也没有人买衣服，但是衣服都被一件件扯烂了。然后我就在服装店旁边坐下等飞机。然后突然在我面前出现了一种装置，就是大概和我们现实生活中厕所的洗手池一样的东西但是更加赛博朋克一点。突然我的旁边就是一家卖洗发水的店。我站了起来看了看货架上的洗发水，我拿起了货架上最靠前面的一瓶端详。然后这个时候突然不知道哪儿冒出来的一个女服务员对我说：“先生，要不要试一试洗发水？”，而且我立马在脑子里就接受了她会用那个洗手池帮我洗头的设定。妈的醒来之后我在打字的时候细思极恐，我旁边不是服装店吗，我自己坐下来都没有走动，怎么就变成卖洗发水的店了，又他妈从哪里冒出来的傻逼服务员？</p>
<p>好了，我虽然心里有一点惴惴不安，我不是要来坐飞机的吗，为什么还要答应试一试洗发水？但还是欣然同意，洗个头也花不了多少时间的吧，然后我就坐了下来，把头伸到水龙头下面，那个女服务员就帮我把头发弄湿然后把洗发露弄到我头上。给我搓得满头泡沫之后，她也不给我冲掉，而是站起来就掉头走掉了？！我就很诧异，为什么不给我洗完？？但是当我发现有什么不对的时候，我试图自己洗，可是我突然发现那个水龙头我自己没办法弄开水，可能是有什么东西感应的。在我面前不到五米就是一个下去的台阶，那个服务员掉头就走下台阶，我根本看不见她了。我只能坐在那里等她回来给我洗掉这些泡沫，我满头泡沫怎么坐飞机啊？？等了不知道多久，终于来了另一个服务员，给我把头上的洗发水冲掉了。我觉得他应该要给我吹头的时候，他竟然又把我按住然后给我抹上了洗发露然后又把我弄得满头泡沫的时候又非常合理地站起来掉头就要走！！！我他妈疯了，我说，你站住！！！你把我头发上泡沫洗掉啊，他说，我就负责到这里，会有下一个服务员过来给你弄。但是好奇怪啊，为什么我就乖乖的听了她说的话，就是在那里等下一个服务员过来给我冲掉，（搓头和洗掉泡沫应该是两个服务员来服务）感觉非常地合理啊，同时我也不尝试，其实我自己是可以给自己洗掉的啊（双重思想）。过了一阵子，这个时候我觉得他妈的好坑啊（我醒来觉得他们程序可能出bug了），而且我没有手表这个世界好像也没有时钟，我可能要误机了，我自由开始尝试在那个水龙头上摸索，弄了半天终于给弄出水了，自己把泡沫洗掉也没办法吹干就拉着行李冲下楼梯去登机口。</p>
<p>也没电梯，登机口在整个机场的最底部。（我草，太赛博朋克了，机场登机口在现实中不应该是在楼层高的地方吗？）然后我终于下了可能有100层楼，终于到了登机口所在的底层。然后这个时候以我可以我5.5的视力发现地上100层平台站着一个机器人在跳。（可能就是出了bug的洗头机器人）。我顾不上了，只能往里跑，我抬头一看时钟（嗯？怎么突然又有时钟了），所剩时间不多，但是队列还巨几把长，而且等登机的人都特别的木讷和谔谔，站着一动不动，一点动作都没有的。我觉得我要登不上飞机了，我就往里面跑，这群谔谔的人并没有阻止我插队，而是齐声开始相互私底下交流“这人真没素质”，“这人怎么插队啊”，我听见了，我可悲的自尊心让我在队里的某个位置停了下来，没有坚持插队。然后我一停下来，那些队列中等待的人立刻统一地噤声默言了。等了半天，终于轮到我了，什么？？？登机前还他妈要行李再过一遍安检？然后我把我的行李放到那个检测机前面，通过机器之后，我迫不及待地拿起行李就往登机口冲，可是登机口的人把我拦下了，说我的行李没有通过安全检查。我返回安检处，那服务员跟我说，你的行李里面有塑料袋，我们现在整个社会都要淘汰塑料袋。我只能把行李打开，把一个塑料袋里面的东西都拿出来然后把塑料袋丢掉。我这次觉得是真的要登不上飞机了，我拔腿狂奔，我隔着很远，我就眼睁睁地看着那个登机口的时候门口的两个工作人员（现在我确信他们是机器人了）根本不注意我，只是冷冷的盯着前面。然后在我跑到距离登机口还有五米的时候，他们非常恰合时宜地准备回过头把登机口的门关了，我绝望了！一边冲刺，一遍还举起行李，企图强行把行李塞到登机口而让他们无法关门，但我还是失败了。我被挡在了登机口的外面，就差一步。我他妈好气啊，我操了，这什么傻逼机场，我他妈为什么要洗那个头？我他妈为什么下了楼梯还要往回看？我他妈在插队的时候为什么不狠下心来不要理周围人的逼逼？我但凡有哪一步没有被阻碍，我都可以登上飞机。这个时候我想到，赶不上飞机的人就要被迫离开机场，是要冻死在外面的。然后我突然手里不知道为什么有了一把刀，我的内心突然产生了杀人的冲动，然后我立刻冲到安检机器前面把那个揪出我行李里面有塑料袋的工作人员捅死了，但是我心里一点没有杀人的负罪感，非常爽！！你妈逼的就是你让我上不了飞机，非常地解气，虽然我知道我肯定要被捕。然后梦就醒了，就是生活在这样一个社会。我现在想可能我捅死的也只是机器人，而我也分不清我自己到底是人还是机器人了。</p>
<p>颜先生解梦：</p>
<p>上飞机——出国<br>上不了飞机被冻死——<br>最下层登机——主人公的社会地位<br>排队很多人——激烈的竞争<br>沉默木讷的排队的人——沉默木讷的国人<br>想先登机插队被骂，一旦不插队又全都没声——不患寡而患不均？<br>洗头——无用的事<br>很多人轮流洗头并且重复——无能的部门<br>多层安检——重重枷锁<br>朋友——？<br>捅死——对管制的深恶痛绝</p>
<h1 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h1><p>18年上半年某天，我看完了一本书，叫做《<a href="https://book.douban.com/subject/6428468/">我們最幸福 - 北韓人民的真實生活</a>》，是一个通过脱北者的视角描写朝鲜社会的一本书。我那天做了一个梦，很短，但特别真实，所以我就记了很久——</p>
<p>我生活在一个和朝鲜类似的社会中，我突然有一天和我爸讲，爸，我们有能力走，咱们移民吧。然后我爸转头就把我举报了。然后我醒了。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之类的自动转换和强制类型转换</title>
    <url>/2017/06/07/Type-Conversion/</url>
    <content><![CDATA[<p>类型转换：将一个标准类型变量的值赋给另一种标准类型变量时，如果两种类型兼容，则C++会自动将这个值转换为接收变量的类型。例如：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">long count <span class="operator">=</span> <span class="number">8</span><span class="comment">;</span></span><br><span class="line">double time <span class="operator">=</span> <span class="number">11</span><span class="comment">;</span></span><br><span class="line">int side <span class="operator">=</span> <span class="number">3.33</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>上述语句都是可行的，C++包含进行转换的内置规则。这些转换将降低精度。例如3.33赋给int型变量将保留3，丢失0.33。</p>
<p>不兼容的类型如下：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int *p <span class="operator">=</span> <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>虽然计算机内部可能有某个整数代表某个地址，但从概念上来说地址和整数完全不同。所以，这是无法自动转换的。当无法自动转换时，可以使用强制类型转换：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int *p <span class="operator">=</span> (int *)<span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>将指针设置成地址10，可以做是可以这么做，当然有没有意义是另一回事。</p>
<p>对于类来说，可以将类定义成与基本类型、或者另一个类相关，使得从基本类型或者别的类转换成另一种类型是有意义的。即在某些情况下，程序员<strong>可以指示C++如何进行自动转换</strong>，或通过<strong>强制类型转换</strong>来完成。</p>
<h1 id="通过转换函数来实现自动类型转换，显式、隐式转换，强制转换。"><a href="#通过转换函数来实现自动类型转换，显式、隐式转换，强制转换。" class="headerlink" title="通过转换函数来实现自动类型转换，显式、隐式转换，强制转换。"></a>通过转换函数来实现自动类型转换，显式、隐式转换，强制转换。</h1><p>下面看一个类，是英式重量单位：磅与英石的类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stonewt.h -- （英式）重量的单位：磅与英石</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stonewt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; Lbs_per_stn = <span class="number">14</span> &#125;;	<span class="comment">//每英石是14磅</span></span><br><span class="line">	<span class="type">int</span> stone;					<span class="comment">//重量，单位英石，整数</span></span><br><span class="line">	<span class="type">double</span> pds_left;			<span class="comment">//剩余的重量，单位磅</span></span><br><span class="line">	<span class="type">double</span> pounds;				<span class="comment">//总重，单位磅</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs);</span><br><span class="line">	<span class="built_in">Stonewt</span>(<span class="type">int</span> stn, <span class="type">double</span> lbs);</span><br><span class="line">	<span class="built_in">Stonewt</span>();</span><br><span class="line">	~<span class="built_in">Stonewt</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show_lbs</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show_stn</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs)<span class="comment">//构造函数，参数为磅</span></span><br><span class="line">&#123;</span><br><span class="line">	stone = <span class="built_in">int</span>(lbs) / Lbs_per_stn;</span><br><span class="line">	pds_left = <span class="built_in">int</span>(lbs) % Lbs_per_stn + lbs - <span class="built_in">int</span>(lbs);</span><br><span class="line">	pounds = lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">int</span> stn, <span class="type">double</span> lbs)<span class="comment">//构造函数，参数为英石和磅</span></span><br><span class="line">&#123;</span><br><span class="line">	stone = stn;</span><br><span class="line">	pds_left = lbs;</span><br><span class="line">	pounds = stn*Lbs_per_stn + lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>()<span class="comment">//默认构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">	stone = pounds = pds_left = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::~<span class="built_in">Stonewt</span>()<span class="comment">//析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stonewt::show_lbs</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; stone &lt;&lt; <span class="string">&quot;stone, &quot;</span> &lt;&lt; pds_left &lt;&lt; <span class="string">&quot; pound(s)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stonewt::show_stn</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; pounds &lt;&lt; <span class="string">&quot; pound(s)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如何实现类的自动类型转换呢？提供一个将整型数、浮点数转换为Stonewt对象的方法就可以了。下面的构造函数就把一个double型的值转换成为了Stonewt类型。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Stonewt::<span class="constructor">Stonewt(<span class="params">double</span> <span class="params">lbs</span>)</span><span class="comment">//构造函数，参数为磅</span></span><br></pre></td></tr></table></figure></p>
<p>也就是说可以编写如下代码：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Stonewt mycat<span class="comment">;</span></span><br><span class="line"><span class="attribute">mycat</span> <span class="operator">=</span> <span class="number">19.6</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>这一过程叫<strong>隐式转换</strong>，因为它自动创建一个临时对象，把19.6作为初始化值，然后逐个把临时对象的内容复制到mycat里。</p>
<p>只有接受一个参数的构造函数才能作为<strong>转换函数</strong>。下面的构造函数有两个参数，因此不能作为类型转换函数：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Stonewt::<span class="constructor">Stonewt(<span class="params">int</span> <span class="params">stn</span>, <span class="params">double</span> <span class="params">lbs</span>)</span><span class="comment">//构造函数，参数为英石和磅</span></span><br></pre></td></tr></table></figure><br>但是如果在函数声明中给第二个参数提供默认值，它就可以用于转换int。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">Stonewt(<span class="params">int</span> <span class="params">stn</span>, <span class="params">double</span> <span class="params">lbs</span> = 0)</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="显式转换和隐式转换的差别"><a href="#显式转换和隐式转换的差别" class="headerlink" title="显式转换和隐式转换的差别"></a>显式转换和隐式转换的差别</h1><p>将构造函数用作自动转换类型函数似乎是一项不错的特性，然而，当程序员拥有更丰富的C++经验时，将发现这种自发转换类型并非总是需要的，有可能会导致意外的类型转换。因此C++提供了关键字<strong>explicit</strong>，用于关闭这种自动特性。也就是说，如果这样声明函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Stonewt</span><span class="params">(<span class="type">double</span> lbs)</span></span>;    <span class="comment">//不允许隐式转换（自动转换类型）</span></span><br></pre></td></tr></table></figure><br>就不会允许隐式转换了，但任然允许显式转换，显式转换即强制类型转换：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Stonewt mycat<span class="comment">;</span></span><br><span class="line"><span class="attribute">mycat</span> <span class="operator">=</span> <span class="number">19.6</span><span class="comment">;               //不允许，必须显式转换</span></span><br><span class="line"><span class="attribute">mycat</span> <span class="operator">=</span> Stonewt(<span class="number">19.6</span>)<span class="comment">;      //允许</span></span><br><span class="line"><span class="attribute">mycat</span> <span class="operator">=</span> (Stonewt)<span class="number">19.6</span><span class="comment">;      //允许</span></span><br></pre></td></tr></table></figure></p>
<h2 id="到底哪些算隐式转换？"><a href="#到底哪些算隐式转换？" class="headerlink" title="到底哪些算隐式转换？"></a>到底哪些算隐式转换？</h2><p>• 将Stonewt对象初始化为double值。 例子：<code>Stonewt mycat=19.6;</code><br>• 将double值赋给Stonewt对象。例子：<code>mycat=19.6;</code><br>• 将double值传递给接受Stonewt对象作为参数的函数。<br>• 返回值被声明为Stonewt对象的函数试图返回double值时。</p>
<h2 id="注意防止二义性"><a href="#注意防止二义性" class="headerlink" title="注意防止二义性"></a>注意防止二义性</h2><p>例如有这样的语句：<code>Stonewt mydog(50);</code> 因为50是int值，所以会被自动转换为double值再使用<code>Stonewt(double lbs)</code>构造函数。当且仅当不存在二义性错误时才会进行这种二步转换。也就是说，如果这个类还定义了<code>Stonewt(long lbs);</code>这种函数，则编译器会报错。（int可能被转换成double或long都可以）</p>
<h2 id="谨慎使用隐式转换函数"><a href="#谨慎使用隐式转换函数" class="headerlink" title="谨慎使用隐式转换函数"></a>谨慎使用隐式转换函数</h2><p>例如有如下写错的代码：<br><figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line">int array[20];</span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">Stonewt temp(14,4);</span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">int Temp = 0;</span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">cout&lt;&lt;array[temp];/*t写错成小写，本应用Temp作为数组下标*/</span><br></pre></td></tr></table></figure></p>
<p>如果使用的是允许<strong>隐式转换</strong>的转换函数，这里坏处就体现了：在debug时编译器并不能捕捉使用了对象作为数组下标，因为定义了<code>operator int()</code>，所以对象可以变成int值并用做数组下标。</p>
<p>所以说，原则上，最好使用显式转换，避免隐式转换。</p>
<ul>
<li>方法1：在原型前使用<code>explicit</code>限定符。</li>
<li>方法2：用一个功能相同的非转换函数替代转换函数，因为不是转换函数，所以必须显式调用。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="title class_">Stonewt</span>::<span class="title function_ invoke__">Stone_to_int</span>()&#123; <span class="keyword">return</span> <span class="keyword">int</span>(pounds+<span class="number">0.5</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>总之：应谨慎地使用隐式转换函数。通常，最好选择仅在被显式调用才会执行的函数。</p>
<h1 id="通过转换函数，将对象转换成数字"><a href="#通过转换函数，将对象转换成数字" class="headerlink" title="通过转换函数，将对象转换成数字"></a>通过转换函数，将对象转换成数字</h1><p>上述的工作是将各种类型的数字转换成Stonewt对象，那么能做相反的操作嘛？例如可否将一个Stonewt对象转换成double值？</p>
<p>答案是：可以这样做，但不是使用构造函数。构造函数能适用于从某种类型到类类型的转换。要进行相反的操作，需要用到C++中特殊的运算符函数——<strong>转换函数</strong>。</p>
<p>转换函数是用户定义的强制类型转换，定义了转换函数之后，可以像使用强制类型转换那样去转换类型。编译器在发现由类转到基本类型的语句后，会寻找是否有定义与此匹配的转换函数，否则会报错。</p>
<p>定义转换函数的方法：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span>()</span>;</span><br></pre></td></tr></table></figure><br>有以下几个注意点<br>• 转换函数必须是类方法。<br>• 不能指定返回类型。<br>• 不能有参数。</p>
<p>所以，某类类型转换为double型的函数原型如下：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span>()</span>;</span><br></pre></td></tr></table></figure></p>
<p>在Stonewt类中，这样编写转换函数：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换函数</span></span><br><span class="line"><span class="keyword">operator</span> <span class="built_in">int</span>()<span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">operator</span> <span class="built_in">double</span>()<span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法定义</span></span><br><span class="line">Stonewt::<span class="keyword">operator</span> <span class="built_in">int</span>()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">int</span>(pounds + <span class="number">0.5</span>);<span class="comment">//四舍五入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="keyword">operator</span> <span class="built_in">double</span>()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>还是要注意防范二义性错误。下面举一个例子。</p>
<p>在C++中，int值和double值都可以被赋给long变量，如果一个类有转换成int类和double类的函数，但出现了如下语句：（b是一个类对象）<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">long a <span class="operator">=</span> b<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>因为编译器使用任何一个转换函数都是合法的，编译器不想承担选择转换函数的责任，所以会报错。（这就是<strong>二义性错误</strong>）但是删掉其中一条之后编译可以通过。如果删掉了double定义，则编译器使用int定义，先把b对象转换成int值，再把int值赋给long变量。</p>
<p>当定义了很多的转换函数时，仍可以使用显式强制类型转换来指明到底使用哪个转换函数，下列的语句就是可行的：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">long a <span class="operator">=</span> (double)b<span class="comment">;</span></span><br><span class="line">long a <span class="operator">=</span> int (b)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>友元函数避开了通过使用类方法才能访问类成员的限制。</li>
<li>运算符重载可以是类成员函数，也可以是友元函数。</li>
<li>之所以要使用友元函数来重载运算符是因为这个运算符有两个操作数，而且为了使第一个操作数不是类对象。</li>
<li>注意不要出现二义性错误。例如重载运算符加号使两个同类对象相加，却同时使用了非友元和友元的方法（例如对于Time类的两个对象a和b来说，无论a+b或者b+a都是一样的，定义一个即可）。</li>
<li>重载&lt;&lt;运算符特别需要知道声明返回类型为<code>std::ostream &amp;</code>，以及一条<code>return os</code>;</li>
<li>C++允许指定类和基本类型之间进行互相转换的方式。首先，任何接受唯一参数的构造函数都可以作为转换函数，将参数类型转换成类对象。例如假设有一个<code>String</code>类，它包含一个将<code>char *</code>值作为其唯一参数的构造函数，且a是一个String对象，则可以使用像<code>a = &quot;abc&quot;;</code>这样的语句了。如果在函数声明前加上<code>explicit</code> 将限制隐式转换，则只能这样显式地转换：<code>a = String(&quot;abc&quot;);</code></li>
<li>将类转换成别的类型的函数原型是：<code>operator typeName();</code>经验表明，最好不要依赖隐式转换函数。多多注意防止出现二义性的转换函数。注意过多转换函数很容易导致在隐式转换时出现二义性。</li>
<li>与简单的C风格编程结构相比，使用类时必须更加小心谨慎，但作为补偿，它能为我们做的工作也更多。</li>
</ol>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>《万万没想到——用理工科思维理解世界》读书摘抄和笔记</title>
    <url>/2018/05/12/Understanding-The-World-with-Science-and-Technology/</url>
    <content><![CDATA[<p>书本豆瓣页：<a href="https://book.douban.com/subject/25986341/">https://book.douban.com/subject/25986341/</a></p>
<h1 id="反常识思维"><a href="#反常识思维" class="headerlink" title="反常识思维"></a>反常识思维</h1><p>【第一章讲了很多通过科学实验得来的<strong>错误的思维定式</strong>，了解这些缺陷，我们可以避免直觉带来的一些思维陷阱，并学会用理性思维来看待这些东西。】</p>
<h2 id="“反常识”思维"><a href="#“反常识”思维" class="headerlink" title="“反常识”思维"></a>“反常识”思维</h2><p>煽情是文人的膝跳反应……对绝大多数中国观众来说，煽情是他们最能听懂的语言。我们潜意识能有判断人的真诚程度和事情的紧急情况的常识。这种思维方式的维度和标准就是道德，也就是中国典型的熟人社会、关系型社会。这样的社会里，最重要的不是数学计算和理性分析，而是分辨善恶美丑。“价值观”这个词好似能概括这一切，但无非也就是给人和事主观贴上好或坏的标签。</p>
<p>理工科思维和这些不一样。</p>
<ol>
<li><strong>利弊分析</strong>，了解事物的利弊。作出取舍。</li>
<li>人脑大致可分为两个系统，前一个能够自动工作，对于某事物可以立刻给出一个 很难改变的第一印象。后者费力而缓慢，需要集中注意力做很大量的计算工作。文人思维就是系统1的集大成者，理工科思维就是系统2的产物。</li>
<li><strong>量化输入、预计输出。这是理工科思维的最根本方法。</strong></li>
</ol>
<h2 id="别想说服我！"><a href="#别想说服我！" class="headerlink" title="别想说服我！"></a>别想说服我！</h2><p>关于这一点，有一些认识偏见：</p>
<ol>
<li>每个人都爱看能印证自己观念的东西，有的时候还会忽略那些不符合自己观念的证据。（媒体、社交网络利用这一点，制造很多“人们想看的”新闻标题，或者根据你喜好给你推荐信息）</li>
<li>如果你已经开始相信一些东西了，那么你就会主动寻找增强这种相信的信息和证据。（eg：一旦选择了阵营的一方，就会坚定地为这一方而战，我们天生都是律师思维，大脑成了争论设备）</li>
<li>人们更愿意看到和自己一样的地方，并忽略不一样的地方。（星座与性格理论经久不衰）</li>
</ol>
<p>这种网络上一些观点犀利的文章报道，观众们看的畅快淋漓。然而我们要思考：</p>
<ol>
<li><strong>这篇文章提出切实可行的方案了吗？</strong></li>
<li><strong>有没有什么能够修正我们思想的新信息？</strong></li>
</ol>
<p>如果没有，那么它们这是在迎合和肯定你现有的观念而已。</p>
<p>有鉴于此，作者在书中号召我们改变对信息的消费方式：<strong>主动刻意消费，吸收有可能修正我们观念的新信息，而不是吸收对我们现有观念的肯定</strong>（Consume deliberately. Take in information over affirmation）</p>
<p>要做到这些非常难，但也有方法：<strong>避免那些预设立场的文章，尽可能接触第一手资料，养成直接阅读数据的能力。</strong>（有多少人亲自研读各项经济指标来判定房价是否过高？对于大多数人来说，房价是否过高的指标就是他买没买房）</p>
<h2 id="真理追求者"><a href="#真理追求者" class="headerlink" title="真理追求者"></a>真理追求者</h2><p>对于某些问题，大家争论时，经常各持立场，很少妥协，不欢而散。每个人都认为自己是对事不对人。每个人都认为自己在争论过程中是真诚的。</p>
<p>针对这个问题，罗伯特·奥曼（Robert Aumann）在 1976 年发表了一篇论文《不一致的达成》（ “Agreeing to Disagree”）它对上面问题的结论是：如果是两个<strong>理性而真诚的真理追求者</strong>争论问题，争论的结果必然是二人达成一致。换句话说如果争论不欢而散，那么其中必然有一方是虚伪的。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">我：我认为明天决赛阿根廷队将夺冠。</span><br><span class="line">你：了解。但我认为意大利队将夺冠。</span><br><span class="line">我：收到。但我仍然认为阿根廷队夺冠。</span><br><span class="line">你：意大利队。 </span><br><span class="line">我：阿根廷队。</span><br><span class="line">你：意大利队。 <span class="meta"># 仍在坚持</span></span><br><span class="line">我：好吧，意大利队。<span class="meta"># 那你应该更正确</span></span><br></pre></td></tr></table></figure>
<p>基于如下假设：</p>
<ol>
<li>如果你跟我对于一般足球理论的认识一致，换句话说，也就是说如果你认为梅西对阿根廷队很重要，我也这样认为，这就可以说我们的“priors” 是一致的。我们两个理性的人就好比两台计算机，如果给我们完全相同的输入，我们可以计算出相同的结果来。</li>
<li>在决赛前夜，如果我向你宣布，我认为阿根廷队将获得世界杯冠军。而你向我宣布，你认为意大利队将获得世界杯冠军。这样一来我们两人的观点就被亮出来了。我们的观点是 “common knowledge”。</li>
</ol>
<p>推理过程如下：</p>
<blockquote>
<p> 我认为阿根廷能夺冠，是因为我有自己的事实根据，例如我研究过双方的实力对比等。因为对方也是理性的，所以对方在听到我的决定，如果仍然坚持立场，那么他一定有比我更强的信息。虽然如此，可我如果仍在坚持，同样对方也会知道我有了更强的根据。在经过几个来回之后对方仍然坚持意大利获胜，那么我宣布同意你的观点。</p>
</blockquote>
<p>所以得出结论：<strong>两个真诚而理性的人应该对事情有相同的看法</strong>。【但基于强假设：】一致的“priors”，两人都是真诚的。真诚也非常重要，因为也许两个人对梅西的重要性有不同看法。但是这个“不同看法”也是可以通过这种对话达成一致的！</p>
<p>对比到科研上，做科研的人有一个共同优点就是允许新的想法，也允许他人改变自己的想法。（例如写论文的同行评议）因为科研就是真理追求，一大乐趣就是接受新想法。</p>
<h2 id="坏比好重要"><a href="#坏比好重要" class="headerlink" title="坏比好重要"></a>坏比好重要</h2><p>有一个重要的心理学定律：<strong>人们总是喜欢获得而害怕失去。叫做厌恶损失。人们对于负面感情的重视程度总是超过正面感情</strong>，叫做 negativity bias。</p>
<p>坏比好重要【作者讲的是正确对待坏比对待好重要】。<strong>面对负面情绪，最好要理性行事。强烈的负面情绪会带来偏见，因此不要轻易纵容这种情绪。</strong>遇到好人好事主动夸，遇到坏事也要保持淡定。看到好的冒险机会要上，遭受损失也不要太放在心上。</p>
<h2 id="最简单的概率论的五个智慧"><a href="#最简单的概率论的五个智慧" class="headerlink" title="最简单的概率论的五个智慧"></a>最简单的概率论的五个智慧</h2><p>作者认为概率论是现代公民必备的知识，正确理解现在的世界的不确定性，能够直接决定一个人“开化”的程度，改变人看世界的眼光。</p>
<p><strong>1.随机</strong></p>
<p>有些事情是无缘无故发生的。即：有些事的发生，和它之前发生的事情，<strong>都可以没有任何因果关系。</strong></p>
<p>eg：一个人学习成绩好可以是因为他努力学习的结果。而一个人中彩票的原因是什么？答案就是没有任何原因。</p>
<p>概率论知识点：<strong>随机事件</strong></p>
<p>误区：人们经常错误地理解偶然，会想着用必然去解释偶然。</p>
<p>idea：理解随机性，我们知道有些事情发生就发生了，而没有太大解读的意义。为偶然事件大惊小怪，一朝被蛇咬十年怕井绳，是幼稚的体现。</p>
<p><strong>2.误差</strong></p>
<p>绝大多数事情有偶然因素和必然因素的存在。人们会自然的发现必然而排除偶然。但是，你必须要理解误差的存在。</p>
<p>eg：物理学上，对于一个明确定义的物理常数的测量也给不出真实答案，总是在测量结果后面加上误差范围。也就是说，真实的值当然只有一个，但由于偶然因素永远存在，误差永远存在，所以这个真实值我们不清楚是多少也没有办法清楚。真实值可以是在误差范围里的，也可以是在误差范围外的（只不过可能性非常小）。</p>
<p>误区：假设一个同学考了两次考试，一次成绩是59，一次是63，这不叫进步，这叫在误差范围内。</p>
<p>idea：<strong>学会忽略误差范围内的波动，不大惊小怪</strong>。</p>
<p><strong>3.赌徒谬误</strong></p>
<p>eg：如果你在赌场赌钱，你连输了好几把，你是否有强烈的感觉，下一把就要赢了呢？</p>
<p>解读：这完全是错误的，因为一次赌博是完全独立的随机事件，下一把的结果和以前的所有结果没有关联。</p>
<p>概率论的确有一个“大数定理”：如果进行足够多次的实验，那么每一个实验结果出现的频率会等于它们的概率。</p>
<p>误区：人们会错误地理解随机事件的随机性和大数定理：如果在过去一段时间发生的事情不那么均匀，那么人们会误以为事情会尽量往“抹平”的方向走。<strong>这是一个著名的误区！！！</strong>，名字是<strong>赌徒谬误（gambler’s fallacy）</strong></p>
<p>idea：正确理解独立随机事件。</p>
<p><strong>4.在没有规律的地方发现规律</strong></p>
<p>eg：“彩票分析学”，认为彩票中奖号码存在某种“走势”。</p>
<p>结论：独立随机事件的发生是没有规律且不可预测的。【说白了还是没有理解独立随机事件带来的谬误。】</p>
<p>解读：<strong>发现规律是人的本能</strong>【比如下面要谈到的阴谋论】，以至于我们甚至能在没有规律的地方自己也认为有规律。。。人脑非常擅长理解规律，而不理解随机性。</p>
<p>这种“规律”，不是规律，而是从一堆数据中找出一种模式来解释已经发生的事情，问题是，这种“规律”不能预示未来发生的事情，所以不是规律。</p>
<p>idea：<strong>未来是不可以被精确预测的，世界并不是像钟表那样精确运行的。</strong></p>
<p><strong>5.小数定律</strong></p>
<p>就算数据量很少，我们也能发现有些“规律”会自己跳出来，甚至你不相信都不行。</p>
<p>【例如我自己就想到了：Ti 奇数年外国队夺冠，偶数年中国队夺冠。】</p>
<p>解读：这是因为，数据少，随机现象可以看上去“很不随机”，甚至感觉真的有规律一样。</p>
<p>误区：人们往往以为：如果是随机事件，那么结果一定是要分布均匀的，殊不知这一点一定要数据样本总数非常大的时候才可以做到。一旦出现不均匀，人们就会突然高潮迭起：我发现这里面有规律！！！然而实质上，其实这可能只是偶然事件。<strong>如果统计数字很少，就容易出现特别不均匀的情况。</strong>这个现象被诺贝尔经济学奖得主丹尼尔卡尼曼称为“小数定律”。如果我们不能真正理解小数定律，我们就不能真正理解大数定理。</p>
<p>idea：不能只凭自己、家人的经验对某些事物作出判断（样本数量非常小），<strong>别看个例，要看大规模统计。【理工科思维】</strong>。</p>
<p>最后，理解了概率论，有一个最大的好处就是你很少再会大惊小怪了。</p>
<h2 id="阴谋论的心"><a href="#阴谋论的心" class="headerlink" title="阴谋论的心"></a>阴谋论的心</h2><p>【读完这章，恰巧有个朋友跟我讲，他的“形式与政策”课上，一位材料学院的党委书记大谈阴谋论，例如“艾滋病是美国研究出来的针对非洲黑人的种族灭绝”、“SARS病毒是美国人研究出来对付中国人的，因为死亡的XXXX人里面有XXXX是中国人”……不禁感叹读书的内容和生活中的经历就是这么凑巧。】</p>
<blockquote>
<p>（网络上的一篇文章）马航失联是中美两个大佬博弈的结果……，这篇奇文把近来的国际形势，包括乌克兰局势、日本右翼政府态度软化、朝鲜半岛的变化、西方阵营出现裂痕、泰国局势未能稳定、国内改革前进、两会召开、昆明火车站恐怖袭击，通通联系在一起，认为要全盘考虑这些……才能解释一家客机为什么失联</p>
</blockquote>
<p>正如概率论那一章所说，人们很擅长在没有规律的地方发现规律。有一种现象就是阴谋论，例如“中国正在和世界下一盘大棋”的“国际大棋论”，以及所有坏事都是国外敌对势力针对中国搞出来的“帝国主义亡我之心不死”论。</p>
<p>作者利用理工科的视角来解读这一现象。首先，用到了之前提到的：读第一手资料，看大规模的数据调查，而不是相信有立场性的文章。</p>
<p>作者提出，这里面的思维误区不仅仅是上面说的人们善于找规律找联系，还有就是<strong>人们不承认巧合，不承认有些事情就是自然发生的，认为一切背后都是有目的的</strong>。</p>
<p>他提到了芝加哥大学的一个调查。调查内容是这样的，列出一个最流行的阴谋论列表，里面是在美国社会中专门针对美国政府的阴谋论。结果是49%的受访者相信至少一个，18% 的相信三个。这里面的阴谋论非常骇人听闻，例如：</p>
<blockquote>
<p>政府明知手机致癌而不作为；CIA故意让黑人感染艾滋病；转基因食品是政府秘密进行种族灭绝的手段；医院知道疫苗会导致XXX；公共饮用水加氟是为了化学公司的排污</p>
</blockquote>
<p>接下来，作者列出了一个列表，内容是美国真正实施过的阴谋。我个人有印象的是这条：以研究梅毒为名招来一些患病的黑人，甚至让健康人染上梅毒，但并未对他们做了有效治疗。与民间相流传的阴谋论相比，真正的阴谋并没有那么坏，起码耸人听闻程度下降了特别多。这是为什么呢？联系一下林肯那句话“你可以在所有的时间欺骗一部分人，也可以在一段时间欺骗所有人，但你不可能在所有的时间欺骗所有人”，你应该想到完成一个非常大非常坏的阴谋是非常困难的，而且做成了曝光的风险非常大。</p>
<p>（民间）阴谋论为什么不足信，不是因为我们不应该质疑政府——实际上我们应该要质疑政府——而是因为其成立的概率很低。这种骇人听闻的事情，越详细，就越不足信。又扯到概率论掌握不好的事情了。A 与 B 同时发生的概率肯定要小于 A 单独发生的概率 或者 B 单独发生的概率，这是概率论的基本知识点。</p>
<ul>
<li>昆明恐怖袭击事件发生不久，发生了马航失联事件</li>
<li>因为大国博弈，导致昆明恐怖袭击事件发生不久，发生了马航失联事件</li>
</ul>
<p>加上了大国博弈，好像让偶然事件有了合理解释，实际上发生的概率更小了才对。更别提扯到那么多七七八八都联系到一起的阴谋论了。</p>
<p>其实这就是目的论，认为发生什么事情都是背后有目的。目的论是科学研究要排斥的。例如物理，是要给世界的运行给出一套机制，并不是它背后有什么目的，或者有什么精神力量，而是物理定律就决定了让它怎么做。认为凡事都有目的，就是普通人区别于科学思维的一条。【理工科思维又来了】</p>
<h1 id="成功学的解药"><a href="#成功学的解药" class="headerlink" title="成功学的解药"></a>成功学的解药</h1><p>【作者在这一章讲了很多读书、学习的方法，以及科研的思维。】</p>
<h2 id="科学的励志和励志的科学"><a href="#科学的励志和励志的科学" class="headerlink" title="科学的励志和励志的科学"></a>科学的励志和励志的科学</h2><p>成功学鸡汤，它们都不是科学理论。这些道理是不是<strong>可重复和可检验</strong>的呢？想要知道什么品质对成功最重要，最好的方法不是看名人传记，而是进行大规模统计【理工科思维贯穿本章】</p>
<h2 id="练习一万小时成天才？"><a href="#练习一万小时成天才？" class="headerlink" title="练习一万小时成天才？"></a>练习一万小时成天才？</h2><ul>
<li><p>科学的练习方法不是从天而降的神秘招式，它一定程度上存在于生活之中。例如中国选手对乒乓球的压倒性优势，难道说别的国家的人天生不适合这项目吗？其根本原因在于训练方法，有了科学的训练方法才能量产“天才” 【非常能理解，其实有些事情没那么困难，而确实存在科学的方法】</p>
</li>
<li><p><strong>如果你想成为一个科学家，就应该好好学习基础知识，然后尽快找一个好的导师，在他的知道下，从学徒开始做，做真正的科学研究。</strong></p>
</li>
</ul>
<p><strong>刻意练习 deliberate practice</strong></p>
<ol>
<li>只在学习区学习。</li>
<li>把要训练的内容分为有针对性的小块，对每一个小块重复练习。（掌握套路）</li>
<li>获得即使的反馈</li>
<li>练习时注意力必须高度集中</li>
</ol>
<p><strong>一、只在学习区学习</strong></p>
<ul>
<li>只在学习区学习！ 【读这本书，让我非常受用的一点是：一旦已经学会了某一个东西，就不应该继续在上面花时间，应该立刻转入下一个困难点】</li>
<li>想在课堂上做到只在学习区学习是很难的。最好的教育是因材施教【有的内容对于有的同学是已经是舒适区而对于有些同学是恐慌区】</li>
<li>真正把一件事学好的标志就是这件事转入了你的舒适区，以至于你操作起来好似没什么难度。（eg：开车开熟的人，但你要问他怎么开他其实说不清楚，但就是能开的很好，是因为开车已经是他的舒适区了）</li>
<li>一旦学会了，要立刻进入下一关，把这一关的东西倒背如流没有意义，高考制度缺陷在于此，学的好的学生应该把时间投入到更高级的东西上去 【很受用】</li>
<li>你的舒适区给你带来的多大的荣誉，留在舒适区就有多大的诱惑。【总结就是一定要push自己在学习区做事】</li>
<li>脱离舒适区，留在学习区，需要一种很强大的意志力，甚至是一种修炼 【这是看心理学的书非常好用的一点】</li>
</ul>
<p><strong>二、重复的针对性训练</strong></p>
<ul>
<li>学习、训练的到底是什么，是套路。也就是所谓长期记忆。形成长期记忆，定式，成了人脑思维的快捷方式。 【关于这点也能联系到意志力中，养成习惯能帮助我们节省意志力的观点】</li>
<li>必须进行大量的重复训练</li>
<li>训练要有很高度的针对性</li>
</ul>
<p>重复：</p>
<p>【例如弹琴，就是不断训练自己的手指在键盘上的运动而达到形成肌肉记忆的过程。】</p>
<ul>
<li>想要把一个运动、技能、生活习惯，“长到大脑中”，唯一的方法就是不断重复。</li>
</ul>
<p>针对性：</p>
<ul>
<li><p>训练必须要有针对性，否则就是浪费时间，一切从实战出发，明确每次训练要完成的<strong>目标</strong>。</p>
</li>
<li><p>大学里的这些课程有针对性吗？教学以考试为核心，讲的时候同学注重“知识点总结”，考前“划重点”，同学把学习的知识当做考试的材料，而<strong>忘了知识是可以拿来用的，更不知道你的任务不是学习这些知识而是创造新的知识。</strong>  【真是如雷贯耳】</p>
</li>
<li><p>搞科研最好的方法就是尽早找个实验室进去跟着开干。学习知识不是为了考试，不是为了耍酷或者谈资，而是为了有用！对比之下，国外的大学理工科课程非常注重实际，除了考试和作业之外特别强调做项目，强调学以致用。</p>
</li>
</ul>
<p><strong>三、随时获得反馈</strong></p>
<p>这是很有用的老生常谈了</p>
<p><strong>四、刻意练习不好玩</strong></p>
<ul>
<li>一定不是“寓教于乐”，学习不是快乐的。必须要在一个好的环境中单独学习，才是有效的学习时间。</li>
<li>如果你想学点知识，最好的方法就是找本书（正规教科书或者专业著作）老老实实找个没有人的地方坐下来反复读，自己整理笔记，做题。需要重复练习，重复不一定好玩。教育需要全面，娱乐只关注其中好玩的部分，所以娱乐和学习必然不相容。</li>
<li>学习是要付出代价的，要想获得出色的思辨能力对年轻人来说绝非易事。教育的目的本来应该是摆脱现实的奴役，而现在的年轻人正竭力做相反方向的努力。</li>
</ul>
<p>【看这一部分非常的惊喜，自己的学习方法和作者不谋而合。但是仍然在里面吸收了很多的养分】</p>
<ul>
<li>真正决定一个学生进步幅度的不是智商，而是内在动力和学习方法。【而这又和自控有紧密的关联】</li>
<li><p>既然兴趣是如此重要，那么最好的早期教育就是慢慢培养兴趣【这点我觉得中国大学做的很不够好】</p>
</li>
<li><p>关于一个人先天的兴趣，以及喜欢干什么，科学界的共识是先天因素远大于后天因素。每个人都有自己的天生的不同兴趣，区别在于有的人足够幸运能够在比较早的时候找到，而有的人一辈子没找到。</p>
</li>
<li>家庭和社会能为人才做的最好的事情，就是提供施展各种兴趣的环境【感谢爹娘】</li>
<li>寻找适合自己兴趣的环境，并把自己的基因发扬光大，这不就是进化论告诉我们的人生意义吗？</li>
</ul>
<h2 id="上网能避免浅薄吗？"><a href="#上网能避免浅薄吗？" class="headerlink" title="上网能避免浅薄吗？"></a>上网能避免浅薄吗？</h2><ul>
<li>高质量的读书要把自己沉浸在书中，有些地方反复看，还要记笔记</li>
<li>网上的链接、多媒体，反而分散注意力。</li>
<li>上网的关键在于<strong>要成为网络的主人，而不是成为超链接的奴隶。高效率的上网应该要有很强的目的性，不背无关信息左右</strong>。一个真正的智者不会让上网占用读书的时间，他应该要能经常地平静地深入思考。</li>
</ul>
<h2 id="高效冲浪的方法"><a href="#高效冲浪的方法" class="headerlink" title="高效冲浪的方法"></a>高效冲浪的方法</h2><p>由于大多数新闻、文章都是鸡肋信息，因此作者提出了他的阅读方法</p>
<ul>
<li>挑选新闻，看到感兴趣就打开新的标签页</li>
<li>一条一条快速浏览，然后迅速关闭，而觉得值得仔细细读的，也是要先速读，但不要关闭，或者说保存</li>
<li>最后决定细度的文章就很有限了，找一段时间把它们仔细读掉。</li>
</ul>
<p>这种先集中再选择叫做<strong>宽框架</strong>，而所谓<strong>窄框架</strong>，就是遇到一个东西做一次决策。明显前者是要更好的，因为首先第一个好东西很多，不可能都选。第二个就是把所有东西都摆在桌面上对比，也许有的“好东西”相比之下就没那么好了，可以丢弃。</p>
<ul>
<li>运用宽框架，可以改进读书方法。例如有些时候花了时间读了烂书而没有读到好书，可以的一种做法就是把所有感兴趣的书列表，然后每次要看新书的时候从列表中挑选最想看的一本。【这个方法我也和作者不谋而合了，就是豆瓣】</li>
</ul>
<h2 id="笔记本就是力量"><a href="#笔记本就是力量" class="headerlink" title="笔记本就是力量"></a>笔记本就是力量</h2><p>不要再质疑写笔记、写博客的作用了。</p>
<ul>
<li>好笔记是主动的，是对自己思想的记录。</li>
<li>笔记本当然可以看成是电脑的硬盘，但笔记本除了存储之外，还能帮我们思考。【有人错误的认为 CPU 和 内存性能好就行了，而硬盘无关紧要】</li>
<li>一个人所有的知识都可以用知识引擎搜到的话，凭什么要给更多的工资？知识，不能仅仅机械地“存”在脑子里，而要以一种个性化的结构“长”在你脑子里，也就是所谓的知识体系。记笔记，记下自己个性化的理解，就有助于这个过程。</li>
<li>记笔记最直接的目的就是<strong>形成自己的知识体系</strong>，改变自己看待事物的眼光。</li>
</ul>
<p>读书笔记方法论（钱钟书）：</p>
<ul>
<li>做一遍笔记的时间约莫是读书时间的一倍。</li>
<li><strong>借的书还掉，买的书送人，只有笔记永远留存。</strong>【大道至简】</li>
<li>凡读书笔记，必有书目和重要版本的原文页数，论文也记下刊物、出版信息，方便日后引用。【我也有这个习惯】</li>
<li><p>平时自己的<strong>心得体会</strong></p>
</li>
<li><p>写读书笔记的时候，才会发现自己很多自己读第一遍没有读出来的意思。【这就是读书笔记帮你思考的印证】</p>
</li>
<li>笔记还能把新的知识和自己已有的知识联系起来的功能【这很重要，就比如背单词通过背例句和英英释义把新单词和背过的单词联系起来，能加强记忆效果】，让知识“长”在自己大脑上。</li>
<li>世界上有很多爱藏书（不读书）的人，而<strong>真正的高手只藏笔记</strong>。把一本书买回来放到书架上，不等于拥有这本书。保存一个pdf文件到电脑里，不等于拥有这篇文章。<strong>只有把他们全部拆开撕碎，细嚼慢咽，再重新组合成自己的东西，它才真正地属于你。</strong></li>
</ul>
<h2 id="用强力研读书"><a href="#用强力研读书" class="headerlink" title="用强力研读书"></a>用强力研读书</h2><ul>
<li>读书目的是<strong>获得见识</strong>和<strong>学习高水平的思维方法</strong>（经常读书惑而不解，但应该要想到读书的真正目的是什么）</li>
<li>读书提高人的思想内力，也就是对世界的理解和见识。</li>
<li>读书是看完之后能够加深自己对于某一个领域的理解，能够获得一种智慧上升的感觉。</li>
<li>总而言之，读书不是为了考试，读【非名著】小说和各种考试辅导书在作者看来不算读书【在我看来，是的】</li>
<li>阅读有三个层次，为娱乐、为信息、为理解。<strong>读书应该以我为主，而不是以书为主。</strong></li>
</ul>
<p>强力研读：作者提出的一个与刻意学习类似的读书方法。</p>
<ol>
<li>不好玩。读书不是为了娱乐和休息，而是为了理解某个我们原来不懂的东西而读书，以严肃的态度，非得把一本书融会贯通到“长”到我们脑子里不可。读书是累的，写读书笔记是正经的。</li>
<li>用时少。要把精力充沛而不受打扰的时间段留给读最好的书。【其实是用时少but高强度】</li>
<li>不追求快。处在我们学习区的好书，要仔细地研读完。如果很快能阅读完一本书，要么就是舒适区不需要读，要么就是价值低没必要读。</li>
</ol>
<p>核心是<strong>读书笔记</strong>。</p>
<ul>
<li>读书笔记的一个重大作用就是在于日后能以最快的速度重温这本书，直接看笔记即可。所以做笔记要以<strong>能取代原书的标准来做</strong></li>
</ul>
<ol>
<li>清晰表现每一章的逻辑脉络。</li>
<li>写书中的亮点。</li>
<li>大量的自己的看法和心得。</li>
<li>发现这本书和以前读过的其他书和文章的联系。</li>
</ol>
<p>【难度从1-4依次增高，能做到的人凤毛麟角，但只有这么做才能把一本书的效用发挥到最大，而且回报是巨大的】</p>
<ul>
<li>①最重要的一定是要看出作者的逻辑脉络。“需要的是听众的理解而不是激情，听众应该是沉默的读者才好”、<strong>不要抄作者的话，用自己的语言把脉络写下了，就像画地图一样。</strong></li>
<li>②一语惊醒梦中人的亮点要记下来。</li>
<li>③写下自己对此书的评论，记录自己的想法，就好像和作者对话。我的方法就是把自己的评论放在括号中【】，翻阅笔记的时候哪些是书中的，哪些是自己的，一目了然。【这个方法学到了！】低水平的读书人画满重点记号，高水平的读书人写满了批注。这非常宝贵，因为如果你不马上记下来，就会忘记。多年以后，翻阅笔记的时候，心得灵感比原书更有价值。</li>
<li>④当你读过的书多到一定程度，你会发现书和书之间是有联系的，极少有一本书遗世而独立，新知识往往都要建立在旧知识之上。【这是真的，也是只有在读的书比较多了才能有这种体会】一个善于读书的人对于这种来龙去脉是非常敏感的。如果你读的书非常多，你甚至能有一段更难得的经历：体验人类知识的进步（某一个结论在前几年没有定论，然而现在有人写了另一篇论文，给出了有力的证据，或者说推翻了原来的结论。到了这个层次，其实你已经和作者完全平等了，甚至你也可以和他们一较高下了——做科研，写篇文章发表出来！）【希望有一天我也能达到这个水平】</li>
</ul>
<p>最后，记笔记是对一本书最大的敬意。<strong>它不是书评，不必要在乎文笔，完全是写给自己而不是写给别人看的。</strong>【我觉得很多人没这个习惯就是误解了一定要很有文笔才写读书笔记】笔记就算达不到要求，简单的摘抄也有帮助，起码加深记忆。【就算是单纯整理所学知识的读书笔记，也是很有用的。而且如果不去做，是不能达到更高的水平的】</p>
<ul>
<li><strong>世界上有很多毕读书更重要的事情。读书和做事之间，做事优先。</strong>【非常受用】</li>
</ul>
<h1 id="霍金的答案"><a href="#霍金的答案" class="headerlink" title="霍金的答案"></a>霍金的答案</h1><p>【这一章作者讲了一些小故事和例子，介绍什么是科学的思维】</p>
<h2 id="摆脱童稚状态"><a href="#摆脱童稚状态" class="headerlink" title="摆脱童稚状态"></a>摆脱童稚状态</h2><ul>
<li>科学家强调事实和证据。</li>
<li>用证据去反驳一个理论比较简单。【一个反例】</li>
<li>但想用证据去建立一个理论，非常难【显而易见】。只有运气好的时候，科学家才能从大量的事实中发现一些有趣的规律，以至于可以向科学理论的目标前进。</li>
</ul>
<p>相关性研究。比如：吸烟对肺癌的作用</p>
<p>设置病例组和对照组，然后考察两组人在生活习惯上的不同。如果能发现患有肺癌的人中烟民比例显著高于没有肺癌的人中烟民的比例，就得到了一个肺癌与吸烟的相关性。相关性只是科研的初级阶段，尽管这样，它也已经超越了人们的思维本能。用大规模统计来发现相关性这个最简单的科学方法，是我们摆脱童稚状态的第一步。</p>
<p>大多数人没有相关性的思想。例如：</p>
<blockquote>
<p>中国 80% 的青少年犯罪与网瘾有关，中国 20% 的网瘾少年有违法犯罪行为。…… XXX关押的1500名少年犯中有 80% 是由于网瘾造成的。</p>
</blockquote>
<p>我们能否根据这些数据得到网瘾人群比没有网瘾的人群更容易犯罪呢？</p>
<p>其实不能。这个错误就是<strong>没有设置对照组</strong>，缺少了<strong>没有网瘾的青少年群体的犯罪率</strong>，以及<strong>没有犯罪的青少年群体的网瘾率</strong>。这就是非常常见的错误。还比如，你列举再多的“发达的民主国家”也得不出发达与民主的相关性，因为你没有设置对照组，也就是你没有统计“不发达的民主国家”、“不民主的发达国家”、“既不发达也不民主的国家”</p>
<p>【还可以把 “网瘾” 改成 “吸烟”，“青少年犯罪” 改成 “肺癌”，看看上面那个表述换了之后是什么样子：</p>
<p>中国 80% 的青少年犯罪与网瘾有关，中国 20% 的网瘾少年有违法犯罪行为。</p>
<p>中国 80% 的肺癌与吸烟有关，中国 20% 的烟民得了肺癌</p>
<p>能仅凭这句话得出吸烟与肺癌有关吗？现在看出来错误在哪了，如果没有对照组，如果普通人也是 20% 得肺癌，那怎么能说吸烟与肺癌有相关性呢。对照组的作用是很大的，然而却被很多人忽略并断章取义。】</p>
<p>发现相关性，已经是足够发表的科学成就。但相关性结论并不能指导生活。根据肺癌与吸烟的正相关性，如果你不想得肺癌，那么根据这个相关性能否退退你是否应该戒烟呢？</p>
<p><strong>还是不能</strong>。因为根据“吸烟的人更容易得肺癌”，“肺癌患者大部分爱吸烟”也推不出“吸烟导致肺癌”这个结果。<strong>相关性未必代表因果关系，这是非常重要的思维。</strong> 因果性也不全是科学的目标，科学不是一本菜谱上面写满XX会导致YY。除了因果，还必须有机制，能解释为什么有这种现象。【这种机制，可验证可重现】。课题做到了这个程度才真正超越了“集邮”阶段。</p>
<p>不管调查到什么情况，都是对真实世界的管中窥豹，科学研究研究的是有限的真理。【但是，科学思维带来的思维方式的转变，这种机制，是非常重要的，也是本篇的标题“摆脱童稚状态”的关键。】</p>
]]></content>
      <categories>
        <category>ReadingNote</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之虚函数和联编</title>
    <url>/2017/06/07/Virtual-Function-and-Binding/</url>
    <content><![CDATA[<p>RatedPlayer继承示例很简单。派生类对象使用基类的方法，并未做任何修改。然而，可能遇到希望同一个方法在基类和派生类中的行为是不同的。即希望方法的行为应取决于调用对象，也是一种<strong>多态</strong>（Polymorphism）——具有多种形态。有两种重要机制可以使用多态公有继承：</p>
<p>• 在派生类中重新定义基类方法。<br>• 使用虚方法。</p>
<h1 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h1><p>看一个普通银行账户类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string fullName;</span><br><span class="line">	<span class="type">long</span> acctNum;</span><br><span class="line">	<span class="type">double</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Brass</span>(<span class="type">const</span> string &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>,</span><br><span class="line">		<span class="type">double</span> bal = <span class="number">0.0</span>);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Deposit</span><span class="params">(<span class="type">double</span> amt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们对其进行继承，写出新的BrassPlus类，这个类的用户新增了向银行透支取款的功能。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BrassPlus</span> : <span class="title">public</span> <span class="title">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">double</span> maxLoan;</span><br><span class="line">	<span class="built_in">double</span> rate;</span><br><span class="line">	<span class="built_in">double</span> owesBank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BrassPlus(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="built_in">long</span> an = <span class="number">-1</span>,</span><br><span class="line">		<span class="built_in">double</span> bal = <span class="number">0.0</span>, <span class="built_in">double</span> ml = <span class="number">500</span>,</span><br><span class="line">		<span class="built_in">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">	BrassPlus(<span class="keyword">const</span> Brass &amp; ba, <span class="built_in">double</span> ml = <span class="number">500</span>,</span><br><span class="line">		<span class="built_in">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span>()<span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span>(<span class="params"><span class="built_in">double</span> amt</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ResetMax</span>(<span class="params"><span class="built_in">double</span> m</span>)</span> &#123; maxLoan = m; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ResetRate</span>(<span class="params"><span class="built_in">double</span> r</span>)</span> &#123; rate = r; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ResetOwes</span>()</span> &#123; owesBank = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>两个类虽然都声明了<code>ViewAcct</code>和<code>Withdraw</code>方法，但很明显两个类对象的方法行为是不同的。所以在声明时使用了关键字<code>virtual</code>，这些方法被称为虚方法。（定义的时候不需要写virtual）使用<code>virtual</code>，程序将根据引用或指针所指向的<strong>对象类型</strong>选择方法。如果ViewAcct不是虚的，程序是根据引用或指针<strong>本身</strong>的类型来选择方法。例如：<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Brass</span> zc(<span class="string">&quot;zc&quot;</span>, <span class="number">381299</span>, <span class="number">4000</span>.<span class="number">00</span>);</span><br><span class="line"><span class="attribute">BrassPlus</span> wb(<span class="string">&quot;wb&quot;</span>, <span class="number">382288</span>, <span class="number">3000</span>.<span class="number">00</span>);</span><br><span class="line"><span class="attribute">Brass</span> &amp; r1 = zc;</span><br><span class="line"><span class="attribute">Brass</span> &amp; r2 = wb;</span><br><span class="line"><span class="attribute">r1</span>.ViewAcct();</span><br><span class="line"><span class="attribute">r2</span>.ViewAcct();</span><br></pre></td></tr></table></figure><br>上述代码中，如果<code>ViewAcct()</code>不是虚方法的话，引用变量的类型是Brass，所以会调用<code>Brass::ViewAcct()</code>。如果<code>ViewAcct()</code>是虚的，上述代码段的执行情况是：r2引用的是一个BrassPlus对象，所以使用<code>BrassPlus::ViewAcct();</code></p>
<p>当将基类中的某一成员函数声明为虚函数后，派生类中的同名函数（函数名相同、参数列表完全一致、返回值类型相关）自动成为虚函数。然而在派生类中继续使用virtual来指明那些函数是虚函数是一个好方法。</p>
<p>第17行基类声明虚析构函数，虽然该析构函数不执行任何操作。但这样是为了确保释放派生对象时，按正确的顺序调用析构函数。</p>
<p>为什么需要虚析构函数？使用<code>delete</code>释放由<code>new</code>分配的对象的代码说明了为何基类需要包含一个虚析构函数。如果析构函数不是虚的，如果指针指向了一个<code>BrassPlus</code>对象，但还是意味着只会调用<code>Brass</code>的析构函数。如果析构函数是虚的，指针指向的是<code>BrassPlus</code>对象，那么将调用<code>BrassPlus</code>的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数调用序列。</p>
<h2 id="使用基类指针去调用"><a href="#使用基类指针去调用" class="headerlink" title="使用基类指针去调用"></a>使用基类指针去调用</h2><p>让我们完成两个类的类设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::ios_base::fmtflags format;</span><br><span class="line"><span class="keyword">typedef</span> std::streamsize precis;</span><br><span class="line"><span class="function">format <span class="title">setFormat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(format f, precis p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">format <span class="title">setFormat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cout.<span class="built_in">setf</span>(std::ios_base::fixed,</span><br><span class="line">		std::ios_base::floatfield);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(format f, precis p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout.<span class="built_in">setf</span>(f, std::ios_base::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//brass methods</span></span><br><span class="line">Brass::<span class="built_in">Brass</span>(<span class="type">const</span> string &amp; s, <span class="type">long</span> an, <span class="type">double</span> bal)</span><br><span class="line">&#123;</span><br><span class="line">	fullName = s;</span><br><span class="line">	acctNum = an;</span><br><span class="line">	balance = bal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Brass::Deposit</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (amt &lt; <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不能存入数量为负的钱&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		balance += amt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Brass::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//set up ###.## format</span></span><br><span class="line">	format initialState = <span class="built_in">setFormat</span>();</span><br><span class="line">	precis prec = cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (amt &lt; <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不能取出数量为负的钱&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (amt &lt;= balance)</span><br><span class="line">		balance -= amt;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;你的取款额: &quot;</span> &lt;&lt; amt &lt;&lt; <span class="string">&quot; 大于存款余额&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">restore</span>(initialState, prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Brass::Balance</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Brass::ViewAcct</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	format initialState = <span class="built_in">setFormat</span>();</span><br><span class="line">	precis prec = cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;客户： &quot;</span> &lt;&lt; fullName &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;卡号： &quot;</span> &lt;&lt; acctNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;存款： $&quot;</span> &lt;&lt; balance &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">restore</span>(initialState, prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BrassPlus methods</span></span><br><span class="line">BrassPlus::<span class="built_in">BrassPlus</span>(<span class="type">const</span> string &amp; s, <span class="type">long</span> an, <span class="type">double</span> bal, </span><br><span class="line">		<span class="type">double</span> ml, <span class="type">double</span> r) : <span class="built_in">Brass</span>(s, an, bal)</span><br><span class="line">&#123;</span><br><span class="line">	maxLoan = ml;</span><br><span class="line">	owesBank = <span class="number">0.0</span>;</span><br><span class="line">	rate = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BrassPlus::<span class="built_in">BrassPlus</span>(<span class="type">const</span> Brass &amp; ba, <span class="type">double</span> ml, <span class="type">double</span> r)</span><br><span class="line">			: <span class="built_in">Brass</span>(ba)</span><br><span class="line">&#123;</span><br><span class="line">	maxLoan = ml;</span><br><span class="line">	owesBank = <span class="number">0.0</span>;</span><br><span class="line">	rate = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	format initialState = <span class="built_in">setFormat</span>();</span><br><span class="line">	precis prec = cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	Brass::<span class="built_in">ViewAcct</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最大贷款额： &quot;</span> &lt;&lt; maxLoan &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;需向银行还款额： &quot;</span> &lt;&lt; owesBank &lt;&lt; endl;</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;贷款利率： &quot;</span> &lt;&lt; <span class="number">100</span> * rate &lt;&lt; <span class="string">&quot;%\n&quot;</span>;</span><br><span class="line">	<span class="built_in">restore</span>(initialState, prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	format initialState = <span class="built_in">setFormat</span>();</span><br><span class="line">	precis prec = cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> bal = <span class="built_in">Balance</span>();</span><br><span class="line">	<span class="keyword">if</span> (amt &lt;= bal)</span><br><span class="line">		Brass::<span class="built_in">Withdraw</span>(amt);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (amt &lt;= bal + maxLoan - owesBank)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> advance = amt - bal;</span><br><span class="line">		owesBank += advance*(<span class="number">1.0</span> + rate);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;透支款： &quot;</span> &lt;&lt; advance &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;透支款需要交纳利息： &quot;</span> &lt;&lt; advance*rate &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">Deposit</span>(advance);</span><br><span class="line">		Brass::<span class="built_in">Withdraw</span>(amt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;需要取出的钱超过了透支额度，交易取消&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">restore</span>(initialState, prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Brass <span class="title">zc</span><span class="params">(<span class="string">&quot;zc&quot;</span>, <span class="number">381299</span>, <span class="number">4000.00</span>)</span></span>;</span><br><span class="line">	<span class="function">BrassPlus <span class="title">wb</span><span class="params">(<span class="string">&quot;wb&quot;</span>, <span class="number">382288</span>, <span class="number">3000.00</span>)</span></span>;</span><br><span class="line">	zc.<span class="built_in">ViewAcct</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	wb.<span class="built_in">ViewAcct</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;向wb的账户存入1000元&quot;</span> &lt;&lt; endl;</span><br><span class="line">	wb.<span class="built_in">Deposit</span>(<span class="number">1000.00</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;wb的余额： &quot;</span> &lt;&lt; wb.<span class="built_in">Balance</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;从zc的账户中取出4200元&quot;</span> &lt;&lt; endl;</span><br><span class="line">	zc.<span class="built_in">Withdraw</span>(<span class="number">4200.00</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;zc的余额： &quot;</span> &lt;&lt; zc.<span class="built_in">Balance</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;从wb的账户中取出4200元&quot;</span> &lt;&lt; endl;</span><br><span class="line">	wb.<span class="built_in">Withdraw</span>(<span class="number">4200.00</span>);</span><br><span class="line">	wb.<span class="built_in">ViewAcct</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的执行结果如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170607200811340-1351826666.png" alt=""></p>
<p>假设要同时管理<code>Brass</code>和<code>BrassPlus</code>账户，如果能用同一个数组来保存，那再好不过了。然而这是不可行的，因为数组要求所有元素类型相同。Brass和BrassPlus是不同的类型。然而可以创建指向<code>Brass</code>的指针数组。这样，每个元素类型都相同。而且用到了C++的继承特性，因此Brass指针既可以指向Brass对象，也可以指向BrassPlus对象。这就是<strong>多态性</strong>。</p>
<p><strong>根据基类引用或指针去调用，这才是使用的精髓，如果不定义基类的指针去使用，没有太大的意义。</strong></p>
<p>我们改成如下的main函数：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">const <span class="type">int</span> CLIENTS = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	Brass *p_clients[CLIENTS];</span><br><span class="line">	std::string <span class="keyword">temp</span>;</span><br><span class="line">	long tempnum;</span><br><span class="line">	<span class="type">double</span> tempbal;</span><br><span class="line">	<span class="type">char</span> kind;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;输入用户的姓名： &quot;;</span><br><span class="line">		getline(cin, <span class="keyword">temp</span>);</span><br><span class="line">		cout &lt;&lt; &quot;输入用户的卡号： &quot;;</span><br><span class="line">		cin &gt;&gt; tempnum;</span><br><span class="line">		cout &lt;&lt; &quot;输入存款额： &quot;;</span><br><span class="line">		cin &gt;&gt; tempbal;</span><br><span class="line">		cout &lt;&lt; &quot;输入： 1 ：创建普通账户 或者 &quot;</span><br><span class="line">			&lt;&lt; &quot;输入： 2 ：创建可以透支取款的账户： &quot;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (cin &gt;&gt; kind &amp;&amp; (kind != <span class="string">&#x27;1&#x27;</span>&amp;&amp;kind != <span class="string">&#x27;2&#x27;</span>))</span><br><span class="line">			cout &lt;&lt; &quot;输入有误，请输入1或2： &quot;;</span><br><span class="line">		<span class="keyword">if</span> (kind == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">			p_clients[i] = <span class="built_in">new</span> Brass(<span class="keyword">temp</span>, tempnum, tempbal);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">double</span> tmax, trate;</span><br><span class="line">			cout &lt;&lt; &quot;请输入可透支金额上限： $&quot;;</span><br><span class="line">			cin &gt;&gt; tmax;</span><br><span class="line">			cout &lt;&lt; &quot;请输入利率（十进制小数）： &quot;;</span><br><span class="line">			cin &gt;&gt; trate;</span><br><span class="line">			p_clients[i] = <span class="built_in">new</span> BrassPlus(<span class="keyword">temp</span>, tempnum, tempbal,</span><br><span class="line">				tmax, trate);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (cin.<span class="keyword">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p_clients[i]-&gt;ViewAcct();</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> p_clients[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;\nDone\n&quot;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第8行声明的基类指针数组<code>Brass *p_clients[CLIENTS];</code>是精髓。程序的执行结果如下图：</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170607200812903-1802856210.png" alt=""></p>
<h1 id="联编"><a href="#联编" class="headerlink" title="联编"></a>联编</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>程序调用函数时，将执行哪个代码块呢？编译器负责这个问题。</p>
<p>在C语言中，这非常简单，因为每个函数名都对应一个不同的函数。在C++中，由于有重载，这项任务更复杂。编译器必须查看参数才能确定到底使用那个函数。</p>
<p>将源代码中的函数调用解释为执行特定的代码块称为函数名<strong>联编</strong>（binding）。在编译过程中进行联编被称为<strong>静态联编</strong>（static binding），又称为早期联编。</p>
<p>然而，虚函数让这项工作更困难。在上面的第main函数里，使用哪一个函数不是在编译时就能确定的，所以编译器必须能够让程序运行时选择正确的虚方法的代码块，这就叫<strong>动态联编</strong>（dynamic binding），又称晚期联编。</p>
<h2 id="指针和引用类型的兼容性"><a href="#指针和引用类型的兼容性" class="headerlink" title="指针和引用类型的兼容性"></a>指针和引用类型的兼容性</h2><p>动态联编与通过指针和引用的调用方法有关。</p>
<p>我们知道通常是不允许将一种类型的地址赋给另一种类型的指针，不允许一种类型的引用指向另一种类型。例如：<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> <span class="keyword">x</span> <span class="operator">=</span> <span class="number">2.5</span><span class="comment">;</span></span><br><span class="line">int *pi <span class="operator">=</span> &amp;<span class="keyword">x</span><span class="comment">;//not allowed</span></span><br><span class="line">long &amp; r <span class="operator">=</span> <span class="keyword">x</span><span class="comment">;//not allowed</span></span><br></pre></td></tr></table></figure><br>在类中，指向基类的引用或指针可以引用派生类对象，不必进行显示类型转换。将派生类引用或指针转换为基类引用或指针被称为<strong>向上强制转换</strong>（upcasting）。</p>
<p>该规则是<code>is-a</code>关系的一部分。一切<code>BrassPlus</code>对象都是<code>Brass</code>对象，因为它继承了所有可以对<code>Brass</code>对象执行的操作，这些操作都可以对<code>BrassPlus</code>对象执行，而不必担心出现任何的问题。向上强制转换是可以传递的。也就是说如果又从<code>BrassPlus</code>类派生出<code>BrassPlusPlus</code>类，那么<code>Brass</code>指针可以引用<code>Brass</code>对象、<code>BrassPlus</code>对象、<code>BrassPlusPlus</code>对象。</p>
<p>相反的过程，基类引用或指针转换为派生类引用或指针，成为<strong>向下强制转换</strong>（downcasting），如果不显示转换，则<strong>是不允许的</strong>。原因是<code>is-a</code>的关系通常是不可逆的。例如从学生类<code>Student</code>派生出大学本科学生类<code>Undergraduate</code>，你在需要用到学生类的一个对象时，你当然可以使用一个大学生。而你需要一个大学生时，随随便便找一个学生是不符合要求的。</p>
<p>隐式向上强制转换，需要动态联编。C++使用虚函数来满足这种要求。</p>
<h2 id="虚函数和动态联编"><a href="#虚函数和动态联编" class="headerlink" title="虚函数和动态联编"></a>虚函数和动态联编</h2><p>编译器对非虚方法使用静态联编（根据指针or引用的类型调用方法）。如果将方法声明为虚的，则将根据对象的类型调用方法。编译器对虚方法使用动态联编。</p>
<p>大多情况下，动态联编很好，你可能就问了：</p>
<p>• 为什么要有两种类型的联编？<br>• 既然动态联编好，为什么不把它设置成默认的？<br>• 动态联编是如何工作的？</p>
<p><strong>效率</strong>：不要为不使用的特性付出代价。如果派生类（BrassPlus）不重新定义基类方法，就不需要动态联编。在这种情况下，使用静态联编更合理，效率也更高。</p>
<p><strong>概念模型</strong>：例如<code>Brass::Balance()</code>就不该重新定义。有两方面好处：第一提高效率，第二，指出不要重新定义该函数。<strong>仅将那些预期被重新定义的函数声明为虚的</strong>。与现实世界的很多方面一样，类设计并不是一个线行过程。</p>
<h1 id="虚函数注意事项"><a href="#虚函数注意事项" class="headerlink" title="虚函数注意事项"></a>虚函数注意事项</h1><p>• 构造函数不能是虚函数。<br>创建派生类对象时，将调用派生类构造函数，而不是基类构造函数，然后派生类构造函数再使用基类的一个构造函数。这种顺序不同于继承的顺序。因此把构造函数声明为虚函数是没什么意义的。</p>
<p>• 析构函数应当是虚函数，即使析构函数不作任何操作。除非不做基类。<br>如果<code>Employee</code>类是基类，<code>Singer</code>是派生类，如果是默认的静态联编，如果<code>delete</code>一个<code>Singer</code>对象，调用的也是<code>~Employee()</code>，这会释放掉<code>Singer</code>对象中<code>Employee</code>部分指向的内存，但不会释放新的成员指向的内存。如果析构函数是虚的，则会先调用<code>~Singer()</code>，然后调用<code>~Employee()</code>。</p>
<p>• 友元不能是虚函数。<br>友元不是类成员函数，只有类成员函数才能是虚函数。</p>
<p>• 如果重新定义继承的方法，应确保与原来的原型完全相同。但如果返回的类型是基类引用或指针，可以修改为指向派生类的引用或指针。</p>
<p>• 如果基类函数声明被重载了，则应在派生类中重新定义所有基类版本。</p>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="http://blog.chinaunix.net/uid-26851094-id-3327323.html">C++的精髓：虚函数</a></li>
<li><a href="https://www.zhihu.com/question/23971699">C++的虚函数有什么用？</a></li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>我不读硕士的几个理由</title>
    <url>/2019/06/02/Why-I-dislike-research/</url>
    <content><![CDATA[<p>现在的我已经大三下了，也到了对将来要有所打算的时候。尤其是因为我是一个因为转专业降了一级的选手，和我一起高考的，我的同龄人，都已经纷纷决定好了自己的未来，保研的或考研成功的、要二战的、工作的、出国……最近的自己，对于读研也有了一定的想法，想写一篇文章记录一下。</p>
<p>在我看来，对于“为什么读研？”这个问题，也就是，<strong>读研的理由，大概是如下两点</strong>：</p>
<ol>
<li>是为了做科研/为了做有意义的研究/为了做研究/etc.。</li>
<li>是为了取得硕士学位后可以找到一份更好的工作。</li>
</ol>
<p>我的意思是，询问我周围大多数决定读研究生的人，（特指国内研究生，而不是出国）问他们决定读研/考研的原因是什么，都可以归纳到两类中的一类。但其中很大一部分比例是选择了第二条，不过我个人觉得，第一条也是存在的，而且也是非常重要的一点理由。我不否认还会有其他的理由（不属于上述二类），<strong>但我们姑且认定大致是这两点理由</strong>。既然做出读研的决定，理由是两点其中之一，<strong>那么如果将这两条理由反驳，使之都不成立，那么就应该不读研</strong>。</p>
<h1 id="做研究多难？"><a href="#做研究多难？" class="headerlink" title="做研究多难？"></a>做研究多难？</h1><p>在我看来，只有极少数、极少数的人可以说是符合第一条理由的。</p>
<p>由于我自己在实验室呆的时间也算蛮久，知道了科研是怎么一回事。我反驳第一条理由的，也就是说，我的论点阐述如下：<strong>绝大多数人，做不出来有意义的研究</strong>。做研究，做研究，但是做的研究的成果和价值在哪里？要做出真正有意义的研究，做出有价值的研究，做出“好研究”，其中的难度各位应该是晓得的。就是，如果要用“好”来形容一个研究，要给研究加上“好”这个形容词，不知道各位有没有直觉般的体会——这是一件多么 valuable 的事情啊！同时，又是多么困难的事情。有句话是这么说的“没有毕不了业的研究生”，这也是我在实验室里听到的，意思是不管怎样，读硕士，不管怎样，也不会很难毕业。所以这就说明什么呢，作为一个研究人员，很少没有不毕业的，就是体现不管你的毕业论文水平层次多么地次，也都能毕业。绝大部分的硕士生，做出来的研究，其实根本没人会看。我也不说什么别的了，你费劲心血写出来的东西，发到一个什么期刊或者会议上，要么就是影响因子零点零几，要么就是根本没人会引用，要么就是在毕业答辩的时候会被人问几个问题之外根本就无人问津，简单来说就是没人会看，而且实际上，也大概率不会对CS业界有什么影响，没有多大用处，这是多么悲哀的一件事情？（在这里我不想论证“大多数的硕士生的论文的实际用处多大”这一点）对于我来说，我为什么要花三年的时间去写这些 nonsense，为了一个master degree？引用我的朋友的一句话，他说他对论文或者专利没有任何的迷信。我想在实验室的经历带给我的也是类似的体会。（这一点可能非常 offensive，若有冒犯，我先提前道歉，不过这是我认为的情况，若你有更好的意见，欢迎对我提出，我会非常感谢）</p>
<p>对我感触颇大的一件事情就是我自己作为负责人的国创项目。关于项目的具体内容，我不想详细阐述太多。暑假的某一天，我在实验室里看项目相关的东西，在官方手册上，讲到了一个工具的一个关键算法，这个手册还很有意思，说这是来源于某篇博士论文。于是出于兴趣我也点开看了一下，这篇论文是上世纪 90 年代斯坦福的一个博士的 phd 毕业论文。简单地来说，路由器里根据目的 IP 地址来查找路由表下一跳的信息，做这个事情，的，那个，算法，就是他做的，就是 Stanford phd 的毕业论文！我当然没有详细地去看论文，但是这件事绝对绝对绝对给我留下了深刻的印象。上世纪九十年代，互联网不是很流行的时候，斯坦福的博士生，在做的是什么研究？是路由表里的查表算法，这种研究的价值不用我说了吧，如果没有这个算法，网速会大大减慢。再和自己在做的东西一比，自己做的东西，我能说什么？？？科研的日常（水平太次，如有不妥希望能指点一二），选一个topic，读很多的这个topic下面的文献，related work，然后“突然想到一个idea”，接着做一些实验得来的数据就形成了一篇paper。在这个过程中，我自己的work有什么了不起的么？我觉得真的不算什么。我一个学生能想到的idea，真的就没有其他人想得到？业界的公司不会有更好的解决方案（这也是我倾向于进大公司工作的原因）？再说说，Stanford phd 的研究，可以说是能改变世界也不为过吧。而我做的东西，可以说屁都不是。我的第二个论据就是非常现实的一点，就是如果要做出有意义的研究，能改变世界的研究，那么你应该大概率是在top院校，甚至是世界top院校，top中的top，在中国就是top2吧，我国教育资源你也懂（你说top5也行，你说行就行，当然top5能有十几所），而有多少人可以在top院校做科研呢（鄙人实力太差，一所烂校）？<strong>如果你不在top科研院所，那么你基本做不出来好研究（不说改变世界了，只是好研究）</strong>。科研的马太效应，再明显不过了，我想也不需要我过多赘述。</p>
<p>刚进实验室的时候，我非常地苦恼，觉得自己学习进度很慢，做不出来科研。没错，我当时苦恼的事情就是这个（笑），有一个词叫做 peer pressure，是我最真切的感受。不过，后来我就想通了（哈哈，好像非常云淡风轻）。<strong>科研，的确是一个好事，但不是所有的人都要去做。</strong>科研这件事情，是好事，这是肯定的。但是<strong>一件事情是好事，不能推出，所有人都需要去做这件事情</strong>。想通上述这个逻辑是非常重要的。我从两方面来论证这个论点。首先，我有一个设想，假设整个地球只有一万人而且都生活得比较临近，就好比都生活在大学城周围。那么这一万个人中最多10个人是在大学里做研究的，还要有9990人要做类似于厨师、建筑工人、环卫工人、商人、……等等等等，我这里的意思并不是觉得这些职位低人一等，或者做研究是脑力工作高人一等，而是这9990人是维持这个社会运作的必不可少的各行各业，是9990人的存在才允许了这10个人能做研究，因为各位也都知道做研究需要比较充裕的时间，不必为生活奔波，才能有所成就。你认为是这10个人其中之一么？我最反感的就是如下的论调“只要XX了就能XXX”、“我们系里有个学姐/学长做了XXX研究、进了XXX公司”等等一系列类似成功学的言论，我除了把“幸存者偏差”这五个字甩他脸上之外真的没啥好说的。</p>
<p>其二，就是能够改变这个世界的，真正有突出贡献的研究，是少部分人完成的。举个例子，比如互联网，是一个改变了整个地球的研究，但是真正参与互联网的研究的实际人数也就几万十几万工程师。这个数量和整个地球的人数之比大概符合我上面的论调。当然你可能会说，互联网是需要很多人很多人的群策群力才能有今天的样子，我不置可否，我只想说，当谈到例如拥塞控制，万维网（WWW，http协议）等关键的创造，你会想起的也就是那一两个对应的最主要贡献者（天才）的名字。自己是不是天才，自己最清楚。如果你有志于做出非常优秀的研究，那么现阶段的你，应该是手握几篇paper的一个本科生。而不是一个正在准备考研，考本校或者考排名靠后的985，甚至是一个在准备二战的人。</p>
<p>科研，的确是一个好事，但不是所有的人都要去做。</p>
<h1 id="硕士学位真的保证你能找到好工作？"><a href="#硕士学位真的保证你能找到好工作？" class="headerlink" title="硕士学位真的保证你能找到好工作？"></a>硕士学位真的保证你能找到好工作？</h1><p>我的论点自然就是反驳这一条理由。</p>
<p>论据一，很多人读硕士是为了延迟进入社会三年。不具体解释了，太老生常谈了。</p>
<p>论据二，计算机专业本科毕业也有非常多的人能找到很好的，非常 promising 的工作（例如本科毕业进 Google）。反驳了上一条理由之后，如果你读硕士的原因是，master degree才能让我得到一份好工作，也就是说你的目标其实是为了进业界为了有一份好工作。那现实是 undergraduate 也能找到好工作，那我们的思路就应该是这样的：<strong>我应该如何努力，才能使我达到公司要求的标准？</strong>就像那位进 Google 的 undergraduate 一样。<strong>而不是只是思考：我要读 master</strong>。我这个可能说的有点简略，我有这个观点是因为，<strong>在我看来，读 master 就是为了，或者最主要的目的应该是，要做出好的研究，不然实在没有意义</strong>。反过来说，如果大多数人读硕士，做不出好的研究，就是为了找一份更好的工作。在对于这个“好工作”的定义相同的前提下，如果本科毕业就可以得到这个good job position，那么为什么要读 master，而不是应该去思考：公司需要的应聘者的能力究竟是什么？读硕士这个过程能好好地培养你这个能力吗？</p>
<p>论据三，不对，不是论据，而应该是客观事实了，就是 master degree 不保证你能找到好工作，而是你的一些能力达到了公司的要求，通过了公司的面试，你才得到了这份工作。是你的能力让公司挑中了你，而不是 master degree，我觉得在这里很多人本末倒置了。很多人会说，你没有master degree 你的简历关都过不了（诸如此类吧，很多很多特别多，“你没有 985211/一本/硕士/博士/海归……你就一定不能怎样怎样”），我个人反对这个看法。</p>
<p>下面是论据三，如果是为了找一个更好的工作，那么在实际业界的三年难道不比在一个普通的 985211 的三年“研究经历”更有用？更能够贴近现实的职场？更能够增进实际的工作经验？更能够有助于你获得你梦想的 job 和 career？关于学校多么脱离业界，计算机专业可能还好那么一点点，其他化生环材等专业更是不忍吐槽，CS 其实也是五十步笑百步，我这里也不论述了。</p>
<p>我支持：为了转专业跨考读研。</p>
<p>有的人说，我读研读博是为了到高校做老师。个人志趣，可以理解。</p>
<h1 id="采访同学关于此话题的看法"><a href="#采访同学关于此话题的看法" class="headerlink" title="采访同学关于此话题的看法"></a>采访同学关于此话题的看法</h1><p>我把这篇博文发给了若干同学，收录了他们的意见。</p>
<p>tianqiu 是我的同届同学，他主动放弃了保研资格。</p>
<blockquote>
<p>tianqiu：读研的动机你说了两条，对于我来说，我之前是有保研的想法，但是原因貌似并不在你说的这两条里面。我不怕找不到工作，怕的是因为学历的原因导致工资起点比别人低一个档次。我当时是这么想的，现在感觉不对，所以保研欲望越来越低了，如果接下来实习的公司能符合我对第一份工作的预期的话，应该就直接就业了。现在真的越想越觉得读研是一件“很没有意义”的事（对于90%的人来说），纯浪费时间吧，去公司感觉能学的实在太多了。</p>
</blockquote>
<p>评论：我觉得 对于保研的人读研，他们如果对于研究生阶段的思考没有涉及到我这两点的话，也许是这么想的：“保上了，不读白不读，先读着”</p>
<blockquote>
<p>tianqiu：对的，我之前是这么想的，现在感觉保上了反而可能是找罪受，比如逼你出产没营养的论文之类。我之前和我导师聊过，他本人也比较反感大学里这种论文养殖场的环境，所以他基本上是带学生做项目，然后论文就比较水，糊弄一下。这也是我比较喜欢她的一个原因。论文这东西真的是毒瘤，各个高校之间用这个来衡量彼此的差距，但是比的是数量而不是质量，然后底下老师学生都要受苦，恶性循环。</p>
</blockquote>
<p>评论：我觉得国外的培养模式就很有借鉴意义。1如果是对科研的有志之士，本科念完是应该直接读phd的，硕士对于外国人来说不像对中国人那么重要。外国人看清楚自己志向不在科学界本科毕了业就该工作了。2.很费解的一点是所有中国的硕士都要写论文，包括所谓专硕。而国外有授课为主的硕士，有项目为主的，比如美国的cs硕士明确了就是为职业化道路服务的。</p>
<blockquote>
<p>ljr：我觉得大部分人选择去读研的关键诉求在于，对现下的自己没有信心/不太能想象工作的自己，还能读书就继续吧/研究生学历有更大几率给自己一个比现在能拿到的更好的offer（不一定追求的是「好工作」，可能只是比现在更好）。往里深究可以发现：1.因为应试教育，毕业生在能力上往往没办法独当一面。2.任何公司都会优先更高学历者，因为没办法快速了解你，只好打标签，这样大家只好追求更高学历。hr毕竟通用，容易这么简单粗暴，技术面试官应该就不太管学历，但有可能面试了太多水平差的人降低效率，就和hr说提高门槛。3.平均学历和高学历人数提高是zz要求，觉得可以算是某种程度上的好大喜功。当然了，我也坚定认为cs专业不做研究而读研几乎无用</p>
</blockquote>
<p>评论：同意关于应试教育和招聘方面的弊病。关于大学生涯，大家没有掌握好的学习方法，在本科阶段白白浪费时间，凭什么就认为硕士的三年会对自己有一个质的飞跃？</p>
<blockquote>
<p>某学姐：你说的很对 可是真话不能说出来  之前我也有这个苦恼 我不过是个普通人罢了 我一点都不爱科研 明明是专硕却让我做着没有意义的研究</p>
</blockquote>
<p>:(</p>
<blockquote>
<p>wasdns：Part One：这个我认同，即使是博士，也做出的是很多灌水的工作；但是我认为灌水有利有弊，很多人的 paper 虽然应用不到实际场景中，但是提供一种有价值的思路，对于后来人是有所启发的，也有更多的选择。举个例子，当年 ethernet 和 ATM 竞争的时候，虽然 ATM 最后失败了，但是他的很多设计思路我相信对后来的很多设计都起到了影响。至于是不是在 top 院校才能做出好的论文，这个我觉得取决于两个因素，一个是个人一个是环境，环境没法改变，但是个人可以努力向上突破，比如中国第一篇 sigcomm 就是非 top 、比福大还差的院校的博士论文。</p>
</blockquote>
<p>评论：ATM可以说是为了Ethernet的出现做了一个重要的铺垫，但如今我们做的很多研究甚至不能算得上是一个重要成果的铺垫，但是重要成果的确不是一蹴而就的，可以说这导致了一个矛盾，因为我觉得绝大多数普通人做出来的东西甚至连“重要的铺垫”都算不上，只能是一些简单应用罢了。志趣不同导致极为不一样的看法和选择。</p>
<blockquote>
<p>Part TWO 硕士学位真的保证你能找到好工作？ 这个我觉得要看对象；如果是那种混日子的同学，那么在计算机领域硕士文凭含金量还是有一点的，可以帮助他在找工作时找到一份薪资好一点的工作；如果是积极向上的同学，我觉得没有什么影响，就算你是三本毕业，你的努力让你达到了那个水平，也会有好的结果。其实我觉得读硕读博本身是一个开阔眼界，拓宽视野的过程，优势在于毕业后会有更多的工作机会。</p>
</blockquote>
<p>评论：同意</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>非常有意思，十分推荐您在阅读完我这篇胡言乱语之后看一下下面的这两个很有意思的帖子，还有回复的内容也很精彩：</p>
<p><a href="https://www.1point3acres.com/bbs/thread-438895-1-1.html">经验总结 来美六年感悟 PhD科研+码农+生活</a><br><a href="https://www.1point3acres.com/bbs/thread-441060-1-1.html">经验总结 反驳 来美六年感悟PhD科研+码农+生活</a></p>
<p>做科研似乎在大学里算是“政治正确”的声音，就没有人不认为这是一件可以选择的事情，看看下面的回答吧。</p>
<p><a href="https://www.zhihu.com/question/286852301/answer/677097282">知乎的问题：什么样的人不适合做科研？</a></p>
<hr>
<p>写于 2019.6.2 晚 长沙</p>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>王小波杂文阅读摘抄</title>
    <url>/2019/03/19/Xiaobo-Wang-Essays/</url>
    <content><![CDATA[<p>好久没写博客了，最近读了王小波的杂文，做一些摘抄吧~</p>
<h1 id="《沉默的大多数》"><a href="#《沉默的大多数》" class="headerlink" title="《沉默的大多数》"></a>《沉默的大多数》</h1><h2 id="思维的乐趣"><a href="#思维的乐趣" class="headerlink" title="思维的乐趣"></a>思维的乐趣</h2><p>二十五年前，我到农村去插队时……最大的痛苦是没书看，……除此之外，还得不到<strong>思想的乐趣</strong>，……感到自己的生命被剥夺了。</p>
<p>我所在的地方有军代表关着我们，我现在认为，他们是一批<strong>单纯的好人</strong>。但是，在我一生里，再也没有谁比他们使我更加痛苦过了。他们认为，所谓思想的乐趣，就是一天二十四小时都用Maonism来占领……</p>
<p>一个人倘若需要从思想中获得快乐，那么他的<strong>第一个欲望就是学习</strong>。……读到思想的乐趣，我就想到我父亲的遭遇，……每当他企图立论时，都需要在大一统的官方思想体系中找自己的位置……结果他虽然热爱科学且很努力，但在一生却没有得到思维的乐趣。这正是因为在那些年代，有人想把中国人的思想搞得彻底无味。我们这个国家里，只有很少的人觉得思想有乐趣，却有很多的人感受过思想代来的恐慌。</p>
<p>假如一个人每天吃一样的饭，干一样的活，再把八个样板戏翻过来倒过去地看，看到听了上句知道下句的程度，就值得我最大的同情。……<strong>在生活其他的方面，某种程度的单调、机械是必须忍受的，但是思想绝对不能包括在内……在我们生活的这个世界上，最大的不幸就是有人完全拒绝新奇。</strong></p>
<p>知识虽然可以带来幸福，但假如把它压缩成药丸子灌下去，就丧失了乐趣……那是我不能管的事，我只是对孩子表示同情……教条……最大的痛苦莫过于总有人想用种种理由<strong>消灭幸福所需要的参差多态。</strong>……出于功利动机改变人的思想，正如为了某个人的幸福而把他杀掉一样，言之不能成理。</p>
<p>想当年，我在军代表眼里，也是很低下的人，<strong>他们要把自己的思想方法，生活方式强加给我，这也是一种脑移植</strong>。……</p>
<p><strong>在现实世界上，蠢人办不了什么事情</strong>。愚蠢是一种极大的痛苦，降低人的智能，乃是一种最大的罪孽。所以，<strong>以愚蠢教人，是善良的人所能犯下的最严重的罪孽。</strong>……假设我被大奸大恶之徒所骗，心里还能平衡；而被善良的低智人所骗，我就不能原谅自己。</p>
<p>一般人认为，善良而低智是无辜的。假如这种低智是先天造成的，我同意。但是人可以发展自己的智力，<strong>所以后天的低智算不了无辜</strong>。……我认为低智、偏执、思想贫乏是最大的邪恶。……我们这个民族总是有很多理由封锁知识、钳制思想、灌输善良，因此很多有才智之士在其一生中丧失了学习、交流、建树的机会，没有得到思想的乐趣就死掉了。</p>
<p>古人曾说：<strong>天不生仲尼，万古如长夜。</strong>但我有相反的想法。假设历史上曾有一位大智者，一下发现了一切新奇有趣，发现了<strong>终极真理，根绝了一切发现的可能性</strong>，我就情愿到该智者以前的年代去生活……假如这种终极真理已经被发现，<strong>人类所能做的事情就只剩下了依据这种真理做价值判断</strong>，从汉代到后近代，中国人就是这么生活的，我对这样的生活一点都不喜欢。</p>
<p>我认为，在人类的一切智能活动里，没有比做价值判断更简单的事了。……一些缺乏其他能力的人，为什么特别热爱价值判断的领域……对别人做价值判断，那就太简单，太舒服了……在一切的价值判断中，最坏的一种是：想得太多、太深奥，超过了某人的理解程度，是一种罪恶。……对于一位知识分子来说，成为思维的精英，比成为道德精英更为重要。……这些呼吁，当然是对那些立志要当军代表和道德教师的人而发的。</p>
<h2 id="沉默的大多数"><a href="#沉默的大多数" class="headerlink" title="沉默的大多数"></a>沉默的大多数</h2><p>在我周围，像我这样性格的人特多——在公共场合什么都不说，到了私底下则妙语连珠。……对信得过的人什么都说，对信不过的人什么都不说。……后来才发现，这是中国人的通病……<strong>沉默是一种生活方式</strong>。</p>
<p><strong>话语即权力……权力即话语。……</strong>一般人从走进教室，开始接受话语的熏陶……从这些话里我知道了土平炉可以炼钢……</p>
<p>这个世界上有一个很大的误会，就是以为人的种种想法都是由话语教出来的。假设如此，话语就是思维的样板，我说它是个误会，就是世界还有阴的一面，同样的话语也能教出很不同的想法……</p>
<p><strong>话语教给我们很多，但善恶还是可以自明</strong>。（某些）话语教给我的是：要横扫一切牛鬼蛇神，把文化革命进行到底。当时话语就站在人性的反面上，假如完全相信它，就不会有人性。…………<strong>我们人品的一切可取之处，都该感谢沉默的教诲。</strong></p>
<p>我们可以在沉默和话语两种东西中做选择……<strong>我只是想说明一下话语的贫乏。用它来说话都相当困难，更不要说用它来说思想了。</strong><br>我在沉默中度过了很多年……照我看，不管干什么都可以保持沉默……就是写小说，但是写好了不去发表，同样也保持了沉默。沉默的理由，那很简单，就是信不过话语圈，就我短短的人生经历来看，<strong>那是一座声名狼藉的疯人院。</strong>当时我怀疑的不仅仅是亩产三十万，精神原子弹的那个话语圈，而是一切话语圈子。假如今天能证明我犯了以偏概全的错误，我会感到无限的幸福。</p>
<p>所谓弱势群体，就是有些话没有说出来的人……我自己也属于古往今来最大的一个弱势群体，那就是<strong>沉默的大多数。</strong></p>
<h2 id="花剌子模信使问题。"><a href="#花剌子模信使问题。" class="headerlink" title="花剌子模信使问题。"></a>花剌子模信使问题。</h2><p>给君王带来好消息的信使，就会得到提升，给君王代来坏消息的人则会被送去喂老虎……花剌子模君王有一种近似天真的品质，以为奖励带来好消息的人，就能鼓励好消息的到来，处死带来坏消息的人，就能根绝坏消息。……<strong>从某种意义上，学者的形象和花拉子模信使有点像。</strong>……把（做研究）得出的结论报告给公众，包括当权者，这时学者就像个信使；……中国近现代学者李，做好消息使者的人很多。 比方说，现在大家发现了中华文化是最好的文化，世界的前途依赖东方文明。不过也有坏消息信使，此人叫马寅初，五十年代初，提出新人口论。当时以为，只要把马老臭批一顿，就可以根绝中国人口问题，后来才发现，问题不是这么简单。</p>
<p>对于学者来说，研究的结论会不会累及自身……主要取决于学者周围有没有花剌子模君王类的人……</p>
<p>假如可以讲道理，就可以说，首先有了不幸的事实，才有了不幸的消息……如果要反对不幸，应该直接反对不幸的事实，此后才能减少不幸的消息。但这个道理有一定复杂性，不是君王能理解。……信使中有些狡猾之徒，递送坏消息时就会隐瞒不报，甚至篡改。……据我所知，学者没有狡猾到这种程度，<strong>他们只是仔细地提防着自己，不要得出不受欢迎的结论。</strong>人人都渴望受欢迎，因此连做人都不够自然……<strong>假定可以痛快淋漓地做学问，再挣很多的钱，那就什么危机都没有了。</strong></p>
<p>学者往往在<strong>求真实和受欢迎之中，苦苦求索一种两全之路。</strong>……在中国历史上，每一位学者都力求证明自己的学说有巨大的经济效益、社会效益，孟子有“仁者无敌”之说，和林彪的“精神原子弹”有着异曲同工之妙……学术必须有效益，这就构成了另一种花剌子模……因为这个原因，学者承受着一种压力，要和骗子竞赛语惊四座，看着别人的脸色做学问。</p>
<p>实际上，不但是学者，<strong>所有的文化人都是信使</strong>……总之，在面对公众和领导时，大家都是信使……拣<strong>好听的说或许不至于，起码都在提防着自己不要讲出难听的话来……假如混得不好，就该检讨一下自己的嘴是不是不够甜。</strong>……这样，文化园地里，就全是使人喜闻乐见的东西了。</p>
<p>有句老话叫“久居鲍鱼之肆不闻其臭”，人不知自己是不是身在花剌子模，更搞不清自己以为是学术、是艺术的东西到底是真是假。……<strong>假如真的学术和艺术存在的话，在人变得滑头的时候它就会离人世远去。</strong>等到过了一阵子，人们又可以把它召唤回来——这种事件叫做“文艺复兴”。</p>
<h1 id="《一只特立独行的猪》"><a href="#《一只特立独行的猪》" class="headerlink" title="《一只特立独行的猪》"></a>《一只特立独行的猪》</h1><h1 id="《我的精神家园》"><a href="#《我的精神家园》" class="headerlink" title="《我的精神家园》"></a>《我的精神家园》</h1>]]></content>
      <categories>
        <category>ReadingNote</category>
      </categories>
  </entry>
  <entry>
    <title>《一席》节目两则</title>
    <url>/2019/10/05/Yixi-Netizen-and-Patroitism/</url>
    <content><![CDATA[<h1 id="（许子东）网络上的人民"><a href="#（许子东）网络上的人民" class="headerlink" title="（许子东）网络上的人民"></a>（许子东）网络上的人民</h1><p>什么是大众、群众、人民、公民？（除此之外还有臣民、良民、贱民）</p>
<p>我们先来定义一下大众。鲁迅指大众是要被唤醒的对象，他说，大众就是在黑屋子中睡着的人们，你不去叫醒他们，他们就会死去。鲁迅说，我要去叫醒他们，可是如果当他们醒后，发现只有窗没有门，不是会更痛苦吗？这就是鲁迅一辈子的悲观主义的启蒙观。大众代表愚昧，大众的反义词是精英，大众是一个需要被唤醒的对象。另外两个是瞿秋白和梁实秋的定义。瞿秋白认为，大众是文化的主体，大众是艺术的来源，知识分子应该要向大众学习。大众意味着，多数人代表着正确，代表着先进，少数要服从多数，此时对立面是杂音和不服从，顽固分子。梁实秋认为，真正的艺术只能是被少部分人欣赏的，就比如红楼梦真的只有少数人会去看，一个东西喜欢的人多就不可能是雅致的东西。大众代表的是俗，大众的反义词是雅。这三种观点截然不同，但非常好的诠释了大众的内涵。许教授举了个例子，说郭敬明说自己的电影受人民的喜欢。错了！是受大众的喜欢才对。</p>
<p>人民是什么意思呢？人民=群众+领导干部。公民-敌人=人民。人民有如下特点：1.人民是一个群体概念。比如，我去买东西，那人服务态度不好，我说，你这边还摆这个牌子说你为人民服务呢。服务员反呛我，你一个人就能代表人民？某一群人可以是人民，而人民不能对应到一个个具体的人，这是一个非常矛盾的体现。2.人民是一个政治概念，与之相似的一个概念是公民，而公民是法律概念。说到公民，其特征就是有权利，有义务。公民有反义词吗？这个视频没提到，我想了想就是原始社会的自然人。就算一个人犯罪背叛了刑，被剥夺某种权利，但他仍然是公民（如果他不是公民，那执法机关其实失去了对他的管辖权）。而人民的属性是可以被剥夺的，比如文革的时候开个会，进来之前你是人民，会开完会你就不是了，因为你在会上收到了批斗。人民的反义词是敌人。之前受到这种待遇的人，“敌性内处”（定性改为“人民内部矛盾”）是他们梦寐以求的东西。</p>
<p>网民有什么特点。1.其实应该算是大众，那么就具有大众的那三重属性。2.上网冲浪的行为有人民的特点。比如两个人对骂的时候，互相给对方盖帽子，你是五毛，你是美分，而不看你具体讲的是什么东西，用你的思想来给你定罪。这其实还是阶级斗争的那一套。3. 在网络上想要成为人民的一员，“我們在網絡上仇富、仇官、支持大多數。我們在現實生活當中想發財、想升官、想做精英、想做特別的人”。“這個矛盾是我們每個人的矛盾，也是我們身為人民、公民和網民的內在矛盾”。在我看来，精致的利己主义者和机会主义者依然有很深的市场。</p>
<h1 id="（资中筠）谈谈爱国"><a href="#（资中筠）谈谈爱国" class="headerlink" title="（资中筠）谈谈爱国"></a>（资中筠）谈谈爱国</h1><p>人对自己所在的国家有自发的维护和热爱的情感，爱国其实原本是一个不需要特别拿出来讲的概念。但是历史上出现过以爱为名义，做的事情却实际上是伤害，所以我们不得不深沉地考虑这个问题。</p>
<p>我们需要定义什么是爱国。在古代，爱国其实是忠君。例如辛弃疾是著名的爱国词人，“了却君王天下事，赢得身前身后名”。岳飞他最终的目的还是为了把宋徽宗从金人那边接回来，不过高宗已经不愿意徽宗回来。在中国古代，朝廷 = 国家，说到爱国，那就是忠君，忠于朝廷。按照文官自古以来的传统，“文死谏”，就是文官要愿意死于给皇帝提意见，因为最终决策者就是那一个人，你一定要说服他才可以实现你救国救民的政治抱负，所以你要冒着生命危险跟他辩论。所以，那个时候的中国人其实没有“国家”的概念。</p>
<p>国家这个概念出现的很晚，起码要到鸦片战争以后。近代中国，知识分子开眼看世界，了解了中国沉浸在天朝上国的迷梦之中，为了救中国在不停的寻找出路。以前我们当作蛮夷的人，现在看我们反倒是像在看蛮夷，这个观念已经完全颠覆。知识分子出国之后发现了这一点，他们做了他们认为该做的事来救亡图存。严复翻译外国的著作，开启明智。李鸿章这批人发现，我们的军队的实力打不过洋人，所以要购买武器枪炮；为什么他们能造出武器枪炮，是因为洋人的工业化水平高；为什么洋人能工业化，是因为他们有好的体制……现在，对于他们来说，爱国的定义非改不可。教育救国、科技救国、实业救国……到最后到革命了。晚清，有了国家概念之后，怎么样才算爱国？这里面有了很多很多的变化。那么，忠君，还算不算爱国？这里很自然人就会分为左右两派：保守派认为改革是为了保清，可以为清王朝注入新的活力，爱新觉罗家可以继续存在下去；改革派认为这种封建王朝是没有希望的了，因为清政府没有决心和毅力去执行这种体制改革了。这里就有一个爱国还是爱朝廷的事情，保住大清王朝，那当然也是“爱国”。但是对于孙中山这一批人，我爱这个国家，所以我必须把你灭了不可，这样我才能建立一个现代化的中国。我为了保卫这个nation，我必须推翻你这个state，这是一个很大的区别。</p>
<p>下面讲讲义和团、太平天国，和八国联军侵华的事情。说到爱国的问题那么就联系到义和团的问题，现在我们回头来看，清朝的最终衰败就是在义和团事件之后。义和团的事情，就是“打教堂，杀洋人，扶清灭洋”。原来的口号是反清复明。中国古代皇家历来都是对民间组织严加镇压的，不过此次地方官发现他们也打洋人。此时中国已经是半殖民地半封建社会，又不平等条约，洋人来到中国，自然不会非常平等地对待中国人。那么就借他们的力杀杀洋人的威风也挺好的，于是就安抚他们，得到了朝廷的支持，义和团势力越发猖獗。义和团所作所为就是砸掉教堂，杀掉传教士，见着洋人就杀，但其实他们杀的最多的是中国人，比如信教的教徒，卖洋货的商人等。事态严重了之后，外国自然就抗议，说如果你保护不了我们国家的使馆和外交官，那我就要自己派兵过来保护了。这种情况就很危急了，朝廷里分为两派，一派主张镇压义和团，不能让他们乱来，并且和洋人讲和，保护使馆和教堂。另一派主张，干脆利用义和团让他们跟洋人斗。结果主战派就胜利了，而那些个死谏的大臣们得罪了朝廷就杀了头。他们每天上几道奏折说，从春秋以来都是两国相争不斩来使的，不可以攻击外国的使馆，不可以任由杀人犯胡来。说到这里，请问，这里面的人，谁爱国？谁祸国？那些主张不要杀洋人的人，另一派人就攻击他们是汉奸。支持义和团的人就是爱国吗？我们的历史教科书还往往把义和团运动和太平天国当作一种“反封建主义反帝国主义爱国运动”来描绘的。</p>
<p>慈禧太后向十一国宣战，要求使馆撤离，完全放纵义和团进入北京乱杀一气。在这种情况下，李鸿章和刘坤一等两广总督，两江总督，他们在一起抗命，他们得出一个结论：乱命不从。搁在中国古代，圣旨下来你怎么能不从呢？他们联合起来，做了一个“东南互保”的行为。跟他们所管辖的领域的领馆代表洋人谈判，说，在我们管辖的区域，我保证使馆和教堂，外国人的安全，但也请你们不要派兵进来。其结果就是八国联军只攻入了北京城，而没有侵略长江以南甚至是淮河以南一直到广东广大的地区，没有影响到中国经济繁荣，人口密集的南方。在当时的这个情况下，这种做法，是爱国吗？居然不听中央的命令？还私自和外国人谈判？我觉得是很大的爱国举措。晚清的大臣们居然还可以跳出愚忠的范畴，想出这样一个好主意来，着实是大功一件。</p>
<p>所以说，什么是爱国什么是祸国，如果从一个比较有历史距离的位置来看，无论是从出发点还是结果，都是可以看的比较明了的。我认为，就好像许多学生在教室里骂老师教的课没有意义一样，其实你还没有这个资格去评价。往往多年之后你的评价才会有最少的公允可言，起码也是得等你毕业了吧。德国纳粹党，多强啊，日本民族主义军国主义，那时候这两个国家的民众是真的觉得自己很爱国。这种爱国是爱国吗？对日本来讲是祸国，招来了两颗原子弹。所以我们要对爱国这个事情弄清楚，读史可以改变我们思考问题的方式，因为人性是一个比较固定的东西，几千年来不会有太大的变化。</p>
<p>儿不嫌母丑，所以这个国家再怎么差你也要爱——盲目且短视。娘如果生病了，儿子要给他治病，而不只是盲目地爱。在这个过程中，千百年来，爱国仁人志士付出了极大的牺牲。</p>
<p>要摒弃零和思维。不一定是你占便宜人家一定吃亏。互利的东西特别多。</p>
<p>现在倒是有一个比较真实的问题，就是用脚投票的问题。</p>
<p>知识分子，就是对于对自己没有切身利益相关的事情，他也愿意去关心和发声。“无恒产者有恒心，唯士为能”——孟子。</p>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之类的简单定义</title>
    <url>/2017/06/07/class/</url>
    <content><![CDATA[<h1 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span> <span class="comment">//class declaration</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string company;</span><br><span class="line">	<span class="type">long</span> shares;</span><br><span class="line">	<span class="type">double</span> shares_val;</span><br><span class="line">	<span class="type">double</span> total_val;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares*shares_val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">(<span class="type">const</span> std::string &amp;co, <span class="type">long</span> n, <span class="type">double</span> pr)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> price)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++关键字<code>class</code>指出这些代码定义了一个类设计。Stock是这个新类的类型名。该声明能够让我们声明新的Stock类型变量——被称为对象。每个对象都代表一个Stock（股票）</p>
<p>例子：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Stock A<span class="comment">;</span></span><br><span class="line">Stock B<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>我们通过对象声明了新的Stock类型变量，可以代表A、B分别持有的某股票。<br>接下来，要储存的数据以类数据成员的形式出现（例如company，shares）</p>
<p>例如：<br>A的<code>ompany</code>存储了公司的名称，<code>shares</code>成员存储了A持有股票的数量，<code>shares_val</code>存储了每股的价格，<code>total_val</code>存储了股票总价格。</p>
<p>要执行的操作以类成员函数的形式出现（又称为方法），例如set_tot()。</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>关键字<code>private</code>和<code>public</code>，描述了对类成员的访问控制。使用类对象， 都可以直接访问公用部分，到只能通过公有成员函数来访问对象的私有成员。因此，公有成员函数是程序与对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据，被称为数据隐藏。</p>
<ul>
<li><code>private</code>：类内可见。</li>
<li><code>public</code>：类内外可见。</li>
</ul>
<p>类设计尽可能将公有接口和实现细节分开。将实践细节放在一起并将它们与抽象数据类型分开，被称为封装。数据隐藏（数据放在<code>private</code>里）也是封装。将实现的细节放在<code>private</code>里，如<code>set_tot()</code>也是封装。</p>
<p>数据隐藏不仅防止了数据被直接访问，还让用户无需了解数据是如何被表示的。所需要的只是各种类函数的功能，需要接受什么样的参数，返回什么样的结果。原则是将实现的细节从接口设计中分离出来，如果以后对代码进行维护、升级就直接对细节进行修改而无需修改接口。这样对维护程序更有利。</p>
<p>无论类成员是数据成员还是成员函数，都可以在共有部分或者私有部分去声明它。但由于数据隐藏是OOP的主要目标之一，所以数据项通常放在私有部分，组成接口的成员函数放在共有部分。否则无法从程序中调用这些函数。如果把成员函数放在私有部分，则不能直接在程序中调用这种函数，只有公有部分能使用它们。通常这么做是使用私有成员函数来处理不属于公有接口的实现细节部分。</p>
<h2 id="class-和-struct-的区别"><a href="#class-和-struct-的区别" class="headerlink" title="class 和 struct 的区别"></a>class 和 struct 的区别</h2><p>类的描述看上去很像是有一个带有<code>private</code>和<code>public</code>这样的标签的结构声明。实际上，C++对结构进行了扩展，使之具有与类相同的特效。它们之间的唯一区别是，结构的默认访问类型是<code>public</code>，而类的默认类型是<code>private</code>。</p>
<p>C++程序员通常使用类来描述，结构只是用来表示纯粹的数据对象。</p>
<p>tips：如果没有写<code>private</code>就定义成员，那么成员的属性默认是<code>private</code>。<code>private</code>是类成员的默认访问控制。</p>
<h2 id="实现类成员函数"><a href="#实现类成员函数" class="headerlink" title="实现类成员函数"></a>实现类成员函数</h2><p>定义成员函数时，使用<strong>作用域解析运算符</strong><code>::</code>来标识函数所属的类。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> Stock::<span class="keyword">update</span>(<span class="type">double</span> price)</span><br></pre></td></tr></table></figure>
<p>这种表示法意味着我们定义的update是Stock类的成员，不仅表明了update是成员函数，还允许我们把另一个类的成员函数也命名为update。</p>
<p>作用域解析运算符还确定了方法定义的类的身份。所以<code>update()</code>具有<strong>类的作用域</strong>（class scope），Stock类的其他成员函数不必使用作用域解析运算符就可以使用<code>update()</code>方法，这是因为它们同属一个类，所以update是可见的。</p>
<h2 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h2><p>如果创建两个Stock类<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Stock A<span class="comment">;</span></span><br><span class="line">Stock B<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>要使用对象的成员函数，和结构体成员一样，使用<strong>成员运算符</strong>。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">A.show()<span class="comment">;</span></span><br><span class="line">B.show()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>A调用show()时，<code>share</code>是<code>A.shares</code>，<code>share_val</code>是<code>A.share_val</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::acquire</span><span class="params">(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n, <span class="type">double</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	company = co;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative.&quot;</span></span><br><span class="line">			&lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">		shares = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		shares = n;</span><br><span class="line">	share_val = pr;</span><br><span class="line">	<span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Number of shares purchased can&#x27;t be negative.&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot; Transaction is aborted.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		shares += num;</span><br><span class="line">		share_val = price;</span><br><span class="line">		<span class="built_in">set_tot</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Number of shares sold can&#x27;t be negative.&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot; Transaction is aborted.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (num&gt;shares)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;You can&#x27;t sell more than you have!&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot; Transaction is aborted.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		shares -= num;</span><br><span class="line">		share_val = price;</span><br><span class="line">		<span class="built_in">set_tot</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::update</span><span class="params">(<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	share_val = price;</span><br><span class="line">	<span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">			  &lt;&lt; <span class="string">&quot;   Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">			  &lt;&lt; <span class="string">&quot;   Share Price: $&quot;</span> &lt;&lt; share_val</span><br><span class="line">			  &lt;&lt; <span class="string">&quot;   Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>设计一个类的流程</p>
<ul>
<li>提供类声明。<br>  ○ 包括数据成员和函数成员<br>  ○ 声明有私有部分，只能通过成员函数进行访问。公有部分，可以被程序直接访问<br>  ○ 基本格式如下：</li>
</ul>
<pre><code>class classname
&#123;
private:
    data member declarations
public:
    member function prototypes
&#125;;
</code></pre><pre><code>○ 公有部分的内容形成了公有接口，因此C++通过类来实现了抽象、数据隐藏、封装的OOP特性
</code></pre><ul>
<li>实现类成员函数。<br>  ○ 可以在类声明里提供完整的函数定义，而不是函数原型。但通常做法是单独提供函数定义，除非函数很小。<br>  ○ 需要用作用域解析运算符来指明成员函数到底属于哪个类。</li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】1. 位、字节、整型</title>
    <url>/2017/06/24/csapp-1-Bits-and-Bytes/</url>
    <content><![CDATA[<p>《Computer Systems a Programmer’s Perspective》，机械工业出版社。中文译名《深入理解计算机系统》。作者：（美）Randal E.Bryant / David O’Hallaron </p>
<p>想写点推荐理由，作罢，原因是自己学识尚浅（留坑以后写？）。这里附上几个链接，也许你看过之后，也会产生和我一样的想法，阅读这本计算机界的经典著作。</p>
<ul>
<li><a href="https://book.douban.com/subject/5333562/">豆瓣——深入理解计算机系统（原书第2版）</a></li>
<li><a href="http://www.cnblogs.com/JeffreyZhao/archive/2009/11/23/recommended-reading-3-csapp.html">老赵书托（3）：深入理解计算机系统</a></li>
<li><a href="http://csapp.cs.cmu.edu/3e/perspective.html">CMU CSAPP网站：何为Programmer’s Prospective？</a></li>
</ul>
<hr>
<h1 id="程序的结构和执行"><a href="#程序的结构和执行" class="headerlink" title="程序的结构和执行"></a>程序的结构和执行</h1><p>这是本书的第一部分，Program Structure and  Execution。包括内容是第二到第六章。第二章的标题是：信息的表示和处理（Representing and  Manipulating Information）</p>
<h1 id="位、字、数据类型"><a href="#位、字、数据类型" class="headerlink" title="位、字、数据类型"></a>位、字、数据类型</h1><h2 id="位"><a href="#位" class="headerlink" title="位"></a>位</h2><blockquote>
<p>对于有十个手指头的人类来说，使用十进制表示法是很自然的事情，但是当构造处理信息的机器时，二进制的值工作得更好。……这些微不足道的二进制数字，或者成为位（bit），奠定了数字革命的基础</p>
</blockquote>
<p>现代计算机的处理、存储的信息以二进制表示。甚至可以说计算机的一切就是0和1。一个bit就是一个0或1。那为什么就偏偏是二进制而不是我们常用的十进制，或者什么三进制五进制之类？简单来说还是离散信号和模拟信号的区别。简言之，0和1这种离散值在用机器来表示时是非常方便的，例如高低电平、纸条带上孔的有无等等。而且模拟信号（如电压）有诸如很容易受其他条件干扰，很容易产生误差这样的缺点，离散数值的优势就体现了。如果说，一个单独的位，只能代表0或1，起不了多大的作用。但如果有很多的位（足够数量），并且对二进制数字串进行一定形式的编码（例如IEEE浮点规则、ASCII码等等），那么我们能赋予一串二进制数一定的意义，让其具有存储、处理信息的能力。虽然0和1是离散的，但大量的0和1，足够让我们认为是“连续”的。此时，二进制数就会向我们展示它的魔力。</p>
<h2 id="十进制0-15的三种进制表示"><a href="#十进制0-15的三种进制表示" class="headerlink" title="十进制0~15的三种进制表示"></a>十进制0~15的三种进制表示</h2><table>
<thead>
<tr>
<th>十六进制</th>
<th>十进制</th>
<th>二进制</th>
<th>十六进制</th>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0000</td>
<td>8</td>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0001</td>
<td>9</td>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0010</td>
<td>A</td>
<td>10</td>
<td>1010</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>0011</td>
<td>B</td>
<td>11</td>
<td>1011</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0100</td>
<td>C</td>
<td>12</td>
<td>1100</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>0101</td>
<td>D</td>
<td>13</td>
<td>1101</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>0110</td>
<td>E</td>
<td>14</td>
<td>1110</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>0111</td>
<td>F</td>
<td>15</td>
<td>1111</td>
</tr>
</tbody>
</table>
<ul>
<li>这张表需要熟悉，也就是要了解进制转换的一些规则。</li>
</ul>
<h2 id="字"><a href="#字" class="headerlink" title="字"></a>字</h2><p>8 个 bit 是一个字，或者叫做字节（byte）。字节是作为最小的可寻址存储器单位（并不是一个个位去存储和访问）。每个字节都有一个唯一的数字作为标识，这个数字就是<strong>地址</strong>（Address）</p>
<p>计算机有一个很重要的概念叫做<strong>字长</strong>（word size），指明整数和指针的<strong>标称大小</strong>。因为一个个地址都是唯一的数字，就是由一个字编码的。所以字长决定的一个最重要的系统参数就是虚拟地址空间的最大大小。一般来说32位的计算机，限定虚拟地址空间为4GB（2的32次方减1个字节）。</p>
<h2 id="C语言数据类型的字节数"><a href="#C语言数据类型的字节数" class="headerlink" title="C语言数据类型的字节数"></a>C语言数据类型的字节数</h2><p><img src="http://osax8w13y.bkt.clouddn.com/1-1.png" alt=""></p>
<h2 id="大端法、小端法"><a href="#大端法、小端法" class="headerlink" title="大端法、小端法"></a>大端法、小端法</h2><p>测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_int</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">show_bytes</span>((byte_pointer)&amp;x, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">12345</span>;</span><br><span class="line">	<span class="built_in">show_int</span>(x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在显示一个w位的整数时，如果w是8的整数，那么能以字节为单位来表示。最低有效字节排在前面的方式叫做小端法，大多intel兼容机器采取小端法。大端法采用的是最高有效字节在最前面，也就是我们平常习惯的方式。例如十进制<code>12345</code>的32位编码是<code>0000 3039</code>。小端法是如下的输出。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1-2.png" alt=""></p>
<h1 id="bool代数、逻辑运算、移位运算"><a href="#bool代数、逻辑运算、移位运算" class="headerlink" title="bool代数、逻辑运算、移位运算"></a>bool代数、逻辑运算、移位运算</h1><p><a href="https://en.wikipedia.org/wiki/Boolean_algebra">bool代数</a></p>
<p><a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts">位运算</a></p>
<p>以下是一些补充记录：</p>
<ul>
<li><p>掩码运算。按位与：<code>&amp;</code>，常用于保持某位不变：<code>x&amp;1</code>，或把某些位置为0：<code>x&amp;0</code>。按位或：<code>|</code>，常用于将某些位置置为1：<code>x|1</code>。</p>
</li>
<li><p>对于逻辑运算来说，0 代表<code>false</code>，所有的非 0 值代表<code>true</code>。</p>
</li>
<li><p>对于任何值a来说，<code>a ^ a = 0</code>，一个数与自己的异或为零，因此有<code>(a ^ b) ^ a = b</code> ，加以利用可以带来有趣的结果。例如：a是密钥，b是明文，a^b是加密，加密后的值就被保护。想要知道明文，只能用a去解密。</p>
</li>
<li><p>对于右移<code>&lt;&lt;</code>，机器支持两种模式的右移。   </p>
<ul>
<li>逻辑右移，右移后在左端补0。</li>
<li>算术右移，右移后在左端补<strong>最高有效位的值</strong>。</li>
<li>例如 对于 <code>x = 0x10010011，x =&lt;&lt; 4</code>; 如果是逻辑右移，结果为 <code>x =  0000 1001</code>；如果为算术右移，结果为<code>1111 1001</code>。</li>
</ul>
</li>
<li><p>移位数量应该保持小于字长。</p>
</li>
<li><p>加减法优先级比移位高。</p>
</li>
</ul>
<p>关于位运算符放一张很久之前整理的表格：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1-3.png" alt=""></p>
<h1 id="整数（integer）表示"><a href="#整数（integer）表示" class="headerlink" title="整数（integer）表示"></a>整数（integer）表示</h1><h2 id="整数编码"><a href="#整数编码" class="headerlink" title="整数编码"></a>整数编码</h2><p>整数分为有、无符号两种类型，<code>unsigned</code>。根据字节数的不同还分为<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code>。</p>
<p>对于整数的编码，简言之，就是每个位上面的值乘以该位对应的权值，再求和。</p>
<p>1.无符号数编码（binary to unsigned）</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1-4.png" alt=""></p>
<ul>
<li>UMax，即编码全为1。</li>
<li>UMin，编码全为0。</li>
</ul>
<p>2.补码编码（binary to Two’s compliment），与unsigned的区别在于最高有效位解释为<strong>负权</strong></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1-5.png" alt=""></p>
<ul>
<li>TMax，符号位为0，剩下位全为1。</li>
<li>TMin，符号位为1，剩下位全为0。</li>
<li>求一个有符号数的负数（补码的逻辑运算非），可以理解为把全部位取反后，对结果再加 1。特别地，TMin 的“负数”依然是 TMin。</li>
</ul>
<p>C语言默认是有符号整型。如果想要无符号常数，需要加关键词U做限制。</p>
<h2 id="无符号数和有符号数之间的转换"><a href="#无符号数和有符号数之间的转换" class="headerlink" title="无符号数和有符号数之间的转换"></a>无符号数和有符号数之间的转换</h2><p><img src="http://osax8w13y.bkt.clouddn.com/1-6.png" alt=""></p>
<p>关键点：同样字长的有符号数和无符号数，使用的是相同的位模式。</p>
<p>难点：C语言中，对于一个运算，如果一个运算数是有符号的，另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换成无符号数，并且假设这两个数是非负的。因此，会导致一些奇怪的结果。例如：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1-7.png" alt=""></p>
<p>对于第一个式子来说，由于一个操作数是有符号，另一个操作数是无符号，那么有符号数-1被强制转换成一个无符号数，会变成一个很大的无符号数。</p>
<p>第二个，<code>-2147483647-1</code> 其实就是头文件<limit.h>中32位补码TMin的写法（这是由于C语言规则所致）。转换成无符号之后的值要比TMax大1。</limit.h></p>
<p>第三个，这两个操作数都是有符号型，而且2147483648大于TMax，导致溢出，成了一个很小的负数。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1-8.png" alt=""></p>
<h2 id="扩展、截断"><a href="#扩展、截断" class="headerlink" title="扩展、截断"></a>扩展、截断</h2><p><img src="http://osax8w13y.bkt.clouddn.com/1-9.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_int</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">show_bytes</span>((byte_pointer)&amp;x, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_short</span><span class="params">(<span class="type">short</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">show_bytes</span>((byte_pointer)&amp;x, <span class="built_in">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//扩展</span></span><br><span class="line">	<span class="type">short</span> x = <span class="number">12345</span>;</span><br><span class="line">	<span class="built_in">show_short</span>(x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;short x = %d\n&quot;</span>, x);</span><br><span class="line">	<span class="built_in">show_int</span>(x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;int x = %d\n\n&quot;</span>, (<span class="type">int</span>)x);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//截断</span></span><br><span class="line">	<span class="type">int</span> y = <span class="number">123456</span>;</span><br><span class="line">	<span class="built_in">show_int</span>(y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;int y = %d\n&quot;</span>, y);</span><br><span class="line">	<span class="built_in">show_short</span>(y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;short y = %d\n\n&quot;</span>, (<span class="type">short</span>)y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>扩展，例如<code>short</code>到<code>int</code>，<code>int</code>到<code>long long int</code>这样。不会改变数字的值。如果是无符号数就是扩展全部为0的位，有符号数就是扩展全部为1的位。</p>
<p>截断，例如<code>int</code>到<code>short</code>，有点类似于右移，类似于模2的n次方，但只是类似。对于大的数据，截断会导致溢出。例如<code>int</code>型整数<code>123456</code>大于<code>short</code>能表示的最大数值范围，如果将其截断会导致上溢出从而得到一个负数。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1-10.png" alt=""></p>
<p>如果打算通过使用扩展位数的手段来使得一些运算结果由原本的溢出变为不溢出，那么强制类型转换和计算这两个过程的先后顺序很重要。例如下面这个函数验证两个32位的int型整数做乘法有没有产生溢出，验证的手段是先用64位的整型存结果，再将64位乘积截断为32位是否会改变其值：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">imull</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pll = (<span class="type">long</span> <span class="type">long</span>)x * y;</span><br><span class="line">    <span class="keyword">return</span> pll == (<span class="type">int</span>)pll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码第二行的强制类型转换至关重要，<strong>先转换再计算</strong>。如果第二行是这么写的话：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">long long pll <span class="operator">=</span> x * y<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>那么会用32位值来计算乘积（可能这会溢出），然后再将其扩展为64位。显然不会达到目的。可以参考下面的运行结果</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1-11.png" alt=""></p>
<hr>
<h1 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h1><p>部分公式、数据截图来源</p>
<ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期  ICS课程网站</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】10. 代码优化</title>
    <url>/2017/06/29/csapp-10-Code-Optimization/</url>
    <content><![CDATA[<p>写程序的主要目标是使它在所有可能的情况下都能正确运行（bug free），一个运行得很快但有 bug 的程序是毫无用处的。在 bug free 的基础上，程序员必须写出清晰简洁的代码，这样做是为了今后检查代码或修改代码时，其他人能够读懂和理解代码。另一方面，让程序运行得更快也是一个很重要的考虑因素。不过，程序获得最大加速比的时候，是它第一次运行起来的时候。</p>
<p>在提到优化程序性能时（Code optimization），我们往往会想到算法与数据结构中的一个概念——复杂度。事实上，除了算法复杂度之外，仍然有许多的代码书写小细节可以改进性能表现。不过，编写高效的程序，第一个考虑的还是选择一组合适的算法与数据结构，因为算法复杂度影响还是相当大的，而且通常比其他常量因素更重要。第二点，我们必须写出编译器能够有效优化以转换成高效可执行代码的源代码。对于第二点，理解程序是如何被编译和执行、理解处理器和存储器系统是如何运作的、理解编译器优化的局限性是很重要的。在程序开发过程中，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡，也就是在尽量不破坏程序的模块化和通用性的前提下，做到对代码性能的优化。</p>
<p>即使是最好的编译器也受到<strong>妨碍优化的因素</strong>（optimization blocker）的阻碍，程序员必须编写容易优化的代码，来<strong>帮助</strong>编译器（很让人眼界一新的观点）。研究程序的汇编代码，是理解编译器，理解代码如何被运行的最有效的手段之一。</p>
<h1 id="理解编译器优化能力的局限性"><a href="#理解编译器优化能力的局限性" class="headerlink" title="理解编译器优化能力的局限性"></a>理解编译器优化能力的局限性</h1><p>编译器必须很小心地对程序使用<strong>安全</strong>的优化。在C语言标准的保证之下，编译器要确保优化后得到的程序和未优化的版本有着一样的行为（知道这个也就知道编译器不是万能的）看看下面两个过程：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> *xp, <span class="type">int</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> *xp, <span class="type">int</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += <span class="number">2</span>* *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看这两个过程似乎有相同的行为，且过程 func2 的效率更高一点，它虽然用到了乘法，但只需要三次存储器引用（读 <code>*xp</code>，读 <code>*yp</code>，写 <code>*xp</code>），而 func1 要用到六次存储器引用。那么编译器能不能把代码 func1 优化成 func2 呢？答案是否定的。当 xp 等于 yp 的情况下，func1 会把指针所指向的值增加 4 倍，而 func2 只会增加 3 倍。这就是一个优化前后程序行为不同的典型例子——两个指针指向同一个存储器位置的情况，叫做<strong>存储器别名使用</strong>（memory aliasing），这就造成了一个<strong>妨碍优化的因素</strong>——编译器不能确定两个指针是否指向同一个位置，那么它就必须假设可能会存在这种情况，限制了优化能力。所以程序员要编写帮助编译器的代码，帮助编译器产生高效的可执行代码。</p>
<h1 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h1><p>如果一个表达式总是得到同样的结果，最好把它移动到循环外面，这样只需要计算一次。编译器有时候会试图尝试代码移动，不过编译器会十分小心，它们不能确定移动一个函数的代码是否会有副作用，因此往往会假设会有副作用。所以程序员要手动帮助编译器来优化。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void set<span class="constructor">_row(<span class="params">double</span> <span class="operator">*</span><span class="params">a</span>, <span class="params">double</span> <span class="operator">*</span><span class="params">b</span>, <span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        a<span class="literal">[<span class="identifier">n</span><span class="operator">*</span><span class="identifier">i</span> + <span class="identifier">j</span>]</span> = b<span class="literal">[<span class="identifier">j</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里 n*i 是重复被计算的，可以放到循环外面</span></span><br><span class="line">void set<span class="constructor">_row(<span class="params">double</span> <span class="operator">*</span><span class="params">a</span>, <span class="params">double</span> <span class="operator">*</span><span class="params">b</span>, <span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> j;</span><br><span class="line">    <span class="built_in">int</span> ni = n<span class="operator"> * </span>i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        a<span class="literal">[<span class="identifier">ni</span> + <span class="identifier">j</span>]</span> = b<span class="literal">[<span class="identifier">j</span>]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="冗余的过程调用"><a href="#冗余的过程调用" class="headerlink" title="冗余的过程调用"></a>冗余的过程调用</h1><p>看一个循环低效率，但编译器没办法优化的极端例子。下面这个函数的作用是将一个字符串中所有大写字母转换成小写字母</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_lower</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的问题在于，每次循环都要调用一遍 <code>strlen</code>。而<code>strlen</code>的实现基本类似于下面这个样子：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    s++;</span><br><span class="line">    length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在理想情况下，我们可能认为编译器能够认为循环中的 <code>strlen</code> 每次都会返回相同的结果，因此能够将其优化，移出循环。然而很可惜的是，这样的分析远远超出了编译器的能力。很多时候只能靠程序员自己进行代码优化。每次调用 <code>strlen</code> 就是一次 $ O(n) $，n是字符串长度。<code>my_lower</code>的时间复杂度高达$ O(n^2) $。所以，一个看上去无足轻重的代码片段可能隐藏的渐进低效率。冗余的过程调用在字符串长度较低时毫无危险，但当应用到一个有一百万个字符的串上，突然，这段无危险的代码就会成为主要的性能瓶颈。</p>
<p>优化的方法就是让其计算一次就好：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_lower</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="消除不必要的存储器引用"><a href="#消除不必要的存储器引用" class="headerlink" title="消除不必要的存储器引用"></a>消除不必要的存储器引用</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把 nxn 的矩阵 a 的每一行加起来，存到向量 b 中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum_rows1</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            b[i] += a[i*n + j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sum_rows1 的内部 for 循环</span></span><br><span class="line"></span><br><span class="line">.L4:</span><br><span class="line"></span><br><span class="line">    movsd   (%rsi, %rax, <span class="number">8</span>), %xmm0  <span class="comment"># 从存储器位置 b[i] 载入浮点数，%rsi 保存数组 b 的起始地址， %rax 保存 i</span></span><br><span class="line">                                    <span class="comment"># %rdi 是 a[i*n+j] 的位置</span></span><br><span class="line">    addsd   (%rdi), %xmm0           <span class="comment"># 计算结果，放到%xmm0 是存放浮点数的寄存器</span></span><br><span class="line">    movsd   %xmm0, (%rsi, %rax, <span class="number">8</span>)  <span class="comment"># 再把计算结果写会存储器位置</span></span><br><span class="line">    addq    $8, %rdi                </span><br><span class="line">    cmpq    %rcx, %rdi</span><br><span class="line">    jne     .L4</span><br></pre></td></tr></table></figure>
<p>可以看到，每次都会把 <code>b[i]</code> 读入，写。但每次读入的时候，都是上次最后写入的值，这样的无用读写显得很浪费。我们能够消除这样的无用读写，引入一个临时变量，用来在循环中累计计算出来的值。只有在循环完成之后，才将结果写入存储器。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum_rows2</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            val += a[i*n + j];</span><br><span class="line">        b[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="处理条件分支"><a href="#处理条件分支" class="headerlink" title="处理条件分支"></a>处理条件分支</h1><p>在汇编语言的跳转时有说到，对于以流水线模式工作的CPU，遇到分支的时候，CPU必须预测分支往哪个方向走。如果预测失误，会导致很严重的性能惩罚。对于本质上无法预测的情况，如果编译器能产生使用条件数据传送而不是条件控制转移的代码，能极大提高程序的性能。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">void minmax1(int a<span class="comment">[]</span>, int b<span class="comment">[]</span>, int n)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = a<span class="comment">[i]</span>;</span><br><span class="line">        a<span class="comment">[i]</span> = b<span class="comment">[i]</span>;</span><br><span class="line">        b<span class="comment">[i]</span> = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//优化版本如下：</span><br><span class="line">void minmax2(int a<span class="comment">[]</span>, int b<span class="comment">[]</span>, int n)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int min = a<span class="comment">[i]</span> &lt; b<span class="comment">[i]</span> ? a<span class="comment">[i]</span> : b<span class="comment">[i]</span>;</span><br><span class="line">        int max = a<span class="comment">[i]</span> &lt; b<span class="comment">[i]</span> ? b<span class="comment">[i]</span> : a<span class="comment">[i]</span>;</span><br><span class="line">        a<span class="comment">[i]</span> = min;</span><br><span class="line">        b<span class="comment">[i]</span> = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期  ICS课程网站</a></li>
<li><a href="http://www.cnblogs.com/chkkch/archive/2011/06/24/2089378.html">对于循环展开的抨击</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】12. 高速缓存存储器</title>
    <url>/2017/06/30/csapp-12-Cache-Memory/</url>
    <content><![CDATA[<h1 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h1><p>在存储层次结构中，<strong>高速缓存存储器</strong>，也叫 <strong>cache</strong> 是最接近 CPU 寄存器的那一块。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/cache1.png" alt=""></p>
<p>更一般而言，<strong>缓存</strong>（caching）是一个无所不在的技术。缓存的意思是：对于每层的存储设备，位于 k 层的更快更小的存储设备，都能用作位于 k+1 层的更大更慢的存储设备的缓存，这也是存储器层次结构的中心思想。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/caching.png" alt=""></p>
<p>存储器层次结构的本质是：<strong>每一层存储设备都是较低一层的缓存</strong>。在每一层上，某种形式的逻辑必须管理缓存，可以是硬件、软件、或软硬结合。例如：编译器管理寄存器文件，是缓存的最高层次。L1、L2、L3 高速缓存是由硬件逻辑来管理的。在一个有虚拟存储器的系统中，DRAM 就是磁盘上的数据块的缓存，是由操作系统、CPU 上的地址翻译逻辑管理的。</p>
<h1 id="缓存的基本原理、命中"><a href="#缓存的基本原理、命中" class="headerlink" title="缓存的基本原理、命中"></a>缓存的基本原理、命中</h1><p>当 CPU 需要一个数据的时候，不只是读取这个数据的一些字节。数据总是以<strong>块</strong>作为一个传送单元在第 k 层和第 k+1 层之间来回拷贝的。第 k 层作为第 k+1 的缓存，在任何时刻，缓存中都保存着一个 k+1 层的块的一个<strong>子集</strong>，如图所示：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/caching-concept.png" alt=""></p>
<h2 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h2><p>当程序需要第 k+1 层中的某个数据对象 d 时，会首先在更高一层的 k 层的块中查找 d，根据存储器层次结构的性质，第 k 层的读取速度比 k+1 层的快 。如果 d 刚好在第 k 层中，那么就叫做<strong>缓存命中</strong>（cache hit）。例如，一个有良好时间局部性的程序可以经常从上图中的块 14 中读取一个数据对象，因此程序运行得很快。</p>
<h2 id="缓存不命中"><a href="#缓存不命中" class="headerlink" title="缓存不命中"></a>缓存不命中</h2><p>如果 d 不在 k 层中，那就是<strong>缓存不命中</strong>（cache miss）。一旦发生不命中，可能有两种行为：一是取出 k+1 层中包含 d 那个块，放到第 k 层中。二是第 k 层中已经满了，此时就需要采取<strong>替换</strong>（replacint），取出第 k 层原有的一个块作为<strong>牺牲块</strong>（victim），然后与包含 d 的那个块替换。决定由哪一个块作为牺牲块，就叫做<strong>替换策略</strong>（replacement policy）</p>
<p>不命中有三种种类：</p>
<ul>
<li><strong>冷不命中</strong>（clod miss）：一开始高速缓存里一定是空的，那么对任何对象的访问都不会命中。</li>
<li><strong>冲突不命中</strong>（confilict miss）：缓存足够大，但是因为某些对象会映射到同一个缓存块，会引起替换，导致缓存一直不命中。</li>
<li><strong>容量不命中</strong>（capacity miss）：工作集大小超过缓存的大小。</li>
</ul>
<h1 id="cache-结构"><a href="#cache-结构" class="headerlink" title="cache 结构"></a>cache 结构</h1><p>早期计算机系统存储器的层次只有三层：CPU 寄存器、DRAM 主存和磁盘。不过由于 CPU 和主存之间的差距逐渐增大，设计者被迫在寄存器文件和主存之间插入了一个小的 <strong>SRAM 高速缓存存储器</strong>，也就是 <strong>L1 高速缓存</strong>（一级 cache）。L1 cache 的访问速度几乎和寄存器一样快。随后，系统设计者又插入了 L2 高速缓存和 L3 高速缓存。</p>
<p>下面介绍高速缓存的通用组织。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/cache-oganazation.png" alt=""></p>
<p>考虑一个存储器地址有 m 位的计算机系统，能形成 $ M = 2^m $ 个不同的地址。</p>
<p>高速缓存有三个关键的指标：</p>
<ul>
<li>$ S = 2^s $ 个<strong>高速缓存组</strong>（set）的数组。</li>
<li>每个组包含 $ E $ 个高速缓存<strong>行</strong>（line）。</li>
<li>每行由一个 $ B = 2^b $ 字节的数据<strong>块</strong>（block）组成的</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/Address.png" alt=""></p>
<p>从地址上来看，可以把 S、E、B 理解为层级关系：高速缓存是一个数组，一共 S 组，每组包含 E 行，每行一个 B 字节的块和其他信息。</p>
<p>其他信息包括：<strong>有效位</strong>（valid bit）标明这个行是否包含有意义的信息。还有 $ t = m - b - s $ 个标记位（tag）用来标识存储在此的块。</p>
<p>高速缓存的大小指的是所有块大小的和。标记位和有效位不包含实际的块内数据信息，不算在内。因此：</p>
<p>$$ C = S × E × B $$</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/parameter.png" alt=""></p>
<h2 id="直接相映"><a href="#直接相映" class="headerlink" title="直接相映"></a>直接相映</h2><p>每个组只有一行（E = 1）的高速缓存称为<strong>直接相映高速缓存</strong>（direct-mapped cache）。高速缓存确定一个请求是否命中，然后取出被请求的字的过程，分为三步：</p>
<ol>
<li>组选择</li>
<li>行匹配</li>
<li>字抽取</li>
</ol>
<h3 id="组选择"><a href="#组选择" class="headerlink" title="组选择"></a>组选择</h3><p>（假设计算机系统有一个 CPU 、寄存器文件、一个 L1 高速缓存和一个主存）</p>
<p>当 CPU 执行一条读存储器字 w 的指令。它向 L1 高速缓存请求这个字。L1 要确定这个请求是否命中，首先进行组选择。从 w 的地址中间抽出<strong>索引位</strong>。这 s 个位就被看成是一个数组的索引，</p>
<h3 id="行匹配"><a href="#行匹配" class="headerlink" title="行匹配"></a>行匹配</h3><p>已经选择了一个组之后，接下来一步要确定是否有字 w 的一个拷贝存在这个组的一个高速缓存行中。在直接相映高速缓存中这很容易，因为每一组只有一行。如果有效位被设置了，而且标记位和要读的字 w 中的标记相匹配时，这一行就包含 w 的拷贝。换句话说，到这里就确定得到了一个缓冲命中。另一方面，如果有效位没有被设置（类似于冷不命中的情况），或者标记不匹配（别的数据也会放到这一组里），就得到一个缓冲不命中。</p>
<h3 id="字选择"><a href="#字选择" class="headerlink" title="字选择"></a>字选择</h3><p>一旦我们知道 w 就在这个这个高速缓存组中，最后一步只要确定我们要读的块是从哪里开始的就行。块偏移就提供了所需要的第一个字节的偏移。</p>
<h3 id="不命中时"><a href="#不命中时" class="headerlink" title="不命中时"></a>不命中时</h3><p>如果缓存不命中，那就需要从存储器层次结构中的下一层取出被请求块，然后将新块存储在组索引位指示的组中的一个高速缓存行中。如果每行都满了，就要驱逐一个现有行。对于直接相映高速缓存，因为每组只有一行，所以替换策略非常简单：用取出的行替代当前行。</p>
<h2 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h2><p>直接相映高速缓存的冲突不命中造成的原因就是因为每一组只有一行。<strong>组相联高速缓存</strong>（set associative cache）放松了这条限制，每个组保存多于一行的高速缓存行。$ 1 &lt; E &lt; \frac{C}{B} $</p>
<p>组选择和直接相映组选择没什么区别，也是用组索引标记组。</p>
<p>行匹配的话，就复杂一些，因为一个组有多个行，组中的任何一行都可以包含任何映射到这个组的存储器块，所以高速缓存必须搜索组中的每一行，来寻找一个标记与要读取的字中地址的标记匹配的有效行。</p>
<p>替换策略就变得复杂了。如果发生了不命中时组里还有空行，只需直接拉入 cache 中即可。但如果没有空行，我们就必须选择一个作为替换行。最简单的替换策略是随机选择一个要替换的行替换出去。更好的替换策略就考虑到了局部性原理，使得在较近的将来使用被替换出去的行的概率最小。<strong>最不常使用</strong>（Least-Frequently-Used，LFU）替换一个在过去一段时间内引用最少的一行。<strong>最近最少使用</strong>（Least-Recently-Used，LRU）替换最后一次访问时间最久远的一行。复杂的替换策略都需要额外的时间和硬件成本。一般来说，在存储器层次结构中，越往下走，一次不命中的开销就更加昂贵，用更好的替换策略也就显得更值得了。</p>
<h2 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h2><p><strong>全相连高速缓存</strong>（fully associative cache）是一个包含所有高速缓存行的组。即 $ E = \frac{C}{B} $</p>
<p>组选择就很简答，因为只有一个组，不需要在地址中有组索引位，只需要有效位、标记位和偏移。</p>
<p>行匹配和字选择和组相联高速缓存中是一样的。前面提到，对于一个组包含多个行的，就必须搜索所有行。因此构造一个又大又快的相联高速缓存很困难，也很昂贵。因此全相联高速缓存只适合做小的高速缓存，例如虚拟存储器中的翻译备用缓冲器（TLB），它缓存页表项。</p>
<h1 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h1><p>也就是<strong>写 cache</strong>，CPU 把待处理或已经处理的数据存入高速缓存中。</p>
<p>写入的情况比读要复杂一些。假设我们要写一个已经缓存了的字 w 的<strong>写命中</strong>（write hit）。在高速缓存更新了字 w 的拷贝之后，怎么更新 w 在更低层次中的拷贝呢？处理写命中有两种方式：</p>
<ul>
<li><strong>直写</strong>（write-throug）：立即将 w 的高速缓存块写回紧接的低一层中。</li>
<li><strong>写回</strong>（write-back）：尽可能推迟存储器更新，只有当替换算法要驱逐更新过的块时，才将其写到紧接的低一层中。</li>
</ul>
<p>如何处理<strong>写不命中</strong>（写不命中就是包含 w 的块不在 cache 中）？</p>
<ul>
<li><strong>写分配</strong>（write-allocate）：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块</li>
<li><strong>非写分配</strong>（not-write-allocate）：避开高速缓存，直接把这个字写到低一层中。</li>
</ul>
<p>优化写操作是一个细致而又困难的问题。</p>
<p>处理写命中时，直写相当简单，但缺点就是每次写都会引起总线流量。写回能显著减少总线流量，但增加了复杂性，对于高速缓存，需要维护一个额外的修改位，来表明这个块是否被修改过。处理写不命中时，写分配试图利用空间局部性，缺点是每次不命中都会导致一个低一层的块被传送到高速缓存。<strong>直写通常是非写分配的，写回通常是写分配的</strong>。</p>
<h1 id="参数对性能的影响"><a href="#参数对性能的影响" class="headerlink" title="参数对性能的影响"></a>参数对性能的影响</h1><ul>
<li>高速缓存的大小：较大的高速缓存可能会提高命中率，但实现一个大的存储器总是要更难一些。</li>
<li>块大小：较大的块可能可以更好的利用空间局部性。不过，对于给定的高速缓存大小，块越大意味着高速缓存行数越小，这会损害时间局部性比空间局部性好的程序的命中率。此外，因为块比较大，当出现不命中惩罚时，传送时间较长。</li>
<li>相联度：较高的相联度的优点是降低了由于冲突不命中出现抖动的可能性，缺点就是需要更多的成本，还会增加不命中惩罚，因为选择牺牲行的算法复杂度增加了。</li>
<li>写策略：直写比较容易实现。越往存储器层次结构下面走，传送时间增加，减少传送数量就变得更加重要。一般而言，高速缓存越往下层，越可能使用写回而不是直写。比较建议采用写回和写分配的高速缓存模型</li>
</ul>
<p>可以看到，很多事情不是非黑即白的，一项技术既不是完美无缺也不是一无是处，我们往往都需要寻找折衷方案。</p>
<h1 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h1><h2 id="利用局部性原理"><a href="#利用局部性原理" class="headerlink" title="利用局部性原理"></a>利用局部性原理</h2><ul>
<li>利用时间局部性，一旦一个数据对象在第一次不命中的时候被拷贝到缓存中，那么就期望后面对该目标有一系列的访问命中。</li>
<li>利用空间局部性：块包含多个数据对象，期望后面对该块中的其他对象的访问能弥补不命中后拷贝该块的花费。</li>
</ul>
<h2 id="避免冲突不命中"><a href="#避免冲突不命中" class="headerlink" title="避免冲突不命中"></a>避免冲突不命中</h2><p>例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> dotprod(<span class="built_in">float</span> x[<span class="number">8</span>], <span class="built_in">float</span> y[<span class="number">8</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> <span class="built_in">sum</span> = <span class="number">0.0</span>;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    for(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">sum</span> += x[i] * y[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 x 和 y 数组来说，这个函数具有良好的空间局部性，因此我们期望它对高速缓存的利用率较高。不幸的是，事实并非总是如此。这里，<code>float</code>是 4 个字节，假设 x 的是位于从 0 开始到 32 的连续存储器中，y 紧随其后，从 32 到 64。假设一个块是 16 个字节。高速缓存由两个组构成，整个高速缓存的大小是 32 字节。</p>
<p>在运行时，第一次迭代引用的是 <code>x[0]</code>，冷不命中，加载进入 cache 的第一个块包含了 <code>x[0]</code> 到 <code>x[3]</code> 的四个浮点数。接下来是对 <code>y[0]</code> 的引用。很不幸的是，<code>y[0]</code>的组索引和 <code>x[0]</code> 是一样的，因此包含 <code>y[0]</code>的块被拷贝进来的时候，又覆盖了包含了 <code>x[0]</code> 到 <code>x[3]</code> 的块。冲突不命中就是读取数据的时候，这些数据都映射到同一个组中。虽然高速缓存有其他空余的空间，但都没有利用到。用一个术语<strong>抖动</strong>（thrash）来描述在同一个组中不断出现冲突不命中。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/thrash1.png" alt=""></p>
<p>即使程序有良好的空间局部性，也可能因为抖动而出现速度下降，这个问题是很真实的。如果程序员能意识到，修正抖动是很容易的。例如，将数组 x 定义得更长一点，定义成 <code>float  x[12]</code>，让<code>x[i]</code>和<code>y[i]</code>映射到不同的组，就可以消除这个问题。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/thrash2.png" alt=""></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】13. 链接</title>
    <url>/2017/07/02/csapp-13-Linking/</url>
    <content><![CDATA[<p>下面就要进入本书的第二部分——在系统上运行程序。书的第一部分，主要是研究单个应用程序，关注的是数据类型、机器指令、程序性能、存储器系统等话题。在书的第二部分，我们继续对计算机系统的探索。现代操作系统与硬件合作，（进程的概念、虚拟存储器）为每个程序提供一种假象，好像这个程序是计算机上唯一运行的程序。实际上在任何时间点，计算机上都有多个程序在运行。</p>
<p><strong>链接</strong>（Linking）是将各种代码和数据收集起来组合成一个<strong>单一文件</strong>的过程。链接是由<strong>链接器</strong>（Linker）完成的。链接器在软件开发中扮演着一个关键的角色，因为它使<strong>分离编译</strong>成为可能——我们不用将一个大型程序组织为一个巨大的源文件，而是把它分解为更小、更好管理的模块，我们可以独立修改和编译这些模块。当我们修改一个模块时，只需重新编译这个模块，重新链接即可，不必编译其他文件。</p>
<p>特别是在现在的 IDE 都比较发达的情况下，链接通常是默默无闻的。当我们写好代码，按下“编译并运行”的按键时，我们通常不会很注意链接的过程。那学习链接的概念有什么好处呢？</p>
<ul>
<li>帮助你构造大型程序</li>
<li>避免一些危险的编程错误</li>
<li>了解语言的作用域规则</li>
<li>理解其他重要系统概念，（加载和运行程序、虚拟存储器、分页、存储器映射、共享库）</li>
</ul>
<h1 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h1><p><img src="http://osax8w13y.bkt.clouddn.com/13-compilesystem.png" alt=""></p>
<ul>
<li><strong>预处理器</strong>（cpp）：根据 # 开头的的命令，修改原始的 C 程序。会将源代码<code>hello.c</code>转变为<code>hello.i</code>，是被修改后的源文件。</li>
<li><strong>编译器</strong>（cc1）：将文本文件<code>hello.i</code>翻译成<code>hello.s</code>，它就是 C 代码对应的汇编语言程序。汇编程序是很有用的，它以一种标准的文本格式描述低级的机器语言指令，也就为不同高级语言的不同编译器提供了通用的输出语言。</li>
<li><strong>汇编器</strong>（as）：将<code>hello.s</code>翻译成<strong>机器语言指令</strong>，并打包成<strong>可重定位目标程序</strong>（relocatable object program）的形式，保存在<code>hello.o</code>中。<code>hello.o</code>是一个二进制文件，字节编码是机器语言指令。如果直接用文本编辑器打开二进制文件，将会看到乱码。</li>
<li><strong>链接器</strong>（ld）：将对象程序<code>hello.o</code>和所需要的静态库<code>lib.a</code>经过链接器的处理，最终成为一个可执行目标文件。例如，这个 hellowolrd 程序用到了函数 <code>printf</code>，这个函数就存在一个名为 <code>printf.o</code> 的单独编译好的目标文件。链接器就负责合并两个目标文件，得到一个<strong>可执行目标文件</strong>（executable object file），简称可执行文件<code>hello.exe</code></li>
<li><strong>加载器</strong>（loader，shell 调用）：将可执行文件加载到内存中执行。</li>
</ul>
<p>假设我们写了两个 C 语言代码，分别是<code>main.c</code>和<code>sum.c</code>，前者中代码用到了后者中定义的函数。两者分别经过编译过程（cpp、cc1、as）之后，生成可重定位目标文件<code>main.o</code>和<code>sum.o</code>，最后，执行链接操作：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">ld -o <span class="built_in">sum</span> main.o <span class="built_in">sum</span>.o</span><br></pre></td></tr></table></figure>
<p>就得到可执行文件<code>sum</code>。</p>
<h1 id="链接的基本知识"><a href="#链接的基本知识" class="headerlink" title="链接的基本知识"></a>链接的基本知识</h1><p>下面来了解一些关于链接的术语。</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>Unix 下 <code>ld</code> 程序，叫做<strong>静态链接器</strong>，以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接，可以加载运行的可执行目标文件做为输出。</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>三种形式：</p>
<ul>
<li><strong>可重定位目标文件</strong>。包含二进制代码和数据。可以在链接时与其他可重定位文件结合起来，创建一个可执行目标文件</li>
<li><strong>可执行目标文件</strong>，可以被拷贝到存储器中执行。</li>
<li><strong>共享目标文件</strong>，一类特殊的可重定位目标文件，可以在加载或运行时动态地加载到存储器中并链接。</li>
</ul>
<p>目标文件纯粹是字节块的集合，有的块包含程序代码，有的保存数据，或者指导链接器和加载器的数据结构。链接器对目标机器知之甚少，编译器和汇编器已经完成了大部分工作。</p>
<p>各个系统之间，目标文件格式不尽相同。下面讨论的是 Unix 可执行和可链接目标文件格式（Executable and Linkable Format，<strong>ELF</strong>）。虽然我们的讨论集中在 ELF 上，但是不管是那种格式，基本概念是互通的。</p>
<h1 id="链接器做了什么？"><a href="#链接器做了什么？" class="headerlink" title="链接器做了什么？"></a>链接器做了什么？</h1><p>链接器主要是将有关的目标文件彼此相连接生成可加载、可执行的目标文件。链接器的核心工作是：</p>
<ul>
<li><strong>符号解析</strong>（symbol resolution）</li>
<li><strong>重定位</strong>（relocation）</li>
</ul>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>来看一下典型的 ELF 可重定位目标文件的格式。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/ELF1.png" alt=""></p>
<table>
<thead>
<tr>
<th>节</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>ELF header</td>
<td>描述生成该文件的系统的字的大小、字节顺序、目标文件类型、机器类型等，帮助链接器语法分析和解释目标文件的信息</td>
</tr>
<tr>
<td>.text</td>
<td>编译后的机器代码</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据</td>
</tr>
<tr>
<td>.data</td>
<td>已初始化的全局变量</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化的全局变量，在目标文件不占实际空间，是“better save space”的缩写</td>
</tr>
<tr>
<td>symtab</td>
<td><strong>符号表</strong>，存放在程序中定义和引用的函数与全局变量的信息</td>
</tr>
<tr>
<td>.rel.text</td>
<td>.text节的重定位信息，当链接时，指令的位置就被修改</td>
</tr>
<tr>
<td>.rel.data</td>
<td>.data节的重定位信息，当链接时，变量的位置就被修改</td>
</tr>
<tr>
<td>.debug</td>
<td>调试符号表</td>
</tr>
<tr>
<td>Section Header Table</td>
<td>节头部表，存放每个节的偏移和大小</td>
</tr>
</tbody>
</table>
<p>每个可重定位目标模块 m ，都有一张符号表。符号表实际上是一个结构体数组，每一个元素包含名称、大小和符号的位置。符号表存放如下三种符号：</p>
<ul>
<li>在 m 中定义，且能被其他模块引用全局符号，也就是不带 static 的全局变量。</li>
<li>在其他模块中定义，并被 m 引用的全局符号，是其他模块中的全局变量或者函数。这些符号叫做外部符号（external）</li>
<li>在 m 中定义的带 static 的全局变量，这些符号对 m 是随处可见的，但不能被其他模块所引用。</li>
</ul>
<p>我们知道，局部变量会由栈来管理。局部静态变量，会存放到<code>.bss</code>或者<code>.data</code>节中，也不由符号表来管理。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>链接时，符号解析就是将对每个符号的引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。</p>
<p>看下面两张图，可以理解符号表的作用，以及链接器对哪种类型的符号感兴趣：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/symbol1.png" alt=""></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/symbol2.png" alt=""></p>
<p>符号解析的过程：对定义和引用在相同模块中的本地符号，符号解析相当简单。编译器只允许每个模块中每个本地符号只有一个定义。不过，对全局符号的引用解析就麻烦得多，当编译器遇到一个不是在本模块中定义的符号（变量名或函数名）时，它会<strong>假设</strong>这是在某个其他模块中定义的，并把后续工作交给链接器处理。如果链接器在所有的模块都找不到这个被引用的符号的定义，它就会输出报错信息并终止。一般来说，报错信息就是：undefined reference to something。</p>
<h2 id="解析多重定义的符号"><a href="#解析多重定义的符号" class="headerlink" title="解析多重定义的符号"></a>解析多重定义的符号</h2><p>符号解析时，符号有强弱之分：</p>
<ul>
<li>强符号：函数和初始化的全局变量。</li>
<li>弱符号：未初始化的全局变量。</li>
</ul>
<p>根据下面的规则来处理多重定义的符号：</p>
<ul>
<li>不允许有多个重名强符号。</li>
<li>如果有一个强符号和多个弱符号，选择强符号</li>
<li>多个弱符号，那么就从中任意选择一个。</li>
</ul>
<p>在上图的<code>main.c</code>中，<code>time</code>是弱符号，其余的符号是强符号。</p>
<p>如果说在两个不同的文件中定义了同名的函数，由于函数都是强符号，链接时就会报错。</p>
<p>下面看一个特殊的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">15212</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = 0x%x y = 0x%x \n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件2</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果如下，可以看到，变量 y 的值也被改变了。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/ex.png" alt=""></p>
<p>上述代码的问题在于，文件2中定义的变量 x 是弱定义，在调用 f 函数对 x 进行写入的时候，实际上操作的应该是文件1中定义的强符号。在文件2中，x 的类型是 double，占 8 个字节，赋值语句 <code>x = -0.0</code> 会导致文件1中定义的强符号 y 的数据也被覆盖。在 linux 下，编译会发出一条警告，提示我们，两个同名符号的大小不同。</p>
<p>由上面的例子可以知道，对链接知识的不了解，可能导致意想不到的错误，而且编译器不会报 error。因此，我们可以得到一些很重要的编程经验：</p>
<ul>
<li><strong>避免使用全局变量</strong></li>
<li>如果一定要使用全局变量：<ul>
<li>加上 <code>static</code>，使其成为静态变量。</li>
<li>定义全局变量时初始化，使其成为强符号。</li>
<li>使用 <code>extern</code> 来标识是从其他模块引用的全局符号。</li>
</ul>
</li>
</ul>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>重定位就是当链接器完成了符号解析这一步之后，链接器就知道了输入模块的代码节和数据节的确切大小，可以开始重定位了。看下图：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/relocation.png" alt=""></p>
<p>重定位说白了就是把不同可重定位对象文件拼成可执行对象文件。在这个合并的步骤中，为每个符号分配<strong>运行时地址</strong>。</p>
<p>重定位分两步：</p>
<ul>
<li><strong>重定位节和符号定义（合并）</strong>。将所有相同的节合并为新的聚合节。然后，链接器确定运行时存储器地址赋给新的节，再根据偏移量赋给每个符号。此时，程序中的每个指令和全局变量都有唯一的<strong>运行时地址</strong>了。</li>
<li><strong>重定位节中的符号引用</strong>。链接器修改代码节和数据节中对每个符号的引用，使其指向正确的运行时地址。</li>
</ul>
<p>下面是一个实验，源文件<code>relocation.c</code>如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum(<span class="type">int</span> *a, <span class="type">int</span> n);</span><br><span class="line"><span class="type">int</span> <span class="keyword">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="keyword">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源文件<code>sum.c</code>如下：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum(<span class="type">int</span> *a, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, <span class="built_in">result</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">        <span class="built_in">result</span> += a[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用指令：<code>gcc -c relocation.c -o relocation.o</code>，-c 选项的意思是只编译不链接，我们可以由此得到可重定位目标文件。</p>
<p>使用指令：<code>objdump -r -d relocation.o</code>反编译对应的可重定位对象文件，可以得到如下的汇编代码：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/relocationex1.png" alt=""></p>
<p>全局数组<code>array</code>需要重定位。call 指令调用函数 <code>sum</code>，这也是一个需要重定位的符号。我们将目光移到 call 指令这一行。<code>e8</code>是 <code>call</code> 的字节编码，可以看到，后面的操作数都是零，就是留出位置让链接器在链接的时候填上对应的实际内存地址。同理<code>bf</code>是<code>mov</code>的字节编码，<code>array</code>的首地址也是链接完成后才知道的，因此还没有确定地址。</p>
<p>call 指令的下一行，有一句<code>13: R_X86_64_PC32 sum-0x4</code>，这个东西叫做<strong>重定位条目</strong>（relocation entry），无论何时汇编器遇到了对最终位置未知的符号引用，就会生成一个重定位条目，也就是存放在<code>.rel.text</code>和<code>.rel.data</code>节中的数据。<code>objdump</code>为了方便，将汇编代码和重定位条目放到一起显示，虽然他们实际存储不在一起。</p>
<h3 id="PC相对引用重定位"><a href="#PC相对引用重定位" class="headerlink" title="PC相对引用重定位"></a>PC相对引用重定位</h3><p>我们现在来看一下链接器如何确定 call 调用的实际位置。重定位条目<code>13: R_X86_64_PC32 sum-0x4</code>告诉链接器要修改位于目标文件偏移量 0x13 （数一下机器编码的字节数，可以发现 call 指令刚好是第 0x13 个字节）的 <strong>PC相对引用</strong>（PC是指程序计数器），使得它在运行时指向 sum 的偏移量 <code>-0x4</code> 位置。</p>
<p>使用指令<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">gcc -o relocation relocation.<span class="keyword">c</span> sum.<span class="keyword">c</span></span><br><span class="line">objdump -dx relocation</span><br></pre></td></tr></table></figure></p>
<p>在可执行文件的反汇编代码中找到 main 这一节，main 的地址是<code>0x4004d6</code>，sum 的地址是<code>0x4004f5</code>。这也就是链接器为节选择了<strong>运行时地址</strong>。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/relocationex2.png" alt=""></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ADDR</span><span class="params">(.text)</span></span> = <span class="number">0</span>x4004d6</span><br><span class="line"><span class="function"><span class="title">ADDR</span><span class="params">(sum)</span></span> = <span class="number">0</span>x4004f5</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算引用的运行时，程序计数器的地址</span></span><br><span class="line">refaddr = <span class="built_in">ADDR</span>(.text) + offset = <span class="number">0</span>x4004d6 + <span class="number">0</span>x13 = <span class="number">0</span>x4004e9</span><br><span class="line"></span><br><span class="line"><span class="comment">//因此 call 的目标地址是 （第二个refptr是 0 ，计算前 call 后的操作数）</span></span><br><span class="line">*refptr = <span class="built_in">unsigned</span>(<span class="built_in">ADDR</span>(sum) - refaddr) -<span class="number">0</span>x4</span><br><span class="line">        = <span class="built_in">unsigned</span>(<span class="number">0</span>x4004f5 - <span class="number">0</span>x4004e9) -<span class="number">0</span>x4</span><br><span class="line">        = <span class="number">0</span>x8 </span><br></pre></td></tr></table></figure>
<p>以上就是 PC 相对重定位的过程。链接器将结果填入可执行目标文件，call 指令有了如下的重定位形式：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">4004e8</span>:     e8 <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">4004</span>f5 &lt;sum&gt;</span><br></pre></td></tr></table></figure>
<h3 id="绝对引用重定位"><a href="#绝对引用重定位" class="headerlink" title="绝对引用重定位"></a>绝对引用重定位</h3><p>对于全局数组 <code>array</code> 的重定位条目：<code>e：R_X86_64_32 array</code>，重定位条目告诉链接器，这是一个<strong>绝对引用</strong>，将要修改位于目标文件偏移量 0xe 的绝对引用，使其指向符号 <code>array</code>。绝对引用就相对简单，只需要把链接器确定的数组开头的运行时地址，即<code>&amp;array[0]</code>填入相应的地方即可。</p>
<h1 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h1><p>我们目前为止做的工作都是链接器读取一组可重定位目标文件，并把它们链接起来。那在处理一大堆常用的标准函数，例如<code>printf、scanf、malloc</code>等，我们要怎么做呢？</p>
<ul>
<li>思路1：让编译器辨认出对标准函数的调用，生成相应的代码<ul>
<li>缺点：对于有大量标准函数的编程语言，这种方法会显著增加编译器的复杂性。</li>
</ul>
</li>
<li>思路2：将所有的标准函数放到一个单独的可重定位目标文件中，程序员将其与他们自己的目标文件链接生成可执行文件。<ul>
<li>缺点：这样做的话，对于每个可执行文件，都存在一份所有标准函数的集合，很浪费空间。</li>
</ul>
</li>
<li>思路3：将每个标准函数创建一个独立的可重定位目标文件，然后链接的时候显示地链接标准函数<ul>
<li>缺点：耗时，容易出错。</li>
</ul>
</li>
</ul>
<p>共同的缺点：对于标准函数的任何改变，都需要修改新的编译器版本或要重新编译整个可重定位目标文件，这十分耗时。</p>
<p>解决的方法就是引入<strong>库</strong>（library）的概念。</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>比较老式的做法就是所谓的<strong>静态库</strong>（Static Libraries, <code>.a</code> 后缀表示 archive files，归档文件）。</p>
<p>静态库是一个外部函数与变量的集合体。静态库的文件内容，通常包含一堆程序员自定的变量与函数，在编译期间，<strong>静态库没有把全部内容链接，只是把需要的代码链接进去</strong>这个可执行文件与编译可执行文件的程序，都是一种程序的静态创建（static build）。</p>
<p>具体过程就是把不同文件的 .o 文件通过 Archiver 打包成为一个 .a 文件。Archiver 支持增量更新，如果有函数变动，只需要重新编译改动的部分。</p>
<p>在 C 语言中最常用的是 C 标准库与 C 数学库。C 标准库一般可以通过 libc.a 来进行引用，大小 4.6 MB，包含 1496 个对象文件，主要负责输入输出、内存分配、信号处理、字符串处理、操作数据、生成随机数及整型的数学运算。C 数学库可以通过 libm.a 来引用，大小 2 MB，包含 444 个对象文件，主要是提供浮点数运算的支持（比如三角函数、幂次等等）</p>
<p>下面看一个具体例子，各个文件代码如下：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/staticlibrary1.png" alt=""></p>
<p>使用如下指令：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">只编译不链接，获得两个目标文件：</span><br><span class="line">gcc -c addvec<span class="selector-class">.c</span> multvec<span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">将两个目标文件打包成一个后缀为 <span class="selector-class">.a</span> 的静态库：</span><br><span class="line">ar rcs libvector<span class="selector-class">.a</span> addvec<span class="selector-class">.o</span> multvec<span class="selector-class">.o</span> </span><br><span class="line"></span><br><span class="line">使用静态库链接</span><br><span class="line">gcc -c <span class="selector-tag">main</span><span class="selector-class">.c</span> -o <span class="selector-tag">main</span><span class="selector-class">.o</span></span><br><span class="line">gcc -static -o <span class="selector-tag">p</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> ./libvector.a</span><br></pre></td></tr></table></figure>
<p>-static 参数告诉编译器，链接器应当构建一个完全链接的可执行文件。</p>
<p>链接器会判断：<code>addvec.o</code> 中的符号 <code>addvec</code> 被 <code>main.o</code> 引用，因此拷贝这个模块到可执行文件。由于没有用到 <code>multvec.o</code> 中的符号，因此不会拷贝这个模块到可执行文件。此外，由于用到了函数 <code>printf</code> ，链接器还会拷贝 <code>libc.a</code> 中的 <code>printf.o</code> 模块，以及许多其他运行时需要用到的模块。下图很清晰的展现了静态库的好处：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/library2.png" alt=""></p>
<h2 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h2><p>静态库仍有缺点：需要定期维护和更新。如果程序员想要用一个库的最新版本，那么就必须先更新该库，然后再将更新的库与他们的程序重新链接。以及，几乎每个 C 程序都要用到标准 I/O 函数，例如 <code>printf</code>和<code>scanf</code> 之类。按照静态库的思路，这些代码会被拷贝到<strong>每个运行的进程的文本段</strong>中，在一个运行了几十个进程的系统上，会造成存储器资源的极大浪费。</p>
<p><strong>共享库</strong>（shared library）就是致力解决静态库缺陷的现代创新产物。共享库是一个模块，可以在<strong>运行时</strong>加载到任何的存储器位置，并和一个存储器中的程序链接起来。这个过程就叫<strong>动态链接</strong>（dynamic linking），由<strong>动态链接器</strong>（dynamic linking）来完成。</p>
<p>共享库也叫<strong>共享目标</strong>（shared object），在 Unix 系统下常用后缀名 .so 来表示。在 Windows 中大量利用了动态链接库，就是 DLL（dynamic linking library）。</p>
<p>如果还是以上面的例子，但是以动态链接的方式，工作原理如下图：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/dynamiclinking.png" alt=""></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">创建一个共享的目标文件</span><br><span class="line">gcc -shared -fPIC -o libvector<span class="selector-class">.so</span> addvec<span class="selector-class">.c</span> mutlvec<span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">创建可执行目标文件 p2，这个文件的形式是可以在运行时与 libvector<span class="selector-class">.so</span> 动态链接</span><br><span class="line">gcc -o p2 <span class="selector-tag">main</span><span class="selector-class">.c</span> ./libvector.so</span><br></pre></td></tr></table></figure>
<p>-fPIC 指示编译器生成<strong>与位置无关的代码</strong>。目的就是允许多个正在运行的进程共享存储区中相同的库代码，节约了存储器空间。</p>
<p>基本的思路是：创建可执行文件时，静态地执行一部分链接，当程序被加载运行时，动态地完成剩余的链接过程。</p>
<h1 id="可执行目标文件、加载运行"><a href="#可执行目标文件、加载运行" class="headerlink" title="可执行目标文件、加载运行"></a>可执行目标文件、加载运行</h1><p>下图可以看到一个可执行目标文件的形式，它是由多个目标文件合并而来的。我们最开始的 C 源代码，是一个 ASCII 码文件，已经被转换成一个二进制文件，包含了加载程序且运行它所需的所有信息。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/execute.png" alt=""></p>
<p>运行可执行目标文件，就是在外壳中输入它的名字，外壳会调用一个叫做<strong>加载器</strong>（loader）的操作系统代码来运行它。加载器将可执行目标文件的代码和数据从磁盘拷贝到存储器中，然后跳转到程序的入口点，运行该程序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>链接是一种运行程序由多个目标文件构造得来的技术。链接可以发生在编译时（静态链接）、加载时、运行时（动态链接）。理解链接的相关知识点，我们从代码级进入到系统级，有益于我们了解操作系统是如何完成各种复杂工作的。</p>
<hr>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期  ICS课程网站</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%BA%93">wiki -静态库</a></li>
<li><a href="http://www.cnblogs.com/oubo/archive/2011/12/06/2394631.html">C编译器、链接器、加载器详解</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】11. 存储器层次结构</title>
    <url>/2017/06/29/csapp-11-The-Memory-Hierarchy/</url>
    <content><![CDATA[<p>在没有专门研究存储器系统之前，我们依赖的存储器模型是一个很简单的概念，也就是把它看成一个线性数组，CPU 能在一个常数时间内访问任何一个存储器位置。虽然在研究别的问题时，这是一个有效的模型，但是它不能反映存储器系统的实际工作方式。</p>
<p><strong>存储器系统</strong>（memory system）是一个具有不同容量、成本、访问时间的存储器<strong>层次结构</strong>。CPU <strong>寄存器</strong>保存着最常用的数据；靠近 CPU 的小的、快速的<strong>高速缓存存储器</strong>（cache）作为一部分存储在相对慢速的<strong>主存储器</strong>（简称主存）中的数据；主存用来暂时存放存储在容量大、慢速<strong>磁盘</strong>上的数据；磁盘又作为通过网络连接的其他机器的磁盘上的数据的缓冲区域。</p>
<p>存储器层次结构是可行的，因为一个编写良好的程序总是倾向于更频繁访问某一层次上的存储设备。所以，下层的存储设备可以更慢速一点，也因此可以更大、更便宜。</p>
<p>计算机程序有一个重要的基本属性，叫做<strong>局部性原理</strong>（locality）。具有良好局部性原理的程序比局部性差的程序更多地倾向于在存储器层次结构中的较高层次处访问数据，因此运行的更快。</p>
<p>作为一个程序员，你应该理解存储器系统，因为它对应用程序的性能有着巨大的影响。如果了解系统是如何将数据在存储器层次中上上下下移动的，那么你就可以编写你的应用程序，使数据尽量存储在层次较高的地方，CPU 能更快得访问到它们。</p>
<p>计算机技术的成功很大程度上源于存储技术的巨大进步。</p>
<h1 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h1><p>随机存取存储器（<strong>RAM</strong>, Random-Access Memory），有两种类型，第一种叫做静态 RAM（static RAM）。<strong>SRAM</strong> 将每个位存储为一个双稳态（bistable）的存储器单元里，每个单元用一个六晶体管电路来实现。这种电路有一种限制，就是可以无限期保持两种不同的电压状态之一。由于其双稳态特性，只要有电，它就会永远保持它的值。</p>
<p>动态 RAM（Dynamic RAM），将每个位存储为对一个电容的充电。<strong>DRAM</strong> 存储器可以制造得非常密集，每个单元由一个电容和访问晶体管组成。与 SRAM 不同，DRAM 对干扰非常敏感，且被干扰后永远无法恢复。存储器系统必须<strong>周期性</strong>地通过读出，重写来<strong>刷新</strong>存储器的每一位。</p>
<p>SRAM 是只要有供电，那它就会保持不变，不需要刷新。SRAM 速度比 DRAM 快，对干扰不敏感，但也贵得多。SRAM 用来作为高速缓存存储器，DRAM 用来作为主存以及图形系统的帧缓冲区。</p>
<h1 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h1><p>如果断点，那么 DRAM 和 SRAM 会丢失信息，所以他们是易失（volatile——的。<strong>非易失性存储器</strong>（nonvolatile memory）即使是在关电后，依然保持它们的信息。如果想让数据持续保持，要考虑使用非易失性存储器。<strong>PROM</strong>（Progrommable ROM）可编程只读存储器，只能被编程一次。可擦写可编程 ROM（Rrasable Progrommable ROM，<strong>ERPOM</strong>）有一个透明的石英窗口，允许光透过，照射存储单元。紫外线照射，这个单元就被清除。对 ERPOM 的编程是通过一种特殊设备完成。ERPOM 的擦写和重编程的次数可以达到1000次。电子可擦除 ROM（Electrically Erasable ROM，<strong>EEPROM</strong>）可以在印制电路卡上编程。闪存（flash memory）是一种基于 EERPOM 的非易失性存储器。它是一种重要的存储技术，为大量电子设备提供快速、持久的非易失性存储，例如数码相机、手机、笔记本、台式机、音乐播放器等。</p>
<h1 id="访问主存——总线"><a href="#访问主存——总线" class="headerlink" title="访问主存——总线"></a>访问主存——总线</h1><p>数据流通过称为<strong>总线</strong>（bus）的<strong>共享电子电路</strong>在处理器和 DRAM 主存中来来回回。每次 CPU 和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为“总线事务”（bus transaction）。读事务从主存传送数据到 CPU，写事务从 CPU传送数据到主存。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/bus.png" alt=""></p>
<p>总线是一组并行的导线，能携带信号、数据、地址。多个设备可以共享同一根总线。数据和地址信号可以共享一组线，也可以用不同的，取决于总线的设计。信号的作用是同步事务，标识当前正在被执行事务的类型。</p>
<p>总线配置：主要部件是 CPU 芯片、I/O 桥芯片组（包括存储控制器），DRAM 存储器模块。这些部件由总线连接起来。<strong>系统总线</strong>连接 CPU 和 I/O 桥。<strong>存储器总线</strong>连接 I/O 桥和主存。I/O 桥的作用是将系统总线的电子信号翻译成存储器总线的电子信号。总线设计是计算机系统中复杂而又变化迅速的方面。使用简单而抽象的模型是很有用的，可以掌握主题思想而不必与私有的设计细节绑得太紧。</p>
<p>假设 CPU 需要从硬盘中读取一些数据，就发起读事务，会给定指令，逻辑块编号和目标地址，并发送给存储器总线。主存感受到信号，就读地址，从 DRAM 中取出数据，写到存储器总线，然后信号沿着总线返回 CPU。假设 CPU 需要把寄存器的内容写到主存上，就发起写事务，CPU 还是先将地址放到系统总线上，存储器从存储器总线读出地址，然后等待数据到达。 CPU 将寄存器内容拷贝到系统总线上，最后主存从存储器总线读取这些数据，然后存储到 DRAM 中。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/bus-transaction.png" alt=""></p>
<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p><strong>磁盘</strong>（disk）是由<strong>盘片</strong>（platter）构成的，每个盘片有两个面，或者成为<strong>表面</strong>（surface），表面覆盖着磁性记录材料。盘片中央有一个可以旋转的<strong>主轴</strong>（spindle），它是的盘片以固定速度旋转，速度通常在5000 ~ 15000 转每分钟。磁盘通常包含一个或多个盘片，封装在一个密封的容器内，整个装置被称为<strong>磁盘驱动器</strong>（disk drive），简称为磁盘。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/disk1.png" alt=""></p>
<p>每个表面是由一组成为<strong>磁道</strong>（track）的同心圆组成的。每个磁道划分成一组<strong>扇区</strong>（sector）。每个扇区包含相等数量的数据位（比如 512 字节），数据就编码在扇区上的磁性材料中。扇区之间有一些间隙（gap）。术语<strong>柱面</strong>（cylinder）来描述多个盘片的驱动器，柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合。</p>
<h2 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h2><p>容量是指磁盘可以记录的最大位数，由下面几个因素决定：</p>
<ul>
<li>记录密度（recording density，位/英寸）：track 中 1 英寸能保存的字节数</li>
<li>磁道密度（track density，道/英寸）：1 英寸直径能保存多少条 track</li>
<li>面密度（areal density，位/平方英寸）：上面两个数值的乘积</li>
</ul>
<p>$  磁盘容量 = \frac{字节数}{扇区} × \frac{平均扇区数}{磁道} × \frac{磁道数}{表面} × \frac{表面数}{盘片} × \frac{盘片数}{磁盘}  $</p>
<p>假设一个磁盘有 5 个盘片，每个扇区 512 个字节，每个面 20000 个磁道，每条磁道平均 300 个扇区。则磁盘容量是：</p>
<p>$ 磁盘容量 = \frac{512 字节}{扇区} × \frac{300 个扇区}{磁道} × \frac{20000 个磁道}{表面} × \frac{2 个表面}{盘片} × \frac{5 个盘片}{磁盘} = 30 720 000 000 字节 = 30.72 GB $</p>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>磁盘用<strong>读/写头</strong>来读写存储在磁性表面的位，当磁道上的每个位通过它的下面时，读写头能够感知到这个位的值，也能修改这个位的值。读写头连接在一个<strong>传送臂</strong>（actuator arm）的一端。通过旋转，传动臂可以将读写头定位在磁盘上的任何磁道上，这个行为叫做<strong>寻道</strong>（seek）。在任何时刻，所有读写头位于同一柱面。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/disk2.png" alt=""></p>
<p>寻道时间：</p>
<p>$ T_{avgseek}  $ 通常在 3 ~ 9 ms，一次最大的寻道时间 $ T_{maxseek} $ 可以达到 20 ms。</p>
<p>一旦读写头定位到了期望的磁道，下一个行动就是等待目标扇区的第一个位旋转到读写头下。最好情况下就是要读取的位刚好在读写头下，最差的情况就是需要旋转一整圈。</p>
<p>旋转时间：</p>
<p>$$ T_{avg rotation} = \frac{1}{2} × \frac{1}{RPM} × \frac{60 secs}{1 min} $$</p>
<p> RPM 是指：rotation per minute 每分钟旋转次数，RPM 的倒数就是 MPR ，即每转一圈需要的分钟数。乘以二分之一后转换单位即可。</p>
<p>当寻道和旋转都完成了之后，驱动器就可以开始读或写内容了。读写传送时间依赖于旋转速度和每条磁道的扇区数目。粗略估计一个扇区以秒为单位的平均传送时间如下：</p>
<p>$$ T_{avgtransfer} = \frac{1}{RPM} × \frac{1}{平均扇区数 / 磁道} × \frac{60 secs}{1 min} $$</p>
<p>传送时间 = 转一圈所需分钟数 × 一个扇区占一个磁道的占比 </p>
<ul>
<li>访问磁盘扇区的主要时间是寻道时间和旋转时间。开始访问第一个字节要耗时很久，但访问剩下的字节几乎不需要时间。</li>
<li>寻道时间和旋转延迟差不多。</li>
</ul>
<p>例如有一个如下参数的磁盘</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>旋转速率</td>
<td>7200 RPM</td>
</tr>
<tr>
<td>平均寻道时间</td>
<td>9ms</td>
</tr>
<tr>
<td>每条磁道的平均扇区数</td>
<td>400</td>
</tr>
</tbody>
</table>
<p>平均旋转时间：</p>
<p>$$ T_{avgrotation} = \frac{1}{2} × \frac{1}{7200} = 4 ms $$</p>
<p>传送时间：</p>
<p>$$ T_{avg transfer} = \frac{1}{7200} × \frac{1}{400}  = 0.02 ms $$</p>
<p>总时间为：</p>
<p>$$ T_{access} = T_{avgseek} + T_{avgrotation} + T_{avgtransfer} = 13.02 ms $$ </p>
<h1 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h1><p><img src="http://osax8w13y.bkt.clouddn.com/ssd.png" alt=""></p>
<p>基于闪存的磁盘驱动器，称为<strong>固态硬盘</strong>（Solid State Disk，<strong>SSD</strong>），是替代传统磁盘的极有吸引力的替代产品。<strong>闪存翻译层</strong>（flash translation layer）是一个硬件设备，扮演与磁盘控制器相同的角色。闪存芯片替代传统磁盘中的机械驱动器。固态硬盘中分成很多的块(Block)，每个块又有很多页(Page)，大约 32-128 个，每个页可以存放一定数据（大概 4-512KB），页是进行数据读写的最小单位。对一个页进行写入操作的时候，需要先把整个块清空后才能写这一页，而一个块大概在 100,000 次写入之后就会报废。</p>
<p>与传统的机械硬盘相比，固态硬盘由半导体存储器构成，没有移动的部件，因此在在读写速度上有很大的优势，能耗低，更结实。SSD 也容易磨损。</p>
<h1 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h1><p>一个编写良好的计算机程序常常具有比较好的<strong>局部性</strong>（locality）</p>
<ul>
<li><strong>时间局部性</strong>(Temporal Locality): 如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。程序循环、堆栈等是产生时间局部性的原因。</li>
<li><strong>空间局部性</strong>(Spatial Locality): 在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。</li>
<li><strong>顺序局部性</strong>(Order Locality): 在典型程序中，除转移类指令外，大部分指令是顺序进行的。顺序执行和非顺序执行的比例大致是5:1。此外，对大型数组访问也是顺序的。指令的顺序执行、数组的连续存放等是产生顺序局部性的原因。</li>
</ul>
<p>一般而言，<strong>具有良好的局部性的程序比局部性差的程序运行得更快。</strong>计算机系统的各个层次，硬件、操作系统、应用程序，都利用了局部性。</p>
<p>下面来看局部性原理在程序设计时的体现。我们来看看一个利用循环对数组求和的函数对于每个数据引用的模式</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> sumv(<span class="built_in">int</span> *v, <span class="built_in">int</span> <span class="built_in">N</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i, <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    for(i = <span class="number">0</span>; i &lt; <span class="built_in">N</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sum</span> += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为数组中的元素是一个接一个访问的，因此有很好的空间局部性。由于每个元素只访问一次，因此时间局部性很差。对于循环体中的每个变量，函数要么有很好的空间局部性，要么有很好的时间局部性。因此这个函数有良好的局部性。</p>
<p>我们说像 sumv 函数这样访问数组的函数，具有 <strong>步长为 1</strong>的引用模式（stride-1 reference pattern）每隔 k 个元素进行访问，就叫 <strong>步长为 k</strong> 的引用模式。一般来说，随着步长的增加，空间局部性下降。对于多维数组来说，步长就是一个很重要的问题。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/good-locality.png" alt=""></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/bad-locality-fixup.png" alt=""></p>
<p>一些看上去很小的改动对程序的性能会有很大的影响。步长越小，空间局部性越好。如果在存储器中以大步长跳来跳去，空间局部性很差。了解了高速缓存的工作原理后，就能明白为什么具有良好局部性的程序通常比局部性差的程序运行得更快。</p>
<h1 id="存储体系"><a href="#存储体系" class="headerlink" title="存储体系"></a>存储体系</h1><p>存储技术和计算机软件的一些基本属性：</p>
<ol>
<li>硬件存储技术：不同的存储技术的访问时间差异很大，速度快的技术成本较高，速度慢的技术容量较大。不同的存储技术有不同的价格和性能折中，也以不同的速度在变化。</li>
<li>软件：一个编写的好的计算机程序倾向于展现出良好的局部性。</li>
<li>硬件和软件的这些基本属性互相补充得很完美。它们这种补充性质让人们想到一种组织存储器系统的方法，就是<strong>存储器层次结构</strong>（memory hierarchy）。从高层往底层走，存储设备变得更慢，但也变得更便宜，容量更大。</li>
</ol>
<p><img src="http://osax8w13y.bkt.clouddn.com/memory-hierarchy.png" alt=""></p>
<hr>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期  ICS课程网站</a></li>
<li><a href="http://baike.baidu.com/item/%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">局部性原理</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】14. 异常控制流和进程</title>
    <url>/2017/07/09/csapp-14-Exception-Control-Flow-Execptions-and-Processes/</url>
    <content><![CDATA[<p>从给处理器加电，到断电为止，处理器做的工作其实就是不断地读取并执行一条条指令。这些指令的序列就叫做 CPU 的<strong>控制流</strong>（control flow）。最简单的控制流是“平滑的”，也就是相邻的指令在存储器中是相邻的。当然，控制流不总是平滑的，不总是一条接一条地执行，总会有出现改变控制流的情况。我们知道的程序内部状态改变的机制有两条：</p>
<ul>
<li>跳转和分支</li>
<li>调用和返回</li>
</ul>
<p>这些机制局限于程序本身的控制。当<strong>系统状态</strong>（system state）发生改变的时候，以上机制就不能很好地应对复杂的情况，例如：</p>
<ul>
<li>数据从磁盘或者网络适配器到达</li>
<li>有一条指令执行了除以零的操作</li>
<li>用户按下 ctrl+c</li>
<li>系统内部的计时器到时间</li>
</ul>
<p>现代系统通过使控制流发生突变来应对这些情况。这种机制叫做<strong>异常控制流</strong>（exceptional control flow）。异常控制流发生在计算机系统的各个层次。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/exception.png" alt=""></p>
<ul>
<li>在硬件层，硬件检测到的事件会触发控制转移到异常处理程序</li>
<li>在操作系统层，内核通过上下文转换将控制从一个进程转到另一个进程</li>
<li>在应用层，一个进程可以发送信号到另一个进程，接受者将控制突然转移到一个信号处理程序</li>
</ul>
<p>学习异常控制流很重要：</p>
<ul>
<li>可以帮助你理解重要的系统概念，例如 I/O、进程、虚拟存储器</li>
<li>可以帮助你理解应用程序和操作系统是如何交互的，例如陷阱、系统调用</li>
<li>可以帮助你编写进程相关的新应用程序，理解并发</li>
<li>理解软件异常如何工作</li>
</ul>
<p>对于汇编语言、CPU、存储器的学习，可能已经使你初步了解应用是如何与硬件交互的。而学习异常控制流的重要性在于开始学习应用是如何与操作系统进行交互的。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>最底层的机制称为异常（Exception），更高层次的异常控制流包括进程切换（Process Context Switch）、信号（Signal）和非本地跳转（Nonlocal Jumps）。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/exceptiontable.png" alt=""></p>
<p>异常是异常控制流的一种形式，它是由硬件和操作系统组合来实现的。异常就是控制流的突变，用来响应处理器状态的某种变化。状态变化被称为<strong>事件</strong>（event）。当处理器检测到时间的发生时，它就会通过一张叫做<strong>异常表</strong>（exception table）的跳转表，跳到一个专门用来处理这类事件的操作系统子程序——<strong>*异常处理程序</strong>（exception handler）</p>
<p>系统为每种类型的异常都分配了一个唯一的非负整数的异常号。当系统启动时，操作系统分配并初始化异常表，条目 k 包含异常 k 的处理程序的地址，异常表的起始地址存放在异常表基址寄存器中。当处理器检测到事件，并确定了异常号 k 后，处理器触发异常，执行间接过程调用。异常类似于过程调用，但有些许不同：</p>
<ul>
<li>过程调用在跳转之前，要把返回地址压入栈中。然而，根据异常的类型，返回地址有可能是当前指令、下一条指令、也可能直接终止被中断的程序。</li>
<li>如果控制从用户态转到内核态，那么这些项目被压入内核栈而不是用户栈。</li>
<li>异常处理程序都运行在内核态下。</li>
</ul>
<p>一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。异常处理程序处理完事件之后，它通过执行特殊的“从中断返回”的指令，可选地返回到被中断的程序，将适当的状态弹回到处理器的控制和寄存器中，如果中断的是一个用户程序，就将状态恢复为用户模式。最后将控制返回给被中断的程序。</p>
<h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><p>异常分为四类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>原因</th>
<th>同步or异步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断（interrupt）</td>
<td>来自 I/O 设备的信号</td>
<td>异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱（trap）</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障（fault）</td>
<td>潜在的可恢复错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止（abort）</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不返回</td>
</tr>
</tbody>
</table>
<h2 id="中断（interrupt）"><a href="#中断（interrupt）" class="headerlink" title="中断（interrupt）"></a>中断（interrupt）</h2><p><img src="http://osax8w13y.bkt.clouddn.com/interrupt.png" alt=""></p>
<p>中断是处理来自处理器外部的 I/O 设备的信号的结果。中断是<strong>异步</strong>（asynchronous）的，异步的意思就是是由处理器外面发生的事情引起的。对于执行程序来说，这种“中断”的发生完全是不知道什么时候会发生，CPU对其的响应也完全是被动的。</p>
<p>如下的例子就是中断：</p>
<ul>
<li>计时器中断：计时器中断是由计时器芯片每隔几毫秒触发的，内核用计时器中断来从用户程序手上拿回控制权。</li>
<li>I/O 设备的中断，这个种类就包含很多可能了。例如：用户按下 Ctrl+C、网络上一个数据包的到达、磁盘上的数据到达等等。</li>
</ul>
<p>通过像处理器芯片上的一个引脚发信号，将异常号放到总线上，触发中断。异常号标识引起中断的设备。处理器意识到中断后，调用适当的中断处理程序。当处理程序返回时，将控制返回给下一条指令。就好像程序正常地执行，没有发生过中断一样。</p>
<h2 id="陷阱（trap）"><a href="#陷阱（trap）" class="headerlink" title="陷阱（trap）"></a>陷阱（trap）</h2><p>除了中断的其余三者（陷阱、故障和终止）是<strong>同步</strong>（synchronous）的，意思是执行当前指令的时候触发异常。</p>
<p>陷阱是<strong>有意的异常</strong>。陷阱是一类很重要的异常。有一个用途就是在用户程序和内核（kernel）之间提供一个接口，叫做<strong>系统调用</strong>（system call）。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/systemcall.png" alt=""></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/systemcall1.png" alt=""></p>
<p>系统调用看起来就像函数调用。通常，处理器设有两种模式：“用户模式”与“内核模式”，<br>然而某些功能是需要系统内核级别的支持才能完成，因此内核提供一系列具备预定功能的函数，通过一组称为系统调用的接口呈现给用户。系统调用把应用程序的请求、参数和控制传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序。</p>
<h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>为了使操作系统内核得到保护，操作系统提供一个机制，限制应用程序可以使用的指令以及它可以访问的地址空间范围。处理器通常是使用某个控制寄存器中的一个模式位（mode bit）来提供这种功能的。当设置了模式位，进程就运行在<strong>内核状态</strong>，可以执行指令集中的任何指令，访问任何存储器位置。相反，则运行在用户模式，不允许执行一系列特权指令，例如停止处理器、改变模式位、或者发起一个 I/O 操作，同时限制用户模式中的进程访问内核区的代码和数据，任何这样的尝试都会导致故障。进程从用户模式变为内核模式的方法就是通过注入中断、故障或陷入系统调用这样的异常。</p>
<h2 id="故障（fault）"><a href="#故障（fault）" class="headerlink" title="故障（fault）"></a>故障（fault）</h2><p>故障就是由错误情况引起的，它可能被故障处理程序修正，修正之后就可以将控制返回到引起故障的指令，并重新处理它。当然，也有可能是一个无法修复的故障，那么处理程序会返回到内核中的 abort 例程，会终止引起故障的程序。</p>
<p>故障的示例：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/pagefault.png" alt=""></p>
<p>一、缺页（page fault），当指令引用一个虚拟地址，而虚拟地址对应的物理页面此时不在主存而在硬盘中，会发生缺页故障。缺页处理程序就从磁盘加载适当的页（一个页面就是一个虚拟存储器的连续的一个块，典型的是 4KB），然后将控制返回给引起故障的指令。因为相应的页面调度已经完成，在此执行指令时，就不会有缺页故障了。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/invalidmemory.png" alt=""></p>
<p>二、非法的存储器地址引用（invalid memory reference）也是一种故障，只不过故障处理程序会将控制返回给 abort 例程，abort 例程会终止这个程序，并报“段错误”。</p>
<h2 id="终止（abort）"><a href="#终止（abort）" class="headerlink" title="终止（abort）"></a>终止（abort）</h2><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。终止处理程序从来不将控制返回给应用程序，而是返回给 abort 例程，终止这个应用程序。</p>
<p>从上面的例子中，我们可以看到异常的具体实现是依靠在用户代码和内核代码间切换而实现的，是比汇编中的跳转、返回更加底层的机制。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>异常是允许操作系统提供<strong>进程</strong>（process）概念的基本构造块。进程是计算机科学中最深刻最成功的概念之一。进程为每个程序提供一种假象，好像这个程序是计算机上唯一运行的程序，并独占处理器和存储器资源。而实际上在任何时间点，计算机上都有多个程序在运行。这种假象就是通过进程的概念提供给我们的。</p>
<p>进程的定义是：</p>
<blockquote>
<p> A process is an instance of a running program.</p>
</blockquote>
<p>进程就是<strong>计算机中一个执行中的程序的实例</strong>。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。</p>
<p>用户下达运行程序的命令后，就会产生进程。操作系统如何实现进程、管理进程的细节超出了本书的讨论范围，我们将关注进程这个概念提供给程序的两种关键抽象：</p>
<ul>
<li>逻辑控制流（logic control flow），提供一个假象——好像程序独占处理器。</li>
<li>私有地址空间，是通过虚拟内存（virtual memory）的机制，提供一个假象——好像程序独占存储器。</li>
</ul>
<h2 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h2><p>多进程的操作是怎样的呢？</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/multiprocessiong.png" alt=""></p>
<p>现代处理器一般有多个核心，所以可以真正同时执行多个进程。而对每一个核心来说，还是有可能会切换执行不同的进程。在上图的多进程模型中，虚线部分可以认为是当前正在执行的进程，内存中需要另一块区域，当处理器去执行别的进程时，来保存当前的寄存器值。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/controlflow.png" alt=""></p>
<p>如果用调试器单步执行程序，我们会看到一系列的程序计数器的值，值的序列就是<strong>逻辑控制流</strong>，每一个进程都有自己的逻辑流。在上图中，每条竖线都代表一部分逻辑流。多个进程轮流进行的概念叫做<strong>多任务</strong>（multitasking），操作系统中常用时间片（time slice）的机制来实现，因此多任务又称为<strong>时间分片</strong>（time slicing）。逻辑流如果在执行时间上与另一个逻辑流重叠，那么就叫<strong>并发流</strong>（concurrent flow），这两个流就是<strong>并发</strong>地执行（concurrency），否则叫做顺序流（sequential flow）。并发与处理器核心数无关，只需要满足两个流在时间上重叠，那就是并发执行。如果两个流并发地运行在不同的处理器核心上，那么就称为并行流（parallel flow），并行流是并发流的真子集。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><img src="http://osax8w13y.bkt.clouddn.com/contextswithching.png" alt=""></p>
<p>切换进程时，<strong>内核</strong>会负责具体的调度，用到的机制称为<strong>上下文切换</strong>（context Switch）。<strong>上下文</strong>（context）是内核重启一个被抢占的进程所需要的状态，也可以理解为一个进程拥有的信息。包括代码、数据、堆栈、通用寄存器的内容、程序计数器、环境变量、内核数据结构，比如打开文件描述符的集合、描绘地址空间的页表、包含进程信息的进程控制块等等。</p>
<p>上下文切换是一种较高形式的异常控制流。在进程某些时刻，<strong>内核</strong>可以决定<strong>抢占</strong>当前执行的进程，重新开始一个被抢占的进程，这种行为叫做<strong>调度</strong>（schedule）。内核的做法是：</p>
<ol>
<li>保存当前进程的上下文，</li>
<li>恢复某个先前被抢占的进程的上下文，</li>
<li>将控制传递给这个新恢复的进程。</li>
</ol>
<p>所有的系统都有某种产生周期性定时器中断的机制，典型的就是每 1 毫秒或每 10 毫秒，内核判定某个进程已经运行了足够长的时间，要切换到另一个进程运行。</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p><img src="http://osax8w13y.bkt.clouddn.com/processmemory.png" alt=""></p>
<p>在逻辑控制流中我们可以看到，整个过程中，CPU 交替执行不同的进程，而每个进程的内存大致都长一个样子。虚拟内存系统会负责管理地址空间，进程也给程序提供一种假象，好像它独占使用系统的地址空间。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B">wiki</a></li>
<li><a href="http://blog.csdn.net/u014563989/article/details/53574118">进程相关函数简单总结</a></li>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">15213课程网站</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】2. 整型运算</title>
    <url>/2017/06/25/csapp-2-Integers/</url>
    <content><![CDATA[<p>现在想补补推荐这本书的理由。</p>
<blockquote>
<p>Most books on systems—computer architecture, compilers, operating systems, and networking—are written as if the reader were going to design and implement such a system. We call this the “<strong>builder’s persepective</strong>.” We believe that students should first learn about systems in terms of how they affect the behavior and performance of their programs—a “programmer’s perspective.”</p>
<p>For programmers, what really matters is how the finite word sizes used to represent integer and floating point data determines what values can be represented and the behavior of different operations.</p>
</blockquote>
<p>在上一篇笔记中，在浏览CSAPP课程网站时，有一段话让我印象深刻。本书的标题中有A Programmer’s Perspective，那么，何为A Programmer’s Perspective？作者认为，大多数的、涉及方方面面的计算机书籍，组成原理、编译器、操作系统、网络……等等，很多都是以“建设者”的角度（builder’s perspective）来写成一本书的。这些书的作者认为他要面向的读者，买这本书来看的目的是真的要搭建/配置/写出来一个完整的Network/OS/complier等等。</p>
<p>就以信息在计算机的表示来举例，数字逻辑、数字电路等书籍会切切实实教它的读者怎么样去实现一个有效率的计算电路。这本书的特色就是：从程序员的角度出发的，程序员更想需要知道的是：机器是如何以有限的字长来表示无符号和有符号整型，以及浮点数的编码规则。</p>
<blockquote>
<p>The material in this book has direct value for programmers. Students find that it explains many of the mysterious problems they’ve already encountered, that it helps them write and debug code more efficiently, and that their programs are more reliable and efficient.</p>
</blockquote>
<p>为什么两个数加起来会变成一个负数？作为学生的我们，肯定会遇到这个问题。但是在课堂上，老师往往只会抛出两个字“溢出”。我们知道“溢出”了，但我们不知道何为“溢出”，为何“溢出”，“溢出”到底是“怎样溢出”的。知其然，还要知其所以然。这些看似神秘的问题，在这本书里都有很好的解答，会让你有豁然开朗之感。理解了底层原理，能帮助你更高效的debug，写出更可靠的程序。</p>
<blockquote>
<p><strong>The material in this book is unique.</strong> Much of it is not presented in any other book or taught in previous courses. Instead, a traditional coverage of systems requires programmers to figure out on their own how the characteristics of the systems they study in builder-centric courses can be exploited to improve their programs. <strong>The book provides a solid foundation for builder-centric courses</strong>. We believe that more advanced systems courses should present systems from a builder’s perspective. Students will be much better oriented to the needs and constraints of these systems by first studying them from a programmer’s perspective.</p>
</blockquote>
<p>都说中国计算机教材饱受诟病，当然的确也肯定有那么些真材实料，但饱受诟病的原因就是很多书都是抄外国的，再加上一点自己的东西。要么就是直接国内互相抄。有点再为了让“中国人看得懂”，翻译的就烂了，甚至添油加醋，出现错误的都有。我就特别佩服这种敢直接说“我们的材料都是独一无二”的这种精神。这本书是美国CMU（卡内基梅隆大学，Carnegie Mellon University）的一门课程——ICS，Intro to Computer Systems（计算机系统导论）的教材，本书的作者在CMU坐镇亲自授课。这门课也成为了CMU的“<strong>镇校神课</strong>”。这本“以程序员角度”来写的书，CSAPP，能够为我们以后学习以建设者思想为中心的更高级的课程打下坚实的理论基础。</p>
<p><strong>2017-04-12 update</strong>：到目前为止看了这本书两个月，进度差不多是一半，觉得这本书知识点结构清晰，有逻辑有条理，叙述又准确，又有翔实的补充资料，题目也是精心编排的，PPT做的又好，还有lab可以做，确保能让读者真正的学到东西。反观大学的计算机组成原理课的教材，要条理没条理要逻辑没逻辑，填鸭式地强行灌输知识点，PPT质量惨不忍睹，例题和课后题一看就是应试。拿IEEE浮点规则来说，根本没几个同学学懂了这个编码规则，但实际上它是很beautiful的，但被垃圾教材教成了什么样子…不知道这种全方位被碾压的东西为何还存在于大学课堂上，简直是根本没道理的事情。课这么烂，还不如少上几节课。</p>
<hr>
<h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><p>两数相加会得出一个负数？！</p>
<p>表达式 <code>x &lt; y</code> 和表达式 <code>x - y &lt; 0</code> 有可能产生不同的结果？！</p>
<p>这些其实是因为计算机运算的<strong>有限性</strong>而导致的。理解这些计算的细微之处能够让我们编写更加可靠的代码。</p>
<h2 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h2><p>考虑两个无符号整数x和y，如果都是w位无符号数字（以下的w都代表w位无符号数），那么满足 <code>0 ≤ x, y ≤ 2^w - 1</code> 。如果计算x和y的和，那么得到的结果<strong>可能需要w+1位</strong>。如果出现了需要w+1位的情况，那么就是<strong>加法上溢了</strong>。</p>
<p>说的更明白一点，对于我们最熟悉的十进制，三位数加三位数的结果最多用四位数表示就够了（999+999=1998）此时x，y是十进制下的加数，<code>0 ≤ x, y ≤ 10^3 - 1</code>，结果可能需要4位。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/2-1.png" alt=""></p>
<p>如果说，为了不出现上溢，那我扩宽机器支持的数字位数行不行？如果为了让两个 <code>w</code> 位数加起来不溢出，那么我们需要 <code>w + 1</code> 位，因此就可以存储 <code>w + 1</code> 位的数。而两个 <code>w + 1</code> 的数相加，有需要 <code>w + 2</code>  个位来保证不会上溢……依次类推，这种“膨胀”意味着，如果我们想这么做的话，那么我们只能对字长<strong>不加任何限制</strong>。例如Lisp，事实上就支持<strong>无限精度</strong>运算（当然要在机器的存储器限制之内）。更常见的是，编程语言支持<strong>固定精度</strong>的运算，所以说，如果超出机器能表示的范围，那么运算结果就是溢出了。</p>
<p>可以把无符号加法 <code>x + y</code> 视为一种<strong>模运算形式</strong>，等价于加法运算后的结果<strong>模上2的w次方</strong>。可以这么理解，因为如果溢出，是相当于进位，也就是比w位多一位，那么那一位就会被抛弃。<strong>模2的w次方</strong>这个动作，就好似“丢掉”了这个第 w + 1 位的进位数字。例如一个4位数字（中括号是其二进制位表示） <code>x = 9 [1001]</code> 和 <code>y = 12 [1100]</code>，加法运算结果是<code>21 [10101]</code>。丢弃最高位的结果是<code>[0101]</code>也就是十进制5，可以把 5 认为是21 mod 16 = 5。</p>
<p>简单的说，如果现在有一台支持4位的无符号数加法运算的“计算器”摆在你面前，那么大于2^w也就是16的结果都是溢出的。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/2-2.png" alt=""></p>
<p>C语言程序中，<strong>不会</strong>把溢出作为错误而发送信号。考虑一个函数，判断两个无符号数相加会不会产生溢出，那么它应该是下面这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uadd_ok</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">unsigned</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> (s&gt;=x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h2><p>如果能够理解无符号加法的溢出，那么也就很好理解补码加法时，如果太大的结果也是会溢出的。只不过如果是正溢出的话，结果会变成一个很小很小的负数。这个现象的关键还是在于补码的编码机制。其实就正溢的情况来看，补码正溢和无符号正溢有些许不同。无符号正溢会导致现有w位放不下运算结果而溢出，而补码正溢时，是因为加法导致运算进位的1成了符号位，而符号位的权是负权。</p>
<p>简而言之，如果加法运算之后的结果仍然落在无符号、补码所能够表示的范围之内，那么就不会溢出，否则会溢出。溢出后结果的具体情况根据不同的编码规则来。</p>
<blockquote>
<p>正溢出(positive overflow)和负溢出(negative overflow)。正溢出就是数值太大把原来为 0 的符号位修改成了 1，反而成了负数；负溢出是数值太小，把原来为 1 的符号位修改成了 0，反而成了正数。</p>
</blockquote>
<p><img src="http://osax8w13y.bkt.clouddn.com/2-3.png" alt=""></p>
<h2 id="减法、非"><a href="#减法、非" class="headerlink" title="减法、非"></a>减法、非</h2><p>减法其实就是做“加一个数的相反数”，所以说还是可以归结到加法上去，然而能够顺带解决“相反数”的问题。</p>
<p>在初中时，相反数的定义是 <code>x +（-x） = 0</code> ，<code>-x</code> 是 <code>x</code> 的相反数。对于一个无符号整数x，那么一定存在另外一个无符号整数，会让他们的相加结果为零。这个结果就是2的w次方减去x。他俩的相加结果为2的w次方，需要w + 1位表示—— w + 1位是1，剩下的全为0。w + 1位会被抛弃，那么结果就是0。</p>
<p>补码的非有一条比较神奇的技巧。求补码的非的一种方法是——对每一位求补，在对结果加1。也可以说<strong>取反加一</strong>，也就是说如果用C语言编码，可以对任意整数值x，计算-x和~x+1两个表达式的值，他们是绝对相等的。是不是很神奇？</p>
<p>例如字长为4的情况，有符号整数5，那么补码表示法为<code>[0101]</code>，每一位取补后是<code>[1010]</code>，加一为<code>[1011]</code>，刚好是-5的补码表示法。</p>
<h2 id="乘法，与移位运算的联系"><a href="#乘法，与移位运算的联系" class="headerlink" title="乘法，与移位运算的联系"></a>乘法，与移位运算的联系</h2><p>两个w位的数，加起来的数可能需要w + 1位，乘起来是可能需要2w位的（具体例子像上面加法那样举一个就很明白了）。对于无符号和补码的乘法来说，乘法运算的位级表示<strong>都是一样的</strong>。但依然结果是被截断为机器最长的能够表示的位数。</p>
<p>这里比较有的说的是，在大多数机器上，乘法指令运算速度是比较慢的（需要10个或者更多的时钟周期）。然而其他整数运算（加减法、位运算）只需要一个时间周期。所以编译器会采取的一个重要优化就是<strong>通过位运算和加减法的组合</strong>来尝试<strong>代替乘除法</strong>运算。</p>
<p>我们知道“把一个数左移n位相当于乘上2的n次方”。那么，如果一个程序包含表达式 <code>x * 14</code>，编译器会重写为<code>(x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1)</code> 。无论x是无符号还是补码，甚至乘法导致了溢出，直接计算x乘以14和通过位运算和加法的组合计算，两个计算都会得到同样的结果（根据运算的属性可以证明这一点）。</p>
<p>这是编译器会做的事情。如果我们要写 <code>x * 14</code>，那么就直接这么写。</p>
<h2 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h2><p>在大多数机器上，整数除法比乘法更慢——通常需要30个或者更多的时间周期。如果能够用右移来实现的话，那是再好不过了。不幸的是，这种方法不能推广到除以任何常数K，这点于乘法不同。乘以任何常数都可以转化成加法和左移的结合，然而不能用右移（除以2的幂）来表示除以任意常数K。</p>
<p>左移只有一种，就是在右边是补0。而右移有两种，就是<strong>算术右移</strong>和<strong>逻辑右移</strong></p>
<blockquote>
<p>逻辑右移，右移后在左端补0。算术右移，右移后在左端补最高有效位的值。</p>
</blockquote>
<p>如果采取算术右移的话，负数除以2的幂会让左端补的是1，那么保持了负数的符号。</p>
<p>除法就会导致<strong>除不尽</strong>，移位会导致<strong>结果永远是向下舍入</strong>，有的时候会导致和我们的期望不一致。下面给出16位表示的<code>-12340</code>进行算术右移的结果。</p>
<table>
<thead>
<tr>
<th>k</th>
<th>算术右移k位后的位表示（相当于除以2的k次方）</th>
<th>结果（十进制，没有加偏移量）</th>
<th>实际的结果</th>
<th>我们期望的舍入结果 </th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1100111111001100</td>
<td>-12340</td>
<td>-12340.0</td>
<td>-12340</td>
</tr>
<tr>
<td>1</td>
<td><em>1</em>110011111100110</td>
<td>-6170</td>
<td>-6170.0</td>
<td>-6170</td>
</tr>
<tr>
<td>4</td>
<td><em>1111</em>110011111100</td>
<td>-772</td>
<td>-771.25</td>
<td>-771</td>
</tr>
<tr>
<td>8</td>
<td><em>11111111</em>11001111</td>
<td>-49</td>
<td>-48.203125</td>
<td>-48</td>
</tr>
</tbody>
</table>
<p>我们知道，整型5除以整型2的结果是2，实质上是结果2.5向下舍入。然而对于负数除以2的幂，我们会希望向上舍入。对于这个问题，我们可以在移位之前添加<strong>偏置值</strong>（biasing），通过这种方式修正不合适的舍入。对于<code>x / y</code>，偏移量为<code>y - 1</code>，也就是说有对<code>x / y</code> 向上舍入的结果对 <code>（x + y - 1）/y</code>。向下舍入相同。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/2-7.png" alt=""></p>
<h1 id="思考和总结"><a href="#思考和总结" class="headerlink" title="思考和总结"></a>思考和总结</h1><h2 id="对于整数运算"><a href="#对于整数运算" class="headerlink" title="对于整数运算"></a>对于整数运算</h2><p>正如上文提到，计算机执行整数运算实际上是一种<strong>模运算</strong>形式。表示数字的有限字长<strong>限制了数值的取值范围</strong>，所以结果可能溢出。无论是无符号、补码，在进行加减乘除移位的时候，都有完全一样或者非常类似的位级行为。</p>
<p>某些规定可能会产生令人意想不到的结果，而这些可能是难以察觉的bug的源头。特别地，我们看到unsigned数据类型，它们的概念很简单，但不恰当的运用它们可能导致即使是资深人士都意想不到的行为。</p>
<h2 id="何时使用无符号整型呢？"><a href="#何时使用无符号整型呢？" class="headerlink" title="何时使用无符号整型呢？"></a>何时使用无符号整型呢？</h2><p><img src="http://osax8w13y.bkt.clouddn.com/2-5.png" alt=""></p>
<p>如果对无符号整型的内容不是很理解，<strong>请不要使用</strong>无符号整型！</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/2-6.png" alt=""></p>
<h2 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h2><p>在32位机器上运行如下代码。假设我们对有符号值使用补码运算，对有符号值使用的是算术右移，对有符号值使用的是逻辑右移。变量的初始化声明如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int x <span class="operator">=</span> ArbitraryValue()<span class="comment">;</span></span><br><span class="line">int y <span class="operator">=</span> ArbitraryValue()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">unsigned ux <span class="operator">=</span> x<span class="comment">;</span></span><br><span class="line">unsigned uy <span class="operator">=</span> y<span class="comment">; //ux,uy 是x,y 的无符号型</span></span><br></pre></td></tr></table></figure>
<p>对于下面的C语言表达式，请说明 1）对于所有的 x 和 y 值，表达式恒为真。或者 2）给出使表达式为假的 x 和 y 的值。<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>. (x &gt; <span class="number">0</span>) || (x - <span class="number">1</span> &lt; <span class="number">0</span>) </span><br><span class="line"><span class="attribute">2</span>. (x &amp; <span class="number">7</span>) != <span class="number">7</span> || (x &lt;&lt; <span class="number">29</span>) &lt; <span class="number">0</span></span><br><span class="line"><span class="attribute">3</span>. (x * x) &gt;= <span class="number">0</span></span><br><span class="line"><span class="attribute">4</span>. x &lt; <span class="number">0</span> || -x &gt;= <span class="number">0</span></span><br><span class="line"><span class="attribute">5</span>. x &gt; <span class="number">0</span> || -x &gt;= <span class="number">0</span></span><br><span class="line"><span class="attribute">6</span>. x + y == ux + uy</span><br><span class="line"><span class="attribute">7</span>. x * ~y + ux * uy == -x</span><br></pre></td></tr></table></figure><br>解答or提示：</p>
<ol>
<li>若 x = TMin ，x - 1 = TMax。</li>
<li>7 的二进制表示是 0111 ，如果 (x &amp; 7) != 7 这个表达式为假，那么 x 的第二位必须是 1。左移29位之后，这个1变成了符号位。</li>
<li>假。可能溢出</li>
<li>真。</li>
<li>TMin的逆元是TMin。当 x = TMin 时， -x 也等于 TMin。</li>
<li>真。补码和无符号加法有相同的位级行为。</li>
<li>~y = -y - 1（一个有符号数的相反数是各位取反后加一）。<code>uy * ux</code> 等于<code>x * y</code>。因此：左边 = <code>x * （-y - 1）+ x * y = x</code> = 右边。</li>
</ol>
<h1 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h1><p>部分公式、数据截图来源</p>
<ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期  ICS课程网站</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】3. 浮点数</title>
    <url>/2017/06/25/csapp-3-Floating-Point/</url>
    <content><![CDATA[<p>回想起刚学C语言时，我对浮点数的印象大概是“能够表示小数”的数据类型。还死记硬背过例如什么“小数用 double 存，用 %f 输出”这类的话。实际上呢，浮点数可以用这么一个公式来概括：</p>
<p>$$ \sum_{k=-j}^i b_k×2^k$$</p>
<p>除了我们所熟知的，表示小数之外，它对执行涉及非常大的数字、非常接近于0的数字，以及更普遍地作为对实数运算的结果的近似值，是非常有用的。</p>
<p>以下摘取一些书本中的内容：</p>
<p>20世界80年代，每个计算机制造商都指定了自己的表示浮点数的规则，以及对浮点数执行运算的细节。因此，这对不同的计算机之间的协同工作带来了很大的不便。这一切都随着<strong>IEEE 754</strong>标准的推出而改变了。这是一项由Intel公司赞助的计划，详细地制定了浮点数的表示方法和运算标准。因为其具有足够的合理性和先进性，被IEEE采纳为浮点数的标准，在1985年发布。目前，实际上所有的计算机都支持这个后来被称为<strong>IEEE浮点</strong>的标准。大大提高了各种程序在不同机器上的可移植性。</p>
<blockquote>
<p>旁注：IEEE（读作“Eye-Triple-Eee”），指电器和电子工程师协会，是一个包括所有电子和计算机技术的专业团体。它出版刊物、举办会议、建立委员会来定义各种标准，涉及范围从电力传输到软件工程。</p>
</blockquote>
<p>这一节中，我们将看到IEEE 754 浮点格式是如何表示数字的，以及有关的其他细节。许多程序员认为浮点数没甚意思（往坏了说，深奥难懂）。但我们将看到，IEEE标准是相当优雅和容易理解的。</p>
<h1 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h1><p>理解浮点数的第一步是理解含有小数部分的二进制数字。对于我们熟悉的十进制来说，一个小数可以表示为</p>
<p>$$ d_md_{m-1}…d_1d_0.d_{-1}d_{-2}…d_{-n}$$</p>
<p>每个数位上面的数字的范围是0~9。上面的一长串表示法所表示的数值d为：</p>
<p>$$ d = \sum_{i=-n}^m = 10^i×d_i$$</p>
<p>十进制，意味着数字权为10。小数点左边的数字的权是10的正幂或0次幂，乘起来之后累加会得到<strong>整数部分的值</strong>。小数点右边的数字的权是10的负幂，乘起来之后累加会得到<strong>小数部分的值</strong>。下面举一个 $12.34_{(10)}$ 的运算过程作为例子。</p>
<p>$$ 1×10^1+2×10^0+3×10^{-1}+4×10^{-2} = 12\frac{34}{100}$$</p>
<p>其实二进制小数不会很难理解，跟10进制不同的是，把10的幂次改成2的幂次，仅此而已。还有就是，二进制只有0和1组成。下面举一个$101.11_{(2)}$的运算过程作为例子。</p>
<p>$$ 1×2^2+0×2^1+1×2^0+1×2^{-1}+1×2^{-2} = 4+0+1+\frac{1}{2}+\frac{1}{4}=5\frac{3}{4}$$</p>
<p>对于十进制小数的一些性质，完全能够在二进制小数中发现类似的。例如，对于十进制小数来说，把小数点右移一位相当于乘以10。那么，对于二进制小数来说，把小数点往右移一位相当于乘以2。</p>
<p>由于二进制小数：$0.111111….$ 非常接近于1，因此我们用 $1.0−ϵ$来表示。</p>
<p>很显然，编码长度是有限的。十进制表示法是无法<strong>准确地表达</strong>像三分之一这样的无限循环小数。其究极原因是在于，如果把十进制小数想象成一种编码的话，那么这种编码方案的精度不够，所以无法准确地把三分之一表示出来（这个例子有点牵强，因为三分之一是无限循环的）。由此，我们可以想象，二进制数表示法只能表示那些能够被写成 $x×2^y$ 的小数。例如，数字 $\frac{1}{5}$ 可以被精确地表示成十进制小数 0.2，但没办法用一个二进制小数<strong>准确</strong>地表示它，只能通过提高二进制表示位的长度来提高精度，从而<strong>近似</strong>地去表示。这是一个很重要的理念。</p>
<h1 id="IEEE-754-浮点标准"><a href="#IEEE-754-浮点标准" class="headerlink" title="IEEE 754 浮点标准"></a>IEEE 754 浮点标准</h1><p>在正式进入对754标准的讲解之前，我想先回到我之前在博客中提到过的一句话：</p>
<blockquote>
<p>0和1这种离散值在用机器来表示时是非常方便的……虽然0和1是离散的，但大量的0和1，足够让我们认为是“连续”的。</p>
</blockquote>
<p>什么叫做“大量的离散，足够让我们认为是连续的”呢？对于整数编码了解后，我们知道其实计算机能够表示的整数的范围很有限。但如果用比较长的字长，例如32位，那么对于普通人来说，他们日常需要用到的加减法是绝对够用了。但是，整数编码是表示不了特别大的数的，也不能表示特别小的负数、以及小数。例如，如果你用一个32位的int整型去存储计算阶乘!n的结果，那么计算到13的阶乘时就已经溢出了。即使你用long long去存，算到20的阶乘也就溢出了。</p>
<p>下面你将能够看到，浮点数不仅仅能表示小数，还具有表示特别大/特别小的数的能力。但通过二进制小数我们也了解到，不是每个数都能够被“精确”地表示，有的时候只能用另一个近似数通过“舍入”去表示，因此也增加了对于编码设计、数值分析方面的挑战性。综上所诉，我们可以这样认为：<strong>整型只能表示范围较小的数，但它能表示的每个数都是准确的。浮点数虽然能编码一个很大的范围，但这种表示只是近似的。</strong></p>
<p>下面介绍IEEE 754标准的内容。IEEE浮点标准使用 $ V=(-1)^s×M×2^E$ 的形式来表示一个数。</p>
<ul>
<li><strong>符号位（sign）</strong>，与补码类似，s为1代表这个数为负，s为0代表这个数为正</li>
<li><strong>阶码（exponent）</strong>E的作用是对浮点数加权，权重是2的E次幂。</li>
<li><strong>尾数（significand）</strong>M是一个二进制小数，范围是$1到2−ϵ$（规格化）或者$0到1−ϵ$（非规格化）</li>
</ul>
<p>标准浮点格式把位划分成三个字段，分别对上面这三种值进行编码</p>
<ul>
<li>开头第一位代表符号位</li>
<li>接下来是 k 位的字段 exp，编码的是阶码，但是结果要减去偏置值。（需要重点理解）</li>
<li>在接下来 n 位的小数字段 frac，编码尾数M，但是编码出来的值依赖于这个数是规格化数or非规格化数（后面会解释，需要重点理解）</li>
</ul>
<p>比较常见的是 32 位和 64 位的浮点数编码。在C语言中，32 位对于的就是数据类型<strong>float</strong>，称为单精度浮点数（single precision）。64 位的是<strong>double</strong>，称为双精度浮点数（double precision）。下面是他们的编码格式。float 和 double 的区别其实就是所占字节不一样，实质上就是 k 和 n 位数的不同。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/3-1.png" alt=""></p>
<h2 id="规格化和非规格化的值"><a href="#规格化和非规格化的值" class="headerlink" title="规格化和非规格化的值"></a>规格化和非规格化的值</h2><h3 id="规格化的值-Normalized-Values"><a href="#规格化的值-Normalized-Values" class="headerlink" title="规格化的值(Normalized Values)"></a>规格化的值(Normalized Values)</h3><p>在 exp ≠ 000…0 和 exp ≠ 111…1 时（阶码部分不全为0或全为1），表示的值就叫<strong>规格化值</strong>。到底规格化是什么意思呢？对于规格化数来说，用二进制数来表示时，原本连续的值会被规范到有限的定值上。如果把规格化的数放到数轴上表示，那他们之间的<strong>距离是不同</strong>的。（后面会举例子解释，现在不懂不用太担心）</p>
<p>对于规格化值，阶码字段（exp这部分）的编码区域的无符号值为<code>e</code>，但阶码<code>E</code>的值是$E = e - Bias$，注意这里不要把大小写e和E搞混。</p>
<p>Bias是指<strong>偏移量</strong>，值为$ 2^{k-1}-1 $，k是阶码字段的位数。</p>
<p>也就是说</p>
<ul>
<li>单精度规格化数的 Bias 是 127，e 的范围是 1 ~ 254，E 的范围是 -126 ~ 127</li>
<li>双精度规格化数的 Bias 是 1023，e 的范围是 1 ~ 2046，E 的范围是 -1022 ~ 1023</li>
</ul>
<p>之所以需要采用一个偏移量，是为了保证 exp 编码只需要以无符号数来处理。</p>
<p>还记得吗？阶码值<code>E</code>，是用来做浮点数的权。可以看到，这个权在 <code>float</code> 最大可以达到 127，最小可以达到 -126，<code>double</code> 的范围就更大了。想想看，用float可以表示的最大的数是表示为某个小数乘以 2 的 127 次方，这就是为什么浮点数可以表示<strong>很大的数与很小的数</strong>的原因，相比之下，<code>int</code> 能存下的最大的数也就 10 的 ⑨ 次方啊。</p>
<p>对于小数字段<code>frac</code>，它就是描述<strong>小数值f</strong>，0 ≤ f ≤ 1 。对于规格化数，尾数<code>M</code>定义为 <code>M = 1 + f</code>。你也可以这样理解：<code>M</code> 一定是一个以 1 开头的小数，形如 <code>M=1.xxxxx.xx</code>，那些 xxx 就是 <code>frac</code> 的编码部分。当 <code>frac</code> 全为 0 时 <code>M</code>最小（M=1.0），当 <code>frac</code> 全为 1 时 <code>M</code>最大（M = 2 - ϵ，无限接近于 2）。之所以采取这种方式，是因为如果阶码没有溢出，我们总是可以调整阶码（想象一下，也就是移动小数点的位置）来把尾数控制在 1 ≤ M ＜ 2 之间。这种方式就是<strong>轻松获得一个额外精度位</strong>的技巧。也可以理解为：开头的 1 是白送的，<strong>不需要额外的编码位</strong>。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">12345</span>；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,(<span class="type">float</span>)x);</span><br></pre></td></tr></table></figure>
<p>在强制类型转换时，到底发生了什么呢？</p>
<p>首先，用二进制来表示十进制的12345：</p>
<p>$$12345_{10}=11000000111001$$</p>
<p>将其小数点左移13位，创造一个规格化的形式：</p>
<p>$$12345 = 1.1000000111001_2 × 2^{13}$$</p>
<p>依照此式，构造 float 型的 32 位浮点数编码：</p>
<ul>
<li><p>正数，所以符号位为 0</p>
</li>
<li><p>阶码的值 E 为 13，∵ E = e - Bias， ∴ e = E + Bias = E + 127 = 140。所以阶码字段就是 140 的八位（float 的 E 一共 8 位，可以回过头再看看那张表）二进制表示，即 10001100，这就是 exp 字段。</p>
</li>
<li><p>将上述规格化形式的小数部分，后续添 0 添到23位，也就是添10个0，构造frac字段，即 10000001110010000000000</p>
</li>
</ul>
<p>将其组合在一起，就形成了<strong>32位单精度浮点数12345的编码</strong>：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0</span>  <span class="number">10001100</span>  <span class="number">10000001110010000000000</span></span><br><span class="line"><span class="attribute">s</span>    exp            frac</span><br></pre></td></tr></table></figure>
<h3 id="非规格化的值-Denormalized-Values"><a href="#非规格化的值-Denormalized-Values" class="headerlink" title="非规格化的值(Denormalized Values)"></a>非规格化的值(Denormalized Values)</h3><p>当阶码域exp全为0时，所表示的数就是非规格化形式。这里的意思是，原本用二进制表示的连续值，它们之间的<strong>间距是一样的</strong>。</p>
<p>在这种情况下有两点不同。对于阶码字段，阶码值<code>E</code>改成了<code>E = 1 - Bias</code>。也就是说</p>
<ul>
<li>单精度非规格化数的 E 是 -126</li>
<li>双精度非规格化数的 E 是 -1022</li>
</ul>
<p>对于尾数字段，尾数的值是 <code>M = f</code>。也就是说，<code>M</code>不再是一个以 1 开头的小数，而是以 0 开头的小数。这所以这样设置是有原因的。首先，非规格化数定义了一种表示零的方法，如果使用规格化数，由于总有 <code>M ≥ 1</code>，那么我们就不能表示 0。实际上，零的表示就是<code>exp</code>和<code>frac</code>字段全为 0，因此，对于浮点数来说，还有正零和负零的区别。非规格化数的另一个用途就是表示<strong>非常接近零的数</strong>。这种机制实现了由<strong>最大非规格化数到最小规格化数的平滑转换</strong>。</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>第一类是当exp全为1，frac全为0时，表示的值为<strong>无穷</strong>。当符号位 s = 1 代表负无穷，s = 0 代表正无穷。当小数域不是0，那就代表 NaN（Not a Number），不是一个数，表示出错。例如计算 -1 开根号的值就是 NaN。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src="http://osax8w13y.bkt.clouddn.com/3-2.png" alt=""></p>
<p>我们采取一位符号位，4 位 exp 位，3 位 frac 位，bias = 2 ^ 3 - 1 = 7的编码方式。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">   符号 阶码 尾数  </span><br><span class="line">    s exp  frac  e   E   十进制值</span><br><span class="line">                         小数部分 * 2的E次方</span><br><span class="line">------------------------------------------------------------------<span class="language-yaml"><span class="meta">---</span></span></span><br><span class="line"><span class="language-yaml">                             <span class="comment"># 这部分是非规范化数值，E = 1 - bias = -6</span></span></span><br><span class="line"><span class="language-yaml">    <span class="number">0</span> <span class="number">0000 </span><span class="number">000</span>   <span class="number">0</span>  <span class="number">-6</span>   <span class="number">0</span>   </span></span><br><span class="line"><span class="language-yaml">    <span class="number">0</span> <span class="number">0000 </span><span class="number">001</span>   <span class="number">0</span>  <span class="number">-6</span>   <span class="number">1</span><span class="string">/8</span> <span class="string">*</span> <span class="number">1</span><span class="string">/64</span> <span class="string">=</span> <span class="number">1</span><span class="string">/512</span>     <span class="comment"># 能表示的最接近零的值</span></span></span><br><span class="line"><span class="language-yaml">    <span class="number">0</span> <span class="number">0000 </span><span class="number">010</span>   <span class="number">0</span>  <span class="number">-6</span>   <span class="number">2</span><span class="string">/8</span> <span class="string">*</span> <span class="number">1</span><span class="string">/64</span> <span class="string">=</span> <span class="number">2</span><span class="string">/512</span> </span></span><br><span class="line"><span class="language-yaml">    <span class="string">...</span></span></span><br><span class="line">   <span class="number"> 0 </span>0000<span class="number"> 110 </span> <span class="number"> 0 </span> -6   6/8 * 1/64 = 6/512</span><br><span class="line">   <span class="number"> 0 </span>0000<span class="number"> 111 </span> <span class="number"> 0 </span> -6   7/8 * 1/64 = 7/512     <span class="comment"># 能表示的最大非规范化值</span></span><br><span class="line">------------------------------------------------------------------<span class="language-yaml"><span class="meta">---</span></span></span><br><span class="line"><span class="language-yaml">                              <span class="comment"># 这部分是规范化值，E = e - bias </span></span></span><br><span class="line"><span class="language-yaml"></span></span><br><span class="line"><span class="language-yaml">    <span class="number">0</span> <span class="number">0001 </span><span class="number">000</span>   <span class="number">1</span>  <span class="number">-6</span>   <span class="number">8</span><span class="string">/8</span> <span class="string">*</span> <span class="number">1</span><span class="string">/64</span> <span class="string">=</span> <span class="number">8</span><span class="string">/512</span>     <span class="comment"># 能表示的最小规范化值</span></span></span><br><span class="line"><span class="language-yaml">    <span class="number">0</span> <span class="number">0001 </span><span class="number">001</span>   <span class="number">1</span>  <span class="number">-6</span>   <span class="number">9</span><span class="string">/8</span> <span class="string">*</span> <span class="number">1</span><span class="string">/64</span> <span class="string">=</span> <span class="number">9</span><span class="string">/512</span></span></span><br><span class="line"><span class="language-yaml">    <span class="string">...</span></span></span><br><span class="line">   <span class="number"> 0 </span>0110<span class="number"> 110 </span> <span class="number"> 6 </span> -1   14/8 * 1/2 = 14/16</span><br><span class="line">   <span class="number"> 0 </span>0110<span class="number"> 111 </span> <span class="number"> 6 </span> -1   15/8 * 1/2 = 15/16     <span class="comment"># 最接近且小于 1 的值</span></span><br><span class="line">   <span class="number"> 0 </span>0111<span class="number"> 000 </span> <span class="number"> 7 </span> <span class="number"> 0 </span>  8/8 *<span class="number"> 1 </span>= 1</span><br><span class="line">   <span class="number"> 0 </span>0111<span class="number"> 001 </span> <span class="number"> 7 </span> <span class="number"> 0 </span>  9/8 *<span class="number"> 1 </span>= 9/8          <span class="comment"># 最接近且大于 1 的值</span></span><br><span class="line">   <span class="number"> 0 </span>0111<span class="number"> 010 </span> <span class="number"> 7 </span> <span class="number"> 0 </span>  10/8 *<span class="number"> 1 </span>= 10/8</span><br><span class="line">    ...</span><br><span class="line">   <span class="number"> 0 </span>1110<span class="number"> 110 </span> <span class="number"> 14 </span><span class="number"> 7 </span>  14/8 *<span class="number"> 128 </span>= 224</span><br><span class="line">   <span class="number"> 0 </span>1110<span class="number"> 111 </span> <span class="number"> 14 </span><span class="number"> 7 </span>  15/8 *<span class="number"> 128 </span>=<span class="number"> 240 </span>      <span class="comment"># 能表示的最大规范化值</span></span><br><span class="line">---------------------------------------------------------------<span class="language-yaml"><span class="meta">---</span></span></span><br><span class="line"><span class="language-yaml">                                                <span class="comment"># 特殊值</span></span></span><br><span class="line"><span class="language-yaml">    <span class="number">0</span> <span class="number">1111 </span><span class="number">000</span>   <span class="string">价码部分全为</span> <span class="number">1</span><span class="string">，小数部分全为</span> <span class="number">0</span><span class="string">，正无穷大</span></span></span><br><span class="line"><span class="language-yaml">    <span class="number">1</span> <span class="number">1111 </span><span class="number">000</span>   <span class="string">无穷大的符号位是</span> <span class="number">1</span><span class="string">，代表负无穷大</span></span></span><br><span class="line"><span class="language-yaml">    <span class="number">0</span> <span class="number">1111 </span><span class="number">001</span>   <span class="string">阶码部分全为</span> <span class="number">1</span><span class="string">，小数部分不全为</span> <span class="number">0</span><span class="string">，NaN</span></span></span><br></pre></td></tr></table></figure>
<p>观察表格，我们更好地可以理解之前的几个细节：</p>
<ul>
<li>连续非规格化值之间的间距是一样的，上面这个例子中，都是差了1/512</li>
<li>连续的规格化值之间的间距不同。这是由于 exp 的不同而导致的。比方说最接近 1 的数字是 15/16 和 9/8，分别相差 1/16 和 1/8。</li>
<li>“浮点数能编码一个很大的范围，但这种表示只是近似的。”我们能想象，如果frac位的长度越长，那么对于小数表示的精度就能越高。如果exp位的长度越长，那么能够表示的范围就越大。</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/3-3.png" alt=""></p>
<p>上面是一个数轴，表示的是这种编码方式下的能表示的数在数轴上排列的情况。可以看到，浮点数表示的范围是很大的，也能够表示特别大和特别小的数。但是数的分布不是均匀的——在数轴两端，数字比较稀疏；在越靠近原点的地方，数字越稠密。在最靠近原点的地方，是非规格化数。</p>
<h2 id="舍入（rounding）"><a href="#舍入（rounding）" class="headerlink" title="舍入（rounding）"></a>舍入（rounding）</h2><p><img src="http://osax8w13y.bkt.clouddn.com/3-4.png" alt=""></p>
<p>因为表示方法限定了浮点数不是精确的，因此浮点运算只能<strong>近似</strong>地表示实数运算。因此，对于某个运算结果 x，我们需要想出一个系统的方法，找到一个能够用浮点编码表示的<strong>最接近</strong>的匹配值 x1，用 x1 来表示运算结果。这就是舍入的任务。</p>
<p>浮点数采取的规则是<strong>舍入到偶数</strong>，即：将数字向上或向下舍入，使得结果的最低有效数字是偶数。舍入到偶数我认为可以这么理解：<strong>四舍六入，五到偶</strong>。</p>
<p>例如，我们要把一个一位小数舍入到整数位，那么1.4会舍入成1，1.6会舍入成2。如果是按照四舍五入的话，2.5和1.5会舍入成3和2。如果是按照舍入到偶数，那么2.5和1.5都是舍入成2的。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/3-5.png" alt=""></p>
<p>为什么倾向于采取这种方法？我们很容易想到这样的情景：用某种方法舍入一组数值，必然会在用这些数值做某种计算的时候产生误差，误差的类型依照舍入方法而不同。例如，如果都采取向上舍入，那么一组数据经舍入后，求这组数据的平均值，那么平均值肯定是偏大的。之所以采取舍入到偶数，可以认为舍入到偶数是一种比四舍五入更加“<strong>公平</strong>”的舍入方法，我们把中间值5，一半向上舍入，一半向下舍入，那么就在大多数的现实情况中避免了计算的统计偏差。</p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><h3 id="浮点加法"><a href="#浮点加法" class="headerlink" title="浮点加法"></a>浮点加法</h3><p>$$ (-1)^{s1}M_1·2^{E_1} + (-1)^{s2}M_2·2^{E_2} $$</p>
<p>结果：（这里假设 E1 ≥ E2）<br>$$(-1)^{s}M·2^{E}$$</p>
<p>其中<br>$$ s = s1 ∧s2，M = M1 + M2, E = E1$$</p>
<p>过程如下：</p>
<ol>
<li>如果两个浮点数的阶码不一样，那么首先要<strong>对阶</strong>。因为假设了E1 ＞ E2，所以可以把第二个数的小数点往左移动，然后增加E2的值。</li>
<li>尾数相加得结果M。</li>
<li>规格化，把M通过左移or右移小数点来表示为1.xxx的形式，并更新E的值。</li>
<li>如果不能完成规格化的操作，那么就是非规格化数。</li>
<li>如果超过了可以表示的范围，那么就是溢出。</li>
<li>最后把M舍入到frac的精度。</li>
</ol>
<h3 id="浮点乘法"><a href="#浮点乘法" class="headerlink" title="浮点乘法"></a>浮点乘法</h3><p>$$ (-1)^{s1}M_1·2^{E_1} × (-1)^{s2}M_2·2^{E_2} $$</p>
<p>结果：<br>$$(-1)^{s}M·2^{E}$$</p>
<p>其中<br>$$ s = s1 ∧ s2，M = M1 × M2, E = E1+E2$$</p>
<p>仍然需要进行规格化操作、也需要舍入、也有可能溢出。</p>
<h2 id="浮点运算性质"><a href="#浮点运算性质" class="headerlink" title="浮点运算性质"></a>浮点运算性质</h2><p>对于浮点值x和y，如果对它们进行某种运算，那么计算的结果实际上是将<strong>精确</strong>的计算结果舍入后的结果。因此，浮点运算有以下几条重要的性质：</p>
<ul>
<li>满足交换率，但不满足结合律</li>
</ul>
<blockquote>
<p>例如表达式（3.14 + 1e10） - 1e10的结果会是0.0——因为舍入的缘故，3.14就丢失了。然而，表达式3.14 + （1e10 - 1e10）会得到正确结果3.14</p>
</blockquote>
<ul>
<li>浮点加法满足单调性原则。</li>
</ul>
<blockquote>
<p>如果 a ≥ b ，那么对于任何的x值，除了产生NaN，都有x + a ≥ x + b。</p>
</blockquote>
<ul>
<li>浮点加法不具有可结合性。</li>
</ul>
<blockquote>
<p>（1e20 × 1e20）× 1e-20的值为正无穷，然而 1e20 × （1e20 × 1e-20）的值为1e20。</p>
</blockquote>
<ul>
<li>不具备分配性。</li>
</ul>
<blockquote>
<p>1e20 ×（1e20-1e20） 的值为0.0，然而1e20 × 1e20 - 1e20 × 1e20会得到NaN。</p>
</blockquote>
<h2 id="int、float、double间的强制类型转换"><a href="#int、float、double间的强制类型转换" class="headerlink" title="int、float、double间的强制类型转换"></a>int、float、double间的强制类型转换</h2><p>在没有了解编码方面的细节前，我们对这个问题只能说知其然而不知其所以然。</p>
<ul>
<li>int转换成float，数字不会溢出，但是可能被舍入。</li>
<li>int或float转换成double，因为double有比这两者都来得更大的范围，和更高的精度，所以能够保留精确的数值。</li>
<li>double转成float，范围会变小，有可能得到值正负无穷。由于精度也变小了，所以可能被舍入。</li>
<li>float或double转成int，值将会像零舍入。例如：1.999会变成1，-1.999会变成-1。值有可能溢出。<strong>C语言标准没有对这种情况制定固定的结果。</strong></li>
</ul>
<h2 id="对于浮点数的一些总结，以及特殊的浮点数"><a href="#对于浮点数的一些总结，以及特殊的浮点数" class="headerlink" title="对于浮点数的一些总结，以及特殊的浮点数"></a>对于浮点数的一些总结，以及特殊的浮点数</h2><p><img src="http://osax8w13y.bkt.clouddn.com/3-6.png" alt=""></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/3-7.png" alt=""></p>
<h1 id="第一章小结"><a href="#第一章小结" class="headerlink" title="第一章小结"></a>第一章小结</h1><p>好了，我们也看完了浮点数的全部内容，也就了解了信息在计算机内的存储方式这一章的全部内容。</p>
<p>我们从最基本的元素——bit开始，了解了整型和浮点数两个非常重要的数据类型的编码方式。只有了解了位的知识、以及编码方式，我们才可能对这些数据类型涉及的其他方方面面的概念，例如：掩码运算、强制类型转换、扩展、截断、舍入、溢出等等。如果不了解位，那么对于上述这些概念只能是知其然而不知其所以然（好吧，原谅我的词穷，这个词我好像在本篇博客中用了好几遍。。但我觉得知道深层的原理是很有帮助的）。</p>
<p>这些内容很重要，但我觉得比较好的学习方法是举例子来理解。这本书每个小节后面配有很好的题目，可以帮助大家理解这些知识点。</p>
<h1 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h1><ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期  ICS课程网站</a></li>
<li><a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE floating point</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】4. 汇编语言——基础</title>
    <url>/2017/06/25/csapp-4-Machine-Prog-Basics/</url>
    <content><![CDATA[<h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><p>计算机能读懂是<a href="https://en.wikipedia.org/wiki/Machine_code">机器代码</a>（machine code）—— 用字节序列编码的低级操作 —— 也就是0和1。编译器基于编程语言的规则、目标机器的指令集和操作系统的规则，经过一系列阶段产生机器代码。由于机器语言全是由0和1组成的，所以对于编程人员来说编写机器代码十分困难，也不容易学习。<a href="https://en.wikipedia.org/wiki/Assembly_language">汇编语言</a>（assembly language）就是机器语言的可读形式，学习汇编语言有很多的好处。</p>
<blockquote>
<p>An assembly (or assembler) language,[1] often abbreviated asm, is a low-level programming language for a computer, or other programmable device, in which there is a very strong (generally one-to-one) correspondence between the language and <strong>the architecture’s machine code instructions.</strong></p>
<p>Machine code or machine language is a set of instructions <strong>executed directly by a computer’s central processing unit (CPU)</strong>. Each instruction performs a very specific task, such as a load, a jump, or an ALU operation on a unit of data in a CPU register or memory. Every program directly executed by a CPU is made up of a series of such instructions……Numerical machine code (i.e., not assembly code) may be regarded as the lowest-level representation of a compiled or assembled computer program or as a primitive and hardware-dependent programming language.</p>
</blockquote>
<p>我们在用高级语言编程时（例如C语言），高级语言本身提供的抽象级别比较高，因此有“程序设计”的概念，方便我们编程。大多数情况下，抽象级别比较高，工作效率就会提高，也更高效可靠。高级语言相较汇编语言的一个最大优点是：用高级语言编写的程序可以在很多不同的机器上运行，而汇编代码与硬件本身有关联，例如指令集不同那么汇编代码就不同。</p>
<blockquote>
<p>Each assembly language is specific to a particular computer architecture. In contrast, most high-level programming languages are generally portable across multiple architectures but require interpreting or compiling.</p>
</blockquote>
<p>那我们为什么要花时间学习汇编和机器代码呢？</p>
<p>纵观计算机的发展历程，有一个很重要的观点就是用<strong>分层</strong>的思路来构造整个系统，每个下层都对其上层隐藏本层的细节。这个抽象原理对于理解计算机很多方面的知识都有帮助，例如网络四层模型就是一个很典型的例子。扯回编程语言这块，由于语言是“高级”的，自然屏蔽了很多机器级实现过程的细节。例如，如果只是单纯的学习C语言，那对于寄存器、程序计数器、系统的栈、缓冲区溢出等知识点没有办法很好的理解，因为它们对于C语言程序员来说都是被隐藏的处理器状态。C语言的指针通常是引起错误和不理解的来源，但在汇编中访存、取地址都是很常见的操作。学习汇编，能让你学到一些在C语言学习中由于粒度不够细而学不到的东西。除此之外，读完这一章之后，你还能领略到C语言的伟大之处。</p>
<p>抽象和分层是很重要的思想，但对于严谨的学习者来说，并不意味只要懂得抽象原理就足够了。能够阅读和理解汇编代码是仍是一项很重要的技能。<strong>精通细节是理解更深和更基本概念的先决条件</strong>。随着时间的推移，对于汇编代码的学习需求也有变化，我们现在不需要直接用汇编语言编写程序，只需要能够阅读并理解编译器产生的代码就可以了。</p>
<p>处理器执行的指令，被编码成二进制形式。一个处理器支持的指令及其编码集称为<a href="https://en.wikipedia.org/wiki/Instruction_set">指令集体系结构</a>(Instruction-Set Architecture, <strong>ISA</strong>)。</p>
<blockquote>
<p>An instruction set, with its instruction set architecture (ISA), is the interface between a computer’s software and its hardware, and thereby enables the independent development of these two computing realms; it defines the valid instructions that a machine may execute.</p>
</blockquote>
<p>ISA就是机器级程序的格式和行为，这种类型的指令，每一条完成的工作都是非常基本的，例如把两个数相加。因此学习汇编代码就有助于我们了解编译器在把C代码转换成机器代码时所做的转换。相对于C代码，编译器重新排列执行顺序、消除不必要的计算和变量、用基本的、快速的操作代替慢速操作，甚至用迭代替代了递归。学习<strong>逆向工程</strong>（reverse engineering），来研究高级语言，甚至研究系统创建的过程。（好书啊好书）</p>
<blockquote>
<p>可以说，汇编语言很有其特殊性，高级语言的一些抽象的概念，都被归一和具象化了，C语言的指针，在汇编的世界里简直不值一提，因为地址，对地址的引用再平常不过了。另一方面，内存，缓存，寄存器，CPU，又构成了一个奇妙的世界，它们屏息恭立，静待主公的每一条喻令。<br>我不相信，一个人用纯手工一条条指令去雕琢他的程序，用手指感受计算机的呼吸时会无动于衷。……</p>
<p>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/23088538/answer/23631875">https://www.zhihu.com/question/23088538/answer/23631875</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><p>汇编内容比较多，部分涉及具体细节的内容有删减，仅做简单介绍，详情请参考书本。</p>
<h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>Intel 处理器系列俗称 x86，经历了一个长期的、不断发展过程。1965年，Intel公司的创始人Gordon Moore，根据当时的芯片技术（那时他们能够在一个芯片上制造大概有64个晶体管的电路）做出推断：未来10年内，芯片上晶体管数量每年都能翻一番。这个预测就是著名的<strong>摩尔定律</strong>。正如事实所证明的那样，他的预测有点乐观，还有点短视。在超过45年中，半导体工业一直能够让晶体管数量每18个月翻一番。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/4-1.png" alt=""></p>
<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>就像上面讲到的那样，计算机系统用到了许多不同形式的抽象，利用简单的模型隐藏各种细节。其中之一就是指令集，也就是ISA。在学习汇编时，ISA模型给人的感觉好像看上去应该是顺序指令执行，也就是先取出一条指令，等到它执行完毕，再开始下一条。然而处理器的实际工作方式远比这种模式精细复杂，因为处理器可以并发执行多条指令，因此需要做很多的额外工作。<strong>在计算机科学中，用巧妙的方法在提高性能，并完成更多更复杂的功能的同时，又同时保持了一个更简单、更抽象的底层模型功能</strong>，这种想法是无处不在的。</p>
<p>IA32和x86-64就是两种ISA，也是着重介绍的重点。这两者是当今大多数计算机的主导语言，后者是前者在64位机器上的扩展版本。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/4-2.png" alt=""></p>
<p>IA32的机器代码和原始C代码差别非常大。下面这些对于C语言程序员隐藏的概念在IA32中是可见的：</p>
<ul>
<li><p>程序计数器（Program Counter，简称PC），用来指示将要执行的下一条指令的地址。</p>
</li>
<li><p>整数寄存器文件（Register File），非常重要的概念。用来存储地址（对应C语言的指针）或者整数数据，或者用来记录程序的状态，或者保持临时数据，例如局部变量、函数的返回值等等。</p>
</li>
<li><p>条件码（Condition Code），保持最近执行过的算术or逻辑指令的状态信息。用来实现控制或数据流条件变化。（对应C语言的if等等）</p>
</li>
</ul>
<p>对于机器级编程来说，有第另一种极为重要的抽象，那就是把存储器地址抽象成<strong>虚拟地址</strong>（Virtual Memory），提供的模型，让机器代码只是简单地把存储器看成是一个非常大的字节数组。所以，C语言中的各种数据类型，和自定义数据类型（struct），在机器代码中都是用一组字节来表示。汇编代码不区分有符号、无符号常数，不区分各种类型的指针，甚至不区分指针和整数。</p>
<ul>
<li>程序存储器（Program Memory）包含程序的可执行机器代码，操作系统需要的一些信息，例如支持系统运行的栈，以及为用户分配的存储器块（例如malloc）。程序存储器用虚拟地址来寻址（Addressable），操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器中的物理地址。</li>
</ul>
<p>处理器能够执行的操作其实是非常有限的，简单来说只有三种：存取数据、计算和传输控制。存取数据是在内存和寄存器之间传输数据，进行计算则是对寄存器或者内存中的数据执行算术运算，传输控制主要指非条件跳转和条件分支。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>下面给出一个C语言代码以及其汇编代码中的一些关键行。一开始看不懂没关系，我们只需要对其有一个感性认知。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> accum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span>(<span class="built_in">int</span> x, <span class="built_in">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">t</span> = x + y;</span><br><span class="line">    accum += <span class="built_in">t</span>;</span><br><span class="line">    return <span class="built_in">t</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的由编译器产生的汇编代码（部分行）如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sum:</span></span><br><span class="line">    pushl   <span class="variable">%ebp</span></span><br><span class="line">    movl    <span class="variable">%esp</span><span class="punctuation">,</span>  <span class="variable">%ebp</span></span><br><span class="line">    movl    <span class="number">12</span>(<span class="variable">%ebp</span>)<span class="punctuation">,</span>  <span class="variable">%eax</span></span><br><span class="line">    addl    <span class="number">8</span>(<span class="variable">%ebp</span>)<span class="punctuation">,</span>  <span class="variable">%eax</span></span><br><span class="line">    addl    <span class="variable">%eax</span><span class="punctuation">,</span>  accum</span><br><span class="line">    popl    <span class="variable">%ebp</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>观察汇编语言代码，我们可以看到第一个字符串就是操作符，后面可能跟着几个操作数，由逗号分开。操作符就被唯一解码成对应的机器指令，但汇编语言的操作符是能让我们看得懂的。</p>
<p>在汇编代码中，每一行都代表一条机器指令。例如pushl就是把寄存器%ebp的内容压入栈。这段代码已经不存在任何关于局部变量名和数据类型的信息（除了全局变量accum，还没有确定会放在哪里）。</p>
<p>如果使用汇编器（Assembler）将汇编语言翻译为机器语言，机器语言是二进制格式，无法直接查看。但其中有一列17个字节的字节序列：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">55</span> <span class="number">89</span> e5 <span class="number">8</span>b <span class="number">45</span> <span class="number">0</span>c <span class="number">03</span> <span class="number">45</span> <span class="number">08</span> <span class="number">01</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">5</span>d c3</span><br></pre></td></tr></table></figure>
<p>这就是上面列出的汇编指令对应的机器代码。我们可以看出来，机器实际执行的就是对一系列指令进行编码的<strong>字节序列</strong>。机器对于我们写的C语言代码可以说是一无所知的。</p>
<hr>
<h1 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h1><ul>
<li><a href="https://www.zhihu.com/question/23088538">zhihu 学习汇编语言有什么好处？</a></li>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期 ICS课程网站</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】5. 汇编语言——数据</title>
    <url>/2017/06/25/csapp-5-Machine-Prog-Data/</url>
    <content><![CDATA[<p>本博客对于汇编的介绍基于32位机器的Intel x86系列处理器和IA32指令集，也涉及少部分x86-64。由于汇编知识相对复杂，这里只做简单介绍和记录，详细请参照书本！</p>
<h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>下面这张表格中体现了C语言基本数据类型和IA32的对应表示。</p>
<table>
<thead>
<tr>
<th>C语言中的声明</th>
<th>Intel 数据类型</th>
<th>汇编代码后缀</th>
<th>大小（字节） </th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>字节</td>
<td>b(byte)</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w(word)</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l(long)</td>
<td>4</td>
</tr>
<tr>
<td>long int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long long int</td>
<td>“四字”</td>
<td>-</td>
<td>4</td>
</tr>
<tr>
<td>char *</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度</td>
<td>t</td>
<td>10 or 12</td>
</tr>
</tbody>
</table>
<p>大多数的常用数据类型是用双字形式存储的。短整数<code>short</code>、普通整数<code>int</code>和长整数<code>long int</code>的区别是“短”和“普通”整数是固定的 2 和 4 字节，而“长”整数使用的是机器的全字长，因为是32位机器，所以这里 <code>long int</code> 是4字节。</p>
<p><code>long long</code>是由8个字节来表示的，在硬件上 IA32 是不支持的这种数据类型的（x86-64可以）。</p>
<p>指针<code>char *</code>是使用机器的全字长的，因为指针是存储地址的变量。地址和字长有关，字长（word size）表明整数和指针数据的标称大小（nominal size）。在没有涉及到存储器的细节时，我们会把存储器看成一个非常大的数组，所以字长决定一个很重要的属性是虚拟空间的最大大小（每一个字节都要用一个唯一的数字来标识，而这个数字是要编码的）。对于一个字长为 w 位的机器而言，虚拟地址的范围是0 ~ $(2^w)-1$，程序最多访问$2^w$ 个字节。</p>
<p>单精度和双精度浮点数是 4 和 8 字节，不多说。扩展精度<code>long double</code>的大小为10或12字节。</p>
<p>汇编代码后缀的意思是大多数汇编代码指令的后面带有一个字符后缀，表明操作数的大小。例如：<code>movb</code>（传送字节）、<code>movw</code>（传送字）、<code>movl</code>（传送双字）。注意：用 <code>l</code> 表示<code>double</code>和 4 字节整数不会产生歧义，因为浮点数使用的是一套完全不同的指令和寄存器。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>一个 IA32 中央处理器单元（CPU，central processing unit）包含一组8个存储32位值的<strong>寄存器</strong>（register），可以看到寄存器的数量是很少的。下图显示了这八个寄存器的简单表示。它们的名字都以%e开头，实际上它们另有特殊的名字。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5-1.png" alt=""></p>
<p>在大多数情况下，前六个寄存器可以看成<strong>通用寄存器</strong>，对它们的使用没有限制（“大多数情况”下分具体情况，具体情况也是用特殊的寄存器）。最后两个寄存器（<code>%ebp</code>和<code>%esp</code>）保存指向程序的栈中重要位置的指针，所以只有根据栈管理的标准才能修改这两个寄存器的值。</p>
<p>可以看到，字节操作指令可以独立地写更短的地位字节。这是为了<strong>向后兼容</strong>（backwards compatiblity），也就是能让更早的代码正常地工作。下面是x86-64的寄存器，以%r开头的是64位寄存器，可以看到它也是向后兼容的。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5-5.png" alt=""></p>
<h1 id="数据传送：-MOV-指令"><a href="#数据传送：-MOV-指令" class="headerlink" title="数据传送： MOV 指令"></a>数据传送： MOV 指令</h1><p>将数据从一个位置复制到另一个位置是最频繁使用的指令。我们把指令分成<strong>指令类</strong>，一类指令执行的操作是一样的，只不过操作数的大小不同。</p>
<table>
<thead>
<tr>
<th>MOV指令</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>mov S, D</strong></td>
<td>传送字节，<strong>S → D</strong></td>
</tr>
<tr>
<td><strong>movw S, D</strong></td>
<td>传送字</td>
</tr>
<tr>
<td><strong>movl S, D</strong></td>
<td>传送双字</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>MOVS指令</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>movsbw S, D</strong></td>
<td>将做了符号扩展的字节传送到字，<strong>S → D</strong></td>
</tr>
<tr>
<td><strong>movsbl S, D</strong></td>
<td>将做了符号扩展的字节传送到双字</td>
</tr>
<tr>
<td><strong>movswl S, D</strong></td>
<td>将做了符号扩展的字传送到双字</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>MOVZ指令</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>movzbw S, D</strong></td>
<td>将做了零扩展的字节传送到字，<strong>S → D</strong></td>
</tr>
<tr>
<td><strong>movzbl S, D</strong></td>
<td>将做了零扩展的字节传送到双字</td>
</tr>
<tr>
<td><strong>movzwl S, D</strong></td>
<td>将做了零扩展的字传送到双字</td>
</tr>
</tbody>
</table>
<p>例如  <code>MOV</code> 是一类指令，代表传输数据，根据传送的是字节、字还是双字，分为三种指令：<code>movb</code>、<code>movw</code>、<code>movl</code>。</p>
<p><code>mov</code> 移动的数据的大小和目的位置的大小是一样的。与 <code>MOV</code> 不同，<code>MOVS</code> 和 <code>MOVZ</code> 指令类是将一个较小的数据放到一个较大的数据位置。扩展方式分为符号扩展或者零扩展两种方式。如果要将一个较小的数据放到一个较大的数据位置，要么使用扩展版本的指令，要么就选择正确的 <code>mov</code> 后缀。不能将较大的数据放在一个较小的数据位置。</p>
<p>下面要介绍一个非常重要的概念——寻址。</p>
<h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><p>大多数指令有一个或多个操作数（operand），操作数可能指代要引用的数据值、数据来源、或者要存放的目标位置。形成操作数的有效地址的过程，被称为<strong>寻址</strong>（addressing）。</p>
<p>操作数可以被分为三个类型：</p>
<ol>
<li><p>立即数（immediate）</p>
<p> 也就是一个常数值，书写方式是一个美元符号后面跟着一个用标准C表示法表示的整数，例如<code>$0x1F</code>。    </p>
</li>
<li><p>寄存器（register）</p>
<p> 表示某个寄存器的内容。用符号 $ E_a $  来表示任意寄存器a，用引用  $ R[E_a] $ 来表示它的值。这是将寄存器集合看成一个数组 R，用寄存器的名称作为索引。   </p>
</li>
<li><p>存储器引用（memory）</p>
<p> 它根据一个计算出来的地址（称为有效地址）访问某个存储器的位置。因为我们是将存储器看成一个很大的字节数组。我们用<code>M[Addr]</code>表示对存储器中的字节值的引用。存储器寻址的内容就多了，包括：绝对寻址、间接寻址（对啦就是熟悉的指针！）、基址+偏移量寻址、变址寻址、比例变址寻址。在这里除了下面的程序中设计到的寻址方法之外的就不一一讲了。</p>
</li>
</ol>
<p>接下来，对下图中的一些寻址方式做简单介绍：</p>
<p>MOV 的第一个操作数是源S，S要么是一个寄存器，要么是一个立即数，要么是一个存储器位置。第二个操作数是目的地D，只能是寄存器或者存储器位置。（注，图中的<code>movq</code> 的后缀 <code>q</code> 是四字的意思，是 x86-64 中支持64位数据的写法。）</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5-2.png" alt=""></p>
<p>①：第一条指令的第一个操作数是 $0x4 ，说明这是一个立即数，也就是常数。第二个数是寄存器的名字，这种寻址方式叫做：寄存器寻址。对应的C语言就是为一个局部变量赋常数值。</p>
<p>②：第二条指令与第一条不同的是第二个操作数的寄存器两边加上了括号。这其是是间接寻址的意思。形如 $(E_a)$ 的格式代表的操作数值是 $M[R[E_a]]$，也就是说，此时寄存器里存的是一个指针，也就是一个地址，括号可以看成一个C语言的间接引用运算符*。</p>
<p>③：两个寄存器直接的数据传递。</p>
<p>④：把一个局部变量的值复制到一个指针指向的内容。</p>
<p>⑤：把指针指向的内容赋给局部变量temp</p>
<p>这里有一点需要注意的是：<strong>不允许</strong> <code>MOV</code>指令的两个操作数同时为存储器地址。也许你会感到奇怪：把存储器中一个地方的值传送到另一个地方不是很正常吗为什么没有这条指令？一开始对这个有疑惑是很正常的，这种操作需要两条指令——第一条指令将原值加载到寄存器中，第二条指令将该寄存器里的值写到目的存储器位置。</p>
<p>剩下的寻址方法这里就不详细介绍了，贴张图给大家看吧：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5-3.png" alt=""></p>
<h1 id="数据传送示例"><a href="#数据传送示例" class="headerlink" title="数据传送示例"></a>数据传送示例</h1><p>（图表来自于CSAPP课程网站，本人添加了一点小小的说明性信息）分析下面这个交换函数的汇编代码，有助于理解寄存器、存储器、寻址、地址等各种概念。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5-4.png" alt=""></p>
<p>变量 <code>xp</code> 和 <code>yp</code> 是指针，内容是地址，用寄存器 <code>%rdi</code> 和 <code>%rsi</code> 存放。临时变量 <code>t0</code> 和 <code>t1</code> 用寄存器 <code>%rax</code> 和 <code>%rdx</code> 存放。调用 <code>swap</code> 函数后，可以看到在左边的 memory 一列，<code>0x120</code> 和 <code>0x130</code> 里存放了数据 <code>123</code> 和 <code>456</code>，参数 <code>xp</code> 和  <code>yp</code> 已经存到了对应的寄存器。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5-6.png" alt=""></p>
<p>通过间接寻址，将存储器里的值存放到临时变量 <code>t0</code> 和 <code>t1</code> 对应的寄存器里。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5-7.png" alt=""></p>
<p>交换后，<code>* xp</code> 的值和 <code>* yp</code> 的值成功对调。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5-8.png" alt=""></p>
<h1 id="前两节的小结"><a href="#前两节的小结" class="headerlink" title="前两节的小结"></a>前两节的小结</h1><ul>
<li>了解处理器、指令集的历史和发展。</li>
<li>了解C语言、机器语言、汇编语言的区别。<br>  学习汇编语言能让我们理解更多细节，例如寄存器等等……理解编译器需要为C语言代码做的工作——将一些高级语言的表示方法编译为一些更为基本的指令。</li>
<li>汇编语言基础：寄存器、操作数、数据移动、寻址。</li>
</ul>
<hr>
<h1 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h1><ul>
<li><a href="https://www.zhihu.com/question/23088538">zhihu 学习汇编语言有什么好处？</a></li>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期 ICS课程网站</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】6. 汇编语言——控制</title>
    <url>/2017/06/25/csapp-6-Machine-Prog-Control/</url>
    <content><![CDATA[<p>到目前为止我们只考虑了直线代码的执行行为，也就是指令一条接着一条执行。C语言中的某些语句，比如条件语句、循环、分支语句，要求有条件地执行，或根据某些表达式的结果决定操作的顺序。机器代码提供基本的低级机制来实现有条件的行为：测试数据值，然后根据测试结果来改变<strong>控制流</strong>或<strong>数据流</strong>。</p>
<p>先介绍通过控制流来实现有条件的行为。用<code>jump</code>指令可以改变一组机器代码的执行顺序。<code>jump</code>指令指定控制应该传递到程序的哪个其他部分，这可能依赖于某个测试的结果。</p>
<h1 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h1><p>除了整数寄存器，CPU 还负责维护一组<strong>单个位</strong>的<strong>条件码</strong>（condition code）寄存器。最常用的条件码有：</p>
<table>
<thead>
<tr>
<th>条件码</th>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF</td>
<td>进位标志，carry</td>
<td>最近的操作使得最高位产生了进位。可以用来检查无符号操作数的溢出。</td>
</tr>
<tr>
<td>ZF</td>
<td>零标志，zero</td>
<td>最近的操作得出的结果为零</td>
</tr>
<tr>
<td>SF</td>
<td>符号标志，sign</td>
<td>最近的操作得出的结果为负</td>
</tr>
<tr>
<td>OF</td>
<td>溢出标志，overflow</td>
<td>最近的操作导致了一个补码溢出（正溢或负溢）</td>
</tr>
</tbody>
</table>
<p>假设我们用一条 ADD 指令完成一个 C语言表达式 <code>t=a+b</code>的功能，这里变量都是整型。然后，条件码就是根据下面的表达式设置的：</p>
<table>
<thead>
<tr>
<th>条件码</th>
<th>通过下面的表达式来设置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF</td>
<td>(unsigned) t &lt; (unsigned) a</td>
<td>和比加数小，说明出现无符号溢出</td>
</tr>
<tr>
<td>ZF</td>
<td>(t == 0)</td>
<td>结果为零</td>
</tr>
<tr>
<td>SF</td>
<td>(t &lt; 0)</td>
<td>结果为负数</td>
</tr>
<tr>
<td>OF</td>
<td>(a &lt; 0 == b &lt; 0) &amp;&amp; (t &lt; 0 != a &lt; 0)</td>
<td>a、b同时为负，而和为正；或a、b同时为正，而和为负。说明出现了有符号溢出</td>
</tr>
</tbody>
</table>
<h2 id="基础的整数算术操作"><a href="#基础的整数算术操作" class="headerlink" title="基础的整数算术操作"></a>基础的整数算术操作</h2><p>下面列出汇编中基础的整数算术操作：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>leal S, D</td>
<td>&amp;S → D</td>
<td>加载地址</td>
</tr>
<tr>
<td>INC D</td>
<td>D + 1 → D</td>
<td>自增1</td>
</tr>
<tr>
<td>DEC D</td>
<td>D - 1 → D</td>
<td>自减1</td>
</tr>
<tr>
<td>NEG D</td>
<td>-D → D</td>
<td>取负</td>
</tr>
<tr>
<td>NOT D</td>
<td>~D → D</td>
<td>取补</td>
</tr>
<tr>
<td>ADD S, D</td>
<td>S + D → D</td>
<td>加</td>
</tr>
<tr>
<td>SUB S, D</td>
<td>S - D → D</td>
<td>减</td>
</tr>
<tr>
<td>IMUL S, D</td>
<td>S * D → D</td>
<td>乘</td>
</tr>
<tr>
<td>XOR S, D</td>
<td>S ^ D → D</td>
<td>异或</td>
</tr>
<tr>
<td>OR S, D</td>
<td>S `</td>
<td>` D → D</td>
<td>与</td>
</tr>
<tr>
<td>AND S, D</td>
<td>S &amp; D → D</td>
<td>或</td>
</tr>
<tr>
<td>SAL k, D</td>
<td>D &lt;&lt; k → D</td>
<td>左移</td>
</tr>
<tr>
<td>SAR k, D</td>
<td>D &gt;&gt; k → D</td>
<td>算术右移</td>
</tr>
<tr>
<td>SHL k, D</td>
<td>D &gt;&gt; k → D</td>
<td>逻辑右移</td>
</tr>
</tbody>
</table>
<p><code>leal</code> 指令不改变任何条件码，因为它是用来做地址计算的。除此之外，其他指令都会会涉及改变条件码。</p>
<h2 id="设置条件码的特殊指令"><a href="#设置条件码的特殊指令" class="headerlink" title="设置条件码的特殊指令"></a>设置条件码的特殊指令</h2><p>有两类指令，它们只设置条件码而不改变其他任何寄存器。它们是比较和测试指令，<code>CMP S2, S1</code> 和 <code>TEST S2, S1</code>，比较指令是基于两个操作数的差来设置条件码。测试指令是给予两个数的按位与来设置条件码。常见的用法有：两个操作数是相同的（例如用指令 <code>testl %eax, %eax</code>来测试寄存器中存的是零、正数还是负数）；或者有一个操作数是一个掩码，指定哪些位应该被测试。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMP S2, S1</td>
<td>S1 - S2</td>
<td>比较</td>
</tr>
<tr>
<td>TEST S2, S1</td>
<td>S1 &amp; S2</td>
<td>测试</td>
</tr>
</tbody>
</table>
<h2 id="访问条件码：SET指令"><a href="#访问条件码：SET指令" class="headerlink" title="访问条件码：SET指令"></a>访问条件码：SET指令</h2><p>条件码通常不直接读取。有三种方法可以使用，下面依次介绍他们</p>
<ol>
<li>可以根据条件码的组某个组合将一个字节设置为 0 或 1 。</li>
<li>可以跳转到程序的其他部分。</li>
<li>可以有条件地传送数据。</li>
</ol>
<p>SET指令根据条件码的组合，将某一个字节设置为 0 或者 1 。指令名字后面的后缀指明了他们的功效和需要考虑的条件码组合的不同。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/6-set.png" alt=""></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>参考英文</th>
<th>效果</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>sete D</td>
<td>equal</td>
<td>相等/零</td>
<td></td>
</tr>
<tr>
<td>setne D</td>
<td>not equal</td>
<td>不等/非零</td>
<td></td>
</tr>
<tr>
<td>sets D</td>
<td>sign / negetive</td>
<td>负数</td>
<td></td>
</tr>
<tr>
<td>setns D</td>
<td>nonnegtive</td>
<td>非负数</td>
<td></td>
</tr>
<tr>
<td>setg D</td>
<td>greater</td>
<td>大于（有符号&gt;）</td>
<td>a与b的差不为零，差值为正时不能溢出，差值为负时必须溢出，则可以认定a大于b</td>
</tr>
<tr>
<td>setge D</td>
<td>greater or equal</td>
<td>大于等于（有符号≥）</td>
<td>与上面条件相似，只是去掉a与b差值不能为零的限制</td>
</tr>
<tr>
<td>setl D</td>
<td>less</td>
<td>小于（有符号&lt;）</td>
<td>a与b的差值为正的时候必须溢出，或a与b的差值为负但没有发生溢出，则可以认定a小于b</td>
</tr>
<tr>
<td>setle D</td>
<td>less or eqaul</td>
<td>小于等于（有符号≤）</td>
<td>与上面条件相似，只是多加了一条当a与b的差值为0时也可以认定a小于等于b</td>
</tr>
<tr>
<td>seta D</td>
<td>above</td>
<td>超过（无符号&gt;）</td>
<td>计算无符号数a和b的差值时最高位没有进位，且结果也不等于零，认为无符号数a大于b</td>
</tr>
<tr>
<td>setae D</td>
<td>above or equal</td>
<td>超过或相等（无符号≥）</td>
<td>与上面条件相似，但去掉不等于零的限制</td>
</tr>
<tr>
<td>setb D</td>
<td>below</td>
<td>低于（无符号&lt;）</td>
<td>计算无符号数a和b的差值时最高位没有进位</td>
</tr>
<tr>
<td>setbe D</td>
<td>below or equal</td>
<td>低于或等于（无符号≤）</td>
<td>与上面条件相似，但多加了一条当a与b的差值为0时也可以认定a小于等于b</td>
</tr>
</tbody>
</table>
<p>SET指令的操作数是8个单字节寄存器之一，或是存储一个字节的存储器位置，然后将这个字节设置为 0 或 1。下面看一个典型的计算C语言表达式 <code>x &gt; y</code> 的指令序列。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编指令序列：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">cmpl    <span class="variable">%eax</span><span class="punctuation">,</span> <span class="variable">%edx</span>     # Compare <span class="keyword">x</span> : y</span><br><span class="line">setl    <span class="variable">%al</span>            # Set low byte of <span class="variable">%eax</span> <span class="keyword">to</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">movzbl  <span class="variable">%al</span><span class="punctuation">,</span> <span class="variable">%eax</span>      # Set remaining bytes of <span class="variable">%eax</span> <span class="keyword">to</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>%al</code> 是一个单字节的寄存器元素，变量x和y分别存放在<code>%eax</code>和<code>%edx</code>中，然后使用<code>setl</code>指令，如果 a &gt; b，则把<code>%al</code>设置为 1，反之则设置为 0。<code>movzbl</code>是将做了零扩展的字节传送到字，这么做是因为我们为了得到一个32位结果，就要把高24位进行扩展，这里是全部清 0。</p>
<p>注意机器代码如何区别有符号和无符号值是很重要的。同C语言不同，机器代码不会将一个内存中的值和一个具体的数据类型联系起来。有些情况下，对于无符号数和有符号数使用的操作是相同的，根本原因是因为许多算术运算对于两者都有一样的位级行为。另外的一些情况下，对于无符号数和有符号数就要采取不同的操作，比方说不同版本的移位运算，乘除法，不同的条件码组合。</p>
<h1 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h1><p>正常执行情况下，指令会按照它们的顺序一条条执行。<strong>跳转</strong>（jump）指令会导致程序执行切换到一个全新的位置。</p>
<h2 id="jump-指令的字节编码"><a href="#jump-指令的字节编码" class="headerlink" title="jump 指令的字节编码"></a>jump 指令的字节编码</h2><p>在汇编代码中，跳转的目的地通常是用一个标号（label）来标识。考虑下列的汇编代码序列（完全人为编造）：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"> movl  $0, %eax</span><br><span class="line"> jmp   .L1</span><br><span class="line"> movl  (%eax), %edx</span><br><span class="line">.L1:</span><br><span class="line"> popl %edx</span><br></pre></td></tr></table></figure>
<p>指令<code>jmp</code>会导致跳过<code>movl</code>指令，从<code>pop</code>处开始执行。<code>jmp</code>是<strong>无条件跳转</strong>，而下表列出来的跳转指令都是<strong>有条件跳转</strong>，它们根据条件码组合进行跳转，或选择不跳转，继续执行下一条指令。条件码的组合与其意义和<code>SET</code>指令类似。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/6-jump.png" alt=""></p>
<p>前面提到，PC（program counter）——程序计数器的作用是指示要执行的下一条指令的地址。跳转指令有几种不同的编码方法，最常用的是<strong>PC相关寻址</strong>。它们会<strong>将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差值作为编码</strong>。当执行PC相关寻址时，PC的值是跳转指令后面那条指令的地址，而不是跳转指令本身的地址。下面看一个例子：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一段汇编代码：</span></span><br><span class="line"></span><br><span class="line">  jle   <span class="string">.L2</span></span><br><span class="line"><span class="string">.L5</span>:</span><br><span class="line">  <span class="string">....</span></span><br><span class="line">  <span class="string">....</span></span><br><span class="line">  jg    <span class="string">.L5</span></span><br><span class="line"><span class="string">.L2</span>:</span><br><span class="line">  <span class="string">....</span></span><br></pre></td></tr></table></figure>
<p>下面是汇编器产生的 .o 文件的反汇编版本：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span>:  <span class="number">7</span>e <span class="number">0</span>d     jle  <span class="number">17</span>&lt;main+<span class="number">0x17</span>&gt;</span><br><span class="line">a:  <span class="number">89</span> d0     <span class="params">...</span><span class="params">...</span><span class="params">...</span>.</span><br><span class="line"><span class="params">...</span>.</span><br><span class="line"><span class="params">...</span>.</span><br><span class="line"><span class="number">15</span>: <span class="number">7</span>f f3     jg   a&lt;main+<span class="number">0xa</span>&gt;</span><br><span class="line"><span class="number">17</span>: <span class="number">89</span> d0     <span class="params">...</span><span class="params">...</span><span class="params">...</span>.</span><br></pre></td></tr></table></figure>
<p>在反汇编中，第一行是跳转指令<code>jle</code>，它指定了跳转目标为<code>0x17</code>，也就是汇编代码中标签<code>L2</code>。第二行是跳转指令<code>jg</code>，它指定了跳转目标为<code>0xa</code>，也就是汇编代码中的标签<code>L5</code>。观察<strong>指令的字节编码</strong>，可以看到第一条跳转指令的目标编码（在第二个字节中）是<code>0xd</code>，将其加上PC的值，（PC值是跳转指令后面那条指令的地址：<code>0xa</code>）得到结果是<code>0x17</code>，就是正确的地址。</p>
<h2 id="翻译条件分支"><a href="#翻译条件分支" class="headerlink" title="翻译条件分支"></a>翻译条件分支</h2><p>将条件表达式和语句从C语言翻译成机器代码，一个方法就是使用C语言中的 goto 语句。使用 goto 语句常常被认为是一种不好的语言风格，因为它破坏了程序的结构性，并使代码非常难以阅读和调试。这里我们使用它是为了描述汇编代码在完成代码程序控制转移的流程。</p>
<p>C语言中的if-else的通用形式模板是这样的：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">text</span>-expr)</span><br><span class="line">    <span class="keyword">then</span>-<span class="keyword">statement</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">else</span>-<span class="keyword">statement</span></span><br></pre></td></tr></table></figure>
<p>对应汇编实现的通用形式模板是这样的：<br><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">    t = <span class="keyword">text</span>-expr</span><br><span class="line">    <span class="keyword">if</span>(!t)</span><br><span class="line">        <span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">then</span>-statement</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"><span class="symbol">false:</span></span><br><span class="line">    <span class="keyword">else</span>-statement;</span><br><span class="line"><span class="symbol">done:</span></span><br></pre></td></tr></table></figure></p>
<p>下面举一个具体的例子：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">//一份返回绝对值差值的C语言代码</span><br><span class="line"><span class="type">int</span> absdiff(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">result</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        <span class="built_in">result</span> = y - x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">result</span> = x - y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//与之等价的goto版本</span><br><span class="line"><span class="type">int</span> absdiff_goto(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">result</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= y) goto <span class="type">Else</span>;</span><br><span class="line">    <span class="built_in">result</span> = y - x;</span><br><span class="line">    goto <span class="type">Done</span>;</span><br><span class="line"><span class="type">Else</span>:</span><br><span class="line">    <span class="built_in">result</span> = x - y;</span><br><span class="line"><span class="type">Done</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"># 汇编代码</span><br><span class="line"></span><br><span class="line"># 变量<span class="keyword">x</span>存放在 <span class="variable">%ebp</span><span class="number">+8</span>，变量y存放在 <span class="variable">%ebp</span><span class="number">+12</span></span><br><span class="line"></span><br><span class="line">movl    <span class="number">8</span>(<span class="variable">%ebp</span>)<span class="punctuation">,</span> <span class="variable">%edx</span>       # 将变量<span class="keyword">x</span>存放在寄存器<span class="variable">%edx</span>中</span><br><span class="line">movl    <span class="number">12</span>(<span class="variable">%ebp</span>)<span class="punctuation">,</span> <span class="variable">%eax</span>      # 将变量y存放在寄存器<span class="variable">%eax</span>中</span><br><span class="line">cmpl    <span class="variable">%eax</span><span class="punctuation">,</span> <span class="variable">%edx</span>          # 比较 <span class="keyword">x</span>:y</span><br><span class="line">jge     .L<span class="number">2</span>                 # 如果满足大于或等于，跳转到标签L<span class="number">2</span></span><br><span class="line">subl    <span class="variable">%edx</span><span class="punctuation">,</span> <span class="variable">%eax</span>          # y - <span class="keyword">x</span> 结果放到 <span class="variable">%eax</span></span><br><span class="line">jmp     .L<span class="number">3</span></span><br><span class="line"></span><br><span class="line">.L<span class="number">2</span>:</span><br><span class="line">subl    <span class="variable">%eax</span><span class="punctuation">,</span> <span class="variable">%edx</span>          # <span class="keyword">x</span> - y 结果放到 <span class="variable">%edx</span></span><br><span class="line">movl    <span class="variable">%edx</span><span class="punctuation">,</span> <span class="variable">%eax</span>          # 将 <span class="variable">%edx</span> 里的结果放到 <span class="variable">%eax</span></span><br><span class="line"></span><br><span class="line">.L<span class="number">3</span>:                        # return 的是 <span class="variable">%eax</span> 里面的值</span><br></pre></td></tr></table></figure>
<p>逆向工程（reverse engineer），通过分析汇编代码，来推出C语言代码，做这样的练习对理解汇编知识和原理有很大的帮助。只看上面这段汇编代码，你能不能推出C语言的代码来呢？</p>
<h1 id="条件传送"><a href="#条件传送" class="headerlink" title="条件传送"></a>条件传送</h1><p>条件分支的操作方法是实现<strong>控制</strong>的转移——当条件满足时，沿着一条路径进行，不满足时，沿另一条路径进行。这种机制简单明了，但在现代处理器上，会非常的低效率。为什么呢？可以想象，如果一定要彻底执行完一条指令之后才开始新的一条指令，那机器的性能没有被最大程度地发挥。因此 CPU 都是依靠流水线（pipeline）进行操作的。例如一条指令需要ABCDE五个操作，在执行完这一条指令的A操作之后，下一条指令的A操作同时被加载进来开始执行，这样子效率会很高。</p>
<p>当机器遇到条件跳转的时候，机器<strong>不能确定是否会进行跳转</strong>。处理器采用非常精密的<strong>分支预测逻辑</strong>来预测每一条条件跳转指令到底会不会执行。只要猜测还算可靠（现代处理器要求对条件跳转的预测准确度在百分之九十以上），那么流水线模型会运行得很好。一旦错误预测了一个条件跳转指令，那么意味着处理器要丢掉它为该跳转指令后所有指令已经做的工作，去一个新的，正确的跳转位置开始填充流水线。这意味着一个错误的预测会带来严重的惩罚——大约20~40个时钟周期的浪费。</p>
<p>处理器支持<strong>条件传送</strong>（condition move），这与条件跳转不同。后者改变的是控制流，而前者传递的是数据流。其实条件传送就是我们熟悉的三目运算符：<code>?:</code>。例如上面的返回差值绝对值的代码的条件传送版本就是：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> absdiff(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">result</span>;</span><br><span class="line">    <span class="built_in">result</span> = x &lt; y ? y - x : x - y;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之等价的，能体现对应的汇编代码的原理的goto版本：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmovdiff</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t1 = y - x;</span><br><span class="line">    <span class="type">int</span> t2 = x - y;</span><br><span class="line">    <span class="type">int</span> test = x &lt; y;</span><br><span class="line">    <span class="keyword">if</span>(test) t2 = t1;</span><br><span class="line">    <span class="keyword">return</span> t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C语言中的条件传送通用形式模板是这样的：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vt</span> <span class="operator">=</span> then-statement</span><br><span class="line"><span class="attribute">v</span> <span class="operator">=</span> else-statement</span><br><span class="line"><span class="attribute">t</span> <span class="operator">=</span> text-expr</span><br><span class="line">if(t) v <span class="operator">=</span> vt<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到：执行条件传送时，无需预测测试结果，而是把两个分支的运算都完成。处理器只是读取值，然后检查条件码，然后要么更新目标寄存器，要么保持不变。这会使得工作效率变高，因为它规避了预测错误带来的惩罚。</p>
<p>也不是所有的条件表达式都适合用条件传送的。如果两个表达式中有任意一个可能产生错误或者副作用，就会导致非法的行为，例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">readpointer</span><span class="params">(<span class="type">int</span> *xp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (xp ? *xp : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看似乎没什么问题：如果指针为空，则返回0，否则返回指针指向的整数。但其实这个实现是错误的。因为条件传送对指针 xp 的引用是一定会发生的，如果 xp 是一个空指针，会导致一个间接引用空指针的错误。</p>
<p>条件传送也不会总是改进效率。如果两个表达式需要做大量的计算，那么当对应的条件不满足时，所做的工作就白费了。编译器必须权衡条件传送多做的计算，和条件分支预测错误惩罚之间的相对性能。</p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>C语言提供多种循环结构，for、while 和 do while。但看到这里大家也明白，汇编里没有相应的高级抽象指令，而是通过用测试、条件码、跳转组合起来，形成循环的效果。</p>
<h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">do</span> <span class="keyword">while</span> 的 C 语言代码：计算阶乘</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact_dowhile(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">result</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">result</span> *= n;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等价的goto版本：</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact_dowhile_goto(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">result</span> = <span class="number">1</span>;</span><br><span class="line">loop:</span><br><span class="line">    <span class="built_in">result</span> *= n;</span><br><span class="line">    n--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)goto loop;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的汇编代码是：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">    movl    <span class="number">8</span>(%ebp), %edx   <span class="comment"># 获得变量n</span></span><br><span class="line">    movl    $1, %eax        <span class="comment"># int result = 1；</span></span><br><span class="line"> .L2:</span><br><span class="line">    imull   %edx, %eax      <span class="comment"># result *= n;</span></span><br><span class="line">    subl    $1, %edx        <span class="comment"># n--;</span></span><br><span class="line">    cmpl    $1, %edx        </span><br><span class="line">    jg      .L2             <span class="comment"># if(n&gt;1) loop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># return</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>变量</th>
<th>初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td>%eax</td>
<td>result</td>
<td>1</td>
</tr>
<tr>
<td>%edx</td>
<td>n</td>
<td>n</td>
</tr>
</tbody>
</table>
<p>有的时候，确定哪些寄存器放的是什么值，会很有挑战性，特别是在循环代码中。看汇编代码时，理解他们的关系，关键是找到程序值和寄存器的映射关系。编译器常常试图将多个程序值映射到同一个寄存器上，最小化寄存器的使用率。</p>
<p>do-while循环的通用结构是：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">//C语言代码</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">Body</span></span><br><span class="line">	<span class="keyword">while</span> (Test);</span><br><span class="line"></span><br><span class="line">//<span class="keyword">goto</span>版本</span><br><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">	<span class="keyword">Body</span></span><br><span class="line">	<span class="keyword">if</span> (Test)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">loop</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while循环的通用结构是：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">// C 语言 <span class="keyword">While</span></span><br><span class="line"><span class="keyword">while</span> (Test)</span><br><span class="line">	<span class="keyword">Body</span></span><br><span class="line"></span><br><span class="line">// <span class="keyword">goto</span> 版本</span><br><span class="line">    t = test-expr</span><br><span class="line">    <span class="keyword">if</span>(!t)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">    <span class="keyword">Body</span></span><br><span class="line">    t = test-expr</span><br><span class="line">    <span class="keyword">if</span>(t) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>while 与 do-while 最大的区别是它先对 test-expr 求值，所以在第一次执行循环主体 Body 之前，循环就有可能终止。而 do-while 是一定会执行至少一次循环主体的。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言的for</span></span><br><span class="line"><span class="keyword">for</span> (Init; <span class="keyword">Test</span>; <span class="keyword">Update</span>)</span><br><span class="line">	Body</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 先转换到while</span></span><br><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">Test</span>) &#123;</span><br><span class="line">	Body</span><br><span class="line">	<span class="keyword">Update</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成do-while</span></span><br><span class="line">Init;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">Test</span>)</span><br><span class="line">    goto done;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    Body</span><br><span class="line">    <span class="keyword">Update</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="keyword">Test</span>);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line"><span class="comment">//再转换到goto代码</span></span><br><span class="line">    Init;</span><br><span class="line">    t = <span class="keyword">Test</span>;</span><br><span class="line">    <span class="keyword">if</span>(!t)</span><br><span class="line">        goto done;</span><br><span class="line">loop:</span><br><span class="line">    Body;</span><br><span class="line">    <span class="keyword">Update</span>;</span><br><span class="line">    t = <span class="keyword">Test</span>;</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">        goto loop;</span><br><span class="line"></span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><p>switch 语句可以根据一个整数索引值进行多重分支（multi-way branching）。处理具有多种预测可能的分支时，这种语句特别有用，而且提高了C语言代码的可读性。</p>
<p>通过使用一种数据结构，叫做<strong>跳转表</strong>（jump table），使得实现 switch 十分的高效。跳转表是一个数组，表项 i 是一个代码段地址，代码段是当索引值等于 i 时程序应采取的动作。开关索引值就是用来执行一个跳转表内数组引用，来确定目标指令的情况。和用一组很长的 if-else 嵌套不同，使用跳转表的优点是执行开关语句的时间和开关的数量无关。</p>
<p>下面通过一个具体的例子来讲解：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> switch_eg (<span class="type">int</span> x, <span class="type">int</span> n)&#123;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">result</span> = x;</span><br><span class="line"></span><br><span class="line">	switch (n) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">			<span class="built_in">result</span> *= <span class="number">13</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">			<span class="built_in">result</span> += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">			<span class="built_in">result</span> += <span class="number">11</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">104</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">106</span>:</span><br><span class="line">			<span class="built_in">result</span> *= <span class="built_in">result</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		default:</span><br><span class="line">			<span class="built_in">result</span> = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子包含了很多特殊情况：</p>
<ol>
<li>共享的条件：104 和 106 会执行相同的部分。</li>
<li>没有break：102 会继续执行 103 的部分。这个要十分小心，一般Switch出现错误的源头就是忘了break。如果确定要这么用，最好写上注释。</li>
<li>缺失条件：101 和 105</li>
</ol>
<p>具体怎么办呢？使用跳转表。（你会发现<strong>表</strong>的解决方式在很多地方都有用：虚函数，继承，内存管理，动态规划等等。）下面的汇编代码就是跳转表：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">.section</span>    <span class="string">.rodata</span>         <span class="comment"># 只读数据</span></span><br><span class="line">    <span class="string">.align</span> 4                <span class="comment"># 对齐要求</span></span><br><span class="line"><span class="string">.L7</span>:</span><br><span class="line">    <span class="string">.long</span>   <span class="string">.L3</span>             <span class="comment"># x = 0 时选择，L3里操作是 result *= 13; goto done;</span></span><br><span class="line">    <span class="string">.long</span>   <span class="string">.L2</span>             <span class="comment"># x = 1 时选择，因为101是缺失条件，直接 goto default;</span></span><br><span class="line">    <span class="string">.long</span>   <span class="string">.L4</span>             <span class="comment"># x = 2 时选择，result += 10; 然后顺序执行，没有break</span></span><br><span class="line">    <span class="string">.long</span>   <span class="string">.L5</span>             <span class="comment"># x = 3 时选择，result += 11; goto done;</span></span><br><span class="line">    <span class="string">.long</span>   <span class="string">.L6</span>             <span class="comment"># x = 4 时选择，result *= result; goto done;</span></span><br><span class="line">    <span class="string">.long</span>   <span class="string">.L2</span>             <span class="comment"># x = 5 时选择，因为105是缺失条件，直接 goto default;</span></span><br><span class="line">    <span class="string">.long</span>   <span class="string">.L6</span>             <span class="comment"># x = 6 时选择，result *= result;  goto done;注意到104和106执行相同的部分</span></span><br></pre></td></tr></table></figure>
<p>对 switch 语句的处理是：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">movl    <span class="number">8</span>(%epb), %edx       <span class="comment"># 参数 x</span></span><br><span class="line">movl    <span class="number">12</span>(%epb), %eax      <span class="comment"># 参数 n</span></span><br><span class="line"></span><br><span class="line">subl    $10<span class="number">0</span>, %eax          <span class="comment"># n -= 100;</span></span><br><span class="line">cmpl    $6, %eax            </span><br><span class="line">ja      .L2                 <span class="comment"># if(n&gt;6) goto default;</span></span><br><span class="line">jmp     *.L7(,%eax,<span class="number">4</span>)       <span class="comment"># else goto *jumptable[index];</span></span><br></pre></td></tr></table></figure>
<p>C语言的原始代码是 100、102~106 这样的值，针对这些值编译器可以选择做出优化——编译器将 n 的值减去 100，把取值范围移动到 0~6 之间。根据 switch 的参数 n，决定是进入跳转表还是 default 分支。jmp 指令的操作数有前缀 * ，代表这是一个间接跳转，操作数指定一个存储器位置。跳转位置是跳转表里面保存的一个地址，由寄存器 <code>%eax</code> 给出的索引作为引导。（在数据结构部分可以知道如何将数组引用翻译成机器代码）</p>
<h1 id="编译C语言代码时注意事项"><a href="#编译C语言代码时注意事项" class="headerlink" title="编译C语言代码时注意事项"></a>编译C语言代码时注意事项</h1><p>采取比较低的优化等级，这样子才能看到一些特性，不至于因为被编译器优化而看不到我们想要的结果。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/6-C%20compling.png" alt=""></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期 ICS课程网站</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】7. 汇编语言——过程调用</title>
    <url>/2017/06/26/csapp-7-Machine-Prog-Procedure/</url>
    <content><![CDATA[<p>一个过程调用包括将数据（以参数和返回值的形式）与控制从代码的一部分传递到另一部分。除此之外，在进入时为过程的局部变量分配空间，在退出的时候释放这些空间。数据传递、局部变量的分配和释放通过操纵程序栈来实现。栈作为一种能够实现先进后出、后进先出的数据结构，非常适合用于实现函数调用以及返回的机制。</p>
<p>在过程调用中主要涉及三个重要的方面：</p>
<ol>
<li>传递控制：包括如何开始执行过程代码，以及如何返回到开始的地方</li>
<li>传递数据：包括过程需要的参数以及过程的返回值</li>
<li>内存管理：如何在过程执行的时候分配内存，以及在返回之后释放内存</li>
</ol>
<p><img src="http://osax8w13y.bkt.clouddn.com/7-1.png" alt=""></p>
<h1 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h1><p>程序栈其实就是一块内存区域，这个区域内的数据满足先进后出的原则。从栈底到栈顶，地址由高变低。所以新加入栈的以及新开辟的空间的地址都是较小的。有两个特殊寄存器是与栈有关的。寄存器 <code>%ebp</code> 叫做<strong>帧指针</strong>，保存当前栈帧开始的位置。寄存器 <code>%esp</code> 叫做<strong>栈指针</strong>，始终指向栈顶。栈帧（stack frame）是指为单个过程分配的那一小部分栈。大多数信息访问都是相对于帧指针访问的。以前经常看到这类代码：<code>movl  8(%ebp), %eax</code> 意思就是将存放在比帧指针地址大8的变量移动到寄存器里。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/7-stack.png" alt=""></p>
<p>假设过程 P（调用者）调用了过程 Q（被调用者），则 Q 的参数存放在 P 的栈帧中。调用 Q 时，P 的<strong>返回地址</strong>被压入栈中，形成 P 的栈帧的末尾。返回地址就是当过程 Q 返回时应该继续执行的地方。Q 的栈帧紧跟着被保存的帧指针副本开始，后面是其他寄存器的值。</p>
<p>栈中会存放<strong>局部变量</strong>。有下面三个原因：</p>
<ol>
<li>不是所有的变量都能放到寄存器中的，没有那么多寄存器。</li>
<li>有些局部变量是数组，或者结构体。</li>
<li>有些时候需要对某些变量使用 <code>&amp;</code> 运算符，获得其地址，因此要将其放在栈中。寄存器变量是没有地址的。</li>
</ol>
<p>栈向低地址方向增长。可以利用指令<code>pushl</code>将数据存入栈，利用<code>popl</code>将指令从栈中取出。由于栈指针<code>%esp</code> 始终指向栈顶，所以可以通过减小栈指针的值来分配空间，增加栈指针来释放空间。</p>
<h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><p>下面是有关过程调用和返回的指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>call <em>Label</em></td>
<td>过程调用</td>
</tr>
<tr>
<td>call <em>Operand</em></td>
<td>过程调用</td>
</tr>
<tr>
<td>leave</td>
<td>为返回准备栈</td>
</tr>
<tr>
<td>ret</td>
<td>返回</td>
</tr>
</tbody>
</table>
<p>call 指令的效果是将返回地址压入栈中（也就是保存返回地址），然后跳转到被调用过程的起始处。返回地址是在程序中紧跟在 call 后面的那条指令的地址。这样当被调用过程返回时，执行从此（call 指令的下一条指令）继续。</p>
<p>ret 指令从栈中弹出返回地址，然后跳转到返回地址的位置。</p>
<h2 id="寄存器共享"><a href="#寄存器共享" class="headerlink" title="寄存器共享"></a>寄存器共享</h2><p>寄存器是在过程调用中唯一能被所有过程共享的资源。因此我们必须保证被调用者不会覆盖某个调用者稍后会使用的寄存器的值。根据惯例，寄存器<code>%eax</code>、<code>%edx</code>、<code>%ecx</code>被划分为<strong>调用者保存寄存器</strong>。当过程 P 调用过程 Q 时，Q 可以覆盖这些寄存器的数据，而不会破坏 P 所需的数据。寄存器<code>%ebx</code>、<code>%esi</code>、<code>%edi</code>被划分为<strong>被调用者保存寄存器</strong>，Q 在覆盖这些寄存器的值之前，必须将其压入栈中，然后在返回前恢复他们。看下面的例子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">P(<span class="params">int</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> y = x<span class="operator"> * </span>x;   <span class="comment">//变量 y 是在调用前计算的</span></span><br><span class="line">    <span class="built_in">int</span> z = <span class="constructor">Q(<span class="params">y</span>)</span>;</span><br><span class="line">    return y + z;    <span class="comment">//要保证变量 y 在 Q 返回后还能使用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>基于调用者保存：过程 P 在调用 Q 之前，将 y 的值保存在自己的栈帧中；当 Q 返回时，过程 P 由于自己保存了这个值，就可以从自己的栈中取出来。</p>
</li>
<li><p>基于被调用者保存：过程 Q 将值 y 保存在被调用者保存寄存器。如果过程 Q 和其他任何 Q 调用的过程，想使用保存 y 值的被调用者保护寄存器，它必须将这个寄存器的值存放到栈帧中，然后在返回前恢复 y 的值。</p>
</li>
</ul>
<p>这两种方案都是可行的。</p>
<h2 id="过程实例"><a href="#过程实例" class="headerlink" title="过程实例"></a>过程实例</h2><p>考虑下面给出的C语言代码。函数 caller 中包括一个对函数 swap_add 的调用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> swap<span class="constructor">_add(<span class="params">int</span> <span class="operator">*</span><span class="params">xp</span>, <span class="params">int</span> <span class="operator">*</span><span class="params">yp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x = *xp;</span><br><span class="line">    <span class="built_in">int</span> y = *yp;</span><br><span class="line"></span><br><span class="line">    *xp = y;</span><br><span class="line">    *yp = x;</span><br><span class="line"></span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> caller<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> arg1 = <span class="number">534</span>;</span><br><span class="line">    <span class="built_in">int</span> arg2 = <span class="number">1057</span>;<span class="comment">//局部变量，以及作为参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> sum = swap<span class="constructor">_add(&amp;<span class="params">arg1</span>, &amp;<span class="params">arg2</span>)</span>;</span><br><span class="line">    <span class="built_in">int</span> diff = arg1 - arg2;</span><br><span class="line"></span><br><span class="line">    return sum<span class="operator"> * </span>diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出 caller 和 swap_add 的栈帧。左图是还未执行到 <code>int sum = swap_add(&amp;arg1, &amp;arg2);</code>语句之前。可以看到因为要对局部变量取地址，所以要把局部变量放到栈中。栈指针一直指在栈顶。帧指针目前指在最上面，代表过程 caller 的栈帧开始的位置。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/7-frame.png" alt=""></p>
<p>调用了 <code>swap_add</code> 之后，栈成了左边的样子。因为调用函数会使用一个 call 指令。这个指令会压入一个返回地址。紧接着开始了 <code>swap_add</code> 的栈帧。此时 <code>%ebp</code>被更新。在被调用者函数内，使用<code>12(%ebp)</code> 和 <code>8(%ebp)</code>就可以取到两个参数。</p>
<p>下面看一下汇编代码：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">caller</span>:</span><br><span class="line">    pushl   %ebp                <span class="comment"># 保存旧的 %ebp 的一个副本</span></span><br><span class="line">    movl    %esp, %ebp          <span class="comment"># 设置新的栈顶指针，到栈顶</span></span><br><span class="line">    subl    $24, %esp           <span class="comment"># 栈指针减去24，即分配24个字节的空间</span></span><br><span class="line">    movl    $534, -<span class="number">4</span>(%ebp)      <span class="comment"># int arg1 = 534;</span></span><br><span class="line">    movl    $1057, -<span class="number">8</span>(%ebp)     <span class="comment"># int arg2 = 1057; 这两个局部变量都保存在栈上</span></span><br><span class="line">    leal    -<span class="number">8</span>(%ebp), %eax      <span class="comment"># 取地址 &amp;arg2，放到寄存器中</span></span><br><span class="line">    movl    %eax, <span class="number">4</span>(%esp)       <span class="comment"># 保存到栈上</span></span><br><span class="line">    leal    -<span class="number">4</span>(%ebp), %eax      <span class="comment"># </span></span><br><span class="line">    movl    %eax, (%esp)        <span class="comment"># 同上</span></span><br><span class="line">    call    swap_add            <span class="comment"># 参数都齐全了，可以调用函数了</span></span><br><span class="line"></span><br><span class="line">swap_add:</span><br><span class="line">    <span class="keyword">push</span>    %ebp                <span class="comment"># %ebp移动了，栈发生了改变</span></span><br><span class="line">    movl    %esp, %ebp          <span class="comment"># 这两步同 caller，是过程调用的“建立部分”</span></span><br><span class="line">    <span class="keyword">push</span>    %ebx                <span class="comment"># 这是一个被调用者保存寄存器，将旧值压入栈中，作为栈帧的一部分</span></span><br><span class="line"></span><br><span class="line">                                <span class="comment"># 从这里开始才是真正的C语言代码体现的 swap_add 内容</span></span><br><span class="line">    movl    <span class="number">8</span>(%ebp), %edx       <span class="comment"># 获得参数1，放到寄存器中</span></span><br><span class="line">    movl    <span class="number">12</span>(%ebp), %ecx      <span class="comment"># 获得参数2，放到寄存器中</span></span><br><span class="line">    movl    (%edx), %ebx        <span class="comment"># int x = *xp;</span></span><br><span class="line">    movl    (%ecx), %eax        <span class="comment"># int y = *yp;</span></span><br><span class="line">    movl    %eax, (%edx)        <span class="comment"># *xp = y;</span></span><br><span class="line">    movl    %ebx, (%ecx)        <span class="comment"># *yp = x;</span></span><br><span class="line">    addl    %ebx, %eax          <span class="comment"># 计算 x + y，结果放在%eax中，所以会返回%eax中的值</span></span><br><span class="line"></span><br><span class="line">    popl    %ebx                <span class="comment"># 这是被调用过程的“结束过程”</span></span><br><span class="line">    <span class="keyword">pop</span>     %ebp                <span class="comment"># 恢复保护寄存器，弹出栈帧指针</span></span><br><span class="line">    ret                         <span class="comment"># 此时栈顶是返回地址，ret指令就弹出这个地址，然后跳转到这个地址</span></span><br><span class="line"></span><br><span class="line">                                <span class="comment"># caller 剩余的代码会紧跟在后面</span></span><br><span class="line">    movl -<span class="number">4</span>(%ebp), %edx         <span class="comment"># 此时 %ebp 指的是 caller 自己的 %ebp</span></span><br><span class="line">    subl -<span class="number">8</span>(%ebp), %edx         <span class="comment"># int diff = arg1 - arg2;</span></span><br><span class="line">    imull %edx, %eax            <span class="comment"># 计算 sum * diff，%eax是存放 swap_add 返回值的</span></span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>说句题外话，看到这个 swap 函数之后，也能解答一个初学者的问题：为什么下面这个 swap 函数不能交换参数的值？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> swap(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">temp</span>;</span><br><span class="line">    <span class="keyword">temp</span> = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = <span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swap 函数被调用时，用寄存器存参数 a 与 b，作为<strong>临时存储</strong>，然后对寄存器内的两个值做了一通操作，并没有<strong>影响到存储器中 a 与 b 的值</strong>。</p>
<p>用 <code>leave</code> 指令可以使栈做好返回的准备。其作用就是将帧指针移到栈顶然后抛出。</p>
<p>分配给 caller 的栈帧有24个字节，8个用于局部变量，8个用于传参，还有8个字节未使用。这主要是满足 x86 的一个编程指导方针——对齐（alignment）的要求：一个函数使用的栈空间必须是 16 字节的整数倍，包括一开始保存的 %ebp 的 4 字节和返回值的 4 字节，所以共分配了 24 个字节。</p>
<p>从这个例子我们可以看到，编译器根据简单的惯例来产生管理栈结构的代码。栈帧中需要包含：</p>
<ul>
<li>帧指针副本，标识自己的栈帧从哪里开始</li>
<li>局部变量（如果需要）</li>
<li>临时空间（如果需要）</li>
<li>调用其他函数之后，压入返回信息</li>
</ul>
<p>可以用相对于 %ebp 的偏移量来访问变量和参数。可以用通过加减栈顶指针来释放或分配空间。在返回时，必须将栈恢复到调用前的状态，恢复所有的被调用者保护寄存器和 %ebp，重置 %esp。为了让程序能正确执行，让所有过程遵循一个统一一致的惯例是很重要的。</p>
<p>一个调用过程（call 指令之后）的汇编代码包括三个部分：</p>
<ol>
<li>建立部分：压入帧指针，移动栈指针，压入需要保存的寄存器的值。</li>
<li>主体部分：函数的功能部分</li>
<li>结束部分：恢复需要保存的值，弹出帧指针，返回。</li>
</ol>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>有了前面的的基础，要理解递归就简单很多了。为什么过程能调用自己本身呢？因为每个调用在栈中都有自己的私有空间。多个未完成的调用，他们局部变量，之间<strong>不会相互影响</strong>。栈的原则很自然地提供了一个策略：过程被调用时分配局部存储，返回时释放。</p>
<p>上一个课后题的例子：</p>
<p>一个具有通用结构的C函数如下：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int rfun(unsigned x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">??</span><span class="string">?)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">??</span>? ;</span><br><span class="line">    unsigned nx = <span class="string">??</span>? ;</span><br><span class="line">    int rv = rfun(nx);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">??</span><span class="string">?;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>给出对应的汇编代码，<strong>其中省略了建立和完成代码</strong>，请通过汇编代码分析：</p>
<ol>
<li>被调用者保护寄存器 %ebx 存的是什么？</li>
<li>C语言代码中的问号应该填什么？</li>
<li>描述C语言代码的作用。</li>
</ol>
<p>汇编代码如下：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">    movl    <span class="number">8</span>(%ebp), %ebx           <span class="comment"># 开头第一句一般是取参数。</span></span><br><span class="line">    movl    $0, %eax                <span class="comment"># int y = 0; （变量名随便取的）</span></span><br><span class="line">    testl   %ebx, %ebx              <span class="comment"># 测试 x</span></span><br><span class="line">    je      .L3                     <span class="comment"># if(x==0) return;</span></span><br><span class="line">    movl    %ebx, %eax              <span class="comment"># else &#123; y = x;</span></span><br><span class="line">    shrl    %eax                    <span class="comment">#       y &gt;&gt;= 1;&#125;</span></span><br><span class="line">    movl    %eax, (%esp)            <span class="comment"># 压入栈中，很明显，是为了下一次调用使用</span></span><br><span class="line">    call    rfun                    <span class="comment"># 递归调用</span></span><br><span class="line">                                <span class="comment"># 别忘了 call 会压入返回地址，然后跳转</span></span><br><span class="line">    movl    %ebx, %edx              </span><br><span class="line">    andl    $1, %edx                <span class="comment"># %edx 中存的值是 (x &amp; 1)</span></span><br><span class="line">    leal    (%edx, %eax), %eax      <span class="comment"># 寄存器是公用的资源。</span></span><br><span class="line">                                    <span class="comment"># y = (x &gt;&gt; 1) + ( x &amp; 1)    </span></span><br><span class="line">.L3:</span><br></pre></td></tr></table></figure>
<p>经过上面的分析可以得出解答：</p>
<ul>
<li><code>%ebx</code> 存放的是参数 x 的值。</li>
<li>我们在汇编中分析出来的一个新变量 <code>y</code> 应该就是C语言代码中的 <code>nx</code>。</li>
<li>C语言代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfun</span><span class="params">(<span class="type">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> nx = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rv = <span class="built_in">rfun</span>(nx);</span><br><span class="line">    <span class="keyword">return</span> rv + (x &amp; <span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的作用是：递归地计算一个无符号数的每一位上的数字之和。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/7-2.png" alt=""></p>
<p>对于递归，目前我觉得有一个很恰当的比喻：</p>
<blockquote>
<p>我们使用词典查词，本身就是递归，为了解释一个词，需要用到更多词。当你查一个词，发现要解释这个词的一句话里有一个词你不懂，于是你开始查这第二个词。可惜的是，查第二个词的时候仍然有不懂的词，于是查第三个词……这样一直查下去，知道有一个词的解释你完全能看懂，那么递归走到了尽头，开始返回，然后你按照查词顺序的倒序逐个看明白了之前你所查的每个词的意思。你最开始查的那个词，是最后才知道其意思的。</p>
</blockquote>
<p>所以对于理解递归，很重要的一点是要理解递归什么时候触及到边界，开始返回了。</p>
<blockquote>
<p>古之欲明明德于天下者，先治其国；欲治其国者，先齐其家；欲齐其家者，先修其身；欲修其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知，致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期 ICS课程网站</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】8. 汇编语言——数据存储</title>
    <url>/2017/06/27/csapp-8-Machine-Data-Storage/</url>
    <content><![CDATA[<p>下面介绍一些C语言中常见的特殊的数据存储方式，以及它们在汇编语言中是如何表示的。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种将标量数据聚集成更大数据类型的方式。实现数组的方式其实十分简单，也非常容易翻译成机器代码。C语言的一个特点是可以产生指向数组元素的指针，然后可以对这些指针进行运算。</p>
<p>数组的基本原则如下：</p>
<p>对于数组的声明：<code>T A[N];</code>，这句语句有两个效果。首先，它在存储器中分配一个 <code>L * N</code> 个字节的<strong>连续区域</strong>，L 是数据类型 T 单位为字节的大小，用 $ X_A $ 来表示起始位置。其次，它引入标识符 A ，可以用 A 作为<strong>指向数组开头的指针</strong>，指针的值就是$ X_A $。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/8-1.png" alt=""></p>
<p>汇编代码：假设 E 是一个 int 型数组，我们想计算 <code>E[i]</code>，数组的地址存储在寄存器 <code>%edx</code> 中， 下标 <code>i</code> 存放在寄存器 <code>%ecx</code> 中。下列指令会计算地址 $ X_E + 4i $，读取这个存储器的值，然后将结果放到寄存器 %eax 中。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">movl    (<span class="built_in">%edx</span>, <span class="built_in">%ecx</span>, <span class="number">4</span>), <span class="built_in">%eax</span></span><br></pre></td></tr></table></figure>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>C语言允许对指针进行运算，计算的过程中，值会根据该指针引用的类型的大小进行伸缩（指针类型的作用）。下面这些例子给出一些关于数组 E 的表达式，以及每个表达式的汇编代码实现。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>结果类型</th>
<th>值</th>
<th>汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>int *</td>
<td>$ X_E $</td>
<td>movl %edx, %eax</td>
</tr>
<tr>
<td>E[0]</td>
<td>int</td>
<td>$ M[X_E] $</td>
<td>movl (%edx), %eax</td>
</tr>
<tr>
<td>E[i]</td>
<td>int</td>
<td>$ M[X_E + 4i] $</td>
<td>movl (%edx, %ecx, 4), %eax</td>
</tr>
<tr>
<td>&amp;E[2]</td>
<td>int *</td>
<td>$ X_E + 8 $</td>
<td>leal 8(%edx), %eax</td>
</tr>
<tr>
<td>E+i-1</td>
<td>int *</td>
<td>$ X_E + 4i - 4 $</td>
<td>leal -4(%edx, %ecx, 4), %eax</td>
</tr>
<tr>
<td>*(E+i-3)</td>
<td>int</td>
<td>$ M[X_E + 4i - 12] $</td>
<td>movl -12(%edx, %ecx, 4), %eax</td>
</tr>
<tr>
<td>&amp;E[i]-E</td>
<td>int</td>
<td>i</td>
<td>movl %ecx, %eax</td>
</tr>
</tbody>
</table>
<h2 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h2><p>当我们创建数组的数组时，数组的分配和引用的一般原则也是成立的。例如有声明：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">int <span class="selector-tag">A</span><span class="selector-attr">[5]</span><span class="selector-attr">[3]</span>;</span><br></pre></td></tr></table></figure>
<p>则相当于下面的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">row3_t</span>[<span class="number">3</span>];</span><br><span class="line">row3_5 A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>A 数组是一个包含 5 个元素的数组，每一个元素是一个含有 3 个整数的数组。也可以看成是一个 5 行 3 列的二维数组。用 <code>A[0][0]</code> 到 <code>A[4][2]</code> 来引用。二维数组是以行优先的顺序来排列的。第 0 行的所有元素，可以写作 <code>A[0]</code>。 </p>
<p>对于数组 <code>T[R][C]</code>; 来说，他的元素 <code>T[i][j]</code> 的存储器地址为：$  X_D + L(C * i + j)  $ </p>
<p><img src="http://osax8w13y.bkt.clouddn.com/8-2.png" alt=""></p>
<h1 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h1><p>C语言提供了两种结合不同的对象来创建数据类型的机制：结构（struct），将多个对象集合到一个单位中；联合（union），允许用几种不同的类型引用一个对象。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>C语言的 struct 创建一种数据类型，将可能不同的数据类型的对象聚合到一个对象中。结构体中各个组成部分由名字来引用。类似于数组的实现，结构体的所有组成部分都存放在存储器中的一段<strong>连续</strong>的区域内，指向结构体的指针就是结构体第一个字节的地址。编译器维护每个结构类型的信息，指示每个字段（field）的字节偏移。以这些偏移作为存储器引用中指令的位移，从而产生对结构体元素的引用。</p>
<p>假设有下面的结构体声明：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">rec</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="built_in">int</span> j;</span><br><span class="line">    <span class="built_in">int</span> a[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么在内存中的排列是：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/8-3.png" alt=""></p>
<p>为了访问字段，编译器产生的代码要将结构体的地址加上适当的偏移。例如指向结构体 <code>rec</code> 的指针变量 <code>r</code> 存放在寄存器 <code>%edx</code> 中，下面的代码将元素 <code>r-&gt;i</code> 复制到 <code>r-&gt;j</code></p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">movl    (%edx), %eax        <span class="comment"># 将 r-&gt;i 放到寄存器中</span></span><br><span class="line">movl    %eax, <span class="number">4</span>(%edx)       <span class="comment"># 将寄存器的值复制到 r-&gt;j 中</span></span><br></pre></td></tr></table></figure>
<p>可以看到，为了访问字段 j，代码将 r 的地址加上偏移量 4。</p>
<h2 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h2><p>联合体提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用同一个对象。联合体的语法和结构体一样，但语义差别很大——联合体<strong>用不同的字段来引用相同的内存</strong>。</p>
<p>考虑下面的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一台 IA32 Linux 机器上编译时，字段的偏移量、数据类型的完整大小如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>偏移量：c</th>
<th>i</th>
<th>v</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>0</td>
<td>4</td>
<td>12</td>
<td>20</td>
</tr>
<tr>
<td>U</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>一个联合体的总的大小总是等于它的最大字段的大小。对于类型结构体 U 的指针 p，<code>p-&gt;c</code>、<code>p-&gt;i[0]</code>、<code>p-&gt;v</code> 都是引用数据结构的<strong>起始位置</strong>。</p>
<p>在一些上下文中，联合体十分有用，但是它也引起一些讨厌的错误，因为它绕过了C语言类型系统提供的安全措施。</p>
<p>举一个联合体应用的具体例子：现在我们要设计一个特殊的二叉树的数据结构，它有一个特点：每个<strong>叶子</strong>节点有一个 double 类型的值。每个<strong>内部</strong>节点有左右儿子的指针，但是没有数据。如果声明如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    struct</span> <span class="keyword">Node</span> <span class="title">* left</span>;</span><br><span class="line">    struct <span class="keyword">Node</span> <span class="title">* right</span>;</span><br><span class="line">    double data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果用上述结构体，那么每个节点都需要 16 个字节。然而，叶子结点是没有左右儿子的，内部节点是用不着 double data 的，所以每个类型的节点都要浪费一半的内存。如果我们这样声明：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">union <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        union <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">        union <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">    &#125;internal;</span><br><span class="line">    double data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么每个节点就只需要 8 个字节。如果 n 是一个指向 union Node 的指针，那么可以用 <code>n-&gt;data</code> 来表示叶子结点的数据，<code>n-&gt;internal.left</code> 和 <code>n-&gt;internal.right</code>来表示内部节点的左右儿子。</p>
<p>然而这样表示，我们是没办法确定一个给定的节点到底是叶子节点，还是内部节点。有一个方法，是引入一个枚举类型，定义这个联合中可能的不同选择，再用一个结构体将两者包含起来：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">typedef enum &#123;LEAF, INTERNAL&#125; nodetype;</span><br><span class="line"></span><br><span class="line">struct Node_T&#123;</span><br><span class="line">    nodetype <span class="keyword">type</span>;</span><br><span class="line">    union <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">        struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            union <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">            union <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">        &#125;internal;</span><br><span class="line">        double data;</span><br><span class="line">    &#125;<span class="literal">inf</span>o;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>可以发现，这样的联合体只需要12个字节。</p>
<p>相对于编码带来的麻烦问题，其实使用联合体带来的节省是很小的。除非说对于有较多字段的数据结构，结构体带来的节省就会更加吸引人。</p>
<h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct S&#123;</span><br><span class="line">    char c<span class="comment">;</span></span><br><span class="line">    int i[<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    double v<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型</th>
<th>偏移量：c</th>
<th>i</th>
<th>v</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>0</td>
<td>4</td>
<td>12</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>为什么 i 的偏移量不是 1 呢？char 类型的大小不是只有 1 个字节吗？</p>
<p>要解答这个问题，我们必须对数据对齐有一定的了解。计算机系统对于基本的数据类型的合法地址做出了一定的限制，要求地址必须是某个值的倍数（例如4、8、16）。这种<strong>对齐限制</strong>简化了处理器系统和存储器系统之间的接口硬件设计。</p>
<p>对于上面那个结构体，画出来的图是这样的：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/8-4.png" alt=""></p>
<p>它不可能满足对齐要求。假设我们的对齐要求是 4 字节对齐的话，编译器会在字段 c 之后插入一个 3 字节的间隙（用灰色表示），对齐后的结构体如下：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/8-5.png" alt=""></p>
<p>可以看到后面的字段的偏移量发生了改变，整个结构体的大小变成了 20 字节。</p>
<p>另外，编译器结构的末尾可能为了满足对齐要求而需要一些填充。这样，<strong>结构体数组</strong>的每个元素都能满足对齐要求。例如将上述结构体稍作修改：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct S&#123;</span><br><span class="line">    int i[<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    double v<span class="comment">;</span></span><br><span class="line">    char c<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>那么编译器为了使结构体数组的每个元素都满足对齐要求，不得不在末尾插入多余的 3 个字节。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/8-6.png" alt=""></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/8-7.png" alt=""></p>
<p>编译这段代码，可以发现，这个编译器的对齐要求应该是为 8 的倍数。了解到对齐方式之后，我们在写结构体的时候，注意一下元素的排列顺序，可以更有效地利用内存</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期  ICS课程网站</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>【CSAPP笔记】9. 汇编语言——缓冲区溢出</title>
    <url>/2017/06/28/csapp-9-Machine-Prog-Buffer-overflow/</url>
    <content><![CDATA[<h1 id="x86-64-Linux-内存结构"><a href="#x86-64-Linux-内存结构" class="headerlink" title="x86-64 Linux 内存结构"></a>x86-64 Linux 内存结构</h1><p>先来看看一个程序在内存中是如何组织的。Linux 为每个<strong>进程</strong>维持了一段单独的虚拟地址空间。（进程是计算机科学中很深刻、很成功的一个概念。当我们在运行一个程序时，会得到一个假象，好像我们的程序是系统当中运行的唯一程序，独占存储器和处理器资源。）</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1.png" alt=""></p>
<ol>
<li>最上面是栈（stack），一般用来保存局部变量，有 8 MB 的大小限制，因此不建议在函数内开大数组，递归的效率低是因为容易栈溢出。栈的增长方向是向下的。</li>
<li>堆（heap），动态分配的内存会在这里处理，例如 <code>malloc</code>、<code>new</code>。堆是向上增长的。</li>
<li>data 区，静态存储区，存放全局变量，静态变量，常量等。</li>
<li>text 区和共享库，是可执行机器指令，是只读的。</li>
</ol>
<h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><p>通过对过程调用、以及数组怎么翻译成机器代码的学习，我们知道C语言对于数组的引用<strong>不进行任何边界检查</strong>，而且局部变量和状态信息（保护寄存器的值、返回地址）都存在栈中。当对数组进行越界的写操作时可能会破坏掉栈中原有的信息，导致严重的程序错误。一种特别常见的破坏状态称作<strong>缓冲区溢出</strong>（buffer overflow），段错误（segmentation fault）也是C语言初学者经常会犯的毛病。通常，在栈中分配一个数组，用这个数组保存一个字符串，只要字符串的长度超过了为数组分配的空间，就会出现缓冲区溢出。下面这个简单的实例就说明了这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">gets</span><span class="params">(<span class="type">char</span> *s)</span><span class="comment">//一个没有保护措施的 gets 函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> *dest = s;</span><br><span class="line">    <span class="type">int</span> gotchar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!= <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF)&#123;</span><br><span class="line">        *dest++ = c;</span><br><span class="line">        gtochar = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == EOF &amp;&amp; !gotchar)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];<span class="comment">//设置一个较小的缓冲区</span></span><br><span class="line">    <span class="built_in">gets</span>(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 input 中，故意将缓冲区设计的特别小，只有 8 个字节。任何超过 7 个字节的字符串都会导致写越界。检查 GCC 为 input 产生的汇编代码，看看栈是如何组织的：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">    pushl   %ebp                <span class="comment"># 保存帧指针</span></span><br><span class="line">    mov     %esp, %ebp          <span class="comment"># 更新栈指针位置</span></span><br><span class="line">    pushl   %ebx                <span class="comment"># 压入保护寄存器</span></span><br><span class="line">    subl    $2<span class="number">0</span>, %esp           <span class="comment"># 通过减法运算在栈上分配 20 个字节的空间</span></span><br><span class="line">    leal    -<span class="number">12</span>(%ebp), %ebx     <span class="comment"># 计算缓冲区开始的位置，是 %ebp - 12，存放到 %ebx 中</span></span><br><span class="line">    movl    %ebx, (%esp)        <span class="comment"># 将缓冲区开始的位置存到栈中（这是调用 gets 的参数）</span></span><br><span class="line">    call    gets                <span class="comment"># 调用 gets</span></span><br><span class="line"></span><br><span class="line">    movl    %ebx, (%esp)        <span class="comment"># 这是调用 puts 的参数</span></span><br><span class="line">    call    puts;               <span class="comment"># 调用 puts</span></span><br><span class="line"></span><br><span class="line">    addl    $2<span class="number">0</span>, %esp           <span class="comment"># 释放 20 个字节的空间</span></span><br><span class="line">    popl    %ebx;               <span class="comment"># 恢复保护寄存器</span></span><br><span class="line">    popl    %ebp;               <span class="comment"># 弹出帧指针</span></span><br><span class="line">    ret;                        <span class="comment"># 返回</span></span><br></pre></td></tr></table></figure>
<p>可以知道，在运行上面这个程序的时候，栈空间是长这样的：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/4.png" alt=""></p>
<p>gets 从标准输入中读入一行，在末尾加上 null 字符。但是输入只在遇到一个回车符号或文件末尾才停止，并没有加入缓冲区是否会溢出的判断。看栈空间，我们知道 buf 的空间只有 8 个字节，如果我们输入的字符串大于 7 个字节，就会写到我们不该写的地方。如果单看 C 语言，是看不出数组越界写的影响的，只有研究机器代码的程序才能有所体会。</p>
<table>
<thead>
<tr>
<th>输入的字符数量</th>
<th>栈哪一部分被破坏</th>
<th>后果</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 ~ 7</td>
<td>没有被破坏</td>
<td>没有被破坏</td>
</tr>
<tr>
<td>8 ~ 11</td>
<td>保存的 %ebx 的值</td>
<td>被保护寄存器不能正确的恢复，调用者不能依靠这个寄存器的正确性</td>
</tr>
<tr>
<td>12 ~ 15</td>
<td>保存的 %ebp 的值</td>
<td>帧指针被破坏，不能正确地通过帧指针的偏移来引用局部变量</td>
</tr>
<tr>
<td>16 ~ 19</td>
<td>返回地址</td>
<td>返回地址被破坏，运行到 ret 指令时程序会跳转到完全意想不到的地方</td>
</tr>
<tr>
<td>20 以上</td>
<td>破坏了调用者的栈帧</td>
<td>害己害人？</td>
</tr>
</tbody>
</table>
<p>可以看到，破坏是累积的，随着字符数量的增加，破坏的状态就越来越多。</p>
<p>缓冲区溢出有一个更加致命的用途，就是可以让程序执行它本不愿意执行的函数，这是一种常见的通过计算机网络攻击系统安全的做法。上面说到，如果缓冲区溢出覆盖到了返回地址，那么程序在返回的时候会跳到一个完全意想不到的地方。通常，输入给程序一段字符串，这个字符串里面包括<strong>可执行代码</strong>的字节编码，称为<strong>攻击代码</strong>（exploit code），还有一些字节用一个指向攻击代码的指针覆盖返回地址，那么 ret 的执行就会让程序跳转到攻击代码。这也叫做代码注入攻击（code injection attack）</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/2.png" alt=""></p>
<h1 id="对抗栈溢出攻击"><a href="#对抗栈溢出攻击" class="headerlink" title="对抗栈溢出攻击"></a>对抗栈溢出攻击</h1><h2 id="使用安全的函数"><a href="#使用安全的函数" class="headerlink" title="使用安全的函数"></a>使用安全的函数</h2><p>C 语言有很多的库函数，例如<code>strcpy</code>、<code>strcat</code>、<code>sprintf</code> 都不需要告诉它们缓冲区的大小，就能够产生一个字节序列，这样的情况就会导致容易遭受缓冲区溢出的攻击。避免使用这样的没有缓冲区溢出防御机制的函数，更好的做法是是使用例如像<code>fgets</code>、<code>strncpy</code>这样的函数来替代，它包括一个参数，限制读入的最大字节数。</p>
<h2 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h2><p>为了在系统中插入攻击代码，攻击者不但需要插入攻击代码本身，还要插入指向攻击代码开头的指针，以便当函数返回时，通过这个指针跳到攻击代码的位置。放置这个指针需要知道栈的位置。在过去，程序栈的位置非常<strong>容易预测</strong>，栈的位置是相当固定的，这就让攻击者有机可乘。<strong>栈随机化</strong>的思想就是让栈的位置在程序每次运行的时候都有所变化。程序开始时，在栈上分配一段 0 ~ n 字节的，随机大小空间。程序不使用这段空间，而是接在后面执行，会导致程序每次执行的时候后续栈位置有所变化，让黑客难以预测攻击代码的插入位置。分配的 n 需要足够大，这样随机的变化才足够多样；也不能分配的过大，导致浪费内存。</p>
<p>下面是一段典型的确定栈位置的代码：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">local</span>;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>, &amp;<span class="keyword">local</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书本上做了一个实验：在 32 位 Linux 系统上运行上述代码一万次，得到的地址空间变化范围是 <code>0xff7fa7e0 ~ 0xffffd7e0</code>，这段范围的大小约为 $ 2^{23} $。</p>
<p>在 Linux 上，栈随机化已经是标准行为。栈随机化是一大类技术中的一种，称为<strong>地址空间布局随机化</strong>（Address-Space Layout Randomization）。采用此技术，每次运行程序时的不同部分，包括程序代码、共享库、堆、栈、全局变量，都会被加载到存储器的不同区域。这意味着一台机器上运行一个程序，与在其他机器上运行同样的程序，它的地址映射会大相径庭。</p>
<p>然而，一个执著的攻击者可以通过暴力来克服随机化。一种常见的把戏就是在代码开头插入很长的一段 no operation 代码，这段代码除了让程序计数器加一，指向下一条指令外，没有任何效果。攻击者要做的就是猜中栈地址变化序列中的某个地址，程序经过这个序列时，会“滑过”这段代码，达到攻击代码。就会例如上面这段大小为 $ 2^{23} $ 的范围，某黑客有一段 128 字节的缓冲区溢出攻击代码，此黑客想要穷尽所有的起始地址，他需要尝试的次数是 $ \frac{2^{23}}{128} = 2^{17} $ ，也就是说他需要大约十三万次攻击就可以穷尽所有的地址。</p>
<h2 id="栈破坏检测：金丝雀"><a href="#栈破坏检测：金丝雀" class="headerlink" title="栈破坏检测：金丝雀"></a>栈破坏检测：金丝雀</h2><p>第二道防线是应该要有检测能力，检测到栈被破坏了。C语言中，没有可靠的方法来防止对数组的越界写。但我们能够在发生了越界写之前，还没来得及发生有害后果之前，尝试检测到它。做法就是在任何的缓冲区和其他栈部分之间插入一个特殊的金丝雀（canary）值，也叫哨兵（guard），是程序每次运行时随机产生的，攻击者很难知道它是什么。在程序恢复寄存器、从函数返回之前，检查金丝雀的值是否被改变，如果是，那么程序将异常终止。</p>
<p>金丝雀源于历史上用这种鸟在煤矿中察觉有毒的气体。（有点意思）</p>
<h2 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h2><p>限制可以存放可执行代码的存储器区域。一般来说，只有编译器产生的代码的那部分存储器才需要是可执行的。其他部分可以限制为只允许读和写。然而这些机制往往会带来严重的性能损失。</p>
<p>我们讲到的这些技术，是用于最小化程序缓冲区溢出攻击漏洞的三种常见机制。不幸的是，仍有方法能够攻击计算机，蠕虫和病毒还在继续危害许多的机器。</p>
<h1 id="扯点别的"><a href="#扯点别的" class="headerlink" title="扯点别的"></a>扯点别的</h1><p><strong>返回导向编程</strong>。可以利用修改已有的代码，来绕过系统和编译器的保护机制，攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。每一段 gadget 通常结束于 return 指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/3.png" alt=""></p>
<p><strong>Return-to-libc攻击</strong>。限制可执行代码区域有一种手段——研究者提出了数据执行保护策略(DEP)来帮助抵抗缓冲区溢出攻击。安全策略可以控制程序对内存的访问方式，即被保护的程序内存可以被约束为只能被写或被执行(W XOR X)，而不能先写后执行。Return-into-libc 攻击方式就不具有同时写和执行的行为模式，因为其不需要注入新的恶意代码，取而代之的是重用漏洞程序中已有的函数完成攻击,让漏洞程序跳转到已有的代码序列（比如库函数的代码序列）。攻击者在实施攻击时仍然可以用恶意代码的地址（比如 libc 库中的 system（）函数等）来覆盖程序函数调用的返回地址，并传递重新设定好的参数使其能够按攻击者的期望运行。与普通缓冲区溢出攻击相比，return-into-libc 攻击的防御难度更大。它可以避开数据执行保护策略，成为一种更有效、危险性更高的缓冲区溢出攻击。</p>
<p><strong>蠕虫，worm</strong>：蠕虫可以自己运行，并能够将自己的等效副本传播到其他机器。</p>
<p><strong>病毒，virus</strong>：病毒能将自己添加到包括操作系统的其他程序中，但不能独立运行。管蠕虫叫病毒是不对的。</p>
<hr>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://www.cs.cmu.edu/~./213/schedule.html">CMU 2017年春季学期  ICS课程网站</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B">wiki - 返回导向编程</a></li>
<li><a href="http://www.csdn.net/article/a/2014-03-03/15818077">Return-into-libc 攻击及其防御</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25816426">手把手教你栈溢出从入门到放弃（上）</a></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>《暗时间》阅读笔记</title>
    <url>/2017/09/11/dark-time/</url>
    <content><![CDATA[<p>非常向往刘未鹏这样子有书香气息的技术大牛，还有就是 BYvoid。</p>
<h2 id="序言-为什么人人都该学点心理学"><a href="#序言-为什么人人都该学点心理学" class="headerlink" title="序言 为什么人人都该学点心理学"></a>序言 为什么人人都该学点心理学</h2><ul>
<li>日常判断与决策</li>
<li>如何在信息海洋中筛选有效的信息</li>
<li>大脑是我们最重要的工具，为了正确使用这个工具，我们要去了解它，尤其是它的弱点（认知偏见，congnitive bias）</li>
<li>批判性思维</li>
</ul>
<h1 id="第一篇-暗时间"><a href="#第一篇-暗时间" class="headerlink" title="第一篇 暗时间"></a>第一篇 暗时间</h1><h2 id="暗时间"><a href="#暗时间" class="headerlink" title="暗时间"></a>暗时间</h2><ul>
<li><p>善于利用时间思维</p>
<ul>
<li>可以无形中比别人多出很多的时间。“心理年龄”：思考得多的人，心理年龄更大。</li>
<li>在重要的事情上主动提醒自己，将临时的记忆变成硬编码的行为习惯。</li>
</ul>
</li>
<li><p>错觉：“投入时间”这个说法本身就是荒唐的，<strong>实际要看时间和效率的乘积</strong>。</p>
</li>
<li><p>生命像是一个个沙漏，我们每个人的沙漏里面的沙子总量大致相同（寿命差不多），不同的是，有的人沙漏颈部较细，有的人沙漏颈部较粗。前者能够抓住每一粒时间之沙，虽然沙子总量一样，但相对的生命长度更长。</p>
</li>
<li><p><strong>暗时间</strong></p>
<ul>
<li>看书记住的东西只是记忆，只有推理和思考才能深入理解一个事物。推理的过程就是你思维的时间，也是人一生中占据一个显著比例的“暗时间”。</li>
</ul>
</li>
<li><p>专注</p>
<ul>
<li>程序员们都知道，任务切换需要花费额外的花销。要保存当前上下文，以便下次能顺利地切换回来，然后加载目标上下文。<em>进程切换的概念。</em></li>
<li>相比之下，如果只做一件任务，就不会有此损失，这就是为什么专注的人比不专注的人效率要高得多的原因。</li>
<li>进入状态的能力是可以锻炼的。</li>
<li>要充分利用暗时间，不仅要能迅速进入状态，另一个很重要的习惯是能够保持状态多久，也就是思维体力。</li>
<li><strong>迅速进入专注状态，能够长期保持专注状态，是高效学习的两个重要习惯。</strong>只有具备超强的抗干扰能力，才能有效地利用前面提到的种种暗时间。</li>
</ul>
</li>
</ul>
<h2 id="设计你自己的进度条"><a href="#设计你自己的进度条" class="headerlink" title="设计你自己的进度条"></a>设计你自己的进度条</h2><ul>
<li><p>进度条</p>
<ul>
<li>进度条的作用就是让你对整个过程的耗时有一个心理预估。如果没有进度提示的话，我们无法判断这个等待什么时候才是个尽头。</li>
<li>做事情也是同样的道理。善于规划的人，会把目标分成一个个的里程碑，再把里程碑分割成 todo list</li>
<li>如果不做规划，那么任务目标对你来说只有“完成”与“未完成”。对于比较漫长的目标来说，就总是“未完成”，会让你心生怯意。在这样的心理下，不少人就会选择退出。</li>
<li>所谓的规划就是针对这种心理弱点的做事方法。</li>
</ul>
</li>
<li><p>不要过早退出循环</p>
<ul>
<li>我们都在 for 循环，区别就是你在什么情况下 break 的。</li>
<li>当我们畏难的时候，其实我们畏惧的不是困难本身，而是困难所暗示的时间经济学意义。</li>
<li><strong>过早退出是一切失败的根源</strong></li>
</ul>
</li>
<li><p><strong>兴趣遍地都是，专注和持之以恒才是真正稀缺的</strong></p>
<ul>
<li>许多人觉得，兴趣最重要。<em>我也觉得，我是觉得我找到了兴趣，不然会死的很惨</em></li>
<li>然而，我觉得区别他们与其他人的，不是他们拥有奇特的兴趣，而是他们拥有超过常人的毅力。</li>
<li>其实人天生就对新鲜事物怀有好奇心。然而不同的是，有的人的兴趣只能维持几天，当遇到第一个困难、第一个坎的时候，他们就熄灭了。然而另一些人的兴趣火花会变成火苗，火苗变成火种，一直稳定地燃烧很多年。<strong>区别不在兴趣的有无，而是他们的性格里有没有维持兴趣的火种一直燃烧下去的燃料。</strong></li>
</ul>
</li>
<li><p>靠专业技能的成功是最具可复制性的</p>
<ul>
<li>否则学校和教育也不会存在这么多年了。</li>
</ul>
</li>
<li><p><strong>反思</strong>是让人得以改进的最重要的思维品质</p>
<ul>
<li>我们通常容易发现别人的问题和错误，却难以发现自己思维中的问题。</li>
</ul>
</li>
<li><p>饿死在干草垛之间的驴子</p>
<ul>
<li>迷茫期？“学 C++ 还是学 Java？”，有些问题根本不是问题，答案是都学。<em>我的答案是，先选一个开始学下去，最重要的是开始去做，并坚持</em></li>
<li><strong>有的人因为无法做出决定就推迟作出决定</strong>。推迟做决定是最差的决定。</li>
<li>如果你有一些钱，不知道花在 A 上还是 B 上，你先不做决定。不要紧，因为钱还是你的。但如果你有一些时间，不知道花在 A 上还是 B 上，不行，过了这段时间，这段时间就不是你的了。<em>这个社会对一个人的要求还是很严格的，错过了一个时间点，后面要还债的话确实很辛苦</em></li>
<li>不管你多纠结，也不要试图从纠结中逃离，试图拖延。</li>
</ul>
</li>
<li><p>一生的知识积累，<strong>自学起码占 90%</strong></p>
</li>
</ul>
<h2 id="如何有效地记忆和学习"><a href="#如何有效地记忆和学习" class="headerlink" title="如何有效地记忆和学习"></a>如何有效地记忆和学习</h2><ul>
<li><p>何为有效？</p>
<ul>
<li>你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。学习的目的就是为了要在恰当的时候能够想的起来去使用。</li>
<li>缺乏<strong>线索</strong>的记忆就像记忆海洋的孤岛，虽然在那里，但难以访问。富含线索的记忆则是罗马，条条大路通罗马。<em>对此有很多流行并被广泛采纳的意见，例如学习新知识最好与头脑中的旧知识建立联系则记忆比较牢固。比方说背单词的时候不只是记忆单词和词意本身，背词组、例句，记忆相似词汇、易混淆词汇都是为了建立知识间的线索。</em></li>
</ul>
</li>
<li><p>具体的实践方法，真正地学以致用——使知识能够在你需要的时候“蹦”出来，而不是搜肠刮肚无结果：</p>
<ul>
<li>养成习惯，经常主动去回顾一段时间学到的东西。</li>
<li>创造回忆的机会，例如：<strong>经常与他人讨论，或者讲给别人听</strong>（“为什么你从现在就应该写博客”、“教是最好的学”）</li>
<li><strong>整理笔记</strong>，一来巩固淡化的记忆，记忆是很脆弱的东西，我们对事物的首次理解几乎肯定是不深入的；二来给你重新审视知识的机会。因为我常常发现对知识的首次记忆往往是有失偏颇的，一段时间之后再回来看，往往能够和这段时间以来的一些新思考结合起来，得到更多的东西。</li>
<li>书写。将一段时间学习的知识按照一个主题“串”起来大大丰富了知识之间的关联。</li>
<li>实践。</li>
</ul>
</li>
<li><p>值得注意“沉默的证据”、事后偏见、自利归因。</p>
<ul>
<li>读他人传记的时候，注意其内容是否有意无意地犯了事后偏见。例如最常见的将成功归因为个人能力，忽略机遇因素，把偶然当必然。</li>
</ul>
</li>
</ul>
<h2 id="学习密度与专注力"><a href="#学习密度与专注力" class="headerlink" title="学习密度与专注力"></a>学习密度与专注力</h2><ul>
<li><p>在大学里，最不缺的就是业余时间，最缺的就是专注精神。</p>
</li>
<li><p>如果一个人要靠自制力去强迫自己不受干扰，那只能说是寻常人。真正的效率源自于内心对一个东西的强烈的热忱，也就是我们俗称的追求。<em>这句话真的扎心了啊 T T 最近对这句话也是翻来覆去在脑子里想着</em></p>
</li>
<li><p>专注力对学习效率为什么会造成这么大的影响？</p>
<ul>
<li>专注于一件事情所带来的全功率工作——显式的效率。</li>
<li>潜意识进入一种专注于这件事的状态，有的时候可能因为种种原因中断思考（比如睡觉，比如被其他工作中断），但潜意识里仍然保持“惯性”，也就是说，潜意识层面还在努力做思考，时间无形利用起来了，假以时日，日积月累可以产生宏大的效应。</li>
</ul>
</li>
<li><p>如何获得专注力？</p>
<ul>
<li>专注力是一种习惯，既然是习惯，就可以培养。</li>
<li>培养思维体力，这是一个成为非凡专家的必要条件。</li>
<li>还可以通过另外一个充分条件来实现专注力，就是做自己喜欢的事情。</li>
</ul>
</li>
<li><p>时间管理法则 （史蒂芬·柯维 《高效能人士的七个习惯）</p>
<ul>
<li><strong>要事第一</strong>。（重要而不紧迫的事情，即长远积累会对你今后人士产生重大影响的事）<em>反馈期长，但对未来自己更有用的事情，例如好好学习。打游戏就是反馈很快但对未来的自己没什么用的事情</em></li>
<li>关注有两种：主动关注和被动关注。许多人对<strong>琐事</strong>错误地采取了主动关注，比如常常一回到家就想“我今天还有哪些事没做完”。实际上，<strong>让这些不重要的事自己来找你就可以了，即中断式被动关注。</strong></li>
</ul>
</li>
</ul>
<h2 id="一直以来伴随我的一些学习习惯"><a href="#一直以来伴随我的一些学习习惯" class="headerlink" title="一直以来伴随我的一些学习习惯"></a>一直以来伴随我的一些学习习惯</h2><ol>
<li>Google &amp; wikipedia 提前做功课用</li>
<li><strong>看书挑剔，只看经典。</strong>选择书籍时做足功课是对自己的时间负责。 <em>好书让你豁然开朗，烂书浪费你的时间和精力，很庆幸自己一直以来的做法与大牛是一样的。</em></li>
<li>做读书笔记。阅读时的思考（包括闪念）总结下来；把书中的好例子摘抄下来，收益极大。<strong>很多时候仅仅是用自己的语言将知识重新表达一下就能极大加深印象和理解。我觉得，人与人学习的差距不在资质上，而在花在思考的时间和思考的深度上。</strong></li>
<li>多看心理学和思维的书，因为它们是跨学科的。<em>还可能有经济学吧</em></li>
<li>学习一项知识，必须问自己：1）它的本质是什么？ 2）第一原则是什么？ 3）知识结构是怎样的？</li>
<li>学习和思考过程中常常问自己：问题是什么？（提醒自己的思考不要偏离）我到底有什么收获？（提醒自己去总结整理）设想自己正在讲给别人听（有声思考）将给一个完全不懂的人听（挖掘知识背后的本质，最简单的解释。<em>自己有这么做过</em>）</li>
<li>时刻反省自己的思维过程，尤其是当遇到无法理解或解决了问题之后，要把原先的思维过程回顾一遍，看看到底哪个环节被阻塞了。对此，将思维的大致脉络书写下了是很好的习惯。<em>极好的学习习惯</em></li>
</ol>
<ul>
<li>时间和效率</li>
</ul>
<ol>
<li>趁着对一件事情有热情的时候，一股脑儿把万事开头难的最难阶段熬过去。开一个好头是重要的，但不是说持之以恒就不重要。<em>我没这么尝试过</em></li>
<li><strong>重要的事情优先。</strong>尽量避免琐事骚扰，不重要的事能不做就不做。<em>get了</em></li>
<li><strong>重要的事情要营造比较大块的时间来做。</strong></li>
<li><strong>重视知识的本质。</strong> 对于一个程序员来说极其重要。很多人感叹跟不上新变化，应对这个问题的方法是：抓住不变量。（底层知识、算法与数据结构、程序设计理论、良好的编码习惯、分析和解决问题的能力、学习能力、旺盛的求知欲、思维方式）</li>
<li><strong>重视提前积累的强大力量</strong> 计划订长久一点，自然可以多获得准备的时间。设想你若干年后要做什么事情，需要那些技能，然后现在就开始准备。<strong>如果你每次总是盯着明天要做的事情而去准备的话，那么你的准备缓冲区永远不超过一天</strong>，在这种情况下，当你遇到那些需要长期积累的专业技能时你会发现你自己根本没准备好。 <em>有时会觉得，自己比那些高中接触竞赛的人要差的远，其实是闻道有先后。种一棵树最好的时间是十年前，其次是现在，目光放长远，脚踏实地。</em></li>
<li>抬起头来。人是非常容易只看见树木而看不见森林的。时不时抬头审视自己做的事情，问一问：对现在和将来有什么价值？是不是你自己真心希望做的？你学到了什么？它们重要吗？你需要在这个时候去学习这个吗（参加第二条）？时间就是你的资源，你花掉时间去学习知识。所以到底用掉时间来掌握哪些知识是一个重要的问题，判断一个东西值不值得去学也是很重要的。 <em>以前从没想过这一点吧，但回头想想转专业的决定大概和这个有关</em></li>
<li>退订 RSS ，这其实是源于一个人不愿意关上一扇门的心理。实际上，关上一扇门，有时候能增大收益期望。<em>RSS：简易信息聚合，我觉得大概作者的意思是不要让太多无用信息充斥在自己的视线中。我想到了网易云音乐的每日推荐20首歌，我常常听到剩几首的时候，如果此时有别的事情要忙，我却会因为怕错过好歌而把它们听完，其实想想也是没必要的，该做其他事就去做其他事。</em></li>
<li>制定简要的阅读计划。</li>
</ol>
<ul>
<li>else</li>
</ul>
<ol>
<li>根据主题来查阅资料，而不是根据资料来查阅主题。<em>以前我读书就是一本一本的读</em></li>
<li>好资料，坏资料。好资料：从问题出发，着重介绍方法背后的理念，解释，而不是方法的技术细节；按照方法被发明的时间流程来介绍（遇到什么问题，分析、推理过程）。坏资料就是好资料的反面。</li>
<li>学习一个东西要带着疑惑感。做的思考越多，得到解答的印象才越强烈。把整个知识结构一览无余地放在面前，读的过程倒是挺爽，连连点头，读完就很快忘掉了。为什么？没有带着疑问去学习。<em>非常赞同</em></li>
<li>有选择性地阅读。</li>
<li>阅读的问题：知识性、思维性。思维性的东西是跨学科的，任何时候都用得上。并且，如果思维没有培养好的话，学习东西容易走错方向事倍功半。</li>
</ol>
<ul>
<li>为什么看不懂？</li>
</ul>
<ol>
<li>看得不够使劲，书读百遍其义自见，大脑理解一个东西本身就需要一定的处理时间，不能指望看到哪懂到哪，不懂就多仔仔细细多读两遍。</li>
<li>涉及到不懂的概念。<strong>很多人也不分析一下为什么不懂，而是直接放弃。</strong>第一时间要做的是分析，而不是直接求救。</li>
<li>也许书本讲述的顺序不对，可以继续往下看，看到后面就明白了前面的。</li>
</ol>
<ul>
<li><p>对书的质量评估</p>
<ul>
<li>作者、目录和简介、Amazon/豆瓣 上的评价</li>
</ul>
</li>
<li><p>知识的结构</p>
<ul>
<li>我把知识分为本质的和非本质的。</li>
<li>掌握本质的知识特别重要。关键要了解那些重要的思想（很长时间不变的东西），而不是很细的技术细节（易变的东西）</li>
<li>底层知识会无可避免地要用到，既然肯定要用到那还是预先掌握的好。在问题解决过程中，如果不具备必要的知识，是根本无从思考的。分析能力也不是说每个问题都分析出来该用哪些知识然后去查手册的。这使得一个好的知识基变得很重要。</li>
<li>如果你不知道某个工具的存在，遇到问题时也很难想到要用这么一个工具。本质知识就是最为广泛的工具。当编程时遇到问题，如果你缺乏底层知识，你甚至都不知道要去补充哪些底层知识才能解决这个问题。</li>
<li>最小白的例子是，重复造轮子。你要熟悉你的工具，才能有效地使用它。（适用和不适用的场景、编程范式、缺陷和陷阱）这些都是本质知识，如果不事先掌握，指望遇到了再查手册，是很浪费时间的。</li>
<li>学习知识的时候带着第三只眼来判断这个知识是否是不变量，是否完全可以在将来要用到的时候查手册即可。</li>
</ul>
</li>
</ul>
<p><em>勿在浮沙筑高台</em></p>
<ul>
<li>习惯的养成<ul>
<li>经常会有人这么说：说起来容易做起来哪有这么容易啊。</li>
<li>做起来当然不容易，所谓江山易改本性难移。</li>
<li>人的性格和认识事物的框架是长期积累养成的，并且人们非常重视自己的信念。</li>
<li>我们评判一个信念的养成是 satisfcing 原则，并不是 optimizing 原则（够好就行，Herbert Simon 提出）。</li>
<li>为什么说起来容易做起来难，就是“说”只是理性上承认正确，并没有考虑到大脑里居住的那个非理性自我。</li>
<li>理性是情感的奴隶，那么是不是说我们无法克服既有的习惯？肯定也不是。还是可以的</li>
<li>一：认识到习惯的养成和改变不是一天两天的事情，承认它的难度。</li>
<li>二：真的想去改掉or养成习惯，就要在这个过程中常常注意观察自己的行为，否则习惯会以一种你根本察觉不到的方式左右你的行为，让你功亏一篑。</li>
<li>把居住在你内心的非理性自我当成你的孩子（你要培养他），或者当成你的对手（你要战胜他）。<strong>总之不能当成自己</strong></li>
</ul>
</li>
</ul>
<h2 id="我在南大的七年"><a href="#我在南大的七年" class="headerlink" title="我在南大的七年"></a>我在南大的七年</h2><ul>
<li>遇到任何问题去找书，找书就行</li>
<li>最大的两个习惯：热忱和兴趣、不会就查书</li>
<li>我后来在博客上总结自己学习过程中走过的<strong>弯路</strong>，孟岩先生说道：是不是弯路，不是那么容易界定的。<em>是弯路也是财富</em></li>
<li>的确，也许真的有更好的路，但事前真的很难判断哪条路是最优的，我们能做到的，就是把一条路走透、走深了，只要不是一条太不靠谱的路，深入的过程中总会有很多收获。<em>虽然有的时候会怕走错路，处处去寻找前人的经验，但自己也得先走出几步才会发现前面有几条路可以走，犹豫多了反而止步不前</em></li>
<li>博客、回头看就像时光机一样，能够看到一路过来我关注了些什么东西，都是怎么想的。这些东西如果不记录，就会逐渐忘掉，也就无法参照过去的自己，对未来提供更好的借鉴了。</li>
<li>英语——海量的信息源</li>
<li>每当有人觉得我本科做了不少的事情，我就会说其实我本科真的浪费了很多时间。</li>
<li><p><strong>看一个人，只要看他读的书和他见的人</strong>，这两者是一个人成长中最有价值的信息来源。</p>
</li>
<li><p>我想，虽然很多人在本科就明白自己想做什么，我多花了两年多，总还不算太晚。<em>转专业那会，我压力挺大的，在要不要留级的问题上也很纠结。父亲开导我说，他今年45了，如果他能以多花一年时间的代价让自己活得更明白一些，他也愿意。更何况，我才20出头。于是我就降了一级，转到了自己想读的计算机系。家里的支持是我很大的动力来源。</em></p>
</li>
</ul>
<h1 id="第二篇-思维改变生活"><a href="#第二篇-思维改变生活" class="headerlink" title="第二篇 思维改变生活"></a>第二篇 思维改变生活</h1><h2 id="逃出你的肖申克"><a href="#逃出你的肖申克" class="headerlink" title="逃出你的肖申克"></a>逃出你的肖申克</h2><h3 id="为什么我们常说很多时候一定要亲身经历了之后才能明白"><a href="#为什么我们常说很多时候一定要亲身经历了之后才能明白" class="headerlink" title="为什么我们常说很多时候一定要亲身经历了之后才能明白"></a>为什么我们常说很多时候一定要亲身经历了之后才能明白</h3><ul>
<li>切身体验带来的感受才强烈和长久。<ul>
<li>自己是无法从强度上真正感同身受别人的痛苦的（别人断条腿没啥大不了，自己断根手指真是要了命了）（两个人你打我一拳，我打你一拳，力道就会越来越重）</li>
</ul>
</li>
<li>别人口中的故事难免受到他们自己的观念影响而产生偏见。<ul>
<li>客观全面地描述，极少有人能做到。</li>
</ul>
</li>
<li>为什么。<ul>
<li>很难说清，也很难接受“为什么要这样做”。在没有听到逻辑严密，无法辩驳的证据之前，你很难说服自己 A 一定优于 B，直到自己最终在一条路上撞了南墙才肯死心。</li>
</ul>
</li>
<li>世界是复杂的。<ul>
<li>比如：好好学习不一定有好的前程，吸烟不一定短命，不吸烟不一定长寿等等。这是一个复杂的世界，用单一因果来解释几乎总是不恰当的。唯一能靠谱地搞清因素 X 和因素 Y 之间的关系的方式就是通过随机控制实验。</li>
</ul>
</li>
<li>未来是不确定的。<ul>
<li>人类天生就有一种寻求确定性的需要。我们非常希望得到“你只要这样，以后一定能那样”这样的话。相反，这 个 世 界 太 乱。我们最多只能<strong>做好准备，不错失机遇</strong>，个人因素往往是成功的既非充分又非必要条件，所谓谋事在人成事在天。但无需悲观，因为毫无疑问，改善个人因素的确能够大大增加自己的成功几率。</li>
</ul>
</li>
<li>别人的道理，自己的事情。<ul>
<li>“你说的没错，可不适用于我这种情况”</li>
</ul>
</li>
<li>认知失调，自我辩护。<ul>
<li>假设我们听到别人的道理之前已经有了心理<strong>倾向</strong>，那么即使别人给出了一个有一定说服力的理由，我们也会竭力为自己<strong>辩护</strong>（认知失调理论）。又由于世界是复杂的，当这种情况发生时，我们几乎总是能够找到辩护的借口。<em>自认为还是蛮谦虚的吧，喜欢听他人意见。有些时候在某些问题上和别人达不成一致，很可能是这个原因了。</em></li>
</ul>
</li>
<li>失败即成功<ul>
<li>撞南墙的过程中也是可以总结经验教训的</li>
<li>失败的事情披露出来的信息一点也不比成功中的信息少。</li>
</ul>
</li>
<li>情绪对照<ul>
<li>如果没有经历失败后的糟糕记忆，我们就算理性地认识到目前的做法是合适的，也很难从情绪上强烈地感受到这么做的“正确感”。 <em>生活需要挑战和改变，太安逸难以进步</em></li>
</ul>
</li>
<li><strong>天性</strong><ul>
<li>我们有很多根植在大脑中的进化选择出来的天性。在判断和决策的时候这些天性的优先级总是最高的。</li>
<li>比如我们的天性是目光短浅，总会看到眼前利益，这在物质匮乏的古代是适应的。即便有人说服我们要眼光放长远一些，我们自己的内心还是：管他呢！</li>
<li>我们似乎有两个大脑：一个<strong>理性大脑</strong>，一个<strong>原始大脑</strong>。这两个大脑不是合作无间的，我们面临两难决策时，仿佛内心有两个声音在争吵，就是它们在吵架。</li>
<li>为什么你的大脑会让你不开心呢？很简单，如果你总是感到满足的话，就不会去进取，在一个残酷的优胜劣汰的环境中，不思进取的基因很容易被淘汰。<strong>贪婪、嫉妒、短视、投机</strong>，这些天性也许再远古社会曾经成功地让我们的祖先占据了生存繁衍优势，并不是像某些宗教中说的那样这是所谓“原罪”。然而现代社会环境发生了根本性改变，分享、合作、交流、长远、诚实才是现代社会取得成功的方法，显然，我们的天性还没有为这个社会准备好。<em>让人很眼前一新的观点，但为什么我们在分析一个人成功的原因很少说“是贪婪、短视”让他取得了成功？</em></li>
<li>因此，我们要用理性的声音去说服内心的原始人。</li>
</ul>
</li>
</ul>
<h3 id="亲身经历了一定就明白了吗？"><a href="#亲身经历了一定就明白了吗？" class="headerlink" title="亲身经历了一定就明白了吗？"></a>亲身经历了一定就明白了吗？</h3><ul>
<li><p>看重过程，而不是看重单次的结果。从长远来统计，好的过程总体上必然导致更好的结果。</p>
<ul>
<li>没有得到好的结果不代表你的过程就错了。（有人勤奋学习却发现有的同学找了个好老公就无忧无虑了，得到悲观结论学习无用）</li>
<li>结果正确也不一定代表方法就一定正确。<em>学习无用论，幸存者偏差</em></li>
</ul>
</li>
<li><p>认知偏差。</p>
</li>
<li><p>情绪系统。</p>
<ul>
<li>我们平常的决策和判断强烈地依赖与情绪系统的输出</li>
<li>正确的做法不是一概而论听取直觉的意见或者一概而论地步听取，而是将它当做参考，利用自己的理性大脑对其做进一步的批判性思维。</li>
<li>我们在一定程度上是能够驾驭情绪系统的。别忘了情绪系统知识一个比较粗糙的判断决策系统。<em>作者推崇理性＞感性</em></li>
</ul>
</li>
</ul>
<h3 id="不需要亲历也能明白——理性的力量"><a href="#不需要亲历也能明白——理性的力量" class="headerlink" title="不需要亲历也能明白——理性的力量"></a>不需要亲历也能明白——理性的力量</h3><ul>
<li>普通人从自己的错误中学习，聪明人从别人的错误中学习。</li>
<li>我们在大脑中走的更远，在现实中就走得更稳。</li>
<li>实在无法事先知道答案，才必须亲自探险（此时面临的问题是任何前人都没有探索过的）。那时，你就是站在别人的肩膀上的探索者、创新者。</li>
<li>人最重要的能力就是从别人的错误中学习，这类人能够迅速走在别人前面，<strong>在别人跌倒的地方跳过去</strong>，而不是重蹈覆辙。</li>
</ul>
<h2 id="书写是为了更好的思考"><a href="#书写是为了更好的思考" class="headerlink" title="书写是为了更好的思考"></a>书写是为了更好的思考</h2><ul>
<li><p>当我书写的时候，新的内容仍然会源源不断地冒出来，就像我自己的键盘会思考一样。<em>+1</em></p>
</li>
<li><p>书写的好处：</p>
<ol>
<li>书写是对思维的备忘。工作记忆资源是有限的</li>
<li>书写是对思维的缓存。主存有限，只在脑子里想，思维总是走不太远。<em>大脑≈主存，书写≈存到硬盘中</em></li>
<li>书写是与自己对话，反思自己的观点</li>
<li>书写是与别人的交流</li>
<li>在没有付诸笔端的时候，思想在脑海中的存在往往较为模糊。需要写出来。语言自己也会思考</li>
</ol>
</li>
<li><p>很多人不书写的原因是觉得没什么好写的，你越是不开始书写，总是拿有限的思维缓存去默想一个问题，你就越是没有东西可以写。<strong>如果你逼着自己讲一些不成熟的想法写下了，看着自己写的内容，试着进一步拓展它们，就有可能在理性的道路上走得很远，很远。</strong></p>
</li>
</ul>
<h2 id="为什么你从现在开始就应该写博客"><a href="#为什么你从现在开始就应该写博客" class="headerlink" title="为什么你从现在开始就应该写博客"></a>为什么你从现在开始就应该写博客</h2><ul>
<li>交到很多志同道合的朋友</li>
<li>书写是为了更好的思考</li>
<li>教是最好的学（“前提”、“假设”、“逻辑”、“结论”）</li>
<li>讨论是绝佳的反思</li>
<li>激励持续学习和思考</li>
<li>持之以恒地做一件事情</li>
<li>一个长期的价值博客是一份很好的简历。</li>
</ul>
<h2 id="我不想与我不能"><a href="#我不想与我不能" class="headerlink" title="我不想与我不能"></a>我不想与我不能</h2><ul>
<li>“想做”和“不能做”这两个冲突的念头是难以共存的。当你被折磨久了必须改变其中一个。“不能做”要变为“做到”难多了，而“想做”改成“不想做”很容易。</li>
<li>一旦你决定了“不想做”，你就会发现你自然而然的多了许多“不做”的原因：“这件事不是那么重要”、“别人不也没做么”……</li>
<li>虽然最终你没做到这件事，但你觉得你没做是因为“我不想做”，而不是“我不能做”。而且你的理由很充分，你舒坦了。</li>
<li>可惜，事实就是你自己把自己给骗了</li>
<li>心理学上把这个过程叫做“自利归因”，就是<strong>把一件事情发生的原因归结为对自己有利的那种情况，用大白话说就是不能让自己难堪。功劳都给自己占，责任都给别人担</strong></li>
<li>一旦你说出“这不关我的事”，除了心理好受之外，你也开始相信失败真的与你无关。结果就是你下次同样也不会成功。</li>
<li>有俗语“谋事在人成事在天”，其实这话说的是，我们努力是为了增大好的结果发生的几率，而不是为了一个确定的结果。</li>
<li>不要奢望你努力了就绝对成功，不可能的。但更不要以这个理由作为不去努力的原因，因为不去努力就永远不会成功</li>
<li><p>简单的道理被人们一次次忽视不是人们不懂，而是根植在我们内心的毛病：自利归因。</p>
</li>
<li><p>能控制的是：我们自己的<strong>主观能动性</strong>。无论外因如何，只要不是到了人力不能反抗的地步，发挥一下自己的行动力和主观能动性，总能获得更好的结果。如果想改变客观事实，也是要用自己的行动，而不是抱怨。</p>
</li>
</ul>
<h2 id="遇到问题为什么应该自己动手"><a href="#遇到问题为什么应该自己动手" class="headerlink" title="遇到问题为什么应该自己动手"></a>遇到问题为什么应该自己动手</h2><ul>
<li><p>生活像一条漫长的跑道，在你遇到障碍时，如果你总选择绕过，那么你终将越来越发现只能绕开障碍而无力搬开。虽然表面上看和那些绕过障碍的人相比，选择搬开障碍的人的速度慢了很多，但随着越来越熟练于解决障碍，最终速度回超过那些“抄近路”的。</p>
</li>
<li><p><strong>困难的路越走越容易，容易的路越走越难。</strong></p>
</li>
</ul>
<h2 id="什么才是你的不可替代性和核心竞争力"><a href="#什么才是你的不可替代性和核心竞争力" class="headerlink" title="什么才是你的不可替代性和核心竞争力"></a>什么才是你的不可替代性和核心竞争力</h2><p>独特的个性知识经验组合。</p>
<ol>
<li>绝无仅有</li>
<li>实践中有价值</li>
<li>具有可持续发展性</li>
</ol>
<p><strong>应当最大限度加强和发挥自己独特的组合，而不是寻求单项的超越。</strong></p>
<ol>
<li>专业领域技能</li>
<li>跨领域技能</li>
<li>学习能力</li>
<li>性格要素</li>
</ol>
<h1 id="跟波利亚学解题"><a href="#跟波利亚学解题" class="headerlink" title="跟波利亚学解题"></a>跟波利亚学解题</h1><p>解决问题的思维过程，有迹可循吗？</p>
<ul>
<li>越是高等的动物，大脑中用于处理特定问题的硬编码神经元回路就越是多和复杂。</li>
<li>归约：将一个无法直接解决的问题转化为一个新的，容易解决的问题。“联想”是一个极其重要的环节。</li>
</ul>
<h2 id="启发式思考方法"><a href="#启发式思考方法" class="headerlink" title="启发式思考方法"></a>启发式思考方法</h2><ul>
<li>时刻不忘未知量。即时刻别忘记你到底要求什么，问题是什么。</li>
<li>用特例启发思考。（通过特殊例子找规律</li>
<li>反过来推导。（归约。例如100个硬币，两人轮流取，每次只能拿一个或两个，问有必胜策略和先后手之分。这种问题通过试错不太容易找到答案，但反向归约能解决。即通过考察所求结论的隐藏性质来减小问题的复杂度。）</li>
<li>试错。一个题目需要求解一个未知量。用上所有的已知量，或使用所有你能想到的操作手法，尝试看看能不能得到有用的结论。事实上，如果一个问题的<strong>状态空间</strong>是有限的，往往可以通过穷举来找到关键的性质。</li>
<li>调整题目的条件。（删除、增加、改变条件）（通过拿掉一个条件，观察区别，再放上那个条件，就能感觉到题目中内在结构的某种约束）</li>
<li>回忆一个类似的题目的解法。</li>
<li>列出所有与问题可能有关的定理、性质。</li>
<li>考察反面，考察其他所有情况。（解题时容易陷入思维定式）</li>
</ul>
<h2 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h2><ul>
<li>一些有意义的好题目：没有用到你不知道的知识，然而那个最关键的、攸关成败的知识点你就是想不到。（我们能不能做一些工作、或者系统化的步骤去“生成”or“捕获”他们？）</li>
<li><strong>对自身思维过程的反观是人类真正有别于其他动物的本质区别。</strong></li>
<li>知识却也是思维的<strong>桎梏</strong>（傲慢与偏见） 如何在获取知识的同时防止被知识束缚，也是一门技术。</li>
<li><strong>问自己：“我是不是已经掌握了这个知识最深刻最本质的东西”</strong></li>
<li>知识，知识（不同的“能力”区分，实际上还是知识）</li>
<li>好题目，坏题目（考察思维能力：联想、类比、抽象、演绎、归纳、观察、发散思维）</li>
<li>练习，练习（外显记忆转化成内隐记忆）</li>
<li>总结，总结（要运用的话，则需要自己能想出来那关键的一步）</li>
</ul>
<h2 id="锤子和钉子"><a href="#锤子和钉子" class="headerlink" title="锤子和钉子"></a>锤子和钉子</h2><p><strong>如果你手里有一把锤子，所有的东西看上去都像钉子。</strong></p>
<p>任何工具都有适用范畴，学习工具的时候用了很多功夫，所以我们希望用上这些工具。但不要忘掉适用前提，why 和 what 永远在 how 之前。</p>
<ul>
<li><strong>手中有锤，心中无锤。</strong><ul>
<li>不要被工具奴役。始终提醒自己“问题是什么”</li>
<li>但没有工具也是不行的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>第一次胡出日麻役满 first yakuman</title>
    <url>/2018/02/09/first-yakuman/</url>
    <content><![CDATA[<p><del>玩物丧志ing</del></p>
<p>第一次在天凤胡出役满！小四喜~</p>
<p><em>（还是在直播打的 233）</em></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/yakuman1.png" alt=""></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/yakuman2.png" alt=""></p>
<p>牌谱地址：<a href="http://tenhou.net/3/?log=2018020901gm-0089-0000-cc37da31&amp;tw=3&amp;ts=4">http://tenhou.net/3/?log=2018020901gm-0089-0000-cc37da31&amp;tw=3&amp;ts=4</a></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>健身教会了我什么</title>
    <url>/2023/04/02/gym-workouts-teach-me-this/</url>
    <content><![CDATA[<p>第一，健身教会了我永远不要跟别人比较。Don’t compare to others。以前的我还会经常把自己跟别人去做比较，最常见的焦虑来源。我们挺喜欢比房价、比学区、比薪资、比 level、比男朋友比女朋友、比结婚生小孩的速度，但是就是没有多少人说 Don’t compare to others。我以前也在书上读过这个道理，但是我是真的到了健身房之后，<strong>我才真正地深刻理解了跟别人比较是没有意义的</strong>。当你是一个新手，你看到别人练了可能两三年甚至五六年的结果，你并不应该因为他现在的肌肉比你发达而失去你自己的动力。相反，你在健身房，才会真正学会什么叫做真正的 <strong>just focus on yourself</strong>。比较是毫无意义的。要比的话，就拿今天的自己跟昨天的自己比。不要拿今天的自己跟今天的别人比。”Compare yourself to who you were yesterday, not to who someone else is today.” </p>
<p>第二，我从健身中获得了很多的自信。不仅是你身体的肌肉获得了增加，而是你心态的成长。怎么去系统地学习健身，这是 Growth Mindset。只要你坚持养成一个习惯，健身并不是多么困难的事情。而且在养成习惯了之后，甚至你有的时候几天没去健身，你自己都会觉得难受。所以当有人跟夸我说，你很自律的时候，我心里会很诚实地不认为那是一种对自己的称赞。因为我只不过是养成了习惯，我只是借用习惯的力量罢了，我还是待在我自己的舒适区。成功的关键在于，每一次都举起比上一次更加重的力量，也就是所谓的渐进式负荷训练。然后持之以恒，养成习惯，<strong>只要坚持，成功的结果将会很快到来</strong>。</p>
<p>第三，健身改变了我的审美。这可能也是很多东亚地区的人的一些共同的审美观念，“白幼瘦”。自从开始健身之后，我的审美有发生变化，我开始会更加欣赏健康的身体。</p>
<p>第四，<strong>健身先健脑</strong>。这是一句比较戏谑的话，但是话糙理不糙。我想分享一下我在健身房遇到的最无语的事情。有一次我想做夹胸器械，有一个哥们正在做这个动作，他做了得有二十几次，就说明他的重量调的不合适。因为要达到增肌的效果，你应该选择能够做 8 到 12 下的重量（8-12 Repetitions Maximum）。他做到二十几次，已经说明他的重量选择的太轻了，不会有很好的锻炼效果。我在旁边耐心的等他做完。可是，没想到他就开始坐在器械上面开始玩手机了，把器械占据了。于是我上前搭话，我跟他说，嘿您好，咱们可以一起换着用吗？他抬头看了看我，跟我说了一句让我十分无语的话，他说，“我还有两组”。在健身房，我也学会了怎么对待这些人。我的内心觉得像他这样子，肯定是练不出什么结果的（他也确实练的不怎么样），因为他没有去先了解一些基本的知识就来健身，肯定是看不到效果的。既然你都花了时间了，那么还是要去了解一些基础知识，这样才不会让你的时间被浪费。以及他没有做好的另一件事情就是一些健身房的礼仪 Gym Etiquette。如果他不坐在器械上玩手机，我是不会生气的，我或许会跟他说你的重量选择得太轻了。因为<strong>无知并不等于愚蠢，Ignorance is not stupidity.</strong> 他没有选择合适的重量，有可能只是不知道这个概念；但是当我走过去要跟他交换着做而他却连组间休息时间也要占据器械，那就说明他是个蠢人。我发现我对愚蠢的人的忍耐程度也上升了，我听到他的话虽然内心翻了无数个白眼，但当时的我也就去做了别的器械了，让他继续坐在机械上面玩他的手机。It is not my job to fix other people 而且我的心情也完全没有受到影响。这个世界上的蠢人太多了，如果每一个人都需要我来教导他们的话，那么我是没有时间做自己想做的事了。</p>
<p>第五，为了健身增肌的目的，我学会了自己做饭，计算热量、碳水、蛋白质、脂肪三大营养素，这是很有用的知识。通过自己做饭，我还明白了我妈妈以前给我做饭的不容易，我向她表达了我的感谢之情，增进了我们母子之间的感情。</p>
<p>当我健身的时候，<strong>I feel alive. I feel like I’m living a life I really want to live.</strong></p>
<p>我在健身房遇到的最老的一位老人家，我上前搭话，他说他七十岁了。 健身在中国还不是很流行，其实有很多问题都是没有锻炼肌肉力量导致的。我跟这位老人家说：很多老年人摔倒一下就不得了了。他回答我说，对的，没有锻炼，肌肉、骨头都很脆弱的。他说：“<strong>死，也要轻轻松松地去死！</strong>” What a sentence! :) I hope I can still lift weight when I become 70.</p>
<p><img src="/2023/04/02/gym-workouts-teach-me-this/A 70-year old man in gym.jpg" alt="A 70-year old man in gym"></p>
]]></content>
  </entry>
  <entry>
    <title>论仇富心理 Hate Wealthy People</title>
    <url>/2018/03/27/hate-wealthy-people/</url>
    <content><![CDATA[<p>读《黑客与画家》总结。</p>
<h1 id="什么是仇富"><a href="#什么是仇富" class="headerlink" title="什么是仇富"></a>什么是仇富</h1><p>仇富多指对于富人阶层或富人个体的致富手段的合法性、依法纳税等操守所持有的怀疑和否定倾向的社会心态。</p>
<h1 id="赚钱的能力"><a href="#赚钱的能力" class="headerlink" title="赚钱的能力"></a>赚钱的能力</h1><p>当人们非常想把某件事做好，有的人就会因此付出努力，不断学习、练习、实践。知名画家的画比同时代二流画家的画要优秀很多。顶级的国际象棋大师与普通的象棋爱好者下棋下一万盘都难输一盘。顶级的钢琴演奏大师能比普通的爱好者演奏出丰富得多的曲子中的节奏、缓急、轻重、情绪。等等等等。他们对自己的技能十分热爱、经过持久的练习，才能达到登峰造极的地步。</p>
<p>与画画、下棋、弹琴等一样，应该说赚钱也是一种专门的技能。但是出于某种原因，人们对待赚钱这个技能的看法和其他技能不一样：如果某些人擅长画画擅长下棋，没人会说什么。而如果有人善于赚钱，就可能有言论说这是不对的。</p>
<p>为什么？</p>
<ol>
<li>对“财富”的看法有误解。</li>
<li>有一些积累财富的方法是名声不好的。</li>
<li>担心收入差距对社会产生不利影响。</li>
</ol>
<h1 id="1-对财富的看法："><a href="#1-对财富的看法：" class="headerlink" title="1.对财富的看法："></a>1.对财富的看法：</h1><p>创造出有价值的东西才是创造财富。财富 != 金钱。财富作为一个概念存在的时间比钞票什么的存在的时间要久的多，例如其实蚂蚁也拥有财富。我们所需要的东西就是财富，例如衣食住行。再举个例子，即使你没有钞票，但是你有一台魔法机器，能够按照你说的命令变出汽车，为你洗衣做饭等等能提供一切你想要的东西，那么其实你不需要钞票了。</p>
<p>那么金钱是什么呢，金钱是流动的财富表达方式。货币嘛，交易媒介。缺点是容易让大家忽略了本质，我们“挣钱”其实是为了获得自己想要的东西，只不过是用金钱去买。大家挣钱，做生意，目的就是为了创造财富，得到自己真正想要的东西。</p>
<p>所以，有一种说法就是“世界上的财富总额是不变的”。常常能看见这样的说法“前x%的人占据了全球y%的财富”，他的言下之意就包含了“富人拿走了更多的钱，因此其他人变得更穷”的观点。又比方说小孩子并不知道财富来之不易，衣来伸手饭来张口，孩子们以为财富是直接从父母口袋中流出来的，不知道财富是创造出来的。这就对“财富”的看法有所误解，就是把钱和财富混为一谈。财富不是恒定不变的，也不是由某个权威机构分配，别人多我就少的，<strong>财富是创造出来的</strong>。</p>
<p>金钱只是用来交易财富的手段，财富才是有价值的东西。财富从何而来？财富是人类创造的。回到以前的农业时代，并没有公司也没有工资拿，大多数人务农，农产品需要自己生产，这就很明显地说明，财富总量不是固定不变的。如果你想要更多的财富，有可能是需要一点创造财富的能力，或者说你更辛勤地劳作。</p>
<p>由于人和人是有差别的，进入社会之后，财富是你必须自己创造出来的东西，而不是等着别人分给你。<strong>由于每个人创造财富的能力、对财富的欲望强烈程度、受到的教育、头脑等等方面都不一样，所以每个人创造的财富数量很不平等。每个人的技能不同，导致收入不同，这是贫富分化的主要原因，也是很难避免的。</strong></p>
<p>这里我提到的是“创造财富的能力”而不是“拥有金钱”，因为其他的很多东西都能包括在后者里，例如抢银行，贪污受贿等等。</p>
<p>举个例子，根据 Corporate Library 的研究，美国一家上市公司的 CEO 约是一个普通人收入的 100 倍，职业篮球运动员的收入是普通人的 128 倍。报纸、社论引用这种数据时常常会说例如“贫富差距过大”、“收入分配不均”等等字眼，或者说一些高谈阔论“他一个人的价值有我们100个人的价值？”</p>
<p>但是大家可以仔细想一想，一个人的价值如果真的能用工资报酬来衡量的话，那么确实存在这种情况。确实有一些 CEO 收入过高不合理，但存不存在收入不足以体现他创造的财富的呢？乔布斯就是这样的例子。他开创了个人电脑时代，拯救了濒临崩溃的苹果公司，成功开创了下一代影响力巨大的产品。可以说地球上都没几个人能做到他做的事情。</p>
<p>人与人之间创造财富的能力就是可以差别这么巨大。你可以想一想，能通过找100个普通人完成乔布斯的工作吗？如果苹果没了乔布斯，而是由100个普通人组成的董事会掌管，苹果会变成什么样？篮球领队愿意拿一个运动员去换100个普通人吗？</p>
<p>如果没有意识到财富是创造出来，而不是从某个口袋流出来的话，难免对上述现象产生“不公平”的看法。认为财富是理应被大家分享，而不是来源于满足了他人的、有价值的创造活动，那么当你注意到有的人赚的钱很多时，你难免得出“这不公平”的结论。</p>
<h1 id="2-有一些积累财富的方法是名声不好的"><a href="#2-有一些积累财富的方法是名声不好的" class="headerlink" title="2.有一些积累财富的方法是名声不好的"></a>2.有一些积累财富的方法是名声不好的</h1><p>致富的途径不是只有创造财富这一条。历史上，积累财富的常见方法是偷窃、抢占、战争等暴力手段。游牧时期，偷别人的牲口；战胜的一方直接将失败的一方的全部财产占为己有；征税（和平年代）。这是很主要的一条仇富，或者说对贫富分化不满意的原因。例如中国就有“患寡而患不均”的说法。在中国古代，有些“杀富济贫”的人被人们奉为英雄，但是人们却又挖空心思的想成为富人。</p>
<p>在文明程度更高的社会，统治阶级有更高明的方法掠夺财富，例如重税，例如超发货币，还有钱权交易等等。这也能带来财富，但不是自己创造的，而是以强权进行搜刮。</p>
<p>随着欧洲资产阶级的崛起，这一切有所变化。在很长的历史时期内，你的财富得不到保护，随时可能被统治者或者外敌占为己有。<strong>第一个变化就是法律</strong>，资产阶级崛起，立法保障私有财产不可侵犯。人类历史上第一次出现了国家保护平民血汗钱的情况。<strong>第二个变化就是工业化、技术的发展</strong>。因为人们能心安理得地拥有自己创造的财富，不怕被别人夺走，这是一条资本主义发展、产生工业革命、技术突飞猛进的一条必要条件（不是充分条件）。只有自己创造的财富能有保证，那些想致富的人才会去创造财富。这一条是有反面证据的，例如人民公社化运动，人其实跟农奴没什么差别，农奴创造的财富都属于他的主人（公社），因此农奴是不会主动去创造大量财富的，因此公社里的人生产积极性逐渐下降直到崩溃。一旦创造财富能致富这一条变成可能，社会从整体上就能变得有活力、技术愿意革新、人们变得富有。工业革命、信息技术革命使得创造财富的速度有可能超过掠夺他人财富而积累财富的速度。财富“分配”也不是一个零和游戏了。</p>
<p>即使历史情况已有所变化，因为人类历史上致富方式可能是暴力或者是通过权利这一点，让我们依然对有钱人抱有一种敌意态度。中国的改革开放政策中有一条很重要的思路：鼓励一部分人、一部分地区先富起来，先富带动后富，最终实现共同富裕。这一政策在改革开放初期对于打破中国经济发展的桎梏，让经济得以迅速发展，起到了巨大的作用。当前问题是，这一政策没有得到完整的落实。先富起来的人并没有去带动其他人实现共同富裕。从而拉大了相互之间的贫富差距。</p>
<p>所以仇富要分清楚这一点。不过大多数人对于那些对社会真正做出贡献的人，他们拥有财富，在我们看来是理所应当的。例子例如袁隆平等等。而一些贪赃枉法而逍遥法外，坐拥不义之财之人，或者对于巨大财产而来源不明的，中国的一些富豪，尤其是一夜暴富的富豪，比如当今某些煤老板，他们为成为富豪而付出的成本异常地低廉，在他们的发家史上，往往与“腐败、不公”联系在一起，是社会资源分配机制极端不平衡、公平机制极端不健全使这些煤老板们在极短的时间内暴富起来。而与煤老板们的暴富构成强烈对比的是，另一部分社会群体由于社会公平机制的不健全而日益穷困，有的甚至是直接因为暴富者对他们权利的践踏所造成的。贫富差距急剧扩大，对他们的仇富是可以理解的。但有些无脑仇富是应该避免的。我国的宣传有一个很迷的倾向就是高尚的人格往往要和清贫搭在一起，容易让人觉得清贫是高尚的一个必要条件，加大了人们潜意识对富人的质疑。这一点对仇富起了推动作用。</p>
<h1 id="3-担心收入差距对社会产生不利影响。"><a href="#3-担心收入差距对社会产生不利影响。" class="headerlink" title="3.担心收入差距对社会产生不利影响。"></a>3.担心收入差距对社会产生不利影响。</h1><p>经常有人批判贫富分化加剧。在这里提出一个收入差距扩大体现的一些东西。技术的诞生使得生成的财富速度扩大，如果没有体现在收入上面，则有三种可能：（1）技术革新停滞了。（2）那些负责创造大部分财富的人停止工作。（3）创造财富的人没有获得报酬。</p>
<p>（1）和（2）其实都不是好事，这样社会无法发展。如果你想保持社会繁荣，技术继续革新，经济有活力，而大家的收入差距不扩大，那么就是（3）即创造了大量的财富的人没有获得更多的报酬。举个例子就是两位苹果公司的创始人每天工作十几个小时为社会提供了苹果电脑、手机，然后只领取一份普通的朝九晚五的白领的工资。这可能吗？如果得不到报酬，人们是否愿意创造财富？如果工作不带来财富还能主动工作，那么就是工作要带来乐趣了。在一个剥夺个人通过创造财富来获得应得财产的社会，对财富的创造活动中，一旦是没有乐趣的部分，会很快停止，这也是经过历史的实证检验的。一个社会需要富人，是因为他们在成为富人的过程中做出的事情，做出的贡献，也许他们改变了这个星球的面貌。综上所述，收入差距对社会产生不利影响倒是未必。</p>
<p>令人诟病的有另一种观点就是富人占据财富之外还占据其他很多资源。这一点我是同意的。今天的人们也许在同一个房间里，互相称呼对方的名字，穿着差不多的衣服，但银行户头上的余额是天差地别的。今天的人们多多少少有一些区别有一个主要的区别就是教育层次的区别。教育程度的差别和财富的差别是一回事，富人受到良好教育、高等教育的机会更大，这是事实。以及钱可以生钱的缘故，导致贫富差距拉大。这些情况都真实存在。这也是一些人士仇富心理的来源。</p>
<hr>
<p>参考：</p>
<ul>
<li><p><a href="https://book.douban.com/subject/6021440/">《黑客与画家》Paul Graham 著 阮一峰 译</a></p>
</li>
<li><p><a href="https://baike.baidu.com/item/%E4%BB%87%E5%AF%8C%E5%BF%83%E7%90%86/8516756">百度百科：仇富心理</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>ReadingNote</category>
      </categories>
  </entry>
  <entry>
    <title>如何面对家人的恶言相向</title>
    <url>/2021/02/22/how-to-respond-toxin-family/</url>
    <content><![CDATA[<p>如果爱，为何伤害？</p>
<h1 id="对几个问题的思考"><a href="#对几个问题的思考" class="headerlink" title="对几个问题的思考"></a>对几个问题的思考</h1><ul>
<li><strong>一、抚养小孩是父母的职责，并不是小孩感谢父母/原谅父母过错的理由。</strong></li>
</ul>
<p>人们会说“父母养育你不容易”来单方面地为父母获取道义上的优势，但是实际上，父母养育小孩是父母的责任。满足性欲，繁衍后代的事情，除了让父母背负养育子女的巨大责任之外，根本上谈不上任何道德的高尚性。生了当然就要养，养育一个孩子并不是就说明父母就多么伟大了，因为这不是人性，畜生都如此。如果生了不养育，那就是畜生不如。所以，养育孩子是父母的职责。那么现在的问题是，某件事情是你的责任，那么你做了，我就要对你“感激涕零”吗？并不是，因为这件事情是你的责任，意味着是你该做的。你做了一件职责内的事情，并不因此拥有得到对方感激的理由；相反，如果你没有尽到这份责任，没有做到该做的事情，我就要对你进行问责。</p>
<ul>
<li><strong>二、“尊老”是因为老人做了值得令人尊敬的事情，而不是因为老人的年龄，我们也不仅仅因为老人“老了”就原谅他的错误。</strong></li>
</ul>
<p>只需要知道还有一个成语叫做“为老不尊”，就不难明白这一事实。因为单就老人的年龄而言，高龄所带来的衰弱可以要求子女给老人更多的照顾和体贴，而不足以成为要求年轻人向老人表达敬意的充足理由。我们很容易想像一个“既老又坏”的人，所以这种概念应该是不言自明的，为何当这个坏老人是自己的亲属的时候就拎不清这个道理呢？亲属关系，说白了，只不过是一场 fucking genetical accident 基因事故罢了，不就是他曾经在我奶奶的阴道里射过精吗？所以所谓的亲属关系并不是可以给他的过错开脱的理由。</p>
<p>做错了就是做错了，并不因为年老就可以自动得到被害人的宽恕。当伤害来自我们的亲人，可能我们就忘了如何让他们弥补自己的过错，让我引用来自《亲密关系》对于宽恕的定义，“宽恕是‘一种针对曾不公平对待你的人，放弃你的报复的决定’，当宽恕的一些重要构成要素存在时，宽恕就更容易发生。第一个要素是谦卑、真诚的道歉。当背叛者承认他们的错误，为他们的不端行为表示羞愧、悔恨和自责时，受害者更有可能宽恕那些伤害他们的人。如果编造借口，道歉看起来不真诚，或者只是为了恳求理解和怜悯，就不太可能得到受害者的宽恕。”</p>
<ul>
<li><strong>三、你觉得你原谅了老人是你的大度，但实际上只不过是因为你没有能力实现你的正义（或曰复仇）而为了让自己内心觉得好受一点的说法。</strong></li>
</ul>
<p>这是对家里一些女性长辈的观察得到的看法。她们嘴巴上口头上说“我不跟他们（伤害过她们的长辈）计较”，但是实际上她们非常希望听到父母给她们说一句道歉。她们私底下痛恨父母对她们的残忍，如数家珍，椎心泣血，但父母真的在她们面前询问是否曾经伤害过她们，她们嘴巴又只会迅速地吐出：“没事没事，我早都忘了。”实乃尼采笔下形容的奴隶道德的最典型体现。</p>
<p>我觉得这样的亲子关系是有毒的，丧失了良好的互动可能，长辈没有了道德，子女也丧失了勇气。我想发问，做长辈的各位，是想要子女愿意给你提意见，发表一些自己特定的见解和看法，能一起探讨各种有深度的话题的亲子关系，还是想要表面和和气气，但一个个私底下都巴不得你早点死掉的儿女？</p>
]]></content>
  </entry>
  <entry>
    <title>Journey to Urumqi</title>
    <url>/2018/03/03/journey-to-urumqi/</url>
    <content><![CDATA[<p><strong>（流量预警！！！！！！！！！！）</strong></p>
<p>本文记录 2018 年农历春节从惠州自驾回乌鲁木齐的经历。</p>
<p>临时决定，不在南方过年，开车回老家！春节不用给过路费，只需油钱，还能省下下一家人的机票钱，非常值当。</p>
<p>广东惠州，大年三十，简单的年夜饭。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1267.JPG" alt=""></p>
<p>大年初一一早，出发！</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1258.PNG" alt=""></p>
<p>广东北部，韶关的火力发电厂。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1290.JPG" alt=""></p>
<p>（全都是小山坡，丘陵地带，东南的地势地貌已经见怪不怪了，但其实过不了多久就再也看不到绿叶了）广东湖南交界处。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1291.JPG" alt=""></p>
<p>再说一句，还是广东人比较喜欢赚钱，大年初一服务区的饭店照样开门，门庭若市。而再往北开，店主都已经回家过年，只能吃方便面了。</p>
<p>长沙，高速路贯穿中心市区，一览市区夜景。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1296.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1298.JPG" alt=""></p>
<p>本来爷爷奶奶想在长沙住一晚上，但无奈老爹实在太猛，寻思才开了七百公里，如果今晚就住，那明晚到西安，又要住一晚的话，剩下的两千多公里的里程可能要跑五天以上。老爹直接跑了一个通宵。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1299.JPG" alt=""></p>
<p>湖南湖北交界处。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1300.JPG" alt=""></p>
<p>停车下来休息。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1304.JPG" alt=""></p>
<p>已经感受到在南方感受不到的寒意。（襄阳当时零上三度左右</p>
<p>（猛男老爹）在我迷迷糊糊的时候已经开出湖北。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1307.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1308.JPG" alt=""></p>
<p>早晨八九点，落脚古都西安，换另一位长辈继续开。开了一天，里程完成一半。（头一天跑的多一点，后面在晚上可以落脚休息，每天少跑一点）</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1310.PNG" alt=""></p>
<p>环城高速，绕过西安，并不能像在长沙那样一睹西安古都风采。</p>
<p>秦岭、六盘水，山高路弯，隧道长。（秦岭淮河，中国南北的分界线）抬头望去，已经看不到绿色植被了。（常绿阔叶林 -&gt; 落叶阔叶林）</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1313.JPG" alt=""></p>
<p>黄土高坡。中国水土流失最严重和生态环境最脆弱的地区之一。地域广阔，包括西至太行山，冬至青海省日月山，秦岭以北，长城以南的广大地区。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1318.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1322.JPG" alt=""></p>
<p>说实话这局标语显得非常无力……（</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1324.JPG" alt=""></p>
<p>进入甘肃省。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1321.JPG" alt=""></p>
<p>路遇大雪。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1327.JPG" alt=""></p>
<p>第二天晚上落脚，甘肃省武威市，位于兰州西北部，甘肃省中部。 这里是古代的凉州、雍州，雍凉之都、天下要冲、国家蕃卫。曾经的西北的军政中心。</p>
<p>西北地域美食。有点熟悉的味道了。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1333.JPG" alt=""></p>
<p>宾馆的窗户向外看武威市。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1342.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1343.JPG" alt=""></p>
<p>武威火车站。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1351.JPG" alt=""></p>
<p>臊子面。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1350.JPG" alt=""></p>
<p>下一站哈密。</p>
<p>从武威出发之后，上了连霍高速，右边远远地是黄土高坡，左边是中国第一阶梯和第二阶梯的分界线——祁连山，中间就是一望无垠的陇西走廊了，十分平坦，车少，又能看到非常远。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1353.JPG" alt=""></p>
<p>G30 连霍高速，江苏连云港到新疆霍尔果斯，是一条在初中地理课上就听过的，中国最长的高速公路。2014年12月全线通车，，成为国家一带一路计划上的重要道路。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1365.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1354.JPG" alt=""></p>
<p>进入新疆地界。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1379.JPG" alt=""></p>
<p>祁连山和黄土高坡消失不见了，能看见的只有荒漠戈壁，路非常的平直，望不到头，与天相连。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1381.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1385.JPG" alt=""></p>
<p>星星峡，新疆内的第一站。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1389.JPG" alt=""></p>
<p>第二天晚上在新疆哈密市落脚。</p>
<p>新疆美食餐馆。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1404.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1406.JPG" alt=""></p>
<p>抓饭、烤肉与烤包子。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1412%2820180220-003657%29.jpg" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1413%2820180218-225603%29.jpg" alt=""></p>
<p>第三天白天，出发。</p>
<p>天山山脉（新疆地理：三山夹两盆，盆地的地势非常平坦，又都是戈壁和荒漠，路很平，很直，所以新疆的陆路交通是很发达的。 </p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1433.JPG" alt=""></p>
<p>新疆地区的维稳形势在过去的几年内依旧没有减缓，排队等候检查的车辆。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1440.JPG" alt=""></p>
<p>向为国守疆的武警同志致以崇高的敬意！</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1441.JPG" alt=""></p>
<p>风力发电。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1446.JPG" alt=""></p>
<p>油井。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1448.JPG" alt=""></p>
<p>火焰山景区附近。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1451.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1453.JPG" alt=""></p>
<p>破土造路的基建。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1467.JPG" alt=""></p>
<p>高铁桥。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1470.JPG" alt=""></p>
<p>经过三天半的长途跋涉，终于进入终点站——新疆维吾尔自治区的省会，乌鲁木齐市。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1477.JPG" alt=""></p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1478.JPG" alt=""></p>
<p>家楼下。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1492.JPG" alt=""></p>
<p>补上一顿丰盛的团圆饭。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1496.JPG" alt=""></p>
<p>没有什么比得上亲情的温暖。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1517.JPG" alt=""></p>
<p>对远道而来的客人的款待。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1518.JPG" alt=""></p>
<p>外公的书房。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1554.JPG" alt=""></p>
<p>滑雪场的天空。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1615.JPG" alt=""></p>
<p>马。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1619.JPG" alt=""></p>
<hr>
<p>离别的日子很快就到来。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1629.JPG" alt=""></p>
<p>乘机离开家乡。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1658.JPG" alt=""></p>
<p>回到福建。</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1663.JPG" alt=""></p>
<p>默默期待，下一次的团聚！</p>
<p><img src="http://p50lmli7t.bkt.clouddn.com/IMG_1729.PNG" alt=""></p>
<hr>
<p>行程：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">广东省）</span><br><span class="line">惠州</span><br><span class="line">东莞</span><br><span class="line">广州</span><br><span class="line">清远</span><br><span class="line">韶关</span><br><span class="line"></span><br><span class="line">湖南省）</span><br><span class="line">郴州</span><br><span class="line">衡阳</span><br><span class="line">株洲</span><br><span class="line">长沙</span><br><span class="line">岳阳</span><br><span class="line"></span><br><span class="line">湖北省）</span><br><span class="line">荆州</span><br><span class="line">仙桃</span><br><span class="line">天门</span><br><span class="line">随州</span><br><span class="line">襄阳</span><br><span class="line"></span><br><span class="line">陕西省）</span><br><span class="line">商洛</span><br><span class="line">西安</span><br><span class="line">咸阳</span><br><span class="line">宝鸡</span><br><span class="line"></span><br><span class="line">甘肃）</span><br><span class="line">平凉</span><br><span class="line"></span><br><span class="line">宁夏）</span><br><span class="line">固原</span><br><span class="line"></span><br><span class="line">甘肃省）</span><br><span class="line">会宁县</span><br><span class="line">定西</span><br><span class="line">武威</span><br><span class="line">金昌</span><br><span class="line">张掖</span><br><span class="line">酒泉</span><br><span class="line">嘉峪关</span><br><span class="line">玉门</span><br><span class="line">瓜州</span><br><span class="line"></span><br><span class="line">新疆维吾尔自治区）</span><br><span class="line">星星峡</span><br><span class="line">哈密</span><br><span class="line">吐鲁番</span><br><span class="line">达坂城</span><br><span class="line">乌鲁木齐</span><br></pre></td></tr></table></figure>
<p>2018 年 2 月 16 ~ 19 日</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>关于描绘未成年人的色情内容的绘画作品的法律地位的调查</title>
    <url>/2019/07/27/legal-status-of-drawn-pornography-depicting-minors/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>E站昨天由于法律原因关站了，所以我就想了解一下二次元本子（甚至是18禁本子）在国际法律意义上的地位。</p>
<p>首先，对于<strong>现实中的</strong>儿童（18岁以下）的色情图片，拍照，录像，性行为，性侵，性虐待等<strong>儿童色情（child pronography）</strong>行为绝对是非法的，<strong>这个我相信我们都没有异议</strong>。二次元本子有一个法律名词来描述，叫做 <strong>drawn pornography depicting minors（描绘未成年人的色情内容的绘画作品）</strong>。问题就在于，二次元本子（动漫、卡通）能否在司法上被解释为儿童色情。这里我想强调的地方在于，“司法解释”这个词在法学上有特别的意义。法律解释是指解读和运用法律的过程。当涉及实际的案件的时候，法律条文必须经过一定的解释。我们都知道 child pronography 是违法的，但是 drawn pornography depicting minors 到底能不能解释为 child pronography？喜欢看二次元的18禁本子的人就是恋童癖吗？如果在法庭上认可这个解释，那么自然二次元本子就是违法的，如果不认可，就是合法的。在法律解释的过程中，有各种原则和学说，都非常有意思，推荐大家有机会可以看点法律知识。</p>
<h1 id="各个国家的法律"><a href="#各个国家的法律" class="headerlink" title="各个国家的法律"></a>各个国家的法律</h1><table>
<thead>
<tr>
<th>国家</th>
<th>情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>美国、英国、澳大利亚、新西兰、荷兰、南非</td>
<td>明确18禁本子是非法、甚至是犯罪行为；对违反法律的范围定义很广或者有过处罚很重的判例</td>
</tr>
<tr>
<td>挪威、瑞典、波兰、巴西</td>
<td>明确非法，但定义不会那么广泛（如观看并不违法，制造和运输才违法）或者处罚较轻的</td>
</tr>
<tr>
<td>芬兰、意大利、日本、比利时、瑞士</td>
<td>合法</td>
</tr>
<tr>
<td>西班牙</td>
<td>人类之光</td>
</tr>
<tr>
<td>法国</td>
<td>逗比</td>
</tr>
</tbody>
</table>
<p>下面章节的格式内容如下：</p>
<ol>
<li>开头一句话总结</li>
<li>法条原文英文引用和自我的解读</li>
<li>判例</li>
</ol>
<h2 id="1-Australia"><a href="#1-Australia" class="headerlink" title="1. Australia"></a>1. Australia</h2><p>很严格，零容忍，特殊xp迫害。</p>
<p>下面这句话是重点：“if a consenting adult in pornography were “reasonably” <strong>deemed to look under the age of consent, then they could be considered depictions of child pornography</strong>.” <strong>如果本子中的“成年人”“看上去认为是低于我们普遍认为的成年人年龄”，也会被认为是儿童色情描写</strong>。其中一个例子就是对贫乳控的迫害：”small breasts” as one of few examples.</p>
<p>2008年有一个判例，被告电脑里有《辛普森一家》的本子，新南威尔士高级法院认为“ the animated Simpsons characters “depicted”, and thus <strong>“could be considered”, real people</strong>” —— <strong>本子里的人是可以解释成真正的人</strong>。</p>
<p>这里解释一下为什么要贴上判例。全世界有两个比较大的法律体系，一个叫做大陆法系，一个叫做海洋法系。海洋法系的国家，其法律有一个显著的特点叫“判例法”，对于以往的做法很重视，会参考先前判例，也体现了法律执行的态度。最重要的一点是，由于海洋法系尊重、遵循判决先例的原则，就代表以后的未来日子里都可以拿这个判例作为参照（以前有过判例是非法的，就说明这个行为基本上是被法律严格禁止了）。</p>
<h2 id="2-Brazil"><a href="#2-Brazil" class="headerlink" title="2. Brazil"></a>2. Brazil</h2><p>二次元本子<strong>本身在巴西可能不违法，但是制造和持有、分发会是违法的</strong>。</p>
<p>simple visualization of cartoons depicting sexual acts involving fictional lookalikes of human minors <strong>may not be illegal in itself</strong>… <strong>possession</strong> and especially <strong>production and/or distribution</strong> can be interpreted in courts to be of the same level of actual child pornography | legislation is vague on the subject</p>
<h2 id="3-Canada"><a href="#3-Canada" class="headerlink" title="3. Canada"></a>3. Canada</h2><p>算是对于二次元本子制裁很严格的国家。</p>
<p>加拿大法律对于儿童色情的定义如下：defines child pornography to include “a visual representation, <strong>whether or not it was made by electronic or mechanical means</strong>“, that “shows a person who is or is depicted as <strong>being under the age of eighteen</strong> years and is engaged in or is depicted as <strong>engaged in explicit sexual activity</strong>“, or “the <strong>dominant characteristic of which is the depiction, for a sexual purpose, of a sexual organ or the anal region of a person under the age of eighteen years</strong>“</p>
<p>从这个法条来看二次元本子在加拿大必然是非法的：</p>
<ol>
<li>生产方式是电子手段（网络上的本子）或者机械手段（印刷产品）不会妨碍被认定为儿童色情产物</li>
<li>对于“18岁以下的明显的性行为的描述”是儿童色情</li>
<li>或者对于性行为、性目的、性器官、阴部的描绘中的 dominant characteristic 明显低于18岁的，也算是儿童色情。例如，合法萝莉就一定会被判定是非法的。</li>
</ol>
<p>判例1：2011年有一个携带了魔法少女奈叶的本子的美国游客在加拿大被逮捕，因 possession and importation of child pornography 面临1年监禁。<br>判例2：2014年4月，一名男子因U盘中有本子，“20 images were anime, although a few appear to be of real girls between five and 13 years old.”（看这个描述就是很普通的本子）而被判处三个月监禁。</p>
<h2 id="4-Finland"><a href="#4-Finland" class="headerlink" title="4. Finland"></a>4. Finland</h2><p>比较宽松</p>
<p>在芬兰，对于儿童色情的定义，一定是要发生在<strong>现实</strong>中对于<strong>真实的儿童</strong>作为性行为的对象才可以：<strong>Realistic and factual visual depiction of a child</strong> appearing in sexual acts is defined as it having “been <strong>produced in a situation in which a child has actually been the object of sexually offensive conduct and realistic</strong></p>
<p>二次元本子是合法的，因为它和现实生活中的性虐待没有关系（哭了，热泪盈眶）：Purely fantasy-based virtual child pornography – in this case, drawings and paintings – remains legal by Finnish law <strong>because it has no connection to a real abuse situation</strong>; also, such depictions may serve informational or artistic purposes which can make even reality-based images legal</p>
<h2 id="5-France"><a href="#5-France" class="headerlink" title="5. France"></a>5. France</h2><p>很奇葩的国家……搞不懂法国人的脑回路</p>
<p>首先，惩罚是很重的，制造和传播描绘 15 岁以下儿童的色情会被判处最高5年监禁罚款7W5欧元，而且如果你只是画来自娱自乐并没有意图传播也在处罚之列：producing or distributing drawings that represent a minor aged less than 15 years old is considered the same as producing real child pornography and is punishable by up to five years imprisonment and a 75,000 euros fine, <strong>even if the drawings are not meant to be distributed</strong></p>
<p>但是他妈最奇葩的一条来了，The French law states, <strong>“the priority of public authorities is to ensure that artistic creation is disseminated and can be seen by the widest possible audience”</strong>. While clarity is provided on <strong>viewing and distribution of such drawings to now be legal, it remains illegal to produce</strong> 法国政府认为，<strong>公权力的首要目标是确保艺术创作能够让最广大的受众能够享受</strong>，所以看本子和传播本子不会违法，但是制造却是违法的。（前半句话佩服法国政府的见解，后半句话觉得法国人是傻逼……）</p>
<h2 id="6-Italy"><a href="#6-Italy" class="headerlink" title="6. Italy"></a>6. Italy</h2><p>不惩罚二次元本子</p>
<p>意大利对于“虚拟儿童色情”的定义是：Virtual images include images, or parts of images, produced and modified with software from actual photos of minors, <strong>where the quality makes it so that fake situations are manipulated to appear realistic</strong>. 其中重点是能够以假乱真达到让人以为这是真实的儿童色情描写。</p>
<p>因此，二次元本子因为远远达不到上述条件而不属于违法之列。Therefore, <strong>lolicon, shotacon, and cartoon pornography in general are not included</strong></p>
<h2 id="7-Japan"><a href="#7-Japan" class="headerlink" title="7. Japan"></a>7. Japan</h2><p>东 道 主</p>
<p>In Japan, pornographic art depicting underage characters (lolicon, shotacon)<strong> is legal but remains controversial even within the country</strong>. They are <strong>commonly found in manga, erotic computer games, and doujinshi</strong>.</p>
<h2 id="8-Netherlands"><a href="#8-Netherlands" class="headerlink" title="8.Netherlands"></a>8.Netherlands</h2><p>荷兰的法律较为严格，看到现在是第一个将二次元本子<strong>列入刑法</strong>的，是<strong>犯罪行为</strong>。这一次E站就是由于新法律生效而不得不关闭了服务器。</p>
<p>2002年就通过了认定 “virtual child pornography” illegal 的法律。其中对于 virtral child ponography 的定义是 “Three-dimensional, realistic images representing a minor engaged in a sexually explicit conduct” 后来又扩张解释到非 3D 的也算。</p>
<p>2018年荷兰<strong>刑法</strong>修订，任何人<strong>通过自动系统或者通信服务</strong>，在<strong>明知道描绘的图片中角色是小于18岁的情况下</strong>，传播、售卖、展示、制造、进口、运输、出口、获取、占有、访问都是<strong>犯罪行为</strong>，最高4年监禁和8W2欧元的罚款。</p>
<blockquote>
<p>As of September 1, 2018, the Dutch criminal law punishes “anyone who <strong>spreads, sells, openly exhibits, manufactures, imports, transports, exports, acquires, possesses, or accesses</strong> <strong>by means of an automated system</strong> or <strong>using a communication service</strong> an image (or data carrier containing an image) <strong>depicting sexual conduct</strong>, in which <strong>someone knowingly under the age of 18</strong>, is involved (or appears to be involved)” with a <strong>prison sentence of up to 4 years</strong> or a fine in the fifth category (up to €82.000).</p>
</blockquote>
<p>加粗部分的法条把E站给定的死死的，关站不可避免。</p>
<h2 id="8-Belgium"><a href="#8-Belgium" class="headerlink" title="8. Belgium"></a>8. Belgium</h2><p>不违法。</p>
<p>In Belgium, only pornographic art that <strong>realistically depicts</strong> underage characters is illegal. 在比利时，只有实际的现实描绘儿童色情才是违法的，因此二次元本子不违法。</p>
<h2 id="9-New-Zealand"><a href="#9-New-Zealand" class="headerlink" title="9. New Zealand"></a>9. New Zealand</h2><p>非常严格。和澳大利亚相像。</p>
<p>1993年新西兰法律认为一个作品认为是<strong>不良的</strong>，只要符合如下定义：其促进或尝试促进对于儿童、<strong>或年轻人</strong>的<strong>性剥削目的</strong>。 a publication as “<strong>objectionable</strong>“ if it “promotes or supports, or tends to promote or support, the exploitation of children, or young persons, or both, for sexual purposes” 对于 <strong>objectionable</strong> 的材料，制造、传播、拥有、复制都是非法的，最高可以面临<strong>十年监禁</strong>。</p>
<p>判例：2013年4月，一名叫做 Ronald Clark 入狱，因为他持有一本漫画，描绘的是“侏儒,小妖精和其他幻想生物之间的性活动”，被认定是非法的物品。In April 2013, Ronald Clark was jailed for possession of anime that <strong>depicts sex between elves, pixies, and other fantasy creatures.</strong></p>
<p>澳大利亚和新西兰算是非常严格的了，从两个方面来看，一个是对于儿童色情的定义非常广，以至于容纳了二次元本子；再者就是以往判例的处罚力度很大。</p>
<h2 id="10-挪威"><a href="#10-挪威" class="headerlink" title="10. 挪威"></a>10. 挪威</h2><p>严格</p>
<p>As of 2005, the Norwegian penal act criminalizes any depictions that “sexualize” children, <strong>even if it does not actually show sexual acts with children</strong>.[29] This could <strong>include any artificially produced material</strong>, including <strong>written text, drawn images, animation, manipulated images, an adult model with childish clothes, toys, or surroundings</strong></p>
<p>早在2005年挪威法律就制定了严格的法律将二次元本子纳入非法之列，甚至玩具、周边、“带有儿童服饰的成人模型”也是非法的。</p>
<h2 id="11-波兰"><a href="#11-波兰" class="headerlink" title="11. 波兰"></a>11. 波兰</h2><p>非法。</p>
<p>法律大同小异，和众多其他认定二次元本子为非法的国家相似。比较特殊的一条是“如果绘画中的人物年龄存疑，法庭会指派人类学家来鉴定和决定”</p>
<p>The “minor”, according to Polish law, is a person under 18 years old.[35] <strong>If the age of a depicted person is in question, a court may appoint anthropological experts to determine it.</strong></p>
<h2 id="12-南非"><a href="#12-南非" class="headerlink" title="12. 南非"></a>12. 南非</h2><p>非常严格。</p>
<p>任何图片或描述一个人的“真实<strong>或模拟的</strong>”描述为18岁以下的少年，从事性行为，构成“儿童色情”。创建、拥有、生产、进口、出口、广播、或以任何方式采购或访问都是犯罪行为，最高可判十年监禁。</p>
<h2 id="13-西班牙"><a href="#13-西班牙" class="headerlink" title="13. 西班牙"></a>13. 西班牙</h2><p><strong>人类之光！！</strong></p>
<p>Spain allows drawn pornography which doesn’t seem like real children, including cartoons, manga or similar representations … In order to avoid undue extensions of the concept of child pornography, the concept of ‘realistic images’ must be interpreted restrictively. </p>
<p>西班牙允许卡通、漫画之类的色情绘画作品，只要看起来不像是真实的儿童即可。这是为了<strong>防止“不必要的儿童色情的概念扩张”，“realistic images”的概念必须限制性地解释</strong>。</p>
<p>可以回头看一下最开始那段对于“解释”在法律意义上的说明，这是对二次元本子最友好的一国。</p>
<h2 id="14-瑞士"><a href="#14-瑞士" class="headerlink" title="14. 瑞士"></a>14. 瑞士</h2><p>合法</p>
<p>Pornography depicting fictional minors appears to be legal.</p>
<h2 id="15-瑞典"><a href="#15-瑞典" class="headerlink" title="15. 瑞典"></a>15. 瑞典</h2><p>非法</p>
<p>在色情情况下描绘儿童的任何图像或视频在瑞典都被视为儿童色情内容，即使它们是图画。“儿童”被定义为未满18岁或尚未过青春期的“人” 。</p>
<h2 id="16-英国"><a href="#16-英国" class="headerlink" title="16. 英国"></a>16. 英国</h2><p>非法，且十分严格</p>
<p>直接认定 all <strong>non-realistic</strong> sexual images depicting under-18s 是刑事犯罪的。对于儿童的认定和澳大利亚和新西兰一样，只要 predominant impression 是在 18 岁以下即可。</p>
<p>The definition of a “child” in the Act included depictions of 16- and 17-year-olds who are over the age of consent in the UK, as well as any adults where the “predominant impression conveyed” is of a person under the age of 18.</p>
<h2 id="17-美国"><a href="#17-美国" class="headerlink" title="17. 美国"></a>17. 美国</h2><p>在美国这一项法律仍有很多不明确和争议之处，各州法律也不尽相同，但是总体是非常严格的情况。太长，全文谷歌翻译，加粗自己认为的重要部分。</p>
<blockquote>
<p>1973年 - 2002年：美国对模拟儿童色情制品的法律待遇需要了解该短语的组成部分：色情，儿童和模拟。美国法律将这些视为单独的概念。<strong>在美国，色情被视为一种个人表达形式，因此受宪法第一修正案的管辖。</strong>色情内容通常<strong>是受保护的言论，除非它没有通过米勒测试</strong>，正如美国最高法院于1973年在米勒诉加州案中所做的那样。2002年，美国最高法院在阿什克罗夫特诉自由言论联盟中裁定，1996年儿童色情预防法案（CPPA）面临无效禁止虚拟或卡通儿童色情内容。该裁决的依据是，CPPA将<strong>某些形式的受保护的第一修正案演讲定为非法，禁止描绘儿童之间的性行为，即使不是淫秽而且不涉及真正的儿童受害者</strong>。在New York诉Ferber案件中，如果描述的是真正的虐待儿童或真正的儿童受害者，例如，由于拍摄现场表演，那么它不是受保护的言论。根据Miller诉加利福尼亚州的规定，淫秽言论同样被排除在第一修正案保护之外。（注：宪法第一修正案：保护美国人的言论自由；米勒测试：一种测试色情制品的方法，有三个标准，这三个标准都满足的作品被认定为色情作品。）</p>
<p>2003年：在回应阿什克罗夫特诉自由言论联盟时，国会通过了2003年4月30日由乔治·W·布什总统签署成为法律的2003年 “ 保护法”（也称为“ 安珀警示法”）。[72] “保护法”修订了以前关于儿童色情制品的法律，<strong>增加了一项肯定性辩护</strong>，其中指出“所谓的儿童色情制品<strong>并非使用任何实际的未成年人或未成年人制作</strong>”。……。<strong>这个定义不适用于描绘未成年人或成年人的绘画，漫画，雕塑或绘画的描述</strong>。““保护法”还颁布了18项 <strong>USC§1466A</strong>，该文件将具有“任何形式的视觉描绘，包括绘画，卡通，雕塑或绘画”的材料定为刑事犯罪，“描绘了一个从事色情行为的未成年人并且是淫秽 或“描绘了一个曾经或似乎是未成年人参与…… 性交的图像……并且缺乏严肃的文学，艺术，政治或科学价值“。根据其自身条款，<strong>法律并未规定所有模拟的儿童色情内容都是非法的</strong>，只是发现淫秽或缺乏严重价值。<strong>仅仅拥有图像不违反法律，除非</strong>可以证明它们是通过公共承运人（例如邮件或互联网）<strong>传输</strong>，或通过国家线路传输。[77]还有一项肯定的辩护，即拥有否两个以上的图像“合理步骤摧毁”图像或报告并将图像转交给执法部门。[78] 第一起重大案件发生在2005年12月，当时Dwight Whorley在弗吉尼亚州里士满被判18岁以下USC 1466A因使用弗吉尼亚州就业委员会计算机接收“ 淫秽的日本动漫漫画，以图形方式描绘青春期前的女孩被迫从事生殖器 - 生殖器和成年男性的口腔 - 生殖器性交“。[79] [80] [81] 2008年12月18日，第四巡回上诉法院确认了定罪，其中包括20年监禁。[82]惠利向最高法院提出上诉，<strong>但这被否定了</strong>。[83] [84] [85]</p>
<p>2008年至今：<strong>对“18USC§1466A”的回应在许多方面遇到了法律挑战。</strong>2008年5月19日，SCOTUS再次通过美国诉威廉姆斯案（2008年）将阿什克罗夫特（Ashcroft）的控股权用于虚拟儿童色情活动。有人裁定“规约不禁止提供或要求接收虚拟儿童色情内容。<strong>只有在发言者认为认为或打算让听众相信这个主题描绘的是真实儿童时，才会犯罪（ A crime is committed only when the speaker believes or intends the listener to believe that the subject of the proposed transaction depicts real children.）</strong>这意味着’<strong>受保护的表达类别不可避免地被压制（a protected category of expression [will] inevitably be suppressed）</strong>，模拟的儿童色情作品将一如既往。18USC§1466A”的措辞也是一个问题，其中部分法律试图将“任何形式的视觉描绘”定为刑事犯罪，已经在法庭上进行了审判。2008年10月。法官裁定，“保护法”的两部分将“任何形式的视觉描绘，包括绘画，卡通，雕塑或绘画”定为犯罪，但违反宪法，但<strong>汉德利仍面临淫秽指控</strong>。[86] Handley于2009年5月因其律师的建议进行认罪辩解而被定罪，认为陪审团选择审判他的人如果他们被显示在题。[87]</p>
<p><strong>自2008年底的裁决以来，绘制的儿童色情制品一直处于法律灰色地带</strong>。虽然“保护法”的两部分在联邦一级被裁定违宪，但<strong>有关儿童色情制品的法律在各州之间仍然存在差异</strong>。有几个州的法律明确禁止卡通色情和类似的描述，而其他州对这些内容只有模糊的法律。<strong>在加利福尼亚州，这种描述特别不属于州儿童色情法，而在犹他州，他们被明确禁止</strong>。[88] [89]在联邦层面，描绘未成年人冒犯当代社区标准并且“显然具有攻击性”而缺乏“严重的文学，艺术，政治或科学价值”的作品继续被视为非法。法律教授Reza Banakar自那时起，“严重的艺术价值”很难评估，评估缺乏这种价值的法律任务不能客观地执行。[90]在主流媒体自2012年拿起任何情况下，当来自密苏里州的一名男子进入辩诉交易到“藏漫画描绘儿童色情制品”。</p>
</blockquote>
<p>总结：03年颁布了一个法律USC§1466A，使得拥有本子并不违法，通过网络下载和传输违法。05年判例是用网络下载了一个日本的本子被判处20年监禁，上诉到最高法院被驳回。如今，在美国这一项法律仍有很多不明确和争议之处，各州法律也不尽相同。不过还有一点很重要，就是无论某州关于二次元本子的法律情况如何，原有角色的二次创作在理论上在美国都可能违反版权法。但从判例来看还是很严苛的，去美国这么一个讲政治正确的地方也基本上别想看二次元本子了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后引用几段话来表达我的观点，作为本文的结束</p>
<blockquote>
<p>Some analysts have argued whether cartoon pornography depicting minors is a “victimless crime”.</p>
<p>Setsu Shigematsu认为，lolicon漫画不应该等同于涉及真实儿童的摄影或成人视频; 相反，她认为萝莉控代表了一种人为的性欲，背离了“三维现实”，将性能量转向“欲望的二维形象”。Akira Akagi写道，在lolicon漫画中，<strong>这个女孩代表着可爱，而不是她的年龄让她变得有吸引力</strong>。</p>
<p>An argument is the claim that obscene fictional images portray children as sex objects, thereby contributing to child sexual abuse. This argument has been disputed by the fact that there is no scientific basis for that connection as of 1999,[3] and that restricting sexual expression in drawings or animated games and videos might actually increase the rate of sexual crime by eliminating a non-criminal outlet for desires that could motivate crime.</p>
</blockquote>
<p>“victimless crime” 我很喜欢这个表达，没有人受伤的世界。因此，我们也不是恋童癖。有一个广泛的言论，声称淫秽的虚构图像将儿童描绘成性对象，从而会导致针对现实世界的儿童的性虐待。自1999年以来，这种联系没有发现过有科学依据作为支撑，并且限制卡通或动画游戏和视频中的性表达可能实际上通过消除非刑事犯罪性来源来提高性犯罪率。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a href="https://en.wikipedia.org/wiki/Legal_status_of_drawn_pornography_depicting_minors">描绘未成年人的色情内容的绘画作品的法律地位</a></li>
<li><a href="https://en.wikipedia.org/wiki/United_States_v._Handley">美利坚合众国诉汉德里案</a></li>
<li><a href="https://en.wikipedia.org/wiki/Miller_test">Miller Test（美国鉴定材料是否属于色情的标准）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E7%BE%8E%E6%B3%95%E7%B3%BB">海洋法系</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%B3%95%E5%BE%8B%E8%A7%A3%E9%87%8B">法律解释</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lolicon">萝莉控</a></li>
</ul>
]]></content>
      <categories>
        <category>Thinkings</category>
      </categories>
  </entry>
  <entry>
    <title>link-summary-2018</title>
    <url>/2018/03/01/link-summary-2018/</url>
    <content><![CDATA[<p>这些是躺在浏览器里面的有用链接，杂乱无章，故作整理。若有自己写博客总结的未收录。</p>
<h1 id="读物、仰望"><a href="#读物、仰望" class="headerlink" title="读物、仰望"></a>读物、仰望</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/19959253">萧井陌：编程入门指南</a></li>
<li><a href="http://www.epubit.com.cn/article/550">邹欣老师</a></li>
<li><a href="http://www.cnblogs.com/JeffreyZhao/archive/2011/02/10/piano-life-and-interests-driven-practice.html">赵姐夫1：我们不是牛人，所以还是老老实实跟着兴趣走吧</a></li>
<li><a href="http://www.ituring.com.cn/article/14720">赵姐夫2</a></li>
<li><a href="https://www.cnblogs.com/JeffreyZhao/archive/2009/07/15/recommended-reading-2-sicp.html">老赵书托（2）：计算机程序的构造与解释</a></li>
<li><a href="https://www.cnblogs.com/JeffreyZhao/archive/2009/11/23/recommended-reading-3-csapp.html">老赵书托（3）：深入理解计算机系统</a></li>
<li><a href="http://blog.sunner.cn/what-happened-on-them/">孙志岗老师</a></li>
<li><a href="http://www.cnblogs.com/rocedu/p/5167941.html">娄老师：如何提问</a></li>
<li><a href="http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/">刘未鹏1：为什么算法这么难</a></li>
<li><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">刘未鹏2：怎样花两年时间去面试一个人</a></li>
<li><a href="http://blog.csdn.net/pongba/article/details/4202575">刘未鹏3：我在南大的七年</a></li>
<li><a href="https://wenku.baidu.com/view/7b65bbd176a20029bd642de2.html">陈硕：谈一谈网络编程学习经验</a></li>
<li><a href="http://blog.watashi.ws/2044/icpc-2011-orlando-wf/">watashi</a></li>
<li><a href="http://www.shuizilong.com/house/archives/%E3%80%90%E6%85%8E%E5%85%A5%E3%80%91%E6%97%A5%E5%B8%B8%E3%80%82%E3%80%82/">xiaodao</a></li>
<li><a href="http://www.cnblogs.com/qscqesze/p/4363195.html">qsc</a></li>
</ul>
<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><ul>
<li><a href="http://www.cnblogs.com/schaepher/p/5561193.html">github 教程</a></li>
<li><a href="http://blog.csdn.net/u011471873/article/details/51462871">git push报错error: failed to push some refs to ‘git@github.com:</a></li>
<li><a href="http://blog.csdn.net/vosang/article/details/50499300">ssh: connect to host github.com port 22: Connection timed out”错误</a></li>
<li><a href="https://segmentfault.com/a/1190000009048911">gitcommit 规范</a></li>
</ul>
<h1 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h1><h2 id="cnblog"><a href="#cnblog" class="headerlink" title="cnblog"></a>cnblog</h2><ul>
<li><a href="http://www.cnblogs.com/SivilTaram/p/5616478.html">纯MarkDown博客阅读体验优化</a></li>
<li><a href="http://www.cnblogs.com/asxinyu/p/Bolg_Category_For_BlogBeauty.html">博客园美化</a></li>
<li><a href="https://www.jianshu.com/p/23b2bfc9a90d">自定义cnblog界面</a></li>
<li><a href="http://www.cnblogs.com/linxd/p/4955530.html">Mathjax与LaTex公式简介</a></li>
</ul>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><ul>
<li><a href="https://segmentfault.com/a/1190000007261752">Hexo下mathjax的转义问题</a></li>
<li><a href="https://www.zhihu.com/question/21193762/answer/79109280">使用hexo，如果换了电脑怎么更新博客？</a></li>
</ul>
<h1 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h1><ul>
<li><a href="https://www.youtube.com/watch?v=dpcw2XqLp-E&amp;list=PLpherdrLyny-4Y6jXKvi0Ia9jJAk3M_Bs#t=4.767094">Nick Feamster 公开课</a></li>
<li><a href="https://edu.sdnlab.com/">未来网络学院公开课</a></li>
</ul>
<h2 id="SDWAN"><a href="#SDWAN" class="headerlink" title="SDWAN"></a>SDWAN</h2><ul>
<li><a href="http://www.cnblogs.com/allcloud/p/6049843.html">SDWAN技术分析</a></li>
<li><a href="https://www.youtube.com/watch?v=MSzeITPFWbc">tutorial introduction to SD-WAN</a></li>
<li><a href="http://developer.huawei.com/ict/forum/thread-18771.html">SD-WAN业务用例</a></li>
</ul>
<h2 id="OpFlex"><a href="#OpFlex" class="headerlink" title="OpFlex"></a>OpFlex</h2><ul>
<li><a href="https://wiki.opendaylight.org/view/OpFlex:Building_and_Running">OpFlex wiki</a></li>
</ul>
<h2 id="OVS"><a href="#OVS" class="headerlink" title="OVS"></a>OVS</h2><ul>
<li><a href="https://www.sdnlab.com/3166.html">OpenvSwitch 2.3.0 安装</a></li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ul>
<li><a href="https://www.coursera.org/learn/internet-history/lecture/UEu3K/security-introduction">密歇根大学的网络入门课</a></li>
<li><a href="http://www.cnblogs.com/icez/p/3973873.html">wireshark 使用技巧</a></li>
<li><a href="http://tool.520101.com/wangluo/ipjisuan/">ip地址计算器</a></li>
</ul>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><ul>
<li><a href="http://www.wosign.com/Basic/howsslwork.htm">SSL认证加密过程</a></li>
</ul>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ul>
<li><a href="http://blog.csdn.net/goodboy1881/article/details/665041">TCP/IP基础概念学习</a></li>
<li><a href="https://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html">协议森林</a></li>
</ul>
<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="CLRS"><a href="#CLRS" class="headerlink" title="CLRS"></a>CLRS</h2><ul>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2008/index.htm">CLRS 课程主页</a></li>
<li><p><a href="http://open.163.com/movie/2010/12/8/U/M6UTT5U0I_M6V2T998U.html">网易公开课 麻省理工学院 算法导论</a></p>
</li>
<li><p><a href="https://zhidao.baidu.com/question/558630518.html?qbl=relate_question_2&amp;word=%BE%BA%D5%F9%D0%D4%B7%D6%CE%F6%20%CB%E3%B7%A8%B5%BC%C2%DB">算法导论中的 循环不变式怎么理解</a></p>
</li>
<li><a href="http://www.cnblogs.com/bahcelor/p/6851936.html">求解递归式的方法</a></li>
<li><a href="http://daoluan.net/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2013/09/25/rbtree-is-not-difficult.html">红黑树</a></li>
<li><a href="http://blog.csdn.net/chinajane163/article/details/49563031">平摊分析</a></li>
<li><a href="http://blog.chinaunix.net/uid-26548237-id-3374211.html">最长公共子序列 LCS 问题</a></li>
<li><a href="http://blog.csdn.net/xiajun07061225/article/details/8088784">最优二叉查找树（动态规划）</a></li>
<li><a href="http://www.cnblogs.com/cherryljr/p/6519748.html#3910432">KMP</a></li>
<li><a href="http://www.cnblogs.com/xiaoyao24256/p/6590885.html">线段树</a></li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><a href="https://www.tuicool.com/articles/bUjaMv">Leetcode:Reorder List 单链表重排序</a></li>
<li><a href="http://www.cnblogs.com/pianoid/archive/2011/05/03/reverse-a-singly-linked-list.html">反转单链表</a></li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li><a href="http://blog.csdn.net/xiaolei09bupt/article/details/44888049">表达式转逆波兰</a></li>
</ul>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><ul>
<li><a href="https://www.bilibili.com/video/av4224493/">dijkstra, SPFA</a></li>
<li><a href="http://blog.csdn.net/qq_35644234/article/details/60578189">topo sort</a></li>
</ul>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><ul>
<li><a href="http://www.cnblogs.com/hsd-/p/6139376.html">树状数组彻底入门</a></li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li><a href="http://blog.csdn.net/a915800048/article/details/41703865">并查集删除</a></li>
</ul>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><ul>
<li><a href="https://jingyan.baidu.com/article/6fb756ec860e0d241958fb51.html">位、字节、字和字长的概念</a></li>
<li><a href="http://blog.csdn.net/u012861978/article/details/45562483">地址总线，字长，内存容量，寻址范围 之间的计算</a></li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li><a href="http://blog.csdn.net/shaohui973/article/details/8142797">进程和线程对于全局变量共享的问题学习总结</a></li>
<li><a href="https://www.zybuluo.com/359084415/note/740136">操作系统实验</a></li>
</ul>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><ul>
<li><a href="http://bbs.csdn.net/topics/100075723">带参数的main函数，命令行程序</a></li>
<li><a href="http://blog.csdn.net/abc5382334/article/details/18052757">#ifndef 使用详解，防止重复引用</a></li>
</ul>
<h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><ul>
<li><a href="http://www.cppblog.com/Sandywin/archive/2007/07/13/27984.html">stringstream的用法</a></li>
<li><a href="http://blog.csdn.net/xiaofei2010/article/details/8458605#">C++中回车换行（\n\r）和换行(\r)的区别，主要用于win和linux的区别</a></li>
<li><a href="http://blog.csdn.net/kelvin_yan/article/details/41596937">C++中在子函数中动态分配内存</a></li>
<li><a href="http://blog.csdn.net/rushkid02/article/details/7687125">STL priority_queue</a></li>
<li><a href="http://blog.csdn.net/allovexuwenqiang/article/details/5686583">C++ map</a></li>
<li><a href="http://blog.csdn.net/kingstar158/article/details/6859379">文件读写</a></li>
<li><a href="http://blog.csdn.net/yang3wei/article/details/25693695">stringstream中.str()方法和清空操作</a></li>
</ul>
<h1 id="C-sharp"><a href="#C-sharp" class="headerlink" title="C sharp"></a>C sharp</h1><ul>
<li><a href="http://blog.csdn.net/xrongzhen/article/details/5477075">Console.WriteLine()函数中{}输出格式详解(C#)</a></li>
</ul>
<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><ul>
<li><a href="http://www.runoob.com/python/python-strings.html">python网络在线教材</a></li>
</ul>
<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><ul>
<li><a href="http://bank.hexun.com/2009-06-24/118958531.html">RSA</a></li>
<li><a href="http://www.zedwood.com/article/cpp-sha512-function">sha512 function</a></li>
</ul>
<h1 id="宇宙第一IDE"><a href="#宇宙第一IDE" class="headerlink" title="宇宙第一IDE"></a>宇宙第一IDE</h1><ul>
<li><a href="http://www.cnblogs.com/youxin/archive/2011/08/01/2123852.html">Visual Studio中最常用的13个快捷键</a></li>
<li><a href="https://jingyan.baidu.com/article/77b8dc7f225b466174eab604.html">Visual Studio调试小技巧</a></li>
<li><a href="http://bbs.itheima.com/thread-101389-1-1.html">关于Viual Studio 改变编辑器背景背景及背景图片</a></li>
</ul>
<h1 id="CSAPP"><a href="#CSAPP" class="headerlink" title="CSAPP"></a>CSAPP</h1><ul>
<li><a href="http://csapp.cs.cmu.edu/3e/perspective.html">CSAPP 书本的网页</a></li>
<li><p><a href="http://wdxtub.com/2016/04/16/thin-csapp-2/">小土刀读书笔记</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/chkkch/archive/2011/06/24/2089378.html">尽信书不如无书</a></p>
</li>
<li><a href="http://jingpin.jikexueyuan.com/article/38128.html">链接的知识点</a></li>
<li><a href="http://www.cnblogs.com/daoluanxiaozi/archive/2012/03/12/2392281.html">虚拟存储器的知识点</a></li>
</ul>
<h1 id="SICP"><a href="#SICP" class="headerlink" title="SICP"></a>SICP</h1><ul>
<li><a href="http://blog.csdn.net/pongba/article/details/4202575">MIT Scheme 的使用</a></li>
<li><a href="http://blog.csdn.net/wwj_ff/article/details/48031567">scheme 简要介绍</a></li>
<li><a href="https://www.jianshu.com/p/13e082b516a6">Edwin 教程</a></li>
<li><p><a href="http://blog.csdn.net/sqh201030412/article/details/70859225">另一种环境——racket的使用</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/lfkdsk">如何屠龙</a></p>
</li>
<li><a href="http://sicp.readthedocs.io/en/latest/">题解</a></li>
</ul>
<h1 id="其他课程"><a href="#其他课程" class="headerlink" title="其他课程"></a>其他课程</h1><ul>
<li><a href="http://www.doc88.com/p-1751456665635.html">大学物理</a></li>
<li><a href="http://www.doc88.com/p-1794327670996.html">离散数学</a></li>
<li><a href="https://wenku.baidu.com/view/6b8f7804336c1eb91b375d47.html">数字电路</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>p4-specification</title>
    <url>/2017/10/21/p4-specification/</url>
    <content><![CDATA[<p>P416语言规范<br>版本1.0.0<br>P4语言联盟<br>2017年5月22日</p>
<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>P4是用于编程网络设备的数据平面的语言。 本文档提供了P416语言的精确定义，这是P4版本的版本http：// p4。org。 本文档的目标受众包括希望为P4程序编写编译器，模拟器，IDE和调试器的开发人员。 对于有兴趣了解更深层次语言语法和语义的P4程序员而言，本文档也可能引起关注。</p>
<h1 id="1-范围"><a href="#1-范围" class="headerlink" title="1.范围"></a>1.范围</h1><p>本规范文件定义了P416语言程序的结构和解释。 它定义语言，语义规则和语言一致实现的要求。</p>
<p>它没有定义：</p>
<ul>
<li>在程序包处理系统上编译，加载和执行P4程序的机制，</li>
<li>通过一个分组处理系统接收数据并传递给另一个系统的机制，</li>
<li>控制平面管理由P4程序定义的匹配动作表和其他有状态对象的机制，</li>
<li>P4程序的大小或复杂性，</li>
<li>能够提供一致性实现的分组处理系统的最低要求。</li>
</ul>
<h1 id="2-术语，定义和符号"><a href="#2-术语，定义和符号" class="headerlink" title="2. 术语，定义和符号"></a>2. 术语，定义和符号</h1><p>在本文档中，将使用以下术语：</p>
<ul>
<li>架构（Architecture）：一组P4<strong>可编程组件</strong>及其间的<strong>数据平面接口</strong>。</li>
<li>控制平面：涉及<strong>数据平面的配置</strong>和配置的一类<strong>算法</strong>和相应的输入和输出数据。</li>
<li>数据平面：一类<strong>描述数据包处理</strong>系统转换的算法。</li>
<li>元数据（metadata）：在执行P4程序时生成的<strong>中间数据</strong>。</li>
<li>分组（packet）：网络分组是由<strong>分组交换网络携带的数据的格式化单元</strong>。</li>
<li>数据包头（header）：数据包<strong>开头的格式化数据</strong>。给定的分组可以包含表示不同网络协议的分组报头序列。</li>
<li>数据包有效载荷（payload）：数据<strong>包头之后的数据包数据</strong>。</li>
<li>分组处理系统（packet-process system）：用于处理网络数据包的数据处理系统。通常，分组处理系统实现控制平面和数据平面算法。</li>
<li>目标（Target）：<strong>能够执行P4程序的分组处理系统</strong>。</li>
</ul>
<p>本文件中明确定义的所有术语不应被理解为隐含地涉及其他地方定义的类似术语。相反，本文档中未明确定义的任何术语应根据一般可识别的来源（例如IETF RFC）进行解释。</p>
<h1 id="3-概述"><a href="#3-概述" class="headerlink" title="3. 概述"></a>3. 概述</h1><p>P4是用于表示分组如何由诸如硬件或软件交换机，网络接口卡，路由器或网络设备的可编程转发元件的数据平面处理的语言。 名称P4：“编程协议无关的数据包处理器”，“Programming Protocol-independent Packet Processors,”  虽然P4最初是为可编程交换机设计的，但其范围已经扩大到涵盖了各种各样的设备。 在本文的其余部分中，我们对所有这些设备使用通用术语目标。</p>
<p>许多<strong>目标</strong>都实现了控制平面和数据平面。 <strong>P4旨在仅指定目标的数据平面功能</strong>。 P4程序还部分定义了控制平面和数据平面通信的接口，但P4不能用于描述目标的控制平面功能。 在本文的其余部分中，当我们将P4称为“编程目标”时，我们的意思是“编程目标的数据平面”。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/1.p4%E7%A8%8B%E5%BA%8F%E3%80%81%E4%B8%8E%E4%BC%A0%E7%BB%9F%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt=""></p>
<p>作为目标的具体示例，图1示出了传统的固定功能交换机和P4可编程交换机之间的区别。 在传统的交换机中，制造商定义了数据平面功能。 控制平面通过管理表中的条目（例如路由表），配置专用对象（如 meter）以及处理控制包（例如路由协议包）或异步事件（如链路状态更改或学习）来控制数据平面。</p>
<p>P4编程交换机与传统交换机的不同之处在于两种基本方式：</p>
<ol>
<li><p><strong>数据平面功能不是预先固定的</strong>，而是由P4程序定义的。 数据平面在初始化时被配置，以实现由P4程序描述的功能（由长的红色箭头所示），<strong>并且没有内置的现有网络协议知识。</strong></p>
</li>
<li><p>控制平面使用与固定功能设备相同的通道与数据平面进行通信，但是数据平面中的一组表和其他对象不再固定，因为它们由P4程序定义。 <strong>P4编译器生成控制平面用于与数据平面通信的API。</strong></p>
</li>
</ol>
<p>因此，P4可以说是<strong>与协议无关</strong>的，但它使程序员能够表达一组丰富的协议和其他数据平面行为。</p>
<p>结论：话是说的协议无关，但还是离不开吧？</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/2.%E4%BD%BF%E7%94%A8p4%E7%BC%96%E7%A8%8B.png" alt=""></p>
<h2 id="P4语言提供的核心抽象是："><a href="#P4语言提供的核心抽象是：" class="headerlink" title="P4语言提供的核心抽象是："></a>P4语言提供的核心抽象是：</h2><ul>
<li>报头类型（header type） 描述数据包中每个标题的格式（字段集及其大小）。</li>
<li>解析器（Parser）描述接收到的分组中的 header 的允许序列（permitted sequences），定义如何识别那些报头序列，以及从分组中提取的报头和字段。</li>
<li>表（table） 将用户定义的键（key）与操作（action）相关联。 P4表是推广自传统交换机表; 它们可用于实现路由表，流查询表，访问控制列表和其他用户定义的表类型，包括复杂的多变量决策。表是执行数据包处理的机制，P4程序定义了在表内可以匹配的字段和可以执行的操作。</li>
<li>动作（Action）描述数据包头域和元数据如何被操纵的代码片段。 操作可以包括在运行时由控制平面提供的数据。</li>
<li>匹配动作单元（match-action units）执行以下操作序列：<ul>
<li>从分组字段或计算的元数据构造查找密钥</li>
<li>使用构造的键执行表查找，选择要执行的操作（包括相关数据）</li>
<li>最后，执行所选的操作。</li>
</ul>
</li>
<li>控制流（Control Flow） 表达了一个命令性程序，用于描述目标上的分组处理，包括匹配动作单元调用的数据相关顺序。 分离（分组重组）也可以使用控制流来执行。</li>
<li>外部对象（Extern objects）是可以由P4程序通过定义良好的API来操作的体系结构，但内部行为是<strong>硬连线</strong>(involving or achieved by permanently connected circuits.)的（例如，校验和单元），因此不能使用P4进行编程。</li>
<li>元数据（metadata）<ul>
<li>用户定义（user define）的元数据：与每个数据包相关联的用户定义的数据结构。</li>
<li>内在（Intrinsic）元数据：由与每个分组相关联的架构提供的元数据，例如 接受 packet的输入端口。</li>
</ul>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/********** 报头类型 ************/</span> </span><br><span class="line"><span class="regexp">//</span> 以太网</span><br><span class="line">header_type ethernet_t &#123; </span><br><span class="line">    ﬁelds &#123;</span><br><span class="line">        dst_addr : <span class="number">48</span>;</span><br><span class="line">        src_addr : <span class="number">48</span>;</span><br><span class="line">        ethertype : <span class="number">16</span>;	</span><br><span class="line">    &#125;       	</span><br><span class="line">&#125;</span><br><span class="line">header ethernet_t ethernet;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/********** 解析过程 ************/</span></span><br><span class="line"><span class="regexp">//</span> 以太网包头的解析逻辑</span><br><span class="line"></span><br><span class="line">parser start </span><br><span class="line">&#123;</span><br><span class="line">    return  parse_ethernet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parser parse_ethernet </span><br><span class="line">&#123; </span><br><span class="line">    extract(ethernet)</span><br><span class="line">    return switch(latest.ethertype) &#123; </span><br><span class="line">        case <span class="number">0</span>x8100: parse_vlan; case <span class="number">0</span>x0800: parse_ipv4;</span><br><span class="line"><span class="regexp">//</span> Other cases</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/*********** “匹配 - 动作” **********/</span></span><br><span class="line"><span class="comment">#deﬁne  IPV4_LPM_TABLE_SIZE 65536</span></span><br><span class="line">table ipv4_ﬁb_lpm &#123; </span><br><span class="line">    reads &#123;</span><br><span class="line">        metadata.vrf : exact; </span><br><span class="line">        ipv4.dstAddr :lpm;</span><br><span class="line">    &#125;	</span><br><span class="line">    actions &#123;	</span><br><span class="line">        on_miss;	</span><br><span class="line">        ﬁb_hit_nexthop;	</span><br><span class="line">    &#125;</span><br><span class="line">    size  : IPV4_LPM_TABLE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">action on_miss() &#123;</span><br><span class="line"><span class="regexp">//</span> no op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 一旦定义好包头、解析器、表和动作，剩下的任务则是指定从一个表到下一个表的控制流。</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> example: 数据包首先经过L2转发表(<span class="number">12</span>_fwd)，然后可能经过L3路由表（ipv4_ﬁb_lpm和ipv6_ﬁb_lpm）</span><br><span class="line"></span><br><span class="line">control ingress &#123;</span><br><span class="line"><span class="regexp">//</span> L2 forwarding apply(l2_fwd);</span><br><span class="line"><span class="regexp">//</span> L3 routing apply(router_mac) &#123;</span><br><span class="line">    hit </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid(ipv4)) </span><br><span class="line">        &#123; </span><br><span class="line">            apply(ipv4_ﬁb_lpm);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(ipv6)) </span><br><span class="line">            &#123; </span><br><span class="line">                apply(ipv6_ﬁb_lpm)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="regexp">//</span> ACL apply(acl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译-P4-程序"><a href="#编译-P4-程序" class="headerlink" title="编译 P4 程序"></a>编译 P4 程序</h2><p>P4编译器本质上是将在P4程序中表达的数据平面的逻辑翻译成一个在特定可编程数据包处理硬件上的具体物理配置。因此，编译器后端部分自然与其支持的硬件目标紧密结合，而其前端部分则可以在各个P4可编程目标之间通用。这就意味着一个P4程序的具体实现可根据被编译的目标而改变。PISA编译器可以从P4程序的包头和解析器定义中导出解析器和重组器的配置。P4采用的状态机概念使得此映射变得相对容易。PISA编译器可以从表、动作和控制流的定义中导出“匹配 - 动作”阶 段的配置。编译器首先分析每个包头字段、元数据和状态对象在表和动作之间的所有依赖关系。基于这个结果，识别出可放置在相同阶段同时运行的表和动作，以及那些由于依赖性而必须顺序执行的表和动作。同时编译器还应考虑到其他由特定目标带来的相关限制，如可用的表内存、计算逻辑单元和携带数据包包头的寄存器等。</p>
<p>目标制造商提供硬件或软件实现框架，架构定义和该目标的P4编译器。 P4编程人员针对特定架构编写程序，其中定义了目标系统上的一组P4可编程组件以及其外部数据平面接口。</p>
<p>编译一组P4程序会产生两个工件：</p>
<ol>
<li>实现在输入程序中描述的转发逻辑的数据平面配置</li>
<li>用于从控制平面管理数据平面对象的状态的API</li>
</ol>
<p>P4语言旨在实现多种目标（target），包括可编程网络接口卡，FPGA，软件交换机和硬件ASIC。 因此，语言仅限于可以在所有这些平台上高效实现的构造。</p>
<h2 id="3-1-P4的优点"><a href="#3-1-P4的优点" class="headerlink" title="3.1 P4的优点"></a>3.1 P4的优点</h2><p>与最先进的分组处理系统（例如，基于在定制硬件之上编写微代码）相比，P4提供了许多显着的优点：</p>
<ul>
<li>灵活性（Flexibility）：与传统交换机相比，P4使许多数据包转发策略可以表达为程序，这些传统交换机将固定功能的转发引擎暴露给用户。</li>
<li>表现力（Expressiveness）：P4可以使用通用操作和表查找来表达复杂的，与硬件无关的数据包处理算法。 这些程序在实现相同体系结构的硬件目标（假设有足够的资源可用）上是可移植的。</li>
<li>资源映射和管理（Resource mapping and management）：P4程序抽象地描述存储资源（例如，IPv4源地址）; 编译器将这些用户定义的字段映射到可用的硬件资源，并管理诸如分配和调度的低级细节。</li>
<li>软件工程（Software engineering）：P4程序提供重要的好处，如类型检查，信息隐藏和软件重用。</li>
<li>组件库（Component libraries）：制造商提供的组件库可用于将硬件特定功能包装到便携式高级P4结构中。</li>
<li>解耦硬件和软件演进（Decoupling hardware and software evolution）：目标制造商可能会使用抽象架构来进一步将低级架构细节的演进与高级处理分离。</li>
<li>调试（Debugging）：制造商可以提供架构的软件模型，以帮助开发和调试P4程序。</li>
</ul>
<h2 id="3-2。-P4语言演变：与以前版本的比较（P4-v1-0-v1-1）"><a href="#3-2。-P4语言演变：与以前版本的比较（P4-v1-0-v1-1）" class="headerlink" title="3.2。 P4语言演变：与以前版本的比较（P4 v1.0 / v1.1）"></a>3.2。 P4语言演变：与以前版本的比较（P4 v1.0 / v1.1）</h2><p>与P414相比，早期版本的语言P416对语言的语法和语义进行了许多重大的，向后不兼容的更改。 从前一版本（P414）到当前版本（P416）的演进如图3所示。特别是，语言中已经消除了大量的语言特性，并将其转移到库中，包括计数器，校验和单元，仪表等。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/3.p416%E8%AF%AD%E8%A8%80.png" alt=""></p>
<p>因此，语言已经从复杂语言（超过70个关键字）转变为相对较小的核心语言（少于40个关键字，如A部分所示），并附有一个基本构造库，用于编写大多数P4。</p>
<p>P4的v1.1版本引入了一种称为extern的语言结构，可用于描述库元素。 因此，在v1.1语言规范中定义的许多结构将被转换成这样的库元素（包括从语言中消除的结构，例如计数器和计量表）。 这些外部对象中的一些预期将被标准化，并且它们将在将来描述P4元素标准库的文档的范围内。 在本文中，我们提供了几个extern结构的例子。 P416还介绍并重新使用了一些v1.1语言结构来描述架构的可编程部分。 这些语言结构是：解析器，状态，控件和包。</p>
<p>外部对象描述了一组由<strong>对象</strong>实现的方法，但<strong>不描述这些方法的实现</strong>（即它类似于面向对象语言中的抽象类）。 例如，以下构造可用于描述增量校验和单元提供的操作：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> Checksum16 &#123;</span><br><span class="line">    Checksum16();              <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span>()</span>;              <span class="comment">// prepare unit for computation</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">in</span> T data</span>)</span>; <span class="comment">// add data to checksum</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">in</span> T data</span>)</span>; <span class="comment">// remove data from existing checksum</span></span><br><span class="line">    bit&lt;<span class="number">16</span>&gt; <span class="keyword">get</span>(); <span class="comment">// get the checksum for the data added since last clear</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/5.extern.png" alt=""></p>
<p>P416语言修订的一个重要目标是提供一个稳定的语言定义。 换句话说，我们努力确保在P416中编写的所有程序在语言的未来版本被视为程序时将保持语法正确，行为相同。 此外，如果将来版本的语言需要反向兼容性，我们将努力为将P416程序迁移到新版本提供一条简单的途径。</p>
<h1 id="4-架构模型（Architecture-Model）"><a href="#4-架构模型（Architecture-Model）" class="headerlink" title="4. 架构模型（Architecture Model）"></a>4. 架构模型（Architecture Model）</h1><p><img src="http://osax8w13y.bkt.clouddn.com/4.%20Architecture.png" alt=""></p>
<p>P4架构识别P4可编程块（例如，解析器，入口控制流，出口控制流，拆包器等）及其数据平面接口 —— parser, ingress control flow, egress control flow, deparser, etc.) and their data plane interfaces.</p>
<p>P4架构可以被认为是程序与目标之间的契约。 因此，每个制造商必须为其目标提供P4编译器以及相关架构定义。 （我们预计P4编译器可以共享处理所有架构的通用前端）。 架构定义不必暴露数据平面的整个可编程表面 - 制造商甚至可以选择为同一硬件设备提供多个定义，每个具有不同的功能（例如，具有或不具有多播支持）。</p>
<p>图4： 它显示一个具有两个<strong>可编程块</strong>（＃1和＃2）的<strong>目标</strong>（target）。 每个块通过P4代码的单独片段进行编程。 目标通过一组控制寄存器或信号与P4程序接口。 输入控件向P4程序提供信息（例如，从数据包接收的输入端口），而P4程序可以写入输出控件以影响目标行为（例如，数据包必须被引导的输出端口）。 控制寄存器/信号在P4中表示为内在元数据。 P4程序还可以存储和操作与每个数据包相关的数据作为用户定义的元数据。</p>
<p>可以根据<strong>将矢量向量映射到位向量的变换</strong>来完整地描述P4程序的行为。 （The behavior of a P4 program can be fully described in terms of transformations that map vectors of bits to vectors of bits.）</p>
<p>为了实际处理数据包，架构模型解释了P4程序对固有元数据写入的位。 例如，为了使分组在特定输出端口上转发，P4程序可能需要将输出端口的索引写入专用控制寄存器。 类似地，为了使分组被丢弃，P4程序可能需要将“丢弃”位设置到另一专用控制寄存器中。 请注意，内部元数据如何解释的细节是<strong>架构特定</strong>的。</p>
<p>P4程序可以调用由外部对象和架构提供的功能实现的服务。 图5描绘了在目标上调用内置校验和计算单元的服务的P4程序。 在P4中没有指定校验和单元的实现，但它有提供一个接口。 通常，外部对象的接口描述了它提供的每个操作，以及它们的参数和返回类型。</p>
<p>一般来说，P4程序预计不会在不同体系结构中移植。 例如，通过写入自定义控制寄存器来执行广播数据包的P4程序将无法在没有控制寄存器的目标上正常工作。 然而，只要有足够的资源，为某个架构编写的P4程序应该可以移植到所有目标上，忠实地实现相应的模型。</p>
<p>结论：P4 不是一个比较适合移植的设计？</p>
<h2 id="4-2-数据平面接口-Data-plane-interfaces"><a href="#4-2-数据平面接口-Data-plane-interfaces" class="headerlink" title="4.2 数据平面接口 Data plane interfaces"></a>4.2 数据平面接口 Data plane interfaces</h2><p>为了描述可以在P4中编程的功能块，该体系结构包括一个类型声明，指定块与架构中其他组件之间的接口。 例如，架构可能包含以下声明：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">control MatchActionPipe&lt;H&gt;(<span class="keyword">in</span> bit&lt;<span class="number">4</span>&gt; inputPort,</span><br><span class="line">                           <span class="keyword">inout</span> H parsedHeaders,</span><br><span class="line">                           <span class="keyword">out</span> bit&lt;<span class="number">4</span>&gt; outputPort);</span><br></pre></td></tr></table></figure>
<p>control 是一个关键字。</p>
<p>此类型声明描述了一个名为MatchActionPipe的块，可以使用匹配动作单元（match-action unit）调用和其他命令式构造进行编程。</p>
<p>由上述声明可以看出：</p>
<ul>
<li>第一个参数是一个名为inputPort的4位值。 direction参数：input 表示此参数是输入。<strong>无法修改</strong></li>
<li>第二个参数是H类的对象，名为parsedHeaders，其中H是一个类型变量，表示将由P4程序员稍后定义的标题。 方向inout表示此参数既是输入又是输出。</li>
<li>第三个参数是一个名为outputPort的4位值。 方向输出表示此参数是一个输出，其值最初未定义，但可以修改。</li>
</ul>
<h2 id="4-3。-外部对象和函数"><a href="#4-3。-外部对象和函数" class="headerlink" title="4.3。 外部对象和函数"></a>4.3。 外部对象和函数</h2><p>P4程序还可以与架构提供的对象和功能进行交互。 这样的对象使用extern构造来描述，该外部构造描述了这些对象暴露于数据平面的接口。</p>
<p>例子就是校验和 checksum</p>
<hr>
<p><a href="http://www.sdnlab.com/17456.html">http://www.sdnlab.com/17456.html</a></p>
<p><a href="https://p4lang.github.io/p4-spec/docs/P4-16-v1.0.0-spec.html">https://p4lang.github.io/p4-spec/docs/P4-16-v1.0.0-spec.html</a></p>
]]></content>
      <categories>
        <category>paper-reading</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统实验之通过信号量实现复杂PC问题</title>
    <url>/2017/05/20/semaphore-PCproblems/</url>
    <content><![CDATA[<h1 id="PC问题"><a href="#PC问题" class="headerlink" title="PC问题"></a>PC问题</h1><p><a href="http://blog.chinaunix.net/uid-21411227-id-1826740.html">PC问题</a>（producer and consumer，生产者和消费者问题）是操作系统中并发程序设计中的经典同步问题。</p>
<p>semget 函数的作用是创建新的或获得已存在的信号量集。这个函数是以信号量集作为操作单位的，一个信号量集可以包括一个或多个信号量。对于PC问题，有full、empty、mutex1、mutex2等多个信号量。在选取信号量以及对它们进行操作（赋值、P、V）的时候，通过两种变量来识别它们，分别是键值<code>sem_id</code>和信号在信号量集中的序号<code>sem_num</code>。所以可以有两种选择：</p>
<ul>
<li><p>声明四个键值，用来创建四个信号量集，每个信号量集包括一个信号量。在操作信号量时，每个信号量的<code>sem_num</code>都是0。是通过键值<code>sem_id</code>来区分信号量的。</p>
</li>
<li><p>只声明一个键值，创建一个信号量集，但里面有四个信号量。所以每个信号量的键值都一样，而是通过<code>sem_id</code>来区分，分别是0、1、2、3。</p>
</li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170506183005367-1513094013.png" alt=""></p>
<p>从运行结果来看，P、C的过程成功受到了信号量的影响。</p>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201705/1092156-20170506183039539-921756659.png" alt=""></p>
<p><strong>update: 2017-05-20:</strong> 竟然忘了把信号量放到共享存储区中，罪过罪过，在这里多谢浴盆指出我的问题。</p>
<p><a href="https://github.com/ZCplayground/Linux-experiments/blob/master/semaphore%20-%20PCproblem/PCproblem.c">代码地址</a></p>
<h1 id="父子进程、共享存储区"><a href="#父子进程、共享存储区" class="headerlink" title="父子进程、共享存储区"></a>父子进程、共享存储区</h1><p>摘抄一段CSAPP中关于进程的内容：</p>
<p>第8章异常控制流：</p>
<blockquote>
<p>父进程通过调用fork函数来创建一个新的运行子进程……新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间<strong>相同（但是独立的）一份拷贝</strong>，包括文本、数据和BSS段、堆、栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。这意味着父进程调用fork时，子进程可以读写父进程打开的任何文件。</p>
<p>父进程和子进程是<strong>并发运行的独立</strong>进程。</p>
<p>相同但是<strong>独立的地址空间</strong>。如果能在fork函数在父子进程返回后立即暂停，可以看到每个进程的地址空间是相同的（相同的用户栈、堆、本地变量值、全局变量值、相同的代码）。然而，父进程和子进程是独立的进程，它们都有自己私有的地址空间。父进程对于一个变量所做的任何改变都是独立的，不会反映在另一个进程的存储器中。</p>
</blockquote>
<p>第9章虚拟存储器：</p>
<blockquote>
<p>进程这一抽象能够为每个进程提供私有的虚拟地址空间，免受其他进程的错误读写。……幸运的是，存储器映射给我们提供一种清晰的机制来控制多个进程共享对象。</p>
<p>如果一个进程把一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们的虚拟存储器的其他进程而言也是可见的。</p>
</blockquote>
<hr>
<p>关于信号量实验API的一些参考链接</p>
<ul>
<li><a href="https://zhidao.baidu.com/question/1893918728169133900.html">ftok函数</a></li>
<li><strong>重点推荐：</strong><a href="http://www.educity.cn/linux/1241661.html">Linux进程间通信(六)—信号量通信之semget()、semctl()、semop()</a> </li>
<li><a href="http://blog.csdn.net/ta893115871/article/details/7505560">信号量 Linux函数 semget();semctl();semop();</a></li>
<li><a href="http://blog.csdn.net/shaohui973/article/details/8142797">关于进程和线程对于全局变量共享的问题学习总结</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Shape of Voice 《声之形》观后感</title>
    <url>/2017/09/10/shape-of-voice/</url>
    <content><![CDATA[<p>记录于开学前一天。</p>
<p>观后感吧，算不上影片。（剧透提醒</p>
<p>在我看来，这部影片涉及的内容是很多元的，其中包括的元素有校园霸凌（欺负残疾人，孤立）、听力残障（可以理解为任何的身体残疾、残疾人的问题）、自杀、亲情、友情、爱情……有关这部影片的讨论，有一种观点就是这部影片没有真实地反映校园暴力，为校园暴力洗地，没有真实的反映残疾人的感受，有许多情况不切实际等等。但就拿校园霸凌来说，这个内容的体现主要还是集中在影片的前二十分钟。个人认为整部影片讲述的主旨在于两个“残疾人”——女主代表了身体上的残疾，男主代表了心理上的残疾——互相得到救赎的故事。的确，声之形由于包括的元素比较多，对其校园暴力或者残障人士的描写和铺垫确实少了些，但篇幅所限，也是可以理解，单拿这二者对本片进行攻击也有失偏颇。</p>
<p>男主被孤立后，所有周围人的脸上都打了叉，（全片的最高潮就是结尾处这个叉的脱落）虽然我的成长过程中没有这种经历，但我觉得这个描写手法十分巧妙。想写些什么，却对此也没什么细致的感想，只能说“感同身受”这四个字是一个“说起来容易”的词吧，很多事情没有亲身经历过是不会真正地懂那种感受的。</p>
<p>友情：肥宅代表一种人，就是真正的朋友。真正的友情，有可能是无心插柳柳成荫，也有像和其他配角那样有一个曲折的建立过程。</p>
<p>亲情：让我动容的地方，女主外婆去世。虽然我的祖辈都还健在，但我知道迟早这一天会到来。“死亡教育”</p>
<p>爱情：男女主。（妹妹神助攻啊</p>
<p>倒叙的手法让我在影片前半段，脑海里一直有一个疑问：男主为何要轻生？男主到了中学被孤立，打工还了母亲的钱想要离开这个世界。其实事后来看，男主当时的想法十分地幼稚。女主一开始的选择也是“消失”（转学），后面也在烟火大会时跳楼自杀了。不过呢，这是动画电影，他们是男主女主。男主自杀的时候，男主的母亲拯救了男主，女主自杀的时候，男主又拯救了女主。但这让我联想到的是，生活中悲剧里的人物，他们就没有被拯救，走向死亡。同时，“拯救”他人真的不是一件容易的事情（男主我觉得应该是要摔死的，不过毕竟是男主）。友情再一次让我感动，当肥宅在厕所中看到男主激动地拥抱男主，说着“你要是没活着我真的不知道怎么办了”。我想到了得抑郁症自杀的人（高中有老师就是因此去世），我真的能理解抑郁症患者的内心吗？假设我得了抑郁症，真的能有人来拯救我吗？如果抑郁症患者能听到像肥宅这样的痛哭流涕，是不是自杀的情况会少一些呢。。</p>
<p>不过，种种以上，都是生命中可能遇到的大千世界的缩影。最终，在校园祭上，其他人脸上的 × 褪去，BGM渲染到高潮，男主潸然泪下，才让我们明白了这部电影表达的东西。not only about （霸凌、残疾……）or whatsoever.</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>Python Learning</title>
    <url>/2018/05/12/python-learning/</url>
    <content><![CDATA[<h1 id="Basic-1"><a href="#Basic-1" class="headerlink" title="Basic 1"></a>Basic 1</h1><p>格式控制符语法、列表 list、判断、循环、字典 dictionary、函数、函数返回元组并赋给各个变量、默认参数、可变长度参数、递归：汉诺塔</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 廖雪峰的官方网站 python教材 1~4章</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式控制符语法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello, %s, you have %d dollars&#x27;</span> % (<span class="string">&#x27;mickael&#x27;</span>, 1000))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello, &#123;0:s&#125;, your grade &#123;1:.1f&#125;%&#x27;</span>.format(<span class="string">&#x27;xiaoming&#x27;</span>, 17.125))</span><br><span class="line"></span><br><span class="line">s1 = 72</span><br><span class="line">s2 = 85</span><br><span class="line">improve = (s2-s1)/s1 * 100</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello, &#123;0:s&#125;, your grade improved by &#123;1:.1f&#125;%&#x27;</span>.format(<span class="string">&quot;xiaoming&quot;</span>, improve));</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表 list</span></span><br><span class="line"></span><br><span class="line">classmate = [<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;xiaozhao&#x27;</span>,<span class="string">&#x27;xiaohong&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(classmate)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(len(classmate))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(classmate[1])</span><br><span class="line"></span><br><span class="line">classmate.insert(1,<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classmate)</span><br><span class="line"></span><br><span class="line">classmate.pop()</span><br><span class="line"><span class="built_in">print</span>(classmate)</span><br><span class="line"></span><br><span class="line">classmate.pop(1)</span><br><span class="line"><span class="built_in">print</span>(classmate)</span><br><span class="line"></span><br><span class="line">classmate[1] = <span class="string">&quot;Sarah&quot;</span></span><br><span class="line"><span class="built_in">print</span>(classmate)</span><br><span class="line"></span><br><span class="line">L = [<span class="string">&#x27;apple&#x27;</span>, 123, <span class="literal">True</span>]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断</span></span><br><span class="line"></span><br><span class="line">age = 3</span><br><span class="line"><span class="keyword">if</span> age&gt;= 18:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;adult&quot;</span>)</span><br><span class="line"></span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;teenager&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kids&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;your age is&quot;</span>, age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成 int</span></span><br><span class="line"></span><br><span class="line">birth = input(<span class="string">&#x27;birth: &#x27;</span>)</span><br><span class="line">birth = int(birth)</span><br><span class="line"><span class="keyword">if</span> birth &lt; 2000:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;00qian&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;00hou&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> list(range(5)):</span><br><span class="line">    sum = sum + x</span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line"></span><br><span class="line">alphobets = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> alphobets:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line">i = 0</span><br><span class="line"><span class="keyword">while</span>(i&lt;101):</span><br><span class="line">    sum += i</span><br><span class="line">    i += 1</span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line"></span><br><span class="line">L = [<span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> L:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, %s!&quot;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典 dictionary</span></span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>:95, <span class="string">&#x27;Bob&#x27;</span>:75, <span class="string">&#x27;Tracy&#x27;</span>:85&#125;</span><br><span class="line">d[<span class="string">&#x27;Adam&#x27;</span>] = 67</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;Adma&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"></span><br><span class="line">def myabs(x):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> x&gt;=0:</span><br><span class="line">        return x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        return -x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myabs(111))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数返回元组</span></span><br><span class="line"></span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def move(x, y, <span class="keyword">step</span>, <span class="attribute">angle</span>=0):</span><br><span class="line">    nx = x + <span class="keyword">step</span> * math.cos(angle)</span><br><span class="line">    ny = y + <span class="keyword">step</span> * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别赋给每个变量</span></span><br><span class="line"></span><br><span class="line">x, y = move(100,100,60,math.pi/6)</span><br><span class="line"><span class="built_in">print</span>(x,y)</span><br><span class="line"></span><br><span class="line">def quadratic(a,b,c):</span><br><span class="line">    delta = b<span class="number">*b</span> - 4<span class="number">*a</span><span class="number">*c</span></span><br><span class="line">    x1 = (-b + math.sqrt(delta)) / (2 * a)</span><br><span class="line">    x2 = (-b - math.sqrt(delta)) / (2 * a)</span><br><span class="line">    return x1, x2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;quadratic(2, 3, 1) =&#x27;</span>, quadratic(2, 3, 1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;quadratic(1, 3, -4) =&#x27;</span>, quadratic(1, 3, -4))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> quadratic(2, 3, 1) != (-0.5, -1.0):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败&#x27;</span>)</span><br><span class="line">elif quadratic(1, 3, -4) != (1.0, -4.0):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#def power(x):</span></span><br><span class="line">   # return x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认参数</span></span><br><span class="line"></span><br><span class="line">def power(x,<span class="attribute">n</span>=2):</span><br><span class="line">    s = 1</span><br><span class="line">    <span class="keyword">while</span> n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(power(5))</span><br><span class="line"><span class="built_in">print</span>(power(5,3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变长度参数</span></span><br><span class="line"></span><br><span class="line">def clac(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(clac(1,2))</span><br><span class="line"><span class="built_in">print</span>(clac())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归：汉诺塔</span></span><br><span class="line"><span class="comment"># 参数n，表示初始时，3个柱子a、b、c中第1个柱子a上的盘子数量，</span></span><br><span class="line"><span class="comment"># 打印出把所有盘子从A借助B移动到C的方法</span></span><br><span class="line">def move(n, a, b, c):</span><br><span class="line">    <span class="keyword">if</span> n == 1:</span><br><span class="line">        <span class="built_in">print</span>(a, <span class="string">&#x27;--&gt;&#x27;</span>, c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        move(n-1,a,c,b)</span><br><span class="line">        <span class="built_in">print</span>(a,<span class="string">&#x27;--&gt;&#x27;</span>,c)</span><br><span class="line">        move(n-1,b,a,c)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">move(3,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Basic-2"><a href="#Basic-2" class="headerlink" title="Basic 2"></a>Basic 2</h1><p>切片、迭代 Iterable Iterator、列表生成式、生成器 yield</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">L = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取前3个元素的笨方法</span></span><br><span class="line"></span><br><span class="line">r = []</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    r.append(L[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line"><span class="comment"># 从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</span></span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">0</span>:<span class="number">3</span>]) </span><br><span class="line"><span class="built_in">print</span>(L[:<span class="number">3</span>]) <span class="comment">#如果第一个索引是0，还可以省略：</span></span><br><span class="line"><span class="built_in">print</span>(L[-<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(L[:<span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(L[-<span class="number">10</span>:])</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">10</span>:<span class="number">20</span>])</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">0</span>:<span class="number">10</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(L[::<span class="number">5</span>])</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ABCDEFG&#x27;</span>[:<span class="number">3</span>])    </span><br><span class="line"></span><br><span class="line"><span class="comment">#利用切片操作，实现一个trim()函数，去除字符串首尾的空格</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trim</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    length = <span class="built_in">len</span>(s)</span><br><span class="line">    j = length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(s[i]==<span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> i &lt; length - <span class="number">1</span>):</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s[j]==<span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> j &gt;= <span class="number">1</span>):</span><br><span class="line">        j = j - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[i:j+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="keyword">if</span> trim(<span class="string">&#x27;hello  &#x27;</span>) != <span class="string">&#x27;hello&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> trim(<span class="string">&#x27;  hello&#x27;</span>) != <span class="string">&#x27;hello&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> trim(<span class="string">&#x27;  hello  &#x27;</span>) != <span class="string">&#x27;hello&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> trim(<span class="string">&#x27;  hello  world  &#x27;</span>) != <span class="string">&#x27;hello  world&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> trim(<span class="string">&#x27;&#x27;</span>) != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> trim(<span class="string">&#x27;    &#x27;</span>) != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="comment"># 很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代</span></span><br><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span> , <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(key, d[key])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&quot;ABC&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何判断一个对象是可迭代对象呢？</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>,Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;123&#x27;</span>,Iterable))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现下标循环</span></span><br><span class="line"><span class="comment"># enumerate函数可以把一个list变成索引-元素对</span></span><br><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]):</span><br><span class="line">    <span class="built_in">print</span>(i,value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环里，同时引用了两个变量，在Python里是很常见的</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">9</span>)]:</span><br><span class="line">    <span class="built_in">print</span>(x,y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请使用迭代查找一个list中最小和最大值，并返回一个tuple：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findMinAndMax</span>(<span class="params">L</span>):</span><br><span class="line">    <span class="keyword">if</span> L == []:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">min</span> = <span class="built_in">max</span> = L[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="built_in">max</span>:</span><br><span class="line">            <span class="built_in">max</span> = x</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="built_in">min</span>:</span><br><span class="line">            <span class="built_in">min</span> = x</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>,<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> findMinAndMax([]) != (<span class="literal">None</span>, <span class="literal">None</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> findMinAndMax([<span class="number">7</span>]) != (<span class="number">7</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> findMinAndMax([<span class="number">7</span>, <span class="number">1</span>]) != (<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> findMinAndMax([<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>]) != (<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表生成式 List Comprehensions</span></span><br><span class="line"><span class="comment"># Python内置的非常简单却强大的可以用来创建list的生成式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1x1, 2x2, 3x3, ..., 10x10]</span></span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    L.append(x*x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表生成式则可以用一行语句代替循环生成上面的list</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</span></span><br><span class="line"><span class="comment"># for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 笛卡尔积</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环其实可以同时使用两个甚至多个变量</span></span><br><span class="line"><span class="comment"># 列表生成式也可以使用两个变量来生成list：</span></span><br><span class="line">d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>([k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表中所有字符串变成小写</span></span><br><span class="line">L = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>([s.lower() <span class="keyword">for</span> s  <span class="keyword">in</span> L])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习：如果list中既包含字符串，又包含整数，会报错</span></span><br><span class="line"><span class="comment"># 使用内建的isinstance函数可以判断一个变量是不是字符串：</span></span><br><span class="line"><span class="comment"># 修改列表生成式，在其中加上if语句保证可以正确执行 </span></span><br><span class="line"></span><br><span class="line">L1 = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="literal">None</span>]</span><br><span class="line">L2 = [s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L1 <span class="keyword">if</span> <span class="built_in">isinstance</span>(s, <span class="built_in">str</span>)]</span><br><span class="line">L3 = [s <span class="keyword">for</span> s <span class="keyword">in</span> L1 <span class="keyword">if</span> <span class="built_in">isinstance</span>(s,<span class="built_in">int</span>)]</span><br><span class="line"><span class="built_in">print</span>(L3)</span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="built_in">print</span>(L2)</span><br><span class="line"><span class="keyword">if</span> L2 == [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试通过!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 生成器</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</span></span><br><span class="line"><span class="string">所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</span></span><br><span class="line"></span><br><span class="line">L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="built_in">print</span>(g) <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x02587F60&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过next()函数获得generator的下一个返回值：</span></span><br><span class="line"><span class="comment"># generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，</span></span><br><span class="line"><span class="comment"># 没有更多的元素时，抛出StopIteration的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注意，赋值语句：</span></span><br><span class="line"><span class="string">a, b = b, a + b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">相当于：</span></span><br><span class="line"><span class="string">t = (b, a + b) # t是一个tuple</span></span><br><span class="line"><span class="string">a = t[0]</span></span><br><span class="line"><span class="string">b = t[1]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">fib(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上述函数改造成 generator</span></span><br><span class="line"><span class="comment"># 只需要把print(b)改为yield b就可以了：</span></span><br><span class="line"><span class="comment"># 变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib1</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line">f = fib(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单例子 依次返回数字 1 3 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 1&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</span></span><br><span class="line">o = odd()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(o))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(o))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(o))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行3次yield后，已经没有yield可以执行了。第4次调用next(o)就报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 杨辉三角</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">          1</span></span><br><span class="line"><span class="string">         / \</span></span><br><span class="line"><span class="string">        1   1</span></span><br><span class="line"><span class="string">       / \ / \</span></span><br><span class="line"><span class="string">      1   2   1</span></span><br><span class="line"><span class="string">     / \ / \ / \</span></span><br><span class="line"><span class="string">    1   3   3   1</span></span><br><span class="line"><span class="string">   / \ / \ / \ / \</span></span><br><span class="line"><span class="string">  1   4   6   4   1</span></span><br><span class="line"><span class="string"> / \ / \ / \ / \ / \</span></span><br><span class="line"><span class="string">1   5   10  10  5   1</span></span><br><span class="line"><span class="string">把每一行看做一个list，试写一个generator，不断输出下一行的list：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">triangles</span>():</span><br><span class="line">    N = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> N</span><br><span class="line">        N.append(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># print(N)</span></span><br><span class="line">        N = [N[i-<span class="number">1</span>] + N[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(N))]</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> triangles():</span><br><span class="line">     <span class="built_in">print</span>(t)</span><br><span class="line">     n = n + <span class="number">1</span></span><br><span class="line">     <span class="keyword">if</span> n == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 期待输出:</span></span><br><span class="line"><span class="comment"># [1]</span></span><br><span class="line"><span class="comment"># [1, 1]</span></span><br><span class="line"><span class="comment"># [1, 2, 1]</span></span><br><span class="line"><span class="comment"># [1, 3, 3, 1]</span></span><br><span class="line"><span class="comment"># [1, 4, 6, 4, 1]</span></span><br><span class="line"><span class="comment"># [1, 5, 10, 10, 5, 1]</span></span><br><span class="line"><span class="comment"># [1, 6, 15, 20, 15, 6, 1]</span></span><br><span class="line"><span class="comment"># [1, 7, 21, 35, 35, 21, 7, 1]</span></span><br><span class="line"><span class="comment"># [1, 8, 28, 56, 70, 56, 28, 8, 1]</span></span><br><span class="line"><span class="comment"># [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">可以直接作用于for循环的数据类型有以下几种：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">一类是集合数据类型，如list、tuple、dict、set、str等；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">一类是generator，包括生成器和带yield的generator function。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为什么list、dict、str等数据类型不是Iterator？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">总结：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">凡是可作用于for循环的对象都是Iterable类型；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Python的for循环本质上就是通过不断调用next()函数实现的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h1><p>函数可以是变量、简单的函数式编程、map/reduce、filter()、排序、函数作为返回值、匿名函数lambda、装饰器、偏函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(-<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数可以是变量</span></span><br><span class="line">f = <span class="built_in">abs</span></span><br><span class="line">f(-<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y,f</span>):</span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br><span class="line"></span><br><span class="line">x = -<span class="number">5</span></span><br><span class="line">y = <span class="number">6</span></span><br><span class="line">f = <span class="built_in">abs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的函数式编程</span></span><br><span class="line"><span class="built_in">print</span>(add(x,y,f))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高阶函数</span></span><br><span class="line"><span class="comment"># map/reduce</span></span><br><span class="line"><span class="comment"># map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">r = <span class="built_in">map</span>(f, <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># reduce</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，</span></span><br><span class="line"><span class="comment">#这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</span></span><br><span class="line"><span class="comment">#reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">r = reduce(add, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line"></span><br><span class="line">r = reduce(fn,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配合map 写一个把str转换成int的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):</span><br><span class="line">    digits = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> digits[s]</span><br><span class="line"></span><br><span class="line">r = reduce(fn,<span class="built_in">map</span>(char2num,<span class="string">&#x27;13579&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line">DIGITS = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> DIGITS[s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, <span class="built_in">map</span>(char2num, s))</span><br><span class="line"></span><br><span class="line">r = char2num(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line">r = str2int(<span class="string">&#x27;13579&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。</span></span><br><span class="line"><span class="comment"># 输入：[&#x27;adam&#x27;, &#x27;LISA&#x27;, &#x27;barT&#x27;]，输出：[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name.capitalize()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line">L1 = [<span class="string">&#x27;adam&#x27;</span>, <span class="string">&#x27;LISA&#x27;</span>, <span class="string">&#x27;barT&#x27;</span>]</span><br><span class="line">L2 = <span class="built_in">list</span>(<span class="built_in">map</span>(normalize, L1))</span><br><span class="line"><span class="built_in">print</span>(L2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python提供的sum()函数可以接受一个list并求和，</span></span><br><span class="line"><span class="comment"># 请编写一个prod()函数，可以接受一个list并利用reduce()求积：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prod</span>(<span class="params">L</span>):</span><br><span class="line">    <span class="keyword">return</span> reduce(func , L)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;3 * 5 * 7 * 9 =&#x27;</span>, prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))</span><br><span class="line"><span class="keyword">if</span> prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]) == <span class="number">945</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用map和reduce编写一个str2float函数</span></span><br><span class="line"><span class="comment"># 把字符串&#x27;123.456789&#x27;转换成浮点数123.456789：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2float</span>(<span class="params">s</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 思路：map 将 123.456789 变为 123456798，即利用字符串的切片跳过小数点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> DIGITS[s]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># n = s.index(&#x27;.&#x27;) 取得小数点的下标 n = 3</span></span><br><span class="line">    n = s.index(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reduce 函数把[123456789]变为整数之后，除以 10 ^ n1， n1 = len(s) - n - 1 = 10 - 3 - 1 = 6</span></span><br><span class="line">    n1 = <span class="built_in">len</span>(s) - n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x*<span class="number">10</span>+y,<span class="built_in">map</span>(char2num,s[:n]+s[n+<span class="number">1</span>:]))/(<span class="number">10</span>**n1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;str2float(\&#x27;123.456789\&#x27;) =&#x27;</span>, str2float(<span class="string">&#x27;123.456789&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(str2float(<span class="string">&#x27;123.456789&#x27;</span>) - <span class="number">123.456789</span>) &lt; <span class="number">0.00001</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤器</span></span><br><span class="line"><span class="comment"># Python内建的filter()函数用于过滤序列。</span></span><br><span class="line"><span class="comment"># 接受一个函数和一个序列，函数依次作用于序列里的每个元素，根据返回值是 True 还是 False 来决定保留还是丢弃该元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n%<span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">filter</span>(is_odd, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter()函数返回的是一个Iterator</span></span><br><span class="line"><span class="comment"># 需要用list()函数获得所有结果并返回list。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个序列中的空字符</span></span><br><span class="line"><span class="comment"># Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）。返回移除字符串头尾指定的字符生成的新字符串。</span></span><br><span class="line"><span class="comment"># 空串(&quot;&quot;)为False,其他所有字符串皆为True </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">not_empty</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line"></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">filter</span>(not_empty, [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="literal">None</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27; &#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter 求素数 埃氏筛法</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">首先，列出从2开始的所有自然数，构造一个序列：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">取新序列的第一个数5，然后用5把序列的5的倍数筛掉：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">不断筛下去，就可以得到所有的素数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># _odd_iter : 从 3 开始的奇数序列生成器 Iterator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_odd_iter</span>():</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_not_divisiable</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x : x % n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器 不断返回下一个素数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">primes</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter() <span class="comment"># Iterator</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="built_in">next</span>(it) <span class="comment"># Iterator 的第一项</span></span><br><span class="line">        <span class="keyword">yield</span> n </span><br><span class="line">        it = <span class="built_in">filter</span>(_not_divisiable(n),it) <span class="comment"># 能跟第一项整除的就过滤掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印20之内的素数</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">20</span>:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习：</span></span><br><span class="line"><span class="comment"># 回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_iter_</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n </span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">palindrome</span>(<span class="params">n</span>):</span><br><span class="line">    s = <span class="built_in">str</span>(n)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;j:</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">output = <span class="built_in">filter</span>(palindrome, <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">200</span>))</span><br><span class="line">L = <span class="built_in">list</span>(output)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sorted 排序算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Python内置的sorted()函数就可以对list进行排序：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>], key=<span class="built_in">abs</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串排序</span></span><br><span class="line"></span><br><span class="line">L = <span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略大小写排序：</span></span><br><span class="line"><span class="comment"># 即需要key这个函数应用到所有元素上，都变成小写，再比较，所以就是：</span></span><br><span class="line"></span><br><span class="line">L = <span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆序</span></span><br><span class="line"></span><br><span class="line">L = <span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习：</span></span><br><span class="line"><span class="comment"># 用一组tuple表示学生名字和成绩：</span></span><br><span class="line"><span class="comment"># 请用sorted()对上述列表分别按名字、按成绩排序</span></span><br><span class="line"></span><br><span class="line">L = [(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>), (<span class="string">&#x27;Adam&#x27;</span>, <span class="number">92</span>), (<span class="string">&#x27;Bart&#x27;</span>, <span class="number">66</span>), (<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">88</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># tips 选取元组中的元素方法同数组。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">by_name</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">by_grade</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">L2 = <span class="built_in">sorted</span>(L,key=by_name)</span><br><span class="line"><span class="built_in">print</span>(L2)</span><br><span class="line"></span><br><span class="line">L2 = <span class="built_in">sorted</span>(L,key=by_grade)</span><br><span class="line"><span class="built_in">print</span>(L2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数作为返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高阶函数可以接受函数作为参数，也可以把函数当做结果返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变参数求和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_sum</span>(<span class="params">*args</span>):</span><br><span class="line">    ax = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">        ax = ax + n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lazy_sum</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">        ax = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</span></span><br><span class="line"></span><br><span class="line">f = lazy_sum(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(f)   <span class="comment"># &lt;function lazy_sum.&lt;locals&gt;.sum at 0x0227E8E8&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再调用 f 才是真正计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数 &amp; lambda 演算子</span></span><br><span class="line"><span class="comment"># 传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</span></span><br><span class="line"><span class="comment"># Python中，对匿名函数提供了有限支持。</span></span><br><span class="line"></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数lambda x: x * x实际上就是：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</span></span><br><span class="line"></span><br><span class="line">f1 = <span class="keyword">lambda</span> x : x * x</span><br><span class="line"></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">map</span>(f1, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样，也可以把匿名函数作为返回值返回，比如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习：请用匿名函数改造下面的代码：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">filter</span>(is_odd, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>)))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x % <span class="number">2</span> == <span class="number">1</span>, <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>)))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数也是一个对象</span></span><br><span class="line"><span class="comment"># 函数有一个 __name__ 属性可以拿到函数的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2018-05-02&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(now.__name__)</span><br><span class="line">f = now</span><br><span class="line"><span class="built_in">print</span>(f.__name__)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，</span></span><br><span class="line"><span class="string">这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本质上，decorator就是一个返回函数的高阶函数。</span></span><br><span class="line"><span class="comment"># *args: 可变参数</span></span><br><span class="line"><span class="comment"># **kw: 关键字参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 借助Python的@语法，把decorator置于函数的定义处：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2018-05-02&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用now1()函数，不仅会运行now1()函数本身，还会在运行now1()函数前打印一行日志：</span></span><br><span class="line"><span class="comment"># 把@log放到now1()函数的定义处，相当于执行了语句：now1 = log(now1)</span></span><br><span class="line"></span><br><span class="line">now()</span><br><span class="line">now1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">由于log()是一个decorator，接受的参数就是原来的now，所以，原来的now1()函数仍然存在，</span></span><br><span class="line"><span class="string">只是现在同名的now1变量指向了新的函数，于是调用now1()将执行新函数，即在log()函数中返回的wrapper()函数。</span></span><br><span class="line"><span class="string">在wrapper()函数内，首先打印日志，再紧接着调用原始now1函数。</span></span><br><span class="line"><span class="string">log()会返回一个函数，就是wrapper。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，自定义log的文本</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个3层嵌套的decorator用法如下：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2018-05-02&#x27;</span>)</span><br><span class="line"></span><br><span class="line">now2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># To be completed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, base = <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，</span></span><br><span class="line"><span class="comment"># 于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">int2</span>(<span class="params">x, base = <span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(x, base)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(int2(<span class="string">&#x27;10000000&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(int2(<span class="string">&#x27;10101010&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># functools.partial就是帮助我们创建一个偏函数的，</span></span><br><span class="line"><span class="comment"># 不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">int2 = functools.partial(<span class="built_in">int</span>, base = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(int2(<span class="string">&#x27;10000000&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(int2(<span class="string">&#x27;10101010&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(int2(<span class="string">&#x27;10000000&#x27;</span>,base=<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(int2(<span class="string">&#x27;10101010&#x27;</span>,base=<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">传入：</span></span><br><span class="line"><span class="string">int2 = functools.partial(int, base=2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">实际上固定了int()函数的关键字参数base，也就是：</span></span><br><span class="line"><span class="string">int2(&#x27;10010&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">相当于：</span></span><br><span class="line"><span class="string">kw = &#123; &#x27;base&#x27;: 2 &#125;</span></span><br><span class="line"><span class="string">int(&#x27;10010&#x27;, **kw)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当传入：</span></span><br><span class="line"><span class="string">max2 = functools.partial(max, 10)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">实际上会把10作为*args的一部分自动加到左边，也就是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">max2(5, 6, 7)</span></span><br><span class="line"><span class="string">相当于：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">args = (10, 5, 6, 7)</span></span><br><span class="line"><span class="string">max(*args)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">结果为10。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</span></span><br></pre></td></tr></table></figure>
<h1 id="OOP1"><a href="#OOP1" class="headerlink" title="OOP1"></a>OOP1</h1><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    # 构造函数</span><br><span class="line">    # 第一个参数永远是 self 表示一个实例本身，但是传参的时候不需要传</span><br><span class="line">    # 在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    # 可以用 self 来表示类似 this 指针的作用</span><br><span class="line">    def print_score(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bart = Student(<span class="string">&#x27;Bart&#x27;</span>, 59)</span><br><span class="line">lisa = Student(<span class="string">&#x27;Lisa&#x27;</span>, 89)</span><br><span class="line">bart.print_score()</span><br><span class="line">lisa.print_score()</span><br><span class="line"></span><br><span class="line"><span class="comment"># class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的</span></span><br><span class="line"><span class="comment"># 通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</span></span><br><span class="line"><span class="comment"># 创建实例是通过类名+()实现的</span></span><br><span class="line"><span class="comment"># 可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：</span></span><br><span class="line"></span><br><span class="line">bart.sno = 111500206</span><br><span class="line"><span class="built_in">print</span>(bart.sno)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承与多态</span></span><br><span class="line"></span><br><span class="line">class Animal(object):</span><br><span class="line">    def <span class="built_in">run</span>(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal is running.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def <span class="built_in">run</span>(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Dog is running.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def <span class="built_in">run</span>(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cat is running&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">dog.<span class="built_in">run</span>()</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.<span class="built_in">run</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断一个变量是否是某个类型可以用isinstance()判断：</span></span><br><span class="line">a = [1,2,3]</span><br><span class="line"><span class="built_in">print</span>(isinstance(a, list))</span><br><span class="line"><span class="built_in">print</span>(isinstance(dog, Animal))</span><br><span class="line"><span class="built_in">print</span>(isinstance(dog, Dog))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(isinstance(dog,Animal)) # 子类实例也是基类的实例</span><br><span class="line"></span><br><span class="line">def run_twice(animal):</span><br><span class="line">    animal.<span class="built_in">run</span>()</span><br><span class="line">    animal.<span class="built_in">run</span>()</span><br><span class="line"></span><br><span class="line">run_twice(Animal())</span><br><span class="line">run_twice(Dog())</span><br><span class="line">run_twice(Cat())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果以后新增 Animal 的子类，则不需要对 run_twice 进行任何修改</span></span><br><span class="line"><span class="comment"># 这就是著名的“开闭”原则：对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</span></span><br><span class="line"></span><br><span class="line">class Tortoise(Animal):</span><br><span class="line">    def <span class="built_in">run</span>(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Tortoise is running slowly...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">run_twice(Tortoise())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tip：</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得对象信息</span></span><br><span class="line"><span class="comment"># 判断对象类型，使用type()函数：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(type(123))</span><br><span class="line"><span class="built_in">print</span>(type(<span class="string">&#x27;str&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(type(abs))</span><br><span class="line"><span class="built_in">print</span>(type(a))</span><br><span class="line"><span class="built_in">print</span>(type(dog))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(type(123) == type(456))</span><br><span class="line"><span class="built_in">print</span>(type(123) == int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断一个对象是否是函数</span></span><br><span class="line"></span><br><span class="line">import types</span><br><span class="line">def fn():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(type(fn) == types.FunctionType)</span><br><span class="line"><span class="built_in">print</span>(type(abs) == types.BuiltinFunctionType)</span><br><span class="line"><span class="built_in">print</span>(type(lambda x : x) == types.LambdaType)</span><br><span class="line"><span class="built_in">print</span>(type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(10)))==types.GeneratorType)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于class的继承关系来说 ，可以使用isinstance()函数判断class的类型</span></span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def <span class="built_in">run</span>(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Husky is running&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = Animal()</span><br><span class="line">d = Dog()</span><br><span class="line">h = Husky()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;isinstance test&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(isinstance(h, Husky))</span><br><span class="line"><span class="built_in">print</span>(isinstance(d, Dog) <span class="keyword">and</span> isinstance(d, Animal))</span><br><span class="line"><span class="built_in">print</span>(isinstance(d, Husky))</span><br><span class="line"></span><br><span class="line"><span class="comment"># isinstance  也可以当 type 有类似用法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(isinstance(<span class="string">&#x27;a&#x27;</span>, str))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以判断一个变量是否是某些类型中的一种</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(isinstance([1,2,3],(list,tuple)))</span><br><span class="line"><span class="built_in">print</span>(isinstance((1,2),(list,tuple)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要获得一个对象的所有属性和方法，可以使用dir()函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dir(<span class="string">&#x27;ABC&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(dir(h))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; len(&#x27;</span>ABC<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; &#x27;</span>ABC<span class="string">&#x27;.__len__()</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其余的则是 普通属性或方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：</span></span><br><span class="line"></span><br><span class="line">class pig(Animal):</span><br><span class="line">    def __len__(self):</span><br><span class="line">        return 100</span><br><span class="line"></span><br><span class="line">p = pig()</span><br><span class="line"><span class="built_in">print</span>(len(p))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例属性和类属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于Python是动态语言，根据类创建的实例可以任意绑定属性。</span></span><br><span class="line"></span><br><span class="line">class Undergraduate(object):</span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br><span class="line"></span><br><span class="line">s = Undergraduate()</span><br><span class="line"><span class="built_in">print</span>(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line"><span class="built_in">print</span>(Undergraduate.name) # 类的 name 属性</span><br><span class="line">s.name = <span class="string">&quot;Michael&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.name) </span><br><span class="line"></span><br><span class="line">del s.name # # 如果删除实例的name属性</span><br><span class="line"><span class="built_in">print</span>(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习：</span></span><br><span class="line"><span class="comment"># 为了统计学生人数，可以增加一个类属性，每创建一个实例，该属性自动增加：</span></span><br><span class="line"></span><br><span class="line">class Undergraduate(object):</span><br><span class="line">    count = 0</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">        Undergraduate.count += 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Undergraduate.count != 0:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    bart = Undergraduate(<span class="string">&#x27;Bart&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> Undergraduate.count != 1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lisa = Undergraduate(<span class="string">&#x27;Bart&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> Undergraduate.count != 2:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Undergraduates:&#x27;</span>, Undergraduate.count)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;测试通过!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="OOP2"><a href="#OOP2" class="headerlink" title="OOP2"></a>OOP2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.name = <span class="string">&#x27;Chang&#x27;</span> <span class="comment"># 给一个实例动态绑定一个属性</span></span><br><span class="line"><span class="built_in">print</span>(s.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age</span>):</span><br><span class="line">    self.age = age</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">s.set_age = MethodType(set_age, s) <span class="comment"># 给一个实例动态绑定一个方法</span></span><br><span class="line">s.set_age(<span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(s.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s2 = Student()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">s2.set_age(25) # 会报错</span></span><br><span class="line"><span class="string">给一个实例动态绑定的方法对另一个实例不起作用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line">    self.score = score</span><br><span class="line"></span><br><span class="line">Student.set_score = set_score <span class="comment"># 给所有实例都绑定方法，可以给class绑定方法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给class绑定方法后，所有实例均可调用：</span></span><br><span class="line"></span><br><span class="line">s.set_score(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(s.score)</span><br><span class="line"></span><br><span class="line">s2.set_score(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(s2.score)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __slots__ ： 限制实例的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.name = <span class="string">&#x27;Michael&#x27;</span></span><br><span class="line">s.age = <span class="number">25</span></span><br><span class="line"><span class="comment"># s.score = 99 # 报错 AttributeError: &#x27;Student&#x27; object has no attribute &#x27;score&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">GraduateStudent</span>(<span class="title class_ inherited__">Student</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">g = GraduateStudent()</span><br><span class="line">g.score = <span class="number">9999</span> <span class="comment"># __slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用@property 来进行输入检测</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.age = <span class="number">9999</span> <span class="comment"># 这显然不合理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通的方法就是在构造函数里加限制条件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 and 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.set_score(<span class="number">60</span>) <span class="comment"># ok</span></span><br><span class="line"><span class="built_in">print</span>(s.get_score()) <span class="comment"># 60</span></span><br><span class="line"><span class="comment"># s.set_score(9999) # error</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然而上述调用方式稍显复杂，能不能用类似 属性 这样简单的方式来访问类的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python内置的@property装饰器就是负责把一个方法变成属性调用的：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># getter 变成属性，加上一行 @property 就可以了</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</span></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span> <span class="comment"># score.setter</span></span><br><span class="line"><span class="built_in">print</span>(s.score) <span class="comment"># score</span></span><br><span class="line"><span class="comment"># s.score = 9999 报 typeerror 错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义只读属性：只定义 getter 不定义 setter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._birth = value</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2018</span> - self._birth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的birth是可读写属性，而age就是一个只读属性</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.birth = <span class="number">1996</span></span><br><span class="line"><span class="built_in">print</span>(s.birth)</span><br><span class="line"><span class="built_in">print</span>(s.age)</span><br><span class="line"><span class="comment"># s.age = 100 # 报错：can&#x27;t set attribute</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习：</span></span><br><span class="line"><span class="comment"># 请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">width</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._width <span class="comment"># 变量名和函数名要区分开，不然会死循环</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @width.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">width</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._width = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._height</span><br><span class="line"></span><br><span class="line"><span class="meta">    @height.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._height = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolution</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._width * self._height <span class="comment"># 一个和C++很不相同的地方，在类内写属性也要加 slef. 前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line">s = Screen()</span><br><span class="line">s.width = <span class="number">1024</span></span><br><span class="line">s.height = <span class="number">768</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;resolution =&#x27;</span>, s.resolution)</span><br><span class="line"><span class="keyword">if</span> s.resolution == <span class="number">786432</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试通过!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多重继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># 基类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span>(<span class="title class_ inherited__">Animal</span>): <span class="comment"># 哺乳动物</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="title class_ inherited__">Animal</span>): <span class="comment"># 鸟类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runnable</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># 能跑</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyable</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># 能飞</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Flying...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(Mammal, Runnable): <span class="comment"># 狗</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span>(Mammal, Flyable): <span class="comment"># 蝙蝠</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span>(Bird, Flyable): <span class="comment"># 鹦鹉</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span>(Bird, Runnable): <span class="comment"># 鸵鸟</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MixIn</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 比如，编写一个多进程模式的TCP服务，定义如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class MyTCPServer(TCPServer, ForkingMixIn):</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 编写一个多线程模式的UDP服务，定义如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class MyUDPServer(UDPServer, ThreadingMixIn):</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定制类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Student(<span class="string">&#x27;Micheal&#x27;</span>)) <span class="comment"># &lt;__main__.Student object at 0x00000140EEBFC320&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义打印实例信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s)&#x27;</span> % self.name</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__ <span class="comment"># __str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Student(<span class="string">&#x27;Micheal&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># __iter__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a = <span class="number">0</span> </span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration() <span class="comment"># 迭代的停止条件</span></span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __getitem__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行</span></span><br><span class="line"><span class="comment"># 不能通过 Fib()[5] 取元素</span></span><br><span class="line"><span class="comment"># 要想使用下标来取元素，需要实现 __getitem__() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">f = Fib()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(f[x])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(n) == <span class="built_in">int</span>:</span><br><span class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(n) == <span class="built_in">slice</span>:</span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                start = <span class="number">0</span></span><br><span class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(stop):</span><br><span class="line">                <span class="keyword">if</span> x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">f = Fib()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(f[x])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(f[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。</span></span><br><span class="line"><span class="comment"># 最后，还有一个__delitem__()方法，用于删除某个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __getattr__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。</span></span><br><span class="line"><span class="comment"># 要避免这个错误，除了可以加上这个属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;Michael&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;score&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span></span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>:<span class="number">24</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;no such a attribute.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, &#x27;score&#x27;)来尝试获得属性，这样，我们就有机会返回score的值：</span></span><br><span class="line"><span class="comment"># 注意，只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line"><span class="built_in">print</span>(s.name)</span><br><span class="line"><span class="built_in">print</span>(s.score)</span><br><span class="line"><span class="built_in">print</span>(s.age()) <span class="comment"># 返回函数也可以，但相应的调用方式要变</span></span><br><span class="line"><span class="comment"># print(s.abc)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __call__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在实例本身上调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;My name is %s&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&quot;chang&quot;</span>)</span><br><span class="line">s()</span><br><span class="line"></span><br><span class="line"><span class="comment"># __call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用</span></span><br><span class="line"><span class="comment"># 使用 Callalbe 来判断类中有 __call__() 的类实例</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">callable</span>(s))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 中实现常量定义</span></span><br><span class="line"></span><br><span class="line">JAN = <span class="number">1</span></span><br><span class="line">FEB = <span class="number">2</span></span><br><span class="line">PI = <span class="number">3.1415</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺点是 仍是变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更好的方法是为这样的枚举类型定义一个class类型，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Month类型的枚举类，直接使用Month.Jan来引用一个常量，或者枚举它的所有成员，value属性则是自动赋给成员的int常量，默认从1开始计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br></pre></td></tr></table></figure>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Exception</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级语言通常都内置了一套try...except...finally...的错误处理机制，Python也不例外。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，</span></span><br><span class="line"><span class="comment"># 执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;result: &#x27;</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except:&#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;END&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果把除数0改成2，</span></span><br><span class="line"><span class="comment"># 由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;result: &#x27;</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except:&#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;END&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="built_in">int</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ValueError:&#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError:&#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的异常都是 class，文档：https://docs.python.org/3/library/exceptions.html#exception-hierarchy</span></span><br><span class="line"><span class="comment"># 注意：捕获异常的语句会将其子类的异常也一同捕获</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用</span></span><br><span class="line"><span class="comment"># 比如函数main()调用foo()，foo()调用bar()，结果foo()出现了除以零错误，这时，只要main()捕获到了，就可以处理： </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写try...except...finally的麻烦。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用栈</span></span><br><span class="line"><span class="comment"># 如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def foo(s):</span></span><br><span class="line"><span class="string">    return 10 / int(s)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def bar(s):</span></span><br><span class="line"><span class="string">    return foo(s) * 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def main():</span></span><br><span class="line"><span class="string">    bar(&#x27;0&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">main()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">执行，结果如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Traceback (most recent call last):  # 提示我们以下是错误跟踪信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 101, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    main() # 调用main出错了，位置是第 111 行，而原因是</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 99, in main</span></span><br><span class="line"><span class="string">    bar(&#x27;0&#x27;) # 调用 bar(&#x27;0&#x27;) 出错，位置是第 99 行，而原因是</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 96, in bar</span></span><br><span class="line"><span class="string">    return foo(s) * 2 # return foo(s) * 2这个语句出错了，但这还不是最终原因，继续往下看：</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 93, in foo</span></span><br><span class="line"><span class="string">    return 10 / int(s) # return 10 / int(s)这个语句出错了，这是错误产生的源头</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero # 我们判断，int(s)本身并没有出错，但是int(s)返回0，在计算10 / 0时出错，至此，找到错误源头。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。</span></span><br><span class="line"><span class="comment"># 既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ERROR:root:division by zero</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 137, in main</span></span><br><span class="line"><span class="string">    bar(&#x27;0&#x27;)</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 133, in bar</span></span><br><span class="line"><span class="string">    return foo(s) * 2</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 130, in foo</span></span><br><span class="line"><span class="string">    return 10 / int(s)</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string">END  # 继续打印了 END 表明程序打印完错误信息之后会继续执行并正常退出</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误是class，捕获一个错误就是捕获到该class的一个实例。</span></span><br><span class="line"><span class="comment"># 错误并不是凭空产生的，而是有意创建并抛出的。</span></span><br><span class="line"><span class="comment"># Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooError</span>(<span class="title class_ inherited__">ValueError</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> FooError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    logging.exception(e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 176, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    foo(&#x27;0&#x27;)</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 173, in foo</span></span><br><span class="line"><span class="string">    raise FooError(&#x27;invalid value: %s&#x27; % s)</span></span><br><span class="line"><span class="string">__main__.FooError: invalid value: 0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行下面的代码，根据异常信息进行分析，定位出错误源头，并修复：</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2num</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">exp</span>):</span><br><span class="line">    ss = exp.split(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    ns = <span class="built_in">map</span>(str2num, ss)</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> acc, x: acc + x, ns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    r = calc(<span class="string">&#x27;100 + 200 + 345&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;100 + 200 + 345 =&#x27;</span>, r)</span><br><span class="line">    r = calc(<span class="string">&#x27;99 + 88 + 7.6&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;99 + 88 + 7.6 =&#x27;</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">     main()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    logging.exception(e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">控制台输出信息如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">100 + 200 + 345 = 645</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 212, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 209, in main</span></span><br><span class="line"><span class="string">    r = calc(&#x27;99 + 88 + 7.6&#x27;)</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 204, in calc</span></span><br><span class="line"><span class="string">    return reduce(lambda acc, x: acc + x, ns)</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 199, in str2num</span></span><br><span class="line"><span class="string">    return int(s)</span></span><br><span class="line"><span class="string">ValueError: invalid literal for int() with base 10: &#x27; 7.6&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析得知：错误在于 str2num 这个函数无法把 7.6 转换成浮点数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2num</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(s)</span><br><span class="line">    <span class="keyword">else</span>:       </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">exp</span>):</span><br><span class="line">    ss = exp.split(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    ns = <span class="built_in">map</span>(str2num, ss)</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> acc, x: acc + x, ns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    r = calc(<span class="string">&#x27;100 + 200 + 345&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;100 + 200 + 345 =&#x27;</span>, r)</span><br><span class="line">    r = calc(<span class="string">&#x27;99 + 88 + 7.6&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;99 + 88 + 7.6 =&#x27;</span>, r)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Debugging</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断言</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 凡需要用到 print 来打印某个变量来查看是否正确的地方，都可以用 assert 来替代</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">&#x27;n is zero!&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># assert的意思是，assert 后面跟着的表达式应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果断言失败，assert语句本身就会抛出AssertionError</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># main()</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">控制台输出如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 279, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 272, in main</span></span><br><span class="line"><span class="string">    foo(&#x27;0&#x27;)</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 268, in foo</span></span><br><span class="line"><span class="string">    assert n != 0, &#x27;n is zero!&#x27;</span></span><br><span class="line"><span class="string">AssertionError: n is zero!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ python -O err.py</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string">关闭后，你可以把所有的assert语句当成pass来看。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># logging</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python内置的logging模块可以非常容易地记录错误信息：</span></span><br><span class="line"><span class="comment"># 还可以把print()替换为logging。</span></span><br><span class="line"><span class="comment"># 和assert比，logging不会抛出错误，而且可以输出到文件：</span></span><br><span class="line"><span class="comment"># 语句如下：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">import logging</span></span><br><span class="line"><span class="string">logging.basicConfig(level=logging.INFO)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">s = &#x27;0&#x27;</span></span><br><span class="line"><span class="string">n = int(s)</span></span><br><span class="line"><span class="string">logging.info(&#x27;n = %d&#x27; % n)</span></span><br><span class="line"><span class="string">print(10 / n)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">INFO:root:n = 0</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;python learning Error, Debug and Test.py&quot;, line 315, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(10 / n)</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pdb 单步调试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line">pdb.set_trace() <span class="comment"># 设置断点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>/n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pdb 指令：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动调试器：python -m pdb err.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入命令n可以单步执行代码：</span></span><br><span class="line"><span class="comment"># 任何时候都可以输入命令 p 变量名来查看变量：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置断点之后，直接 python err.py 就会停在断点处</span></span><br><span class="line"><span class="comment"># 命令 c 继续运行</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">C:\Users\Administrator\Desktop&gt;python err.py</span></span><br><span class="line"><span class="string">&gt; c:\users\administrator\desktop\err.py(10)&lt;module&gt;()</span></span><br><span class="line"><span class="string">-&gt; print(10/n)</span></span><br><span class="line"><span class="string">(Pdb) p n</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">(Pdb) c</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;err.py&quot;, line 10, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(10/n)</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较好用的 IDE：VSCode、PyCharm</span></span><br><span class="line"><span class="comment"># 虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="comment"># &#x27;r&#x27; 表示只读</span></span><br><span class="line">s = f.read() <span class="comment"># 调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，</span></span><br><span class="line"><span class="comment"># 所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。</span></span><br><span class="line"><span class="comment"># 也可以 用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件很小，read()一次性读取最方便；</span></span><br><span class="line"><span class="comment"># 如果不能确定文件大小，反复调用read(size)比较保险；</span></span><br><span class="line"><span class="comment"># 如果是配置文件，调用readlines()最方便</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    <span class="built_in">print</span>(line.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># file-like Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态语言没有严格的继承体系限制，只要“act like a duck” 那么就是一只鸭子。</span></span><br><span class="line"><span class="comment"># open 函数返回的是 有 read() 方法的对象。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制文件</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;laopo.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="comment"># 用&#x27;rb&#x27;模式打开二进制文件</span></span><br><span class="line"><span class="comment"># print(f.read())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f = open(&#x27;/Users/michael/gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f = open(&#x27;/Users/michael/gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;, errors=&#x27;ignore&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数改为 w 或 wb 表示写普通文件或二进制文件</span></span><br><span class="line"><span class="comment"># a 表示在文件末尾追加</span></span><br><span class="line"><span class="comment"># 具体模式定义参见文档：https://docs.python.org/3/library/functions.html#open</span></span><br><span class="line">f  = <span class="built_in">open</span>(<span class="string">&#x27;text.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小结：在Python中，文件读写是通过open()函数打开的文件对象完成的。使用with语句操作文件IO是个好习惯。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># StingIO </span></span><br><span class="line"><span class="comment"># 就是在内存中创建的临时 file-like Object，常常用作临时缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">f = StringIO()</span><br><span class="line">f.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.getvalue())</span><br><span class="line"></span><br><span class="line"><span class="comment"># BytesIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要操作二进制数据，就需要使用BytesIO。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">f = BytesIO()</span><br><span class="line">f.write(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(f.getvalue())</span><br><span class="line"></span><br><span class="line"><span class="comment"># StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作文件和目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python内置的os模块也可以直接调用操作系统提供的接口函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.name) <span class="comment"># 如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os模块的某些函数是跟操作系统相关的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(os.environ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获取某个环境变量的值，可以调用os.environ.get(&#x27;key&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(os.environ.get(&#x27;PATH&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。</span></span><br><span class="line"><span class="comment"># 查看、创建和删除目录可以这么调用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前绝对路径</span></span><br><span class="line">p = os.path.abspath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某个目录下面创建一个新目录</span></span><br><span class="line">os.mkdir(<span class="string">&quot;E://bb&quot;</span>)</span><br><span class="line">os.rmdir(<span class="string">&quot;E://bb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，os.path.join()返回这样的字符串：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">part-1/part-2</span></span><br><span class="line"><span class="string">而Windows下会返回这样的字符串：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">part-1\part-2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">r&#x27;\Users\michael&#x27;</span>, <span class="string">&#x27;testdir&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</span></span><br><span class="line"></span><br><span class="line">p = os.path.split(<span class="string">r&#x27;C:\Users\michael\testdir\file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便：</span></span><br><span class="line"></span><br><span class="line">p = os.path.splitext(<span class="string">r&#x27;C:\Users\michael\testdir\file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对文件重命名:</span></span><br><span class="line"><span class="comment"># os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;)</span></span><br><span class="line"><span class="comment"># 删掉文件:</span></span><br><span class="line"><span class="comment"># os.remove(&#x27;test.py&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何利用Python的特性来过滤文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录下的所有目录：</span></span><br><span class="line"></span><br><span class="line">L = [x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isdir(x)]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录下所有的.py后缀的文件</span></span><br><span class="line"></span><br><span class="line">L = [x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">&#x27;.py&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习</span></span><br><span class="line"><span class="comment">#实现dir -l</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mydir</span>(<span class="params">path</span>):</span><br><span class="line">  <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">    L = [(path+x) <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(path)]</span><br><span class="line">    <span class="built_in">print</span>(L)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The path not exists!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findrelapath</span>(<span class="params">path</span>):</span><br><span class="line">  <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">    L = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">      newpath = os.path.join(path,x)</span><br><span class="line">      <span class="keyword">if</span> os.path.isfile(newpath):  </span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">      <span class="keyword">elif</span> os.path.isdir(newpath):</span><br><span class="line">        findrelapath(newpath)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The path not exists!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在程序运行的过程中，所有的变量都是在内存中的</span></span><br><span class="line"><span class="comment"># 一旦程序结束，变量所占用的内存就被操作系统全部回收。</span></span><br><span class="line"><span class="comment"># 把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思</span></span><br><span class="line"><span class="comment"># 序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</span></span><br><span class="line"><span class="comment"># 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</span></span><br><span class="line"><span class="comment"># Python提供了pickle模块来实现序列化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(d))</span><br><span class="line"></span><br><span class="line"><span class="comment"># pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dump(d,f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</span></span><br><span class="line"><span class="comment"># 当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">e = pickle.load(f)</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量的内容又回来了！不过，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</span></span><br><span class="line"><span class="comment"># Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">JSON类型    Python类型</span></span><br><span class="line"><span class="string">&#123;&#125;          dict</span></span><br><span class="line"><span class="string">[]          list</span></span><br><span class="line"><span class="string">&quot;string&quot;      str</span></span><br><span class="line"><span class="string">1234.56     int 或 float</span></span><br><span class="line"><span class="string">true/false  True/False</span></span><br><span class="line"><span class="string">null          None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;json.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">json.dump(d,f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># dumps()方法返回一个str，内容就是标准的JSON。</span></span><br><span class="line"><span class="comment"># .txt 文件中的内容：&#123;&quot;name&quot;: &quot;bob&quot;, &quot;age&quot;: 20, &quot;score&quot;: 88&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要把JSON反序列化为Python对象，用loads()或者对应的load()方法，</span></span><br><span class="line"><span class="comment"># 前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;json.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">d = json.loads(s)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h1 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;00\d&#x27;可以匹配&#x27;007&#x27;，但无法匹配&#x27;00A&#x27;；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;\d\d\d&#x27;可以匹配&#x27;010&#x27;；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;\w\w\d&#x27;可以匹配&#x27;py3&#x27;；</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># .可以匹配任意字符，所以：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;py.&#x27;可以匹配&#x27;pyc&#x27;、&#x27;pyo&#x27;、&#x27;py!&#x27;等等。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用&#123;n&#125;表示n个字符，用&#123;n,m&#125;表示n-m个字符：</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">来看一个复杂的例子：\d&#123;3&#125;\s+\d&#123;3,8&#125;。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们来从左到右解读一下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\d&#123;3&#125;表示匹配3个数字，例如&#x27;010&#x27;；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配&#x27; &#x27;，&#x27; &#x27;等；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\d&#123;3,8&#125;表示3-8个数字，例如&#x27;1234567&#x27;。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果要匹配&#x27;010-12345&#x27;这样的号码呢？由于&#x27;-&#x27;是特殊字符，在正则表达式中，要用&#x27;\&#x27;转义，所以，上面的正则是\d&#123;3&#125;\-\d&#123;3,8&#125;。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要做更精确地匹配，可以用[]表示范围，比如：</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[0-9a-zA-Z\_]可以匹配 一个 数字、字母或者下划线；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[0-9a-zA-Z\_]+可以匹配至少由 一个 数字、字母或者下划线组成的字符串，比如&#x27;a100&#x27;，&#x27;0_Z&#x27;，&#x27;Py3000&#x27;等等；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接 任意个 由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[a-zA-Z\_][0-9a-zA-Z\_]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A|B可以匹配A或B，所以(P|p)ython可以匹配&#x27;Python&#x27;或者&#x27;python&#x27;。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ^表示行的开头，^\d表示必须以数字开头。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $表示行的结束，\d$表示必须以数字结束。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：^py$就变成了整行匹配，就只能匹配&#x27;py&#x27;了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re模块：Python提供re模块，包含所有正则表达式的功能。</span></span><br><span class="line"><span class="comment"># 要特别注意的是，由于Python的字符串本身也用\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.<span class="keyword">match</span>(<span class="string">r&#x27;\d&#123;3&#125;\-\d&#123;3,8&#125;$0&#x27;</span>,<span class="string">&#x27;010-12345&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。</span></span><br><span class="line"></span><br><span class="line">test = <span class="string">&#x27;010-12345&#x27;</span></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x27;</span>,<span class="string">&#x27;010-12345&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先是常见的切分代码：</span></span><br><span class="line"></span><br><span class="line">L = <span class="string">&#x27;a  b   c&#x27;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无法识别连续的空格，用正则表达式试试：</span></span><br><span class="line"></span><br><span class="line">L = re.split(<span class="string">r&#x27;\s+&#x27;</span>, <span class="string">&#x27;a  b   c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无论多少个空格都可以正常分割。加入,试试：</span></span><br><span class="line"></span><br><span class="line">L = re.split(<span class="string">r&#x27;[\s\,]+&#x27;</span>, <span class="string">&#x27;a,b, c  d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再加入;试试：</span></span><br><span class="line"></span><br><span class="line">L = re.split(<span class="string">r&#x27;[\s\,\;]+&#x27;</span>, <span class="string">&#x27;a,b;; c  d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [] 表示范围，这个串至少一个的 \s 空白符 或者,逗号 或者;分号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用()表示的就是要提取的分组（Group）。比如：</span></span><br><span class="line"></span><br><span class="line">m = re.<span class="keyword">match</span>(<span class="string">r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>, <span class="string">&#x27;010-123456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</span></span><br><span class="line"></span><br><span class="line">t = <span class="string">&#x27;19:05:30&#x27;</span></span><br><span class="line">m = re.<span class="keyword">match</span>(<span class="string">r&#x27;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&#x27;</span>, t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(m.group(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 贪婪匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。</span></span><br><span class="line"></span><br><span class="line">x = re.<span class="keyword">match</span>(<span class="string">r&#x27;^(\d+)(0*)$&#x27;</span>, <span class="string">&#x27;102300&#x27;</span>) <span class="comment"># 匹配出现在数字后的 0 串</span></span><br><span class="line"><span class="built_in">print</span>(x.group(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(x.group(<span class="number">2</span>)) <span class="comment"># 这个是空串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为\d+采用贪婪匹配，直接把后面数字全部匹配了，0*只能匹配空字符串了。</span></span><br><span class="line"><span class="comment"># 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：</span></span><br><span class="line"></span><br><span class="line">x = re.<span class="keyword">match</span>(<span class="string">r&#x27;^(\d+?)(0*)$&#x27;</span>, <span class="string">&#x27;102300&#x27;</span>) <span class="comment"># 加个?就可以让\d+采用非贪婪匹配：</span></span><br><span class="line"><span class="built_in">print</span>(x.group(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(x.group(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当我们在Python中使用正则表达式时，re模块内部会干两件事情：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">用编译后的正则表达式去匹配字符串。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">re_telephone = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(re_telephone,<span class="string">&#x27;010-12345&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：</span></span><br><span class="line"><span class="comment"># someone@gmail.com</span></span><br><span class="line"><span class="comment"># bill.gates@microsoft.com</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_valid_email</span>(<span class="params">addr</span>):</span><br><span class="line">    re_email = <span class="string">r&#x27;[0-9a-zA-Z\.]*@[0-9a-zA-Z]*\.com&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> re.<span class="keyword">match</span>(re_email,addr):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> is_valid_email(<span class="string">&#x27;someone@gmail.com&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> is_valid_email(<span class="string">&#x27;bill.gates@microsoft.com&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> is_valid_email(<span class="string">&#x27;bob#example.com&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> is_valid_email(<span class="string">&#x27;mr-bob@example.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;测试通过&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习二：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以提取出 Email 的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;Tom Paris&gt; tom@voyager.org =&gt; Tom Paris</span></span><br><span class="line"><span class="comment"># bob@example.com =&gt; bob</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;]&#123;0,1&#125; 表示 可以是 一个 &lt; 或者空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">name_of_email</span>(<span class="params">addr</span>):</span><br><span class="line">    re_emailname = <span class="string">r&#x27;^[&lt;]&#123;0,1&#125;([0-9a-zA-Z\s]*)[&gt;|@]&#x27;</span></span><br><span class="line">    test =  re.<span class="keyword">match</span>(re_emailname, addr)</span><br><span class="line">    <span class="keyword">if</span> test:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> test.group(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="keyword">assert</span> name_of_email(<span class="string">&#x27;&lt;Tom Paris&gt; tom@voyager.org&#x27;</span>) == <span class="string">&#x27;Tom Paris&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> name_of_email(<span class="string">&#x27;tom@voyager.org&#x27;</span>) == <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;测试通过&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Process-and-Thread"><a href="#Process-and-Thread" class="headerlink" title="Process and Thread"></a>Process and Thread</h1><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多进程</span></span><br><span class="line"><span class="comment"># Windows下面没有fork ，请在linux下跑下面的代码</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">import os</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&#x27;</span>Process (%s) start<span class="built_in">..</span>.<span class="string">&#x27; % os.getpid())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pid = os.fork()</span></span><br><span class="line"><span class="string">if pid==0:</span></span><br><span class="line"><span class="string">    print(&#x27;</span>I am child process (%s) <span class="keyword">and</span> my parent is %s<span class="string">&#x27; % (os.getpid(), os.getppid())</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&#x27;</span>I (%s) just created a child process(%s).<span class="string">&#x27; % (os.getpid(), pid))</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows 下没有 fork，实现多进程要使用 multiprocessing 模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing import Process</span><br><span class="line">import os, time</span><br><span class="line"></span><br><span class="line">def run_proc(name):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="attribute">__name__</span>==&#x27;__main__&#x27;:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Process(<span class="attribute">target</span>=run_proc, args=(<span class="string">&#x27;test&#x27;</span>,)) # target 将函数作为单个进程，args 是传参数</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process will start.&#x27;</span>)</span><br><span class="line">    p.start() # 启动</span><br><span class="line">    p.join() # 等待子进程结束后继续运行</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process is end.&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;..................&#x27;</span>)</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pool</span></span><br><span class="line"><span class="comment"># 要启动大量的子进程，可以用进程池的方式批量创建子进程：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing import<span class="built_in"> Pool</span></span><br><span class="line"><span class="built_in"></span>import os, time, random</span><br><span class="line"></span><br><span class="line">def long_time_task(name):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (%s)&#x27;</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time() # 返回当前时间的时间戳</span><br><span class="line">    time.sleep(random.random() * 3)  # random() 方法返回随机生成的一个实数，它在[0,1)范围内。</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s runs %0.2f seconds&#x27;</span> % (name, (end-start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span>% os.getpid())</span><br><span class="line">    p = Pool(3)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(4):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for all subprocesses done...&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Done&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;..................&#x27;</span>)</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程间通信</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考链接：https://www.cnblogs.com/kaituorensheng/p/4445418.html#_label5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing import Process,<span class="built_in"> Queue</span></span><br><span class="line"><span class="built_in"></span>import os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码：</span></span><br><span class="line">def write(q):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process to write: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读</span></span><br><span class="line">def read(q):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process to read: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.<span class="built_in">get</span>(<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Gets %s from queue.&#x27;</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    # 父进程创建队列，传递给各个子进程</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(<span class="attribute">target</span>=write, args=(q,))</span><br><span class="line">    pr = Process(<span class="attribute">target</span>=read, args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line">    pw.join()</span><br><span class="line">    pr.terminate() # pr进程里是死循环，无法等待其结束，只能强行终止:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Done&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;..................&#x27;</span>)</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">多任务可以由多进程完成，也可以由一个进程内的多线程完成。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python的标准库中，绝大多数情况下，我们只需要使用threading这个高级模块。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：</span></span><br><span class="line"></span><br><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新进程执行的代码：</span></span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s is running ...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    n = 0</span><br><span class="line">    <span class="keyword">while</span> n &lt; 3:</span><br><span class="line">        n = n + 1</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;thread %s &gt;&gt;&gt; %s&#x27;</span> % (threading.current_thread().name,n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s is running ...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(<span class="attribute">target</span>=loop, <span class="attribute">name</span>=<span class="string">&#x27;LoopTread&#x27;</span>) # 子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程</span></span><br><span class="line"><span class="comment"># current_thread()函数，它永远返回当前线程的实例。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，</span></span><br><span class="line"><span class="comment"># 而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假定这是你的银行存款:</span></span><br><span class="line">balance = 0</span><br><span class="line"></span><br><span class="line">def change_it(n):</span><br><span class="line">    # 先存后取，结果应该为0:</span><br><span class="line">    global balance # 告诉Python这个变量名不是局部的，而是 全局 的</span><br><span class="line">    ###</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line">    ### 这两句语句在一个线程里应该是要连续执行才对</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(5000000):</span><br><span class="line">        change_it(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(<span class="attribute">target</span>=run_thread,args=(5,))</span><br><span class="line">t2 = threading.Thread(<span class="attribute">target</span>=run_thread,args=(8,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="built_in">print</span>(balance) # 由于线程的调度是由操作系统决定的，当t1、t2交替执行时，只要循环次数足够多，balance的结果就不一定是0了。</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Done.......................&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为函数 change_it 添加一个锁</span></span><br><span class="line"><span class="comment"># 当某个线程开始执行change_it()时，该线程因为获得了锁，因此其他线程不能同时执行change_it()，只能等待，直到锁被释放后，获得该锁以后才能执行。</span></span><br><span class="line"></span><br><span class="line">balance = 0</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(5000000):</span><br><span class="line">        # p(信号量)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            # v(信号量)</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(balance)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Done.......................&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>SICP——启程</title>
    <url>/2017/08/30/sicp-1-The-beginning/</url>
    <content><![CDATA[<p><img src="http://osax8w13y.bkt.clouddn.com/o_sicp-cover.jpg" alt=""></p>
<p>最近开始看被形容为计算机界的“圣经”的一本 MIT 计算机科学入门课的教材 SICP ，计算机程序的构造和解释（Structue and Interpretation of Computer Programs）。我这次不打算像读《CSAPP》那样整本书看完再进行整理，而是想在阅读这本书的过程中不断地记录读书时的感想，重要的概念，有意思的习题等等……便于给自己查缺补漏，另一方面等到时过境迁，回头看这些记录，必定能有新的思考和总结。（以后再找机会补上算法导论的读书笔记</p>
<h1 id="安利的链接"><a href="#安利的链接" class="headerlink" title="安利的链接"></a>安利的链接</h1><ul>
<li><a href="http://blog.zhaojie.me/2009/07/recommended-reading-2-sicp.html">老赵书托（2）：计算机程序的构造与解释</a>  </li>
<li><a href="http://yinwang0.lofter.com/post/183ec2_47bea8">王垠：如何掌握程序语言</a> </li>
<li><a href="https://book.douban.com/subject/1148282/">SICP的豆瓣页面，9.5分的评价</a></li>
<li><a href="http://www.nowamagic.net/librarys/veda/detail/1905">向热爱计算机科学的你推荐SICP</a></li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">wiki - Scheme (programming language)</a> Scheme 语言的基本了解 </li>
</ul>
<p>Scheme 语言的解释器环境推荐 <a href="http://blog.csdn.net/sqh201030412/article/details/70859225">Racket</a></p>
<hr>
<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>第一章 构造过程抽象</p>
<p>1.1.1 ~ 1.1.5 节，P1-13</p>
<p><strong>keywords</strong>: 计算过程、程序设计的基本元素（基本/组合/抽象）、应用序、正则序</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><blockquote>
<p>（本书序）每一个计算机程序都是现实中的或者精神中的某个过程的一个模型，通过人的头脑孵化出来……数量上数不胜数，详情琐碎繁杂……我们很少通过自己的程序将这种过程模拟到永远令人满意的程度。正因为如此……就需要去修改程序，直到这一模型最终达到了一种亚稳定状态。而在这时，就又会出现另一个需要我们去为之奋斗的模型……<strong>如果说艺术解释了我们的梦想，那么计算机就是在以程序的名义执行它们。</strong></p>
<p>（第一版前言）我们所设计的这门计算机科学导引课程……首先，我们希望建立起一种看法：<strong>一个计算机语言并不仅仅是让计算机去执行操作的一种方式</strong>，更重要的，它是一种表述有关方法学的思想的新颖的形式化媒介。因此，<strong>程序必须写的能够供人们阅读，偶尔地取供计算机执行。</strong>……我们的目标是，使完成了这一科目的学生能对<strong>程序设计的风格要素</strong>和<strong>审美观</strong>有一种很好的感觉。……这些技能不仅仅适用于计算机程序设计，对于所有的工程设计都是通用的。</p>
</blockquote>
<p>开篇就给人一种读这本书会是一种精神上的享受的感觉。确实，里面提到的很多东西是以前的学习中从未接触到的。</p>
<p>第一章的名字叫做，构造过程抽象。准备学习的是有关于<strong>计算过程</strong>的知识。计算过程是存在于计算机里的一类抽象事物，过程会去操作一些被称为<strong>数据</strong>的抽象事物。人们创建出<strong>程序</strong>的规则模式，<strong>指导过程的进行</strong>。</p>
<p>书中将计算过程比喻成“巫术”，将我们写的程序比作“咒语”。学习程序设计的人们就是“巫师学徒”，我们要去理解和掌握“咒语”的效果。“咒语”中会出现小错误（bug），可能产生复杂的错误结果。这个比喻特别形象生动。我也理解了程序并不是使输入产生输出的最主要的因素，比方说我用编程语言写了一段代码，控制了一些“过程”，是这些“过程”将输入的结果转化成了输出。</p>
<blockquote>
<p>一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，还应当成为一种框架，使我们能在其中组织自己有关计算过程的思想。</p>
</blockquote>
<h2 id="程序设计的基本要素"><a href="#程序设计的基本要素" class="headerlink" title="程序设计的基本要素"></a>程序设计的基本要素</h2><p>第一个重要的知识点，但每一种强有力的语言都有以下三个机制：</p>
<ol>
<li>基本表达形式，用于表示语言中最简单的个体。（C语言运算符）</li>
<li>组合的方法，从较简单的东西出发，构造复合的元素。（结构体）</li>
<li>抽象的方法，为复合对象命名，将它们当成简单的单元去操作。（函数）</li>
</ol>
<hr>
<h2 id="Scheme-相关"><a href="#Scheme-相关" class="headerlink" title="Scheme 相关"></a>Scheme 相关</h2><ul>
<li><p>1.1.1 讲了 Scheme 的表达式和求值。</p>
</li>
<li><p>1.1.2 讲了 define 的用法。这边提一下 Scheme，它是 Lisp 语言的两种主要方言（方言的意思是拥有 Lisp 主要特性的同时拥有一些自己独有的特性）之一（另一种是 Commom Lisp）。Scheme 是函数式编程语言，这种思想是非常古老的。Lisp 不是一种主流语言，却是今天还在广泛使用的历史第二悠久的语言（比它还老的是 Fortran）。使用学习 Scheme 的原因是这一语言拥有的一些特性，使它成为研究程序设计、构造、数据结构、语言特征的一种极佳媒介。</p>
</li>
</ul>
<p>举例子：下面的表达式就是 Scheme 中最常见的前缀组合式。对 Scheme 解释器输入表达式，解释器就可以返回你结果</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> <span class="number">137</span> <span class="number">349</span>)</span><br></pre></td></tr></table></figure>
<p>结果 486</p>
<p>像加减乘除这种一般性的求值规则，就是前面说到的每个强有力的语言都有的三个机制的第一点：基本表达形式。而 define 就是一种例外，是特殊形式。特殊形式就有自己的求值规则。各种不同类型的<strong>表达式</strong>和与之关联的<strong>求值规则</strong>组成了程序设计语言的<strong>语法形式</strong>。<strong>语法糖</strong>说的是：为完全可以采用统一形式描述的东西给出的另一种表面结构。</p>
<ul>
<li><p>1.1.3 讲了表达式的求值。语法树，就是说我们写的语句，在计算机看来，都是一棵棵语法树。</p>
</li>
<li><p>1.1.4 讲了复合过程，介绍了“复合”的做法。</p>
</li>
<li><p>1.1.5 讲了表达式的求值规则，<strong>代换模型</strong>。其实很简单，就像做函数题一样将参数代入求出结果。不过，<strong>代换</strong>不是解释器的实际工作方式的具体描述。如何求值的方式有两种</p>
<ol>
<li>正则序求值，思路是“完全展开后规约”，就是先不求出值，而是用运算对象表达式去代替形参，直到得到一个只包含基本运算符的表达式后，再求值。</li>
<li>应用序求值，思路是“先求值参数而后应用”，先把参数的值求了然后带入函数中。</li>
</ol>
</li>
</ul>
<ul>
<li>可以证明：对于可以产生合法值的过程应用，两种方法产出的结果将是一样的。</li>
</ul>
<p>Lisp 采用的是应用序求值，是因为正则序可能多次求同样的算式导致重复计算的工作。但下面就给出了一个反例：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">p</span>) (<span class="name">p</span>))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">test</span> x y) </span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> x <span class="number">0</span>)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        y))</span><br><span class="line"></span><br><span class="line">(<span class="name">test</span> <span class="number">0</span> (<span class="name">p</span>))</span><br></pre></td></tr></table></figure>
<p>对于正则序，不断展开，展开成</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">if</span></span>(<span class="name"><span class="built_in">=</span></span> <span class="number">0</span> <span class="number">0</span>) <span class="number">0</span> (<span class="name">p</span>))</span><br></pre></td></tr></table></figure>
<p>就停住，并得出结果 0。</p>
<p>但对于应用序，由于参数 <code>(p)</code> 是递归的，会不断地求 <code>(p)</code> 的值，不断调用自身，因此会在这里卡住死循环。每种编程语言的表达式求值，都是这两种中的一个。</p>
]]></content>
      <categories>
        <category>SICP</category>
      </categories>
  </entry>
  <entry>
    <title>SICP——过程结构</title>
    <url>/2017/09/16/sicp-2-Procedures-structure/</url>
    <content><![CDATA[<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>第一章 构造过程抽象</p>
<p>1.1.7 ~ 1.1.8 节，P13 - 20</p>
<p><strong>keywords</strong>：牛顿法求平方根、局部名、约束/自由变量、作用域、块结构（内部定义过程/过程抽象）</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="1-1-7-牛顿法求平方根"><a href="#1-1-7-牛顿法求平方根" class="headerlink" title="1.1.7 牛顿法求平方根"></a>1.1.7 牛顿法求平方根</h2><p>平方根</p>
<ul>
<li>根号 x 是某个大于等于零的数 y， y^2 = x </li>
<li>这是一个函数，不是一个切实可行的过程</li>
</ul>
<p>牛顿法</p>
<ul>
<li>如果 y 是 x 的平方根，y == x/y</li>
<li>要求 x 的平方根 y，从一个假设值 y 开始，不断求 y 与 x/y 的平均值，来得到更好的猜测</li>
<li>当猜测“足够好”时，结束循环。</li>
</ul>
<p>数学的函数和计算机里的函数有一个很重要的区别，就是后者必须是一个<strong>切实可行的计算过程</strong>。</p>
<ul>
<li>数学中定义：虽然这是一般性的定义，但没有给出切确的计算过程</li>
<li>牛顿法就是一个切确的计算过程。</li>
<li>函数与过程的矛盾，是<strong>描述一件事情的特征</strong>和<strong>描述如何去做这就事情</strong>直接的普遍性差异的一个具体反映。</li>
</ul>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">sqrt-iter</span> guess x)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">      guess</span><br><span class="line">      (<span class="name">sqrt-iter</span> (<span class="name">improve</span> guess x) x)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">improve</span> guess x)</span><br><span class="line">  (<span class="name">average</span> guess (<span class="name"><span class="built_in">/</span></span> x guess)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">average</span> x y)</span><br><span class="line">  (<span class="name"><span class="built_in">/</span></span> (<span class="name"><span class="built_in">+</span></span> x y) <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">  (<span class="name"><span class="built_in">&lt;</span></span> (<span class="name"><span class="built_in">abs</span></span> (<span class="name"><span class="built_in">-</span></span> (<span class="name">square</span> guess) x)) <span class="number">0.001</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">abs</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>)(<span class="name"><span class="built_in">-</span></span> x) x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">sqrt</span></span> x)</span><br><span class="line">  (<span class="name">sqrt-iter</span> <span class="number">1.0</span> x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">sqrt</span></span> <span class="number">9</span>)</span><br><span class="line"><span class="comment">;Value: 3.00009155413138</span></span><br></pre></td></tr></table></figure>
<ul>
<li>过程 <code>good-enough?</code> 就是说明什么情况下算改进到“足够好”，末尾的问号有一个提示 <strong>这个参数是一个过程</strong> 的作用。</li>
<li>最后封装成 <code>sqrt</code> 时，用 1.0 作为起始的猜测值。</li>
<li>这个程序说明，在用于写纯粹数值计算的程序时，至今介绍的简单程序设计语言足以写出其他语言（例如 C）中写出的任何东西了（amazing）。这个程序甚至没有循环结构，但展示了如何不用特殊的迭代结构来实现迭代，只需常规的过程调用即可。</li>
</ul>
<hr>
<h2 id="1-1-8-过程作为黑箱抽象"><a href="#1-1-8-过程作为黑箱抽象" class="headerlink" title="1.1.8 过程作为黑箱抽象"></a>1.1.8 过程作为黑箱抽象</h2><p>程序的过程的分解：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">sqrt</span></span><br><span class="line">         |</span><br><span class="line">     <span class="built_in">sqrt</span>-iter</span><br><span class="line">    /        \</span><br><span class="line">good-enough  improve</span><br><span class="line">/        \      \</span><br><span class="line">square  <span class="built_in">abs</span>    <span class="built_in">average</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>对平方根的计算问题可以很自然地分解成若干子问题。<strong>分解的重要性并不仅仅在于把这个问题分成了多少个小部分</strong>，关键在于<strong>分解中的每一个过程完成了一件清楚的工作</strong>。</li>
<li>例如 基于 <code>square</code> 来定义 <code>good-enough?</code>时就将前者看成一个<strong>黑箱</strong>，如何计算平方的细节隐去不谈了，只需要注意它能计算出平方的事实。这里就说<code>square</code>是一个<strong>过程抽象</strong></li>
<li>用户在使用一个过程时，应该不需要去弄清它究竟是如何实现的。</li>
</ul>
<p>可以写出相似的各种谓词，例如判断奇数偶数：<br><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">remainder</span></span> a b)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&lt;</span></span> a b)</span><br><span class="line">      a</span><br><span class="line">      (<span class="name"><span class="built_in">remainder</span></span> (<span class="name"><span class="built_in">-</span></span> a b) b)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">odd?</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">remainder</span></span> x <span class="number">2</span>) <span class="number">1</span>))      </span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="局部名"><a href="#局部名" class="headerlink" title="局部名"></a>局部名</h2><p>下面这两个过程定义应该是无法区分的：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="built_in">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> y) (<span class="name"><span class="built_in">*</span></span> y y))</span><br></pre></td></tr></table></figure>
<p>这一原则：<strong>过程的意义不应该依赖于作者为其形参所选用的名字</strong>，从表面看起来十分明显，但其实<strong>意义非常深远</strong>。</p>
<ul>
<li>过程的形参必须<strong>局部于</strong>有关的过程体。（如果不相关，且两个不同的过程用了同样的参数名字，那两个过程的参数会相互影响，两个过程彼此之间也不是我们所希望的黑箱了）</li>
<li>一个名字的定义被约束，则被约束的那一集表达式称为这个名字的<strong>作用域</strong>。</li>
<li>这样子的名字叫做<strong>约束变量</strong>。如果一个变量没有被约束，称它是<strong>自由的</strong>。 </li>
</ul>
<p>例如 <code>good-enough?</code> 里</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">  (<span class="name"><span class="built_in">&lt;</span></span> (<span class="name"><span class="built_in">abs</span></span> (<span class="name"><span class="built_in">-</span></span> (<span class="name">square</span> guess) x)) <span class="number">0.001</span>))</span><br></pre></td></tr></table></figure>
<p><code>guess</code>和 <code>x</code>是约束的，<code>&lt;</code> 、<code>-</code>、 <code>abs</code>、 <code>square</code> 是自由的。形参的具体名字是什么，其实完全没关系。前两个名字<code>guess</code>和 <code>x</code>的选择并不影响<code>good-enough?</code> 这个过程的意义，只要不要跟后面四个相同就可以了。</p>
<hr>
<h2 id="内部定义和块结构"><a href="#内部定义和块结构" class="headerlink" title="内部定义和块结构"></a>内部定义和块结构</h2><ul>
<li>对于用户来说，只有一个过程是重要的，那就是<code>sqrt</code>。他们需要这个过程，想知道如何使用这个过程。</li>
<li>我们希望隐藏那些<strong>辅助过程</strong>，例如<code>sqrt-iter</code>、<code>good-enough?</code>之类。虽然 <code>sqrt</code> 需要它，然而那些辅助过程却会干扰那些用 <code>sqrt</code> 的普通用户的思维。我们想要一种方式去“隐藏”</li>
<li>在许多程序员一起构造一个大型系统时，这种情况非常常见。</li>
</ul>
<p>方法：<strong>允许过程里带有一些内部定义，使它们局部于这一个过程。</strong></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">sqrt</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">    (<span class="name"><span class="built_in">&lt;</span></span> (<span class="name"><span class="built_in">abs</span></span> (<span class="name"><span class="built_in">-</span></span> (<span class="name">square</span> guess) x)) <span class="number">0.001</span>))</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">improve</span> guess x)</span><br><span class="line">    (<span class="name">average</span> guess (<span class="name"><span class="built_in">/</span></span> x guess)))</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">sqrt-iter</span> guess x)</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">	guess</span><br><span class="line">	(<span class="name">sqrt-iter</span> (<span class="name">improve</span> guess x) x)))</span><br><span class="line">  (<span class="name">sqrt-iter</span> <span class="number">1.0</span> x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">average</span> x y)</span><br><span class="line">  (<span class="name"><span class="built_in">/</span></span> (<span class="name"><span class="built_in">+</span></span> x y) <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">abs</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span>(<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>) (<span class="name"><span class="built_in">-</span></span> x) x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">sqrt</span></span> <span class="number">9</span>)</span><br><span class="line"><span class="comment">;Value: 3.00009155413138</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>good-enough?</code>、<code>improve</code>、<code>sqrt-iter</code>这三个过程的 define 声明统统移到了第四行 define sqrt 之中。</p>
<ul>
<li>这种嵌套定义的结构就是<strong>块结构</strong>。它就是简单的一种对于名字包装问题的正确解决方式。</li>
</ul>
<p>这里面有一个很好的想法，就是参数 <code>x</code> 已在<code>sqrt</code>中被限定，<code>good-enough?</code>、<code>improve</code>、<code>sqrt-iter</code>三个过程都是在<code>sqrt</code>内被定义的，因此，把参数<code>x</code>在三个过程中传来传去就没有必要了，而是让<code>x</code>成为内部定义的<strong>自由变量</strong>。</p>
<ul>
<li>第一个 define 内的三个 define 中 <code>x</code> 作为内部定义的自由变量。这种方式叫做<strong>词法作用域</strong></li>
</ul>
]]></content>
      <categories>
        <category>SICP</category>
      </categories>
  </entry>
  <entry>
    <title>SICP——过程的“形状”</title>
    <url>/2017/09/17/sicp-3-Procedures-and-the-Processes-They-Generate/</url>
    <content><![CDATA[<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>第一章 构造过程抽象</p>
<p>1.2 节，过程和它们所产生的计算。考察计算过程的局部演化方式，研究计算过程消耗资源（时间和空间资源）的速率。P20 - 37</p>
<p><strong>keywords</strong>：线性递归、迭代、树形递归、增长的阶、概率算法</p>
<p><strong>算法</strong>：斐波那契数列、利用三倍角公式求正弦、分治法求幂、辗转相除法求GCD、费马小定理检查测质数</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>在上一节，我们已经考虑了程序设计的基本要素：</p>
<ul>
<li>基本算术操作</li>
<li><strong>组合</strong>这些基本操作定义符合过程</li>
<li>对复合过程进行<strong>抽象</strong></li>
</ul>
<p>即使知道了这些，我们还不能说已经理解了如何去编程序。这个阶段就好像在学下象棋，知道了每个棋子的移动规则，但却还不知道基本的开局、战术和策略。</p>
<p>像初学象棋者一样，我们还不知道编程领域中各种有用的常见模式。要想成为专家，我们就需要去学习看清不同的过程会产生什么样子的计算过程，考察一些过程产生的计算过程的<strong>局部演化方式</strong>，也可以说是<strong>形状</strong>。还将研究这些计算过程消耗的时间和空间资源。</p>
<h2 id="1-2-1-线性递归和迭代"><a href="#1-2-1-线性递归和迭代" class="headerlink" title="1.2.1 线性递归和迭代"></a>1.2.1 线性递归和迭代</h2><blockquote>
<p>“如果有程序员用递归写阶乘，我直接把他开除。” —— 好像是在某人代码大全读书笔记上看到的片段</p>
</blockquote>
<p>递归计算阶乘：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">1</span>)</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      (<span class="name"><span class="built_in">*</span></span> n (<span class="name">factorial</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">factorial</span> <span class="number">6</span>)</span><br><span class="line"><span class="comment">;Value: 720</span></span><br></pre></td></tr></table></figure>
<p>线性迭代计算阶乘：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name">fact-iter</span> <span class="number">1</span> <span class="number">1</span> n)) </span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">fact-iter</span> product counter max-count)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&gt;</span></span> counter max-count)</span><br><span class="line">      product</span><br><span class="line">      (<span class="name">fact-iter</span> (<span class="name"><span class="built_in">*</span></span> counter product)</span><br><span class="line">		 (<span class="name"><span class="built_in">+</span></span> counter <span class="number">1</span>)</span><br><span class="line">		 max-count))) </span><br><span class="line"></span><br><span class="line">(<span class="name">factorial</span> <span class="number">6</span>)</span><br><span class="line"><span class="comment">;Value: 720</span></span><br></pre></td></tr></table></figure>
<p>对两个计算过程做一个比较，考虑两个计算过程的<strong>“形状”</strong>，会发现有很大的不同。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/Linear%20recursion.png" alt=""></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/Linear%20iteration.png" alt=""></p>
<p>递归是一个经常在计算机学科中各门课、各种书籍中出现的字眼。我觉得在这本书里对递归的解释非常地到位以及准确。</p>
<h3 id="线性递归过程"><a href="#线性递归过程" class="headerlink" title="线性递归过程"></a><strong>线性递归过程</strong></h3><ol>
<li>线性递归这一过程揭示的是<strong>先逐步展开而后收缩的过程</strong>。整个计算过程构造成一个<strong>由一系列推迟进行操作所构成的链条</strong>，<strong>收缩阶段表现为之前积累下来的运算的实际运行</strong>。</li>
<li>对于递归计算过程而言，这里还存在着另外的一些“隐含信息”，它们并未保存在变量里，而是<strong>由解释器维持着</strong>。为了执行这种计算过程，解释器就需要维护好哪些以后要执行的操作的轨迹（栈的概念）。这个链条越长（递归的深度越深），需要保存的信息就越多。</li>
<li>用这种方法计算 n 的阶乘，<strong>推迟执行的乘法链条长度</strong>正比于 n </li>
<li>当我们说一个过程是递归的时候，论述的是这一个过程<strong>语法形式</strong>上的一种事实——过程的定义中（直接或间接地）调用了自己。而当我们说一个计算过程具有递归形式（例如线性递归）的时候，我们说的是这一计算过程的<strong>实际进展方式</strong>，而不是其书写上的语法形式。</li>
</ol>
<h3 id="迭代计算过程"><a href="#迭代计算过程" class="headerlink" title="迭代计算过程"></a><strong>迭代计算过程</strong></h3><ol>
<li>第二个计算过程里没有任何的增长or收缩。</li>
<li>状态可以用固定数目的状态描述变量（<code>product</code>描述累计结果，<code>counter</code>描述何时结束迭代）描述的计算过程。</li>
<li>用这种方法计算阶乘，<strong>所需要的计算步骤</strong>正比于 n</li>
</ol>
<ul>
<li>在迭代的情况里，在计算过程中的任何一点，那几个状态描述变量提供了有关<strong>计算状态的一个完整描述</strong>。</li>
<li>对于递归的计算过程，这里面存在的隐含信息，它们未保存在变量里，而是<strong>由解释器维持着</strong>。<strong>这个链条越长，需要保存的信息也就越多</strong>。</li>
<li>因此，常见语言的大部分实现中，对于递归过程的解释，所消耗的内存与过程调用的数量成正比。</li>
<li><strong>尾递归</strong>，通常被视为一种编译技巧。即：递归调用都在每次函数调用的尾部，可以被编译器优化成迭代。</li>
</ul>
<hr>
<h2 id="1-2-2-树形递归"><a href="#1-2-2-树形递归" class="headerlink" title="1.2.2 树形递归"></a>1.2.2 树形递归</h2><p>求斐波那契数列<code>Fib(n)</code>，如果采用最基础的定义翻译过来的递归过程：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">fib</span> n)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">	((<span class="name"><span class="built_in">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">	(<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">+</span></span> (<span class="name">fib</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>))</span><br><span class="line">		 (<span class="name">fib</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">2</span>))))))</span><br><span class="line"><span class="comment">;Value: fib</span></span><br><span class="line"></span><br><span class="line">(<span class="name">fib</span> <span class="number">5</span>)</span><br><span class="line"><span class="comment">;Value: 5</span></span><br></pre></td></tr></table></figure>
<p>会产生<strong>树形递归</strong>，每个调用中两次递归调用了自身。这是一种很糟糕的方式，因为做了过多的冗余计算。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/Tree%20recursion.png" alt=""></p>
<p>不难证明，这一过程中，计算 <code>(fib 1)</code> 和 <code>(fib 0)</code> 的次数（也就是上面递归树的叶子个数）正好是 <code>Fib(n+1)</code>。而<code>Fib(n)</code> 的增长对于 n 来说是指数级的：Fib(n) 就是最接近黄金分割率的 n 次方除以根号 5 的整数，其中黄金分割率为：</p>
<p>$$ \phi = (1 + \sqrt {5} / 2 $$</p>
<p>简单来说，树形递归的计算步骤将随着输入的增长而指数性增长。</p>
<p>因此，需要规划出一个线性迭代过程。用 a 和 b 表示 <code>Fib(1) = 1</code> 和 <code>Fib(0) = 0</code>，然后反复使用这两条规则：<code>a = a + b</code>/<code>b = a</code>。不难证明，经过 n 次变换， a 和 b 分别等于 <code>Fib(n + 1)</code> 和 <code>Fib(n)</code></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">fib</span> n)</span><br><span class="line">  (<span class="name">fib-iter</span> <span class="number">1</span> <span class="number">0</span> n)) </span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">fib-iter</span> a b count)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> count <span class="number">0</span>)</span><br><span class="line">      b</span><br><span class="line">      (<span class="name">fib-iter</span> (<span class="name"><span class="built_in">+</span></span> a b) a (<span class="name"><span class="built_in">-</span></span> count <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">fib</span> <span class="number">5</span>)</span><br><span class="line"><span class="comment">;Value: 5</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>1.2.3 增长的阶</p>
</li>
<li><p>不同的计算过程在计算资源的消耗上存在巨大差异。这里略微复习到算法与数据结构中复杂度的知识。</p>
</li>
</ul>
<hr>
<h2 id="1-2-4-分治法求幂"><a href="#1-2-4-分治法求幂" class="headerlink" title="1.2.4 分治法求幂"></a>1.2.4 分治法求幂</h2><p>求 b 的 n 次方。如果将 n 个 b 连乘，复杂度是 θ(n)，但有更少步数求幂的方法。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">b^n </span>= <span class="keyword">b^(n/2) </span>* <span class="keyword">b^(n/2) </span>  <span class="comment"># n 是偶数</span></span><br><span class="line"><span class="keyword">b^n </span>= <span class="keyword">b </span>* <span class="keyword">b^(n-1) </span>        <span class="comment"># n 是奇数</span></span><br><span class="line"><span class="keyword">b^n </span>= <span class="number">1</span>                   <span class="comment"># n == 0</span></span><br></pre></td></tr></table></figure>
<p>可以把复杂度从 θ(n) 降到  θ(log n)</p>
<hr>
<h2 id="1-2-5-最大公约数-Greatest-Common-Divisor"><a href="#1-2-5-最大公约数-Greatest-Common-Divisor" class="headerlink" title="1.2.5 最大公约数 Greatest Common Divisor"></a>1.2.5 最大公约数 Greatest Common Divisor</h2><p>r 如果是 a 除以 b 的余数，那么 a 与 b 的公约数正好也是 b 与 r 的公约数。</p>
<p>GCD(a, b) = GCD(b, r)</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">gcd</span></span> a b)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> b <span class="number">0</span>)</span><br><span class="line">      a</span><br><span class="line">      (<span class="name"><span class="built_in">gcd</span></span> b (<span class="name"><span class="built_in">remainder</span></span> a b)))) </span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">gcd</span></span> <span class="number">16</span> <span class="number">28</span>)</span><br><span class="line"><span class="comment">;Value: 4</span></span><br></pre></td></tr></table></figure>
<p><code>remainder</code> 是基础过程，求余。</p>
<p>欧几里得算法是一个高效的算法，这里有一条神奇的 Lame 定理：</p>
<blockquote>
<p>如果欧几里得算法需要 K 步 计算出一对整数的 GCD，那么这对数中较小的那个数必然大于或等于第 K 个斐波那契数</p>
</blockquote>
<p>证明略（或许以后会补</p>
<p>利用这一定理，证明：若 n 是 GCD 两个参数中较小的那个，计算过程需要 k 步，则有 $ n ≥ Fib(k) = \phi^k / \sqrt 5  $，步数 k 的增长是 n 的对数，所以算法增长的阶是 O(log n) 的。</p>
<hr>
<h2 id="1-2-6-用费马检查来进行质数检测"><a href="#1-2-6-用费马检查来进行质数检测" class="headerlink" title="1.2.6 用费马检查来进行质数检测"></a>1.2.6 用费马检查来进行质数检测</h2><p>基本方法：检测 n 是不是质数，从 1 到 根号 n 之间检查因子。需要 θ(根号n) 的复杂度。但有比此更快的 θ(log n) 的方法。是基于数论中著名的<strong>费马小定理</strong>的结果。</p>
<p>假如 a 是整数，n 是质数，且 a,n 互质（即两者只有一个公约数1），那么a的(n-1)次方除以n的余数恒等于1。<code>a^(n-1) mod n == 1</code></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">例如，5是质数，费马检查的过程是：</span><br><span class="line"></span><br><span class="line">取一个与 n =<span class="number"> 5 </span>互质的整数，例如 a = 3</span><br><span class="line"></span><br><span class="line">3 的<span class="number"> 4 </span>次方为<span class="number"> 81 </span>，除以 n 的余数为 1。</span><br><span class="line">再取 a = 2,<span class="number"> 2 </span>的<span class="number"> 4 </span>次方为 16，除以 n 的余数依然为 1。</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>
<p>我们要验证一个数 n 是不是质数，取<strong>任意整数（注意这里的a不用取互质的）</strong> a &lt; n 计算 <code>a^(n-1) mod n</code> 如果不等于 1，那么 n 就肯定不是质数。如果等于 1，就对 n 是质数有了信心，再通过检查更多的 a 值，我们就可以不断确信 n 是一个质数。这个方法叫做<strong>费马检查</strong>，是有名的<strong>概率算法</strong>。概率算法的意思是，例如一个数通过了多轮的费马检查，但不能给出百分百确定这个数就是素数的结果，但是能给出一个概率上有信心的结果。而不是素数的数，用此方法很快就能检测出其非素性。</p>
<p>虽然说有一些能够骗过费马检查的整数，被称为 Carmichael 数，例如 561、1105、1729、2465。由于这些数很罕见，“撞上能够欺骗费马检查的值的机会比宇宙射线导致计算机执行出错的机会还要小”，因此费马检查还是很可靠的。</p>
<ul>
<li>最惊人的应用是在密码学中，对于 200 位长度的因数分解在计算上还是不现实的，但费马检查可以在很短的时间内判断这个数的素性。</li>
</ul>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">;费马素数检查</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">expmod</span> base exp m)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">=</span></span> exp <span class="number">0</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="built_in">even?</span></span> exp)</span><br><span class="line">         (<span class="name"><span class="built_in">remainder</span></span> (<span class="name">square</span> (<span class="name">expmod</span> base (<span class="name"><span class="built_in">/</span></span> exp <span class="number">2</span>) m))</span><br><span class="line">                    m))</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span></span><br><span class="line">         (<span class="name"><span class="built_in">remainder</span></span> (<span class="name"><span class="built_in">*</span></span> base (<span class="name">expmod</span> base (<span class="name"><span class="built_in">-</span></span> exp <span class="number">1</span>) m))</span><br><span class="line">                    m))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">fermat-test</span> n)</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">try-it</span> a)</span><br><span class="line">    (<span class="name"><span class="built_in">=</span></span> (<span class="name">expmod</span> a n n) a))</span><br><span class="line">  (<span class="name">try-it</span> (<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> (<span class="name">random</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">prime?</span> n times)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">=</span></span> times <span class="number">0</span>) true)</span><br><span class="line">        ((<span class="name">fermat-test</span> n) (<span class="name">fast-prime?</span> n (<span class="name"><span class="built_in">-</span></span> times <span class="number">1</span>)))</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> false)))</span><br><span class="line"></span><br><span class="line">(<span class="name">prime?</span> <span class="number">3</span> <span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SICP</category>
      </categories>
  </entry>
  <entry>
    <title>SICP——高阶函数做抽象</title>
    <url>/2017/10/11/sicp-4-Abstractions-with-Higher-Order-Procedures/</url>
    <content><![CDATA[<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>第一章 构造过程抽象</p>
<p>1.3 节，用高阶函数做抽象。P37 - 48</p>
<p><strong>keywords</strong>：过程作为参数、lambda 演算子</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="1-3-1-过程作为参数"><a href="#1-3-1-过程作为参数" class="headerlink" title="1.3.1 过程作为参数"></a>1.3.1 过程作为参数</h2><p>我们可以用 define 对一些过程做抽象。例如下面这个求立方：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">(* <span class="number">3</span> <span class="number">3</span> <span class="number">3</span>)</span><br><span class="line">(* y y y)</span><br><span class="line"></span><br><span class="line">抽象为：</span><br><span class="line"></span><br><span class="line">(<span class="keyword">define</span> (cube <span class="keyword">x</span>) (* <span class="keyword">x</span> <span class="keyword">x</span> <span class="keyword">x</span>))</span><br></pre></td></tr></table></figure>
<p>这一章我们将看见一种更高级的过程抽象。通过 define 产生的过程，迫使我们永远只能使用特定的操作，并且要传入参数，而不能基于更高级的操作去工作。</p>
<p><strong>如果过程只能限制以数为参数，将严重限制我们建立抽象的能力。</strong>因此我们要构造出<strong>以过程为参数、返回过程的高阶过程</strong>，以及 lambda 演算子等技巧。这是强有力的抽象机制，极大的增强了语言的表述能力。下面看看如何将过程作为参数。</p>
<p>考虑几个计算过程：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/%E8%BF%87%E7%A8%8B%E5%8F%82%E6%95%B0.png" alt=""></p>
<p>在这里可以明显的看出，三个过程中有一种共享的基础模式。（在一段范围内把某种东西累加起来）我们也希望程序语言足够强大，写出一个过程，<strong>表达求和的概念</strong>，而<strong>不是只能写出一种特定的求和过程</strong>。其实就上述三个过程，我们可以从中抽象出一种通式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">(define (sum term <span class="selector-tag">a</span> next <span class="selector-tag">b</span>))</span><br><span class="line">    (if (&gt; <span class="selector-tag">a</span> <span class="selector-tag">b</span>)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (+ (term <span class="selector-tag">a</span>)</span><br><span class="line">            (sum term (next <span class="selector-tag">a</span>) next <span class="selector-tag">b</span>))))</span><br></pre></td></tr></table></figure>
<p><code>sum</code>除了原有的两个参数 a 与 b，增加了<strong>过程参数</strong><code>term</code>和<code>next</code>，可以很简单的看出：<code>term</code>是指对当前数进行一个操作后，再把结果累加。<code>next</code>就是计算下一步的 a 值。</p>
<p>下面是对原有的代码进行改进的过程，将过程作为了参数。将一个迭代累加的过程抽象成了一个通式，只需要传入过程来控制我们想要的累加形式即可。“抽象”不仅是用 sum-integers、sum-pi 等名字去描述那些过程，还可以从各种 sum 中抽象出更强的抽象：<strong>求和的概念</strong>。厉害厉害！值得一提的是，之前还很轻易地用 C 语言就可以改写的 Scheme 程序，从这里开始就变得难了。因为 C 语言要实现类似的效果，需要传递函数指针。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">inc</span> n)(<span class="name"><span class="built_in">+</span></span> n <span class="number">1</span>)) </span><br><span class="line"><span class="comment">;定义 inc 过程，用作 x++ 的功能</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">sum</span> term a next b)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&gt;</span></span> a b)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name"><span class="built_in">+</span></span> (<span class="name">term</span> a)(<span class="name">sum</span> term (<span class="name">next</span> a)next b)))) </span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">sum-cubes</span> a b)</span><br><span class="line">  (<span class="name">sum</span> cube a inc b)) </span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">cube</span> x)(<span class="name"><span class="built_in">*</span></span> x x x)) </span><br><span class="line"></span><br><span class="line">(<span class="name">sum-cubes</span> <span class="number">1</span> <span class="number">10</span>)</span><br><span class="line"><span class="comment">;Value: 3025</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">pi-sum</span> a b)</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">pi-term</span> x)</span><br><span class="line">    (<span class="name"><span class="built_in">/</span></span> <span class="number">1.0</span> (<span class="name"><span class="built_in">*</span></span> x (<span class="name"><span class="built_in">+</span></span> x <span class="number">2</span>))))</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">pi-next</span> x)</span><br><span class="line">    (<span class="name"><span class="built_in">+</span></span> x <span class="number">4</span>))</span><br><span class="line">  (<span class="name">sum</span> pi-term a pi-next b))</span><br><span class="line"></span><br><span class="line"><span class="comment">;这个式子会收敛于 π/8</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">*</span></span> <span class="number">8</span> (<span class="name">pi-sum</span> <span class="number">1</span> <span class="number">1000</span>))</span><br><span class="line"><span class="comment">;Value: 3.139592655589783</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一旦有了 sum ，我们就能用它作为基本构件，去形式化其他概念。例如，求函数 f 在范围 a 和 b 之间的定积分近似值，可以用下面公式去完成：</p>
<p>$$\int_a^b = \lbrace f(a+\frac{dx}{2}) + f(a+dx+\frac{dx}{2}) + f(a+2dx+\frac{dx}{2}) + … \rbrace dx $$</p>
<p>这个式子的意思：将 x 轴取极小的小块（dx），大括号内的东西是所有长方体的长的累加，乘以 dx 就是积分。利用前面的 sum，我们可以直接描述 integral 过程：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">integral</span> f a b dx)</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">add-dx</span> x)(<span class="name"><span class="built_in">+</span></span> x dx))</span><br><span class="line">  (<span class="name"><span class="built_in">*</span></span> (<span class="name">sum</span> f (<span class="name"><span class="built_in">+</span></span> a (<span class="name"><span class="built_in">/</span></span> dx <span class="number">2.0</span>)) add-dx b) dx))</span><br><span class="line"><span class="comment">;Value: integral</span></span><br><span class="line"></span><br><span class="line">(<span class="name">integral</span> cube <span class="number">0</span> <span class="number">1</span> <span class="number">0.001</span>)</span><br><span class="line"><span class="comment">;Value: .249999875000001</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-2-lambda-构造"><a href="#1-3-2-lambda-构造" class="headerlink" title="1.3.2 lambda 构造"></a>1.3.2 lambda 构造</h2><p>在用过程做为参数时，我们不免要定义一些诸如 <code>pi-next</code>、<code>add-dx</code> 这样的过程名。这种做法有些不舒服，这些过程用作高阶函数的参数，它们在 <code>pi-sum</code> 和 <code>integral</code> 过程之外，是没什么用途的。我们可以通过引入一种 <strong>lambda λ 表达式</strong>来完成这种描述。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="comment">;比如 pi-sum 可以这么写：</span></span><br><span class="line">(<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">+</span></span> x <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>lambda 创建过程的语法和 define 是一样的，只不过 lambda 不为过程提供一个名字。</p>
<p>可以以如下方法来阅读 lambda 语句：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/lambda.png" alt=""></p>
]]></content>
      <categories>
        <category>SICP</category>
      </categories>
  </entry>
  <entry>
    <title>SICP——构造数据抽象</title>
    <url>/2018/03/08/sicp-5-Building-Abstactions-with-Data/</url>
    <content><![CDATA[<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>进入第二章——构造数据抽象</p>
<p><strong>keywords</strong>：数据复合、数据抽象、抽象屏障。序对、闭包性、序列。映射。<br><strong>程序</strong>： <code>list-ref</code>、<code>append</code>、<code>reverse</code>；<code>map</code>；<code>for-each</code></p>
<h1 id="抽象数据导引"><a href="#抽象数据导引" class="headerlink" title="抽象数据导引"></a>抽象数据导引</h1><p>什么是数据抽象？</p>
<p>过程抽象中，构造更复杂的过程，就把一个过程用作其中的元素。比如说 <code>平方和</code> 过程的实现中使用了<code>求平方</code>和<code>加和</code>两个过程，构造更复杂的过程时，元素的实现细节被隐藏了。对<code>平方和</code>来说，这就构造了<strong>抽象</strong>——这一过程的使用方式，与该过程如何通过更基本的过程实现的具体细节相分离。</p>
<p>针对数据的类似概念就是<strong>数据抽象</strong>，数据抽象是一种<strong>方法学</strong>。一个复合数据对象的使用，应该与是怎么由更基本的数据对象构造的细节隔离开的。</p>
<p>前一章中，涉及的数字，只是一些基础的数字和数值运算。第二章开始，我们要考察更复杂的数据。就像简单的过程可以复合形成复合过程，将数据对象组合起来，形成<strong>复合数据</strong>。</p>
<p>复合数据的意义：</p>
<ul>
<li>提升我们在程序设计时所位于的概念层次。</li>
<li>提高设计的模块性。</li>
<li>增强语言的表达能力。</li>
</ul>
<p>比如，要完成一个对分数进行运算的程序。若将一个分数看成一个分子和一个分母，分别用两个变量来代表。这样做下去，会非常难受，要记得哪一个分母和哪一个分子对应，这种杂乱麻烦的记录工作会严重搅乱程序设计。若是能将两个变量“合在一起”，形成一个<strong>复合数据</strong>，情况就好得多。</p>
<ul>
<li>对分数的操作就可以将这一个复合数据当做一个概念上的单位，提升了层次。</li>
<li>进一步提高程序的模块性。也就是说，处理分数的那些程序部分，与分数如何表达的细节隔离开了。这种把数据对象的使用部分和表示细节部分相分离的技术思想非常具有一般性，这就是被称为<strong>数据抽象</strong>的强有力的设计方法学。</li>
<li>复合对象的使用最重要的是真正地提高了语言的表达能力。举最简单的“线性组合”：$ax + by$为例，我们想到写一个过程接受四个参数返回$ax + by$的值，那么就是下面这个样子：</li>
</ul>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">linear-combination</span> a b x y)</span><br><span class="line">    (<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> a x) (<span class="name"><span class="built_in">*</span></span> b y)))</span><br></pre></td></tr></table></figure>
<p>但是，如果编程语言的表达能力更强，所针对的不仅仅是简单数据，而是分数、复数、多项式等等其他东西的话，应该是下面这个样子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">define</span> (linear-combination a b <span class="keyword">x</span> y)</span><br><span class="line">    (<span class="keyword">add</span> (<span class="keyword">mul</span> a <span class="keyword">x</span>)(<span class="keyword">mul</span> b y)))</span><br></pre></td></tr></table></figure>
<p><code>add</code>和<code>mul</code> 也不是简单的加法和乘法了，而是更复杂的内在。从<strong>抽象</strong>的意义来看，对于过程<code>linear-combination</code>来说，这里的 a、b、x、y 是什么，根本没有关系。这个例子也说明了，为什么一种程序设计语言要提供一种复合简单对象的方法，以及直接操作符合对象的能力，是多么的重要。</p>
<p>复合简单数据的方法就是程序设计语言应该提供某种<strong>“粘合剂”</strong>用于把简单数据对象组合起来，形成复杂的数据对象。在复合的思想中有一个关键的概念——<strong>闭包</strong>，就是粘合剂不但能组合基本的数据，还可以粘合复杂的数据对象（形成更复杂的数据对象）。</p>
<p>除此之外，还将看到，数据抽象能让程序在不同的层次之间建立起<strong>抽象屏障</strong>。这个知识点就像是网络的 OSI 七层模型，或者说“用户——软件——操作系统——硬件”的层次，概念是相同的。</p>
<h1 id="序对"><a href="#序对" class="headerlink" title="序对"></a>序对</h1><p>剧透：<strong>序对可以用做构造任意种类的复杂数据结构的通用的基本构件。</strong></p>
<p>序对其实和离散数学中的“有序对”没什么差别。具体到 Scheme 语言里，有一个基本过程：<code>cons</code>，需要两个参数，返回一个包含这两个参数作为其成分的符合数据对象。对于一个由<code>cons</code>构造的序对，基本过程<code>car</code>和<code>cdr</code>可以取出前后两个部分。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(define x (cons 1 2)</span>)</span><br><span class="line"><span class="comment">(define y (cons 3 4)</span>)</span><br><span class="line"><span class="comment">(define z (cons x y)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(car x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(cdr y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(car z)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(car ( cdr z)</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">(mcons 1 2)</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="Closure-Property"><a href="#Closure-Property" class="headerlink" title="Closure Property"></a>Closure Property</h2><p>介绍一个重要的概念，cons 的<strong>闭包性质</strong>。</p>
<p>闭包性质这一术语来自抽象代数（离散数学也有），意思是一集元素在某个运算下封闭，封闭是指这个运算运用于一集合中的元素，产出的仍然是该集合的元素。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/closure.png" alt=""></p>
<p>如图所示，由于闭包性，你可以不仅可以用 <code>cons</code>去组合数值，还可以用<code>cons</code>组合序对！这一性质，通过它可以构造出许多不同种类的数据结构来。<strong>闭包性质是 cons 组合威力的关键要素，它能用来构建出层次性结构的数据对象。</strong></p>
<p>非常有意思的性质，对不对？联系一下 C 语言，我们可以发现其实 C 语言提供的数据组合方法并不具备这种性质。例如 <code>struct</code> 是可以包含别的 <code>struct</code>，但是要求程序员显示地操纵指针（也就是别的东西，而不是数据对象本身），并限制性地要求<code>struct</code>里面包含的只能是预先定义好的元素。</p>
<blockquote>
<p>Alan Perlis 评价：“……过多的可声明数据结构导致了函数的专用化，造成了对合作的阻碍。让 100 个函数在一个数据结构上操作，远比让 10 个函数在 10 个数据结构上操作更好些。”</p>
</blockquote>
<h1 id="Squence"><a href="#Squence" class="headerlink" title="Squence"></a>Squence</h1><p>利用序对构造出的一类有用结构就是<strong>序列</strong>（Sequence）。定义也非常简单，看下图就行。与我们熟知的表很想，但我觉得链表（linked list）特指那种有一个数据对象和一个指针构成的数据结构。序列更适合本书语境。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/sequence.png" alt=""></p>
<p>可以像图上那样写很多 cons 复合来构成表。为了方便表的构造，Scheme 有一个基础操作<code>list</code>。简单来说<code>(list 1 2 3 4)</code>就等同于上面那一堆 cons 的结果。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> one-through-four (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">car</span></span> one-through-four)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">cdr</span></span> one-through-four)</span><br><span class="line"></span><br><span class="line"><span class="comment">;结果：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="name">mcons</span> <span class="number">2</span> (<span class="name">mcons</span> <span class="number">3</span> (<span class="name">mcons</span> <span class="number">4</span> &#x27;())))</span><br></pre></td></tr></table></figure>
<p>对表来说，<code>car</code>就是<strong>选取表的第一项</strong>，<code>cdr</code>就是选取表中<strong>除去第一项之后剩下元素形成的子表</strong>。嵌套应用<code>car</code>和<code>cdr</code>可以取出表的各项。</p>
<p><code>cons</code> 只能用于在原有表的<strong>前面</strong>增加一个元素，因为表尾最后一个元素应该是<code>nil</code>。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> one-through-four (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name"><span class="built_in">cons</span></span> <span class="number">10</span> one-through-four)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;结果：</span></span><br><span class="line">(<span class="name">mcons</span></span><br><span class="line"> <span class="number">10</span></span><br><span class="line"> (<span class="name">mcons</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  (<span class="name">mcons</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">   (<span class="name">mcons</span> <span class="number">3</span> (<span class="name">mcons</span> <span class="number">4</span> &#x27;())))))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="comment">;用 cons 在后添加是错误的</span></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> one-through-four (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name"><span class="built_in">cons</span></span>  one-through-four <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;结果：</span></span><br><span class="line">(<span class="name">mcons</span></span><br><span class="line"> (<span class="name">mcons</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  (<span class="name">mcons</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">   (<span class="name">mcons</span> <span class="number">3</span> (<span class="name">mcons</span> <span class="number">4</span> &#x27;()))))</span><br><span class="line"> <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;结果：</span></span><br><span class="line">(<span class="name">mcons</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> (<span class="name">mcons</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  (<span class="name">mcons</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   (<span class="name">mcons</span> <span class="number">4</span> (<span class="name">mcons</span> <span class="number">10</span> &#x27;())))))</span><br></pre></td></tr></table></figure>
<h2 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h2><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="comment">;取出列表的第n项</span></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">list-ref</span></span> L n)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">car</span></span> L)</span><br><span class="line">      (<span class="name"><span class="built_in">list-ref</span></span> (<span class="name"><span class="built_in">cdr</span></span> L)(<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> squares (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">list-ref</span></span> squares <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;求表长</span></span><br><span class="line"><span class="comment">;null? 是基本过程，检查参数是不是空表</span></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">length</span></span> L)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> L)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">length</span></span> (<span class="name"><span class="built_in">cdr</span></span> L)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">length</span></span> squares)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;连接两个表</span></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">append</span></span> L1 L2)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> L1)</span><br><span class="line">      L2</span><br><span class="line">      (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> L1) (<span class="name"><span class="built_in">append</span></span> (<span class="name"><span class="built_in">cdr</span></span> L1)L2))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> odds (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">append</span></span> squares odds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;习题1：求表最后一个元素，迭代</span></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">last-pair</span> L)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> (<span class="name"><span class="built_in">cdr</span></span> L))</span><br><span class="line">      L</span><br><span class="line">      (<span class="name">last-pair</span> (<span class="name"><span class="built_in">cdr</span></span> L))))</span><br><span class="line"></span><br><span class="line">(<span class="name">last-pair</span> squares)</span><br><span class="line"></span><br><span class="line"><span class="comment">;习题2：表逆序</span></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">reverse</span></span> L)(<span class="name">reverse-iter</span> L nil))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">reverse-iter</span> list other)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> list)</span><br><span class="line">      other</span><br><span class="line">      (<span class="name">reverse-iter</span> (<span class="name"><span class="built_in">cdr</span></span> list)(<span class="name"><span class="built_in">cons</span></span>(<span class="name"><span class="built_in">car</span></span> list) other))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">reverse</span></span> squares)</span><br></pre></td></tr></table></figure>
<p>尤其是表逆序这一题，我看着代码看了很久。思考它与典型的过程化语言C语言打出来的链表逆序有什么不同。可以看出，表逆序是一个递归过程。在前面的学习中，知道了递归的意思就是与操作延迟推行。表逆序这个过程，若<code>list</code>为空，<code>other</code>便为输出结果。<code>other</code>最初是<code>nil</code>，会直接递归执行到原表 L 的尾部，递归开始返回。从倒数第一个元素，用<code>cons</code> 将其加到 <code>other</code>前面，就完成了这一过程。</p>
<p>这也是 SICP 给我几个最大的触动之一。简单的序对就能够构成很多已知的数据结构，比如说树、还有链表，像类似于什么求链表长度、求树的深度这样子的函数都能够用看上去十分玄幻，但细看十分精妙的几行 scheme 就能写成。光是知道了这几点，我觉得都已经让我觉得非常满足了。</p>
<h2 id="映射（map）"><a href="#映射（map）" class="headerlink" title="映射（map）"></a>映射（map）</h2><p>将某种变换应用于一个表的所有元素得到一个由所有结果构成的新表。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">scale-list</span> items factor)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> items)</span><br><span class="line">      nil</span><br><span class="line">      (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">*</span></span> (<span class="name"><span class="built_in">car</span></span> items) factor)</span><br><span class="line">            (<span class="name">scale-list</span> (<span class="name"><span class="built_in">cdr</span></span> items) factor))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">scale-list</span> (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="number">10</span>)</span><br><span class="line">(<span class="name">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>仍然，可以继续<strong>抽象</strong>这一想法，将其中的公共模式抽象成高阶过程。这一高阶过程就是<strong>映射（map）</strong>。这一公共模式：有一个过程参数和表参数，将过程应用于表中所有元素，输出是所有新的结果构成的新表。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">map</span></span> proc items)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> items)</span><br><span class="line">      nil</span><br><span class="line">      (<span class="name"><span class="built_in">cons</span></span> (<span class="name">proc</span> (<span class="name"><span class="built_in">car</span></span> items))</span><br><span class="line">            (<span class="name"><span class="built_in">map</span></span> proc (<span class="name"><span class="built_in">cdr</span></span> items)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">lambda</span></span>(x) (<span class="name"><span class="built_in">*</span></span> x x)) (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line">(<span class="name">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<p><code>map</code> 建立起了对表处理的高级抽象。</p>
<ul>
<li>在原来的 <code>scale-list</code> 里面，我们的注意力被吸引到了如何对每个元素做处理上。而通过抽象成 <code>map</code> 省略了细节上的层面。</li>
<li>这两种形式定义的差别，不会让计算机进行不同的计算过程，而是让我们对同一个过程有了一种不同的思考方式。</li>
<li><code>map</code> 帮我们建立了一层<strong>抽象屏障</strong>，实现了映射操作，而与如何提取表中元素、如何对每个元素进行操作的细节隔离开了。</li>
</ul>
<p>接下来的练习题中就给出了很生动的例子：过程<code>square-list</code>返回序列中每个数的平方构成的新序列。第一个定义就是过程性语言中的迭代：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="built_in">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> items)</span><br><span class="line">      nil</span><br><span class="line">      (<span class="name"><span class="built_in">cons</span></span> (<span class="name">square</span> (<span class="name"><span class="built_in">car</span></span> items))(<span class="name">square-list</span> (<span class="name"><span class="built_in">cdr</span></span> items)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">square-list</span> (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>其实观察可以发现，内部的过程其实是和<code>map</code>很相似的，这就是为何要抽象的原因。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="built_in">*</span></span> x x))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name"><span class="built_in">map</span></span> square items))</span><br><span class="line"></span><br><span class="line">(<span class="name">square-list</span> (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/JeffreyZhao/archive/2009/07/15/recommended-reading-2-sicp.html">老赵书托</a>中，就提到了这个例子：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/laozhao1.png" alt=""></p>
<blockquote>
<p>如果您理解了上面的代码，其实您已经对函数式编程更细致的抽象能力有所体会了。……目前函数式编程几乎已经成了高级语言的必备特性了，如C#，F#，甚至颇有代替Java语言之势的Scala中也包含了相当的函数式编程能力。事实上，我认为出现这种趋势的一个重要原因，便在于人们之前对面向对象语言的抽象能力寄予过高期望，而这种期望的破灭（或者说“冷静”）使得许多人的注意力又回到了更容易“组合”和“复用”的函数式编程理念上。而且，其实人们从来没有放弃过对小粒度的事物的热爱。例如很多人喜欢C语言的原因，便是因为它没有庞大的架构，可以通过各种方法的组装来编写程序。而Unix编程艺术之一，便是大量小程序的组合复用。</p>
</blockquote>
<h1 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h1><p>for-each 与 map 类似，但它并不返回结果的表，而是把过程应用于各个元素，而得到的值都丢弃不用。返回值是一些其他的东西，例如逻辑值真。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">for-each</span></span> proc items)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">null?</span></span> items))</span><br><span class="line">         (<span class="name">proc</span> (<span class="name"><span class="built_in">car</span></span> items))             <span class="comment">;仅将过程应用于各个元素</span></span><br><span class="line">         (<span class="name"><span class="built_in">for-each</span></span> proc (<span class="name"><span class="built_in">cdr</span></span> items))))) <span class="comment">;满足条件就继续应用下一个。应用 proc 得到的值都丢弃不用 </span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">for-each</span></span> (<span class="name"><span class="built_in">lambda</span></span>(x) (<span class="name"><span class="built_in">newline</span></span>) (<span class="name"><span class="built_in">display</span></span> x))</span><br><span class="line">          (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SICP</category>
      </categories>
  </entry>
  <entry>
    <title>SICP——层次性结构（树），以及约定化的接口</title>
    <url>/2018/03/29/sicp-6-Hierarchical-Stuctures-and-Conventional-Interfaces/</url>
    <content><![CDATA[<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p><strong>keywords</strong>：树、递归、对树映射；约定的序列化接口。<br><strong>程序</strong>：<code>count-leaves</code>、<code>deep-reverse</code>、<code>map</code>、<code>filter</code>、<code>accumulator</code>、<code>enumerate</code></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>利用 cons 的闭包性，将序对用作 cons 的参数，就可以产生层次性结构（树）。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/cons%20tree.png" alt=""></p>
<p><strong>本身是序对的元素</strong>就成了树中的<strong>子树</strong>。因此，<strong>递归是处理树结构的一种很自然的工具</strong>。我们可以来看一个例子：</p>
<p>序列中求表长的 length 的方案是：</p>
<ul>
<li>表 x 的 length 是 (cdr x) 的 length + 1</li>
<li>空表长度为 0</li>
</ul>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">length</span></span> L)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> L)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">length</span></span> (<span class="name"><span class="built_in">cdr</span></span> L)))))</span><br></pre></td></tr></table></figure>
<p>count-leaves 过程，统计一棵树中叶子的个数，其实方案是类似的：</p>
<ul>
<li>空表的 count-leaves 是 0</li>
<li>在递归中，当我们去掉一个 car 时，就可能出现这个 car 是一棵子树的情况。所以正确的归约步骤应该是<ul>
<li>树 x 的 count-leaves 应该是 (car x) 的 count-leaves 与 (cdr x) 的 count-leaves 之和。</li>
<li>树叶的 count-leaves 是 1</li>
</ul>
</li>
</ul>
<p>Scheme 提供基本过程<code>pair?</code>，它检查参数是否为序对。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">count-leaves</span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">null?</span></span> x) <span class="number">0</span>)                       <span class="comment">; cond 中前两个条件的顺序很重要，因为空表将满足 null? 且同时不是序对</span></span><br><span class="line">        ((<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">pair?</span></span> x)) <span class="number">1</span>)                 <span class="comment">; x 不是序对则 x 是叶子</span></span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">+</span></span> (<span class="name">count-leaves</span> (<span class="name"><span class="built_in">car</span></span> x))     <span class="comment">; 左子树</span></span><br><span class="line">                 (<span class="name">count-leaves</span> (<span class="name"><span class="built_in">cdr</span></span> x)))))) <span class="comment">; 右子树</span></span><br></pre></td></tr></table></figure>
<p>查看测试样例：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/length%20and%20countleaves.png" alt=""></p>
<p>可以得知，过程<code>length</code>对于<code>car</code>是序对或者是序列的，也只算 1，cons (list 1 2)(list 3 4) 中(list 1 2)算长度 1，后面的 (list 3 4) 算长度 2。过程<code>count-leaves</code>则注意到了<code>car</code>也需要递归。</p>
<h2 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h2><p>对于序列的<code>reverse</code>过程，写一个<code>deep-reverse</code>过程，以一个表为参数，除了将表中的元素翻转过来之外，把其中的子树也翻转。</p>
<p>如果将<code>reverse</code>用于树，就是只将树的最外层翻转。类似分析，使用递归，将内层子树一起<code>reverse</code></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">reverse</span></span> L)(<span class="name">reverse-iter</span> L nil))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">reverse-iter</span> list other)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> list)</span><br><span class="line">      other</span><br><span class="line">      (<span class="name">reverse-iter</span> (<span class="name"><span class="built_in">cdr</span></span> list)(<span class="name"><span class="built_in">cons</span></span>(<span class="name"><span class="built_in">car</span></span> list) other))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">deep-reverse</span> tree)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">null?</span></span> tree)         <span class="comment">; 空树</span></span><br><span class="line">            &#x27;())                <span class="comment">; Scheme 中 &#x27;() 表示空表</span></span><br><span class="line">          ((<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">pair?</span></span> tree))   <span class="comment">; 叶子</span></span><br><span class="line">            tree)               <span class="comment">; 返回本身</span></span><br><span class="line">          (<span class="name"><span class="built_in">else</span></span>                 <span class="comment">; 递归地逆序左右子树</span></span><br><span class="line">            (<span class="name"><span class="built_in">reverse</span></span> (<span class="name"><span class="built_in">list</span></span> (<span class="name">deep-reverse</span> (<span class="name"><span class="built_in">car</span></span> tree))            </span><br><span class="line">                           (<span class="name">deep-reverse</span> (<span class="name"><span class="built_in">cadr</span></span> tree)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> x (<span class="name"><span class="built_in">list</span></span> (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span>) (<span class="name"><span class="built_in">list</span></span> <span class="number">3</span> <span class="number">4</span>)))</span><br><span class="line">(<span class="name"><span class="built_in">reverse</span></span> x)</span><br><span class="line"><span class="comment">;((3 4) (1 2))</span></span><br><span class="line">(<span class="name">deep-reverse</span> x)</span><br><span class="line"><span class="comment">;((4 3) (2 1))</span></span><br></pre></td></tr></table></figure>
<p>写一个过程<code>fringe</code>，以一个树为参数，返回一个表，元素是这棵树的树叶。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">fringe</span> tree)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">null?</span></span> tree) &#x27;())</span><br><span class="line">        ((<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">pair?</span></span> tree)) (<span class="name"><span class="built_in">list</span></span> tree))</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span></span><br><span class="line">         (<span class="name"><span class="built_in">append</span></span> (<span class="name">fringe</span> (<span class="name"><span class="built_in">car</span></span> tree))</span><br><span class="line">                 (<span class="name">fringe</span> (<span class="name"><span class="built_in">cdr</span></span> tree))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> x (<span class="name"><span class="built_in">list</span></span> (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span>) (<span class="name"><span class="built_in">list</span></span> <span class="number">3</span> <span class="number">4</span>)))</span><br><span class="line">(<span class="name">fringe</span> x)</span><br><span class="line"><span class="comment">;(1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<h2 id="对树的映射-map"><a href="#对树的映射-map" class="headerlink" title="对树的映射 map"></a>对树的映射 map</h2><p>下面是一个与<code>scale-list</code>相似的过程，用一个因子乘上一棵树上所有的叶子。递归的思路和 <code>count-leaves</code> 是类似的</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">scale-tree</span> tree factor)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">null?</span></span> tree) nil)</span><br><span class="line">        ((<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">pair?</span></span> tree)) (<span class="name"><span class="built_in">*</span></span> tree factor))</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name">scale-tree</span> (<span class="name"><span class="built_in">car</span></span> tree) factor)</span><br><span class="line">                    (<span class="name">scale-tree</span> (<span class="name"><span class="built_in">cdr</span></span> tree) factor)))))</span><br></pre></td></tr></table></figure>
<p><strong>map 是处理序列的强有力抽象。</strong></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">map</span></span> proc items)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> items)</span><br><span class="line">      nil</span><br><span class="line">      (<span class="name"><span class="built_in">cons</span></span> (<span class="name">proc</span> (<span class="name"><span class="built_in">car</span></span> items))</span><br><span class="line">            (<span class="name"><span class="built_in">map</span></span> proc (<span class="name"><span class="built_in">cdr</span></span> items)))))</span><br></pre></td></tr></table></figure>
<p><strong>map 与递归结合就也是处理树的一种强有力抽象。</strong></p>
<ul>
<li>将树看成子树的序列，对它使用 map，依次对各棵子树做 proc 返回结果的表。</li>
<li>当被处理的树是树叶，直接用因子去乘。</li>
</ul>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">(define (scale-tree tree factor)</span><br><span class="line">  (map (lambda (sub-tree)</span><br><span class="line">         (if (pair? sub-tree)</span><br><span class="line">             (scale-tree<span class="built_in"> sub-tree </span>factor)</span><br><span class="line">             (*<span class="built_in"> sub-tree </span>factor)))</span><br><span class="line">       tree))</span><br></pre></td></tr></table></figure>
<h1 id="序列作为一种约定的界面"><a href="#序列作为一种约定的界面" class="headerlink" title="序列作为一种约定的界面"></a>序列作为一种约定的界面</h1><p>讲到数据抽象在工程中的作用。</p>
<p>借助这种思想，构建一种不会被数据表示的细节纠缠的程序。一种强有力的设计原理——<strong>使用约定的界面</strong>。</p>
<p>过程1：以一棵树为参数，计算值为奇数的叶子的平方和。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">sum-odd-squares</span> tree)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">null?</span></span> tree) <span class="number">0</span>)  </span><br><span class="line">        ((<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">pair?</span></span> tree))</span><br><span class="line">         (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">odd?</span></span> tree) (<span class="name">square</span> tree) <span class="number">0</span>))</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">+</span></span> (<span class="name">sum-odd-squares</span> (<span class="name"><span class="built_in">car</span></span> tree))</span><br><span class="line">                 (<span class="name">sum-odd-squares</span> (<span class="name"><span class="built_in">cdr</span></span> tree))))))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>枚举</strong>出一棵树的树叶</li>
<li><strong>过滤</strong>它们，选出奇数</li>
<li>求平方 <strong>（映射）</strong></li>
<li>用 + 来<strong>累积</strong>得到的结果，从 0 开始。</li>
</ul>
<p>过程2：k 小于等于某个给定的整数 n，求所有是偶数的斐波那契数Fib(k)的一个表。</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">even-fibs</span> n)</span><br><span class="line">  (<span class="name">define</span> (<span class="name"><span class="built_in">next</span></span> k)</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&gt;</span></span> k n)</span><br><span class="line">        <span class="literal">nil</span></span><br><span class="line">        (<span class="name"><span class="built_in">let</span></span> ((<span class="name">f</span> (<span class="name">fib</span> k)))</span><br><span class="line">          (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">even?</span></span> f)</span><br><span class="line">              (<span class="name"><span class="built_in">cons</span></span> f (<span class="name"><span class="built_in">next</span></span> (<span class="name"><span class="built_in">+</span></span> k <span class="number">1</span>)))</span><br><span class="line">              (<span class="name"><span class="built_in">next</span></span> (<span class="name"><span class="built_in">+</span></span> k <span class="number">1</span>))))))</span><br><span class="line">  (<span class="name"><span class="built_in">next</span></span> <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>枚举</strong> k，k是从 0 到 n 的整数</li>
<li><strong>（映射）</strong>对应每个 k 计算 Fib(k)</li>
<li><strong>过滤</strong>它们，从中选取相应的偶数</li>
<li>用 cons 来<strong>累积</strong>得到的结果，从空表开始。</li>
</ul>
<p>这种过程可以用一些级联处理步骤的方式来描述：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/signal-flow%20plans.png" alt=""></p>
<p><strong>模块化结构是控制复杂性的一种威力强大的策略。</strong>由一些互相比较独立的组件组合构成的设计，有约定的界面使这些部件都能以比较灵活的方式相互连接，进一步推动人们去做模块化的设计。</p>
<h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 map</h2><p>前面提过，不再赘述</p>
<h2 id="过滤器-filter"><a href="#过滤器-filter" class="headerlink" title="过滤器 filter"></a>过滤器 filter</h2><p>过滤一个序列，从中选取满足某个给定的谓词的元素：</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name"><span class="built_in">filter</span></span> predicate sequence)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name">null?</span> sequence) <span class="literal">nil</span>)</span><br><span class="line">        ((<span class="name">predicate</span> (<span class="name"><span class="built_in">car</span></span> sequence))</span><br><span class="line">         (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> sequence)</span><br><span class="line">               (<span class="name"><span class="built_in">filter</span></span> predicate (<span class="name"><span class="built_in">cdr</span></span> sequence))))</span><br><span class="line">        (<span class="name">else</span> (<span class="name"><span class="built_in">filter</span></span> predicate (<span class="name"><span class="built_in">cdr</span></span> sequence)))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">filter</span></span> odd? (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"><span class="comment">;(1 3 5)</span></span><br></pre></td></tr></table></figure>
<p>下面来看一个 <code>filter</code> 的运用例子。</p>
<p>过程 <code>+</code>、<code>*</code>、<code>list</code> 可以<strong>取任意个数的实际参数</strong>。定义这种过程的一种方式是采取一种<strong>尾部带点记法</strong>形式的 define。在一个过程定义中，如果在形参表的<strong>最后一个</strong>参数<strong>之前</strong>有一个<strong>点号</strong>，那么表明这一过程实际调用时，前面各个形式参数将以前面的实际参数位值。但最后一个形式参数以<strong>所有剩下的实际参数的表</strong>为值。</p>
<p>若我们有如下代码：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">f</span> x y . z) &lt;body&gt;)</span><br><span class="line">(<span class="name">f</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">g</span> . w) &lt;body&gt;)</span><br><span class="line">(<span class="name">g</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>则 x 为 1，y 为 2，z 是表(3 4 5 6)，w 是表（1 2 3 4 5 6)，g 是 0 个或多个参数调用。</p>
<p>下面写一个过程 same-parity，返回所有与第一个参数有着同样奇偶性质的参数形成的表。</p>
<ul>
<li>判断奇偶性质，可以用基本过程<code>even?</code>、<code>odd?</code></li>
<li>传递给 <code>filter</code> 过程。</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">same-parity</span> x . others)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">odd?</span></span> x) (<span class="name"><span class="built_in">cons</span></span> x (<span class="name"><span class="built_in">filter</span></span> odd? others)))</span><br><span class="line">        ((<span class="name"><span class="built_in">even?</span></span> x) (<span class="name"><span class="built_in">cons</span></span> x (<span class="name"><span class="built_in">filter</span></span> even? others)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">same-parity</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span><br><span class="line">(<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h2 id="累加器-accumulator"><a href="#累加器-accumulator" class="headerlink" title="累加器 accumulator"></a>累加器 accumulator</h2><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name"><span class="built_in">accumulate</span></span> op initial sequence)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name">null?</span> sequence)</span><br><span class="line">      initial</span><br><span class="line">      (<span class="name">op</span> (<span class="name"><span class="built_in">car</span></span> sequence)</span><br><span class="line">          (<span class="name"><span class="built_in">accumulate</span></span> op initial (<span class="name"><span class="built_in">cdr</span></span> sequence)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">accumulate</span></span> + <span class="number">0</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">accumulate</span></span> * <span class="number">1</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"><span class="number">120</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">accumulate</span></span> cons <span class="literal">nil</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="枚举-enumerate"><a href="#枚举-enumerate" class="headerlink" title="枚举 enumerate"></a>枚举 enumerate</h2><p>枚举出一棵树的所有树叶的列表：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">enumerate-tree</span> tree)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">null?</span></span> tree) nil)</span><br><span class="line">        ((<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">pair?</span></span> tree)) (<span class="name"><span class="built_in">list</span></span> tree))</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">append</span></span> (<span class="name">enumerate-tree</span> (<span class="name"><span class="built_in">car</span></span> tree))</span><br><span class="line">                      (<span class="name">enumerate-tree</span> (<span class="name"><span class="built_in">cdr</span></span> tree))))))</span><br></pre></td></tr></table></figure>
<p>枚举一个给定区间的整数序列：</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">enumerate-interval</span> low high)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&gt;</span></span> low high)</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name"><span class="built_in">cons</span></span> low (<span class="name">enumerate-interval</span> (<span class="name"><span class="built_in">+</span></span> low <span class="number">1</span>) high))))</span><br></pre></td></tr></table></figure>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>现在，我们运用信号流图来重构<code>sum-odd-squares</code>与<code>even-fibs</code>。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/signal-flow%20plans.png" alt=""></p>
<p><code>sum-odd-squares</code>：枚举一棵树的树叶/过滤剩下奇数/求每个元素的平方/从0累加</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">sum-odd-squares</span> tree)</span><br><span class="line">  (<span class="name"><span class="built_in">accumulate</span></span> +</span><br><span class="line">              <span class="number">0</span></span><br><span class="line">              (<span class="name"><span class="built_in">map</span></span> square</span><br><span class="line">                   (<span class="name"><span class="built_in">filter</span></span> odd?</span><br><span class="line">                           (<span class="name">enumerate-tree</span> tree)))))</span><br></pre></td></tr></table></figure>
<p><code>even-fibs</code>：枚举 0~n 的序列/求 Fib(k)/过滤剩下偶数/ 从 nil 开始 cons 成一个表</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">even-fibs</span> n)</span><br><span class="line">  (<span class="name"><span class="built_in">accumulate</span></span> cons</span><br><span class="line">              <span class="literal">nil</span></span><br><span class="line">              (<span class="name"><span class="built_in">filter</span></span> even?</span><br><span class="line">                      (<span class="name"><span class="built_in">map</span></span> fib</span><br><span class="line">                           (<span class="name">enumerate-interval</span> <span class="number">0</span> n)))))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SICP</category>
      </categories>
  </entry>
  <entry>
    <title>SICP——嵌套映射</title>
    <url>/2018/04/01/sicp-7-Nested-Mappings/</url>
    <content><![CDATA[<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p><strong>程序</strong>： 嵌套映射结构 ；<code>permutation</code></p>
<h1 id="嵌套映射"><a href="#嵌套映射" class="headerlink" title="嵌套映射"></a>嵌套映射</h1><p>主要介绍一种方法，将高级语言中多重循环的语句用嵌套映射的计算方式表达。</p>
<p>问题：给定自然数 n ，找出不同的序对 <code>(i, j)</code>,  满足：$ 1 ≤ j ≤ i ≤ n $, 且 $ i + j $ 是素数。假定 n 为 6，则结果应该如下：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>j</th>
<th>i+j</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>7</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>7</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>7</td>
</tr>
<tr>
<td>6</td>
<td>5</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>最自然的解法是；生成所有小于等于 n 的自然数的全序对，进行过滤，选出和为素数的序对。对通过过滤的序对，产生一个三元组<code>(i, j, i + j)</code>。</p>
<p>在高级语言中会这样子产生序对：对于 $ i ≤ n $，枚举 $ j ≤ i $。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">for(i <span class="operator">=</span> <span class="number">1</span><span class="comment">; i&lt;= n; i++)</span></span><br><span class="line">    for(j <span class="operator">=</span> <span class="number">1</span><span class="comment">; j &lt; i; j++)</span></span><br></pre></td></tr></table></figure>
<p>用序列操作、以及映射的方式来讲这两个 for 语句所表达的东西，是如下一段有可能看起来觉得很绕的话：</p>
<p>对序列 <code>(1 ~ n)</code> 做一次映射：对这个序列里的每个 i，对序列<code>(1 ~ i-1)</code> 再做一次做映射，生成序对<code>(list i j)</code>。将所有序对用 <code>append</code> 积累起来，得到一个序对序列。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">accumulate</span> append                                          <span class="comment">;用 append 积累所有序对列表</span></span><br><span class="line">            nil</span><br><span class="line">            (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">lambda</span></span>(i)                                 <span class="comment">;外层映射是：for(i=1;i&lt;=n;i++) 对 i 做映射</span></span><br><span class="line">                   (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">lambda</span></span>(j) (<span class="name"><span class="built_in">list</span></span> i j))              <span class="comment">;内层映射是：for(j=1;j&lt;i;j++) 生成list(i, j)</span></span><br><span class="line">                        (<span class="name">enumerate-interval</span> <span class="number">1</span> (<span class="name"><span class="built_in">-</span></span> i <span class="number">1</span>))))    <span class="comment">;外层映射看3、6行，内层映射看4、5行</span></span><br><span class="line">                 (<span class="name">enumerate-interval</span> <span class="number">1</span> n)))                 <span class="comment">;这里 n 还未定义</span></span><br></pre></td></tr></table></figure>
<p>将 <code>accumulate append map</code> 这一个程序（映射并用append做序列的表积累）定义为一个过程：</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">flatmap</span> proc seq)</span><br><span class="line">  (<span class="name"><span class="built_in">accumulate</span></span> append <span class="literal">nil</span> (<span class="name"><span class="built_in">map</span></span> proc seq)))</span><br></pre></td></tr></table></figure>
<p>过滤找出和为素数的序对：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="comment">;判断素数</span></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">smallest-divisor</span> n)</span><br><span class="line">  (<span class="name">find-divisor</span> n <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">find-divisor</span> n test-divisor)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">&gt;</span></span> (<span class="name">square</span> test-divisor) n) n)</span><br><span class="line">        ((<span class="name">divides?</span> test-divisor n) test-divisor)</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> (<span class="name">find-divisor</span> n (<span class="name"><span class="built_in">+</span></span> test-divisor <span class="number">1</span>)))))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">divides?</span> a b)</span><br><span class="line">  (<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">remainder</span></span> b a) <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">prime?</span> n)</span><br><span class="line">  (<span class="name"><span class="built_in">=</span></span> n (<span class="name">smallest-divisor</span> n)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;判断一个序对的和是不是素数</span></span><br><span class="line"><span class="comment">;由于“序对”是使用 list 形成的表，所以要用 cadr 而不是 cdr</span></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">prime-sum?</span> pair)</span><br><span class="line">  (<span class="name">prime?</span> (<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">car</span></span> pair) (<span class="name"><span class="built_in">cadr</span></span> pair))))</span><br></pre></td></tr></table></figure>
<p>生成一个三元组：<code>(i, j, i + j)</code>，代表 i 和 j 是一个和为素数的序对。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">make-pair-sum</span> pair)</span><br><span class="line">  (<span class="name"><span class="built_in">list</span></span> (<span class="name"><span class="built_in">car</span></span> pair)(<span class="name"><span class="built_in">cdr</span></span> pair)(<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">car</span></span> pair)(<span class="name"><span class="built_in">cadr</span></span> pair))))</span><br></pre></td></tr></table></figure>
<p>整合起来的过程是：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">prime-sum-pairs</span> n)                             <span class="comment">;</span></span><br><span class="line">  (<span class="name"><span class="built_in">map</span></span> make-pair-sum                                    <span class="comment">;对序列(1~n)做映射：生成和为素数的序对的三元组</span></span><br><span class="line">       (<span class="name">filter</span> prime-sum?                               <span class="comment">;从序对的表中过滤，只挑和为素数的序对</span></span><br><span class="line">               (<span class="name">flatmap</span>                                 <span class="comment">;faltmap: 映射，并用把结果用 append 积累</span></span><br><span class="line">                (<span class="name"><span class="built_in">lambda</span></span>(i)                              <span class="comment">;这一行的结果会是一个表，交给filter过滤</span></span><br><span class="line">                  (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">lambda</span></span>(j) (<span class="name"><span class="built_in">list</span></span> i j))           <span class="comment">;嵌套映射的注释见上方</span></span><br><span class="line">                       (<span class="name">enumerate-interval</span> <span class="number">1</span> (<span class="name"><span class="built_in">-</span></span> i <span class="number">1</span>))))</span><br><span class="line">                (<span class="name">enumerate-interval</span> <span class="number">1</span> n)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">prime-sum-pairs</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子讲完了。是不是很神奇呢</p>
<p>下一个例子：全排列：</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name"><span class="built_in">permutations</span></span> s)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name">null?</span> s)</span><br><span class="line">      (<span class="name">list</span> <span class="literal">nil</span>)                                    <span class="comment">;如果 s 为空，s的全排列就为空。这也是递归的最终情况。</span></span><br><span class="line">      (<span class="name">flatmap</span>                                      </span><br><span class="line">       (<span class="name"><span class="built_in">lambda</span></span> (<span class="name">x</span>)                                  <span class="comment">;外层映射是 for x in s，对 x 做一个映射</span></span><br><span class="line">         (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">lambda</span></span> (<span class="name">p</span>) (<span class="name"><span class="built_in">cons</span></span> x p))               <span class="comment">;内层映射是对 p 生成 cons(x, p)，p 是 s 中除外 x 的全排列</span></span><br><span class="line">              (<span class="name"><span class="built_in">permutations</span></span> (<span class="name"><span class="built_in">remove</span></span> x s))))</span><br><span class="line">       s)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name"><span class="built_in">remove</span></span> item sequence)                      <span class="comment">; 返回除了指定 item 之外的所有项</span></span><br><span class="line">  (<span class="name"><span class="built_in">filter</span></span> (<span class="name"><span class="built_in">lambda</span></span>(<span class="name">x</span>) (<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">=</span></span> x item)))</span><br><span class="line">          sequence))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">permutations</span></span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>对比一下C语言的全排列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>], book[<span class="number">10</span>], n;<span class="comment">//a数组代表盒子，book数组代表手中的卡的情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> posi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (posi == n + <span class="number">1</span>)<span class="comment">//如果走到了第n+1个盒子（实际上没有n+1个盒子）说明前n个盒子已经都放好扑克牌</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输出一种全排列</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//一定要返回，回到最近一次调用dfs的地方</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//每个小盒子都可能放1、2、3、、、n的牌，用for循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断编号为i的扑克牌是否还在手上</span></span><br><span class="line">		<span class="keyword">if</span> (book[i] == <span class="number">0</span>)<span class="comment">//book[i]==0说明i号扑克牌在手上</span></span><br><span class="line">		&#123;</span><br><span class="line">			a[posi] = i;<span class="comment">//丢到这个盒子里</span></span><br><span class="line">			book[i] = <span class="number">1</span>;<span class="comment">//book[i]置为1，表示i号扑克牌不在手上</span></span><br><span class="line"></span><br><span class="line">			<span class="built_in">dfs</span>(posi + <span class="number">1</span>);<span class="comment">//走到下一个盒子前进行dfs</span></span><br><span class="line">			book[i] = <span class="number">0</span>;<span class="comment">//非常重要的一步，完成了一次dfs一定要收回这张牌才可以进行下一次尝试</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入n，输出123……n的全排列：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);<span class="comment">//从第一个盒子开始dfs</span></span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SICP</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之智能指针</title>
    <url>/2017/06/22/smart-pointer/</url>
    <content><![CDATA[<p>智能指针是行为类似于指针的类对象，同时还有其他的功能。</p>
<p>我们知道，通过new分配的内存要及时delete，如果不及时回收，会导致内存泄漏。有的时候，我们可能会忘记delete，有没有更好的解决方法呢？假设我们在一个函数中new了一块内存，并让一个指针p指向这块内存。当函数返回时，指针p占据的内存将被释放。如果p指向的内存也被释放，不就解决了会忘记delete导致的内存泄漏问题吗？我们的想法是：指针有一个析构函数，当指针过期时，释放指针指向的内存。问题在于，普通指针并不是一个对象，没有析构函数，我们要做到的就是将其设计成对象，让它过期时，通过它的析构函数删除指向的内存。这正是智能指针背后的思想。</p>
<p>有三种智能指针：<code>auto_ptr</code>、<code>unique_ptr</code>、<code>shared_ptr</code>。auto_ptr是C++98提供的解决方案，C++11已经摒弃，并提供了另外两种解决方案。</p>
<h1 id="使用智能指针"><a href="#使用智能指针" class="headerlink" title="使用智能指针"></a>使用智能指针</h1><p>这三个智能指针模板都定义了类似指针的对象，可以将new获得的地址赋给这种对象。当智能指针对象过期时，其析构函数将使用delete来释放内存。因此，如果将new返回的地址赋给这种对象，就不存在内存泄漏问题。</p>
<p>要使用智能指针，需要包含头文件<code>memory</code>，使用通常的模板语法来实例化所需类型的指针。例如模板 auto_ptr 包含如下的构造函数：<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">X</span>&gt; <span class="symbol">class</span> <span class="symbol">auto_ptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">explicit</span> <span class="built_in">auto</span>_ptr(X *p = <span class="number">0</span>) throw();</span><br><span class="line">...&#125;;</span><br></pre></td></tr></table></figure></p>
<p>请求X类型的 auto_ptr 将获得一个指向X类型的 auto_ptr。其他两种智能指针有相同的语法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">pd1</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;   <span class="comment">//替代了 double *</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">pd1</span><span class="params">(<span class="keyword">new</span> string)</span></span>;   <span class="comment">//替代了 string *</span></span><br></pre></td></tr></table></figure>
<p>如果要用智能指针替换普通指针，需要安装下面三个步骤进行：</p>
<ol>
<li>包含头文件memory</li>
<li>将指针替换成智能指针对象。</li>
<li>删去delete语句。</li>
</ol>
<h1 id="有关智能指针的注意事项"><a href="#有关智能指针的注意事项" class="headerlink" title="有关智能指针的注意事项"></a>有关智能指针的注意事项</h1><p>为何要有三种智能指针？为何摒弃auto_ptr？看下面的赋值语句：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">auto_ptr&lt;string&gt; p1(new string(<span class="string">&quot;lol&quot;</span>))<span class="comment">;</span></span><br><span class="line">auto_ptr&lt;string&gt; p2<span class="comment">;</span></span><br><span class="line"><span class="attribute">p2</span> <span class="operator">=</span> p1<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果p1和p2是常规指针，则两个指针指向了同一个string对象，在delete p1和p2时会导致同一个内存块被释放了两次，这是不能接受的。要避免这种问题，方法有多种：</p>
<ul>
<li>定义赋值运算符，使之执行深度复制。这在类的动态内存分配中有提到。</li>
<li>建立<strong>所有权</strong>（ownership）概念。对于特定的对象，只能有一个智能指针可以指向它，只有拥有对象的智能指针的构造函数会删除该对象。然后，赋值操作会<strong>转让</strong>所有权。这就是用于 auto_ptr 和 unique_ptr 的策略，但后者更严格。</li>
<li>建立<strong>引用计数</strong>（reference counting）概念，用于确定引用同一个特定对象的智能指针数。例如赋值时，计数自增1，指针过期时，计数自减1。只有当最后一个指针过期时，才调用 delete 释放内存块。这是 share_ptr 的策略。</li>
</ul>
<p>三种智能指针各有用途和适用的情况，下面来看一个不适合 auto_ptr 的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	auto_ptr&lt;string&gt; n[<span class="number">5</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">auto_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;1&quot;</span>)),</span><br><span class="line">		<span class="built_in">auto_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;2&quot;</span>)),</span><br><span class="line">		<span class="built_in">auto_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;3&quot;</span>)),</span><br><span class="line">		<span class="built_in">auto_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;4&quot;</span>)),</span><br><span class="line">		<span class="built_in">auto_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;5&quot;</span>))</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	auto_ptr&lt;string&gt; p;</span><br><span class="line">	p = n[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *n[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有权机制是一个好事，可以防止两个不同的智能指针对象调用析构函数时重复删除同一块内存块。但这里错误地使用 auto_ptr 会导致问题。这里的问题在于，语句<code>p = n[2];</code>将导致所有权从 n[2] 转让给 p。n[2]将不再引用该字符串。当程序要输出 n[2] 指向的字符串时，却发现这是一个空指针。报错：auto_ptr not dereferencable</p>
<p>如果用 share_ptr 来替代程序中的auto_ptr，程序将会正常运行并输出正确。使用了shared_ptr后，语句<code>p = n[2];</code>，使得 p 和 n[2] 指向同一个对象，引用计数从1增加到2。在程序末尾 后声明的p先调用其析构函数，引用计数降到1，然后到 n[2] 被释放时，引用计数降低到0，此时再调用delete，释放内存。</p>
<p>unique_ptr采取更严格的所有权机制，如果把上述代码的指针改成 unique_ptr，会在编译阶段就报错。因此，unique_ptr 比 auto_ptr 更安全，编译阶段错误总比潜在的程序运行时崩溃要好得多。</p>
<p>程序试图将一个unique_ptr 赋给另一个时，如果源 unique_ptr 是一个临时右值，那编译器允许这样做。如果源 unique_ptr 将存在一段时间，则编译器会禁止这样做。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="built_in">string</span>&gt; <span class="title">p1</span>(<span class="params"><span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span></span>))</span>;</span><br><span class="line">unique_ptr&lt;<span class="built_in">string</span>&gt; p2;</span><br><span class="line">p2 = p1; <span class="comment">//not allowed</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;<span class="built_in">string</span>&gt; p3;</span><br><span class="line">p3 = unique_ptr&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//allowed</span></span><br></pre></td></tr></table></figure>
<p>第一个例子将留下悬挂的指针p1，语句二不会导致留下悬挂指针，因为它调用构造函数，构造函数创建的临时对象赋值给p3后，在构造函数返回时临时对象被销毁。</p>
<p>当确实有需要时，C++有一个标准库函数<code>std::move()</code>可以将一个 unique_ptr 赋值给另一个。</p>
<h1 id="如何选择智能指针？"><a href="#如何选择智能指针？" class="headerlink" title="如何选择智能指针？"></a>如何选择智能指针？</h1><p>如果程序要使用多个指向同一个对象的指针，应选择<code>shared_ptr</code>。举几个这样的情况的例子：有一个指针数组，此外还有一些额外的辅助指针标识特定的元素，例如最大的元素，最小的元素等等；两个对象都包含指向第三个对象的指针；STL容器和算法，很多STL算法都支持复制和赋值操作。</p>
<p>如果程序不需要多个指向同一个对象的指针，则可以使用<code>unique_ptr</code>。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>我对朋友、友谊的简单几点思考</title>
    <url>/2023/08/10/some-thoughts-on-friendship/</url>
    <content><![CDATA[<p>本文记录多年以来的对朋友、友谊的思考。</p>
<h1 id="一、朋友是自己主动寻找的，而不是被动等待朋友上门的。"><a href="#一、朋友是自己主动寻找的，而不是被动等待朋友上门的。" class="headerlink" title="一、朋友是自己主动寻找的，而不是被动等待朋友上门的。"></a>一、朋友是自己主动寻找的，而不是被动等待朋友上门的。</h1><p>如果有觉得自己朋友很少，没办法和别人形成有效的交际和联络的读者，这是我可以分享的思考第一点。主动去和别人交朋友，主动地和不认识的人打交道、建立关系，这是一种能力，可以锻炼的能力。或许你之所以会觉得“我没什么朋友”，是因为你只想坐在家里等别人上门来和你交朋友，但是这种想法往往是徒劳无功的。一定要主动，主动，主动。</p>
<h1 id="二、只要有最少的共同之处，就可以成为朋友；很多人拿错误的标准要求朋友。"><a href="#二、只要有最少的共同之处，就可以成为朋友；很多人拿错误的标准要求朋友。" class="headerlink" title="二、只要有最少的共同之处，就可以成为朋友；很多人拿错误的标准要求朋友。"></a>二、只要有最少的共同之处，就可以成为朋友；很多人拿错误的标准要求朋友。</h1><p>有的人把成为“朋友”的标准提得太高了。在我看来，想要成为朋友的两个人，只需要有最低最低程度的共同之处，就可以成为朋友了。你们不需要在很多事情上都有共通点。举个例子来说，我在学校从来就没有遇到一个喜欢听古典乐的人，但是有一次我看到一个同学的头像是勃拉姆斯，那么我就主动和他搭话，我们成为了在古典乐上的朋友：我听到什么从来没听过的曲子，有所感触，就和他分享体会。但除此之外，我和他没有什么别的共同话题。这可以作为一个好例子。我和他萍水相逢，也没有很多的共同话题，但是我们在古典乐上分享共同的爱好，就可以成为朋友。如果你们有更多的共同之处，例如你们从事一样的职业、喜欢打同一款游戏、都喜欢某种活动，那么你们会成为更好的朋友。但这些都是强求不来的。只需要记住，只要有最低程度的共同点，两个人就可以当朋友。想通了这一点，心胸会变得开阔。</p>
<p>有很多人对朋友产生的不满情绪的来源让我看了觉得很惋惜。有的人会这样想：“我拿他当朋友，他竟然有XXX这样的想法，这朋友做不下去了……” 简而言之，就是在某件事情上，朋友和你的看法不同；亦或者是朋友以他的习惯而不是某种你的预期来做事，你就感到非常地 surprise，甚至觉得这是一个没办法继续做朋友的迹象。在我看来，这是错误的想法。有这样想法的、缺少宽容人，身边的朋友只会越来越少。能够和你事事都合拍、什么事情都能和你想到一处去，这不仅仅是朋友了，或许是运气好的话一辈子能碰到一个的挚友吧！一辈子可能都遇不上，说明标准定得过高。严以律己，宽以待人，这句话放在交朋友这件事上再合适不过了。而且，这句话绝对不能倒过来（对待自己非常宽容，对待别人都非常严格），有很多人正是以相反的方式践行这句话，可想而知他会获得怎么样的人生。</p>
<h1 id="三、要多主动为朋友做好事；一般来说，你自己不愿意主动维护的关系，对方多半也不愿意。"><a href="#三、要多主动为朋友做好事；一般来说，你自己不愿意主动维护的关系，对方多半也不愿意。" class="headerlink" title="三、要多主动为朋友做好事；一般来说，你自己不愿意主动维护的关系，对方多半也不愿意。"></a>三、要多主动为朋友做好事；一般来说，你自己不愿意主动维护的关系，对方多半也不愿意。</h1><p>如果已经可以做到前面两点 1、交朋友的时候主动，2、对朋友宽容，或许你已经可以迈过没有朋友的难关，不会觉得交朋友是很难的事情了。现在，就要考虑对于不同的朋友，关系的深浅是不同的。英文有个词特别好：Connection，这是说两个人关系的深浅，其实也就是 Connection 的强度。有一个理论叫邓巴数，指“能与某个人维持紧密人际关系的人数上限，通常人们认为是150”。By the way 真的能维持 150 个人是亲密关系吗？哈哈 I don’t know. 但总归这个理论告诉你，你能维持的朋友数量是有上限的，这我觉得跟人类的精力有关。这就是说，和朋友的关系如果不维护，connection 的强度就会慢慢减弱，减弱到从你的 150 个关系中消失。仔细思考一下，大概那些再也没有联系的朋友就是这样子一回事。</p>
<p>寻找朋友要主动，维系已有的 connection 也是最好自己主动。你有没有以前特别要好、甚至志同道合的朋友，但是你和他们已经非常久没有联系了？失去他们，你会觉得可惜吗？尝试 connect 一下，询问一下近况吧？或者路过他们工作的地方，约他们吃个饭叙叙旧？</p>
<h1 id="四、一个判断好朋友的标准：你会真心为他取得的成功感到高兴，并且你也相信他也会如此对你做。"><a href="#四、一个判断好朋友的标准：你会真心为他取得的成功感到高兴，并且你也相信他也会如此对你做。" class="headerlink" title="四、一个判断好朋友的标准：你会真心为他取得的成功感到高兴，并且你也相信他也会如此对你做。"></a>四、一个判断好朋友的标准：你会真心为他取得的成功感到高兴，并且你也相信他也会如此对你做。</h1><p>我心想这可能是对于嫉妒最好的对抗了吧。你会因为别人的成功而感到失望和伤心吗？若是，你们之间或许有某种竞争关系，利益冲突，或者……嫉妒这种事情，真是说不清道不明。</p>
<p>当你真的取得了什么成就，你会和哪些人分享这一好事呢？这是否也说明了这些人是你的好朋友，他们会为你取得的成绩而高兴，而你不用担心你的喜讯引来他们内心深处的不悦，而你没办法察觉。同样的，你会和朋友说 wish you all the best 的时候，do you really mean it? </p>
<p>以上是四点浅显的思考。</p>
]]></content>
  </entry>
  <entry>
    <title>开始学习C++</title>
    <url>/2017/06/07/start-learning-C/</url>
    <content><![CDATA[<p>关于C和C++之间的过渡知识。</p>
<h1 id="第一个C-程序"><a href="#第一个C-程序" class="headerlink" title="第一个C++程序"></a>第一个C++程序</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please enter a Celsius value:&quot;</span>;</span><br><span class="line">	<span class="type">double</span> c, f;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line">	f = c*<span class="number">1.8</span> + <span class="number">32.0</span>;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; <span class="string">&quot; degrees Celsius is &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot; degrees Fahrenheit&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://images2015.cnblogs.com/blog/1092156/201706/1092156-20170607120015231-427863058.png" alt=""></p>
<h1 id="用new来分配空间"><a href="#用new来分配空间" class="headerlink" title="用new来分配空间"></a>用new来分配空间</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>我们知道在C语言里用malloc()来分配内存；在C++仍然可以这样做，但C++有更好的办法——new运算符。</p>
<p>为一个数据对象（结构、基本类型等等）获得并指定分配内存的格式：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ElementType * pointer_name <span class="operator">=</span> new ElementType<span class="comment">;</span></span><br><span class="line">int *p1 <span class="operator">=</span> new int<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>那么，这两种方法，将变量的地址赋给指针，有什么区别呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a ;</span><br><span class="line">	<span class="type">int</span> *p2 = &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种情况是new将找到一个长度正确的内存块，返回该内存块的地址。<br>第二种情况下，可以用变量名a来访问该int，而第一种情况则只能通过指针来访问。<br>乍一看，使用new方法处理数据可能不太好用（p1指向的“东西”没有名称），但是它使得程序在管控内存方面有更大的控制权。</p>
<p>如果像这样，程序只需要一个值，或者一个简单的变量，这样的管理一个小型数据对象来说，直接声明比new或者指针更简单（此时的指针不让人印象深刻）。通常，对于大型数据（如字符数组、结构），应该使用new和指针，这正是指针的用武之地。</p>
<h2 id="使用delete释放内存"><a href="#使用delete释放内存" class="headerlink" title="使用delete释放内存"></a>使用delete释放内存</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	<span class="keyword">delete</span> p1;			<span class="comment">//valid and necessary</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> *p2 = &amp;a;</span><br><span class="line">	<span class="keyword">delete</span> p2;			<span class="comment">//not alowed, memory not allocated by new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存被耗尽？"><a href="#内存被耗尽？" class="headerlink" title="内存被耗尽？"></a>内存被耗尽？</h3><p>可能由于没有足够的内存满足new的要求，这种情况下，new函数将会有错误处理。在较老的实现中，new将返回0，值为0的指针就是空指针（NULL）。C++确保空指针不会指向有效的数据，它常用来表示函数失败（如果成功，返回的是一个有用的指针）</p>
<h3 id="内存泄漏？（memory-leak）"><a href="#内存泄漏？（memory-leak）" class="headerlink" title="内存泄漏？（memory leak）"></a>内存泄漏？（memory leak）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p1;	</span><br></pre></td></tr></table></figure>
<p>这会释放p1的内存，但是不会删除p1本身。例如，delete p1后，可以对p1再使用new分配新内存。一定要配对使用new和delete，否则可能发生内存泄漏，也就是说，被分配的内存无法再被使用。如果这种情况严重，则程序将由于寻找不到内存而终止。</p>
<h2 id="new创建动态数组"><a href="#new创建动态数组" class="headerlink" title="new创建动态数组"></a>new创建动态数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*new and delete*/</span></span><br><span class="line">	<span class="type">int</span> *p1 = <span class="keyword">new</span>  <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">delete</span>[]p1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete中的方括号告诉程序：释放整个数组。<br>new里有括号，delete就要带括号，new里没有，则delete也没有。</p>
<p>总之，使用new和delete的时候，遵守以下规则：（和malloc和free的原则有些许类似）</p>
<ol>
<li>不要使用delete去释放不是new分配的内存。</li>
<li>不要对同一个内存块delete两次。</li>
<li>如果用new[]，则应该使用delete[]。</li>
<li>如果用new（没有方括号），则应该使用delete（没有方括号）</li>
<li>对空指针使用delete是安全的。</li>
</ol>
<h1 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h1><h2 id="在函数里声明数组："><a href="#在函数里声明数组：" class="headerlink" title="在函数里声明数组："></a>在函数里声明数组：</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> sum<span class="constructor">_arr(<span class="params">int</span> <span class="params">arr</span>[], <span class="params">int</span> <span class="params">n</span>)</span></span><br></pre></td></tr></table></figure>
<p>这看似合理，方括号指明arr是一个数组，但实际情况是：arr实际上不是一个数组，而是一个指针。</p>
<p>这样是有好处的，将数组地址作为参数传递可以节省复制整个数组所花费的时间。而且如果数组很大，则使用拷贝时系统内存开销非常大。不仅需要占用很多内存，还需要很多时间去复制，还使得原始数据增加了被破坏的风险。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="attribute">int</span> *p = a;</span><br><span class="line"></span><br><span class="line"><span class="attribute">cout</span>&lt;&lt;sizeof(a)&lt;&lt;endl;</span><br><span class="line"><span class="attribute">cout</span>&lt;&lt;sizeof(*a)&lt;&lt;endl;</span><br><span class="line"><span class="attribute">cout</span>&lt;&lt;sizeof(p)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>上述代码输出结果是20、4、4。</p>
<h1 id="const用法"><a href="#const用法" class="headerlink" title="const用法"></a>const用法</h1><h2 id="用const保护数组数据"><a href="#用const保护数组数据" class="headerlink" title="用const保护数组数据"></a>用const保护数组数据</h2><p>为了确保显示函数不修改数组原始数据，除非函数目的在此，否则应避免这种情况的发生。为防止函数无意中修改了数组的内容，可以在声明形参的时候使用关键字const</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void show<span class="constructor">_array(<span class="params">const</span> <span class="params">double</span> <span class="params">ar</span>[], <span class="params">int</span> <span class="params">n</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>假设函数更改了数组内容，编译器会报错。所以说，const主要是为了防止程序员的错误。</p>
<h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><p>const用于指针：</p>
<h3 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h3><p>让该指针指向一个常量对象，这样可以防止用该修改指针来修改所指向的常量值。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">*p = <span class="number">0</span>;<span class="comment">//invlaid</span></span><br><span class="line">p = &amp;b;<span class="comment">//valid</span></span><br></pre></td></tr></table></figure>
<h3 id="常指针"><a href="#常指针" class="headerlink" title="常指针"></a>常指针</h3><p>将指针本身设置为常量，指针指向一个对象后，就一直效忠于这个对象。可以防止改变指针所指向的位置。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">const</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">*p1 = <span class="number">2</span>;<span class="comment">//valid</span></span><br><span class="line">p1 = &amp;b;<span class="comment">//invalid</span></span><br></pre></td></tr></table></figure>
<p>通用的方法：对于指针的定义语句，从右往左读。例如语句<code>const int *p</code>就是：定义一个指向int型常量的指针。对于<code>int const *p</code>，就是：定义一个常指针，指向一个int。</p>
<h2 id="尽可能的使用const"><a href="#尽可能的使用const" class="headerlink" title="尽可能的使用const"></a>尽可能的使用const</h2><p>将指针参数声明为指向常量数据的指针有两个好处：</p>
<p>1.这样可以避免无意间的修改而导致的错误。<br>2.使用const可以让函数处理const和非const形参，否则只能接受非const形参。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习之string类</title>
    <url>/2017/06/22/string-class/</url>
    <content><![CDATA[<p>许多的程序涉及字符串处理，C语言就在头文件<code>string.h</code>中提供了一系列字符串函数。C++的<code>string类</code>包含在头文件<code>string</code>里。要使用类，关键就在于了解它的公有接口。string类包含大量的方法，包括若干构造函数、赋值、合并、比较、访问各个元素的运算符重载以及用在字符串中查找子串的工具等等。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数是要首先看的，因为对于类而言，我们要知道有哪些方法可以用于创建其对象。下面列出了 string 的七个构造函数。使用构造函数时都进行了简化，即隐藏了这一个事实——string实际上是模板具体化<code>basic_string&lt;char&gt;</code>的一个typedef，同时省略了与内存管理相关的参数。<code>size_type</code>是一个依赖于实现的整型，是在头文件string中定义的。<code>string::npos</code>是string类定义的字符串最大长度，通常为<code>unsigned int</code> 的最大值。缩写<code>NBTS</code>是指null-terminated string，以空字符结束的字符串，也就是传统的C字符串。</p>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>string(const char *s)</td>
<td>以一个C风格字符串初始化</td>
</tr>
<tr>
<td>string(size_tpye n, char c)</td>
<td>构造一个包含n个字符c的string对象</td>
</tr>
<tr>
<td>string(const string &amp;s)</td>
<td>复制构造函数</td>
</tr>
<tr>
<td>string()</td>
<td>默认构造函数</td>
</tr>
<tr>
<td>string(const char *s, size_type n)</td>
<td>初始化为s指向的NBTS的前n个字符，即使超过了NBTS的结尾</td>
</tr>
<tr>
<td>template<class iter=""> string(Iter begin, Iter end)</class></td>
<td>初始化为区间[begin,end)内的字符</td>
</tr>
<tr>
<td>string(const string &amp;s, string size_type pos = 0, size_type n = npos)</td>
<td>初始化为对象s从位置pos开始到结尾的字符，或从pos开始的n个字符。</td>
</tr>
<tr>
<td>string(string &amp;&amp; s)noexcept</td>
<td>C++11，将一个string对象初始化为str，并可能修改str（移动构造函数）</td>
</tr>
<tr>
<td>string(initializer_list<char> il)</char></td>
<td>C++11，将一个string对象初始化为初始化列表il中的字符</td>
</tr>
</tbody>
</table>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">one</span>(<span class="params"><span class="string">&quot;11111111&quot;</span></span>)</span>;<span class="comment">// 构造函数1</span></span><br><span class="line">	cout &lt;&lt; one &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">two</span>(<span class="params"><span class="number">20</span>, <span class="string">&#x27;2&#x27;</span></span>)</span>;<span class="comment">//构造函数2</span></span><br><span class="line">	cout &lt;&lt; two &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">three</span>(<span class="params">one</span>)</span>;<span class="comment">//构造函数3</span></span><br><span class="line">	cout &lt;&lt; three &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	one += <span class="string">&quot;233&quot;</span>;<span class="comment">//重载运算符+=，连接</span></span><br><span class="line">	cout &lt;&lt; one &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	three[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;<span class="comment">//重载运算符[]，可以用数组访问法访问各个字符；重载运算符=，赋值</span></span><br><span class="line">	<span class="built_in">string</span> four;<span class="comment">//默认构造函数构造一个可以稍后进行赋值的空串</span></span><br><span class="line">	four = two + three;</span><br><span class="line">	cout &lt;&lt; four &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">char</span> s[] = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">five</span>(<span class="params">s, <span class="number">20</span></span>)</span>;<span class="comment">//构造函数5</span></span><br><span class="line">	cout &lt;&lt; five &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">six</span>(<span class="params">s + <span class="number">6</span>, s + <span class="number">10</span></span>)</span>;<span class="comment">//构造函数6</span></span><br><span class="line">	cout &lt;&lt; six &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">seven</span>(<span class="params">five, <span class="number">7</span>, <span class="number">16</span></span>)</span>;<span class="comment">//构造函数7</span></span><br><span class="line">	cout &lt;&lt; seven &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于string类的运算符重载，往往经过了多次重载，以便第二个操作数可以是string对象、也可以是C风格字符串、char字符。例如：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="literal">one</span> += <span class="literal">two</span><span class="comment">;//将stirng对象two连接到one后面</span></span><br><span class="line"><span class="literal">one</span> += <span class="string">&quot;123&quot;</span><span class="comment">;//连接一个C风格字符串</span></span><br><span class="line"><span class="literal">one</span> += <span class="string">&#x27;!&#x27;</span><span class="comment">;//连接一个char</span></span><br></pre></td></tr></table></figure>
<p>第五个构造函数有一个模板参数：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">Iter</span>&gt; <span class="symbol">string</span>(<span class="symbol">Iter</span> <span class="symbol">begin, <span class="symbol">Iter</span></span> <span class="symbol">end</span>)</span><br></pre></td></tr></table></figure>
<p><code>begin</code>和<code>end</code>像指针一样，指向内存的两个位置。begin和end可以是<strong>迭代器</strong>——一种广泛存在于STL的广义化指针。范围是<code>[begin,end)</code>，包括begin，但不包括end在内的区间。</p>
<p>现在假设要使用该构造函数用一个string对象初始化另一个string对象，看看下面的语句：<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">string</span> str(five + <span class="number">6</span>, five + <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>该语句是不管用的。原因在于对象名，不会被看做对象的地址（不像是数组名），因此<code>five + 6</code>是没意义的。而数组名s可以被看做地址，因此可作为该构造函数的一个参数。</p>
<p>构造函数<code>string(string &amp;&amp;str)</code>类似于复制构造函数，导致将新创建的string对象初始化为str的副本。但与复制构造函数不同的是，它不保证str视为const。这种构造函数称为<strong>移动构造函数</strong>（move constructor）。有些情况下编译器使用移动构造函数而不使用复制构造函数以优化性能。</p>
<p>构造函数<code>string(initializer_list&lt;char&gt; il)</code> 可以让下面的声明合法：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">string name</span> = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="string输入"><a href="#string输入" class="headerlink" title="string输入"></a>string输入</h2><p>对于类，要知道有哪些输入方式可用。对于C字符串，有下面三种：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="keyword">info</span>[<span class="number">100</span>];</span><br><span class="line">cin&gt;&gt;<span class="keyword">info</span>;                //<span class="keyword">read</span> a word</span><br><span class="line">cin.getline(<span class="keyword">info</span>, <span class="number">100</span>);   //<span class="keyword">read</span> a <span class="type">line</span>, <span class="keyword">discard</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">cin.<span class="keyword">get</span>(<span class="keyword">info</span>, <span class="number">100</span>);       //<span class="keyword">read</span> a <span class="type">line</span>, leave <span class="string">&#x27;\n&#x27;</span> <span class="keyword">in</span> queue</span><br></pre></td></tr></table></figure>
<p> 对于string对象，有两种方式：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">stirng str;</span><br><span class="line">cin&gt;&gt;str;         <span class="regexp">//</span>read a word</span><br><span class="line">getline(cin, str);<span class="regexp">//</span>read a line, discard <span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>getline()有一个可选参数，选定一个字符作为输入边界：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cin.getline(infor, <span class="number">100</span>, <span class="string">&#x27;:&#x27;</span>); </span><br><span class="line">getline(str, <span class="string">&#x27;:&#x27;</span>);            <span class="regexp">//</span>都到冒号或满<span class="number">100</span>个字符结束，如果是遇到冒号结束输入时，丢弃冒号</span><br></pre></td></tr></table></figure></p>
<p>string版本的getline和C字符串的最大区别是getline可以自动调整string对象的大小，使之刚好能存储输入的字符。 自动调整大小的功能使得string版本的getline不需要一个指定读取多少字符的参数。</p>
<p>string输入函数都将自动调整string对象的大小，使之与输入匹配。但也存在一些限制。第一个是string对象有最大允许长度，一般是最大的unsigned int 值，对于平常的使用这不会带来麻烦。但当出现例如你要读取整个文件的内容到一个字符串中时，会产生限制。第二个限制因素是程序可用的内存量不是无限的。</p>
<p>string版本的getline()函数从输入中读取字符，直到发生下面三种情况之一：</p>
<ul>
<li>到达文件尾，此时输入流的<code>eofbit</code>将被设置，这意味着方法<code>fail()</code>和<code>eof()</code>都将返回<code>true</code>。</li>
<li>遇到分界字符，默认为’\n’，也可以用参数指定。分界字符会从输入流中删除。</li>
<li>读取字符数达到最大值。此时会设置输入流的<code>failbit</code>，这意味着方法<code>fail()</code>将返回<code>true</code>。</li>
</ul>
<h2 id="比较、长度、子串"><a href="#比较、长度、子串" class="headerlink" title="比较、长度、子串"></a>比较、长度、子串</h2><p>string类对全部的六个关系运算符<code>&lt; &gt; != == &gt;= &lt;=</code>进行了重载。在一种序列中，一个字符位于一个字符的前面，视为这个前者小于后者。ASCII码中是：数字小于字符，大写字符小于小写字符。对于每个运算符，和+=类似，都进行了多次重载。以便将string对象和另一个string对象、C风格字符串进行比较，也能将C风格字符串和string对象进行比较。</p>
<p>可以用方法 <code>size()</code>和<code>length()</code>来确定字符串长度。</p>
<h2 id="搜索子串"><a href="#搜索子串" class="headerlink" title="搜索子串"></a>搜索子串</h2><p>可以用多种不同的方法搜索给定的字符或子串。</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>size_type find(const string &amp;str, size_type pos = 0)const</td>
<td>从pos开始，查找子串str，如果找到返回第一次出现位置的索引，如果找不到返回string::nops</td>
</tr>
<tr>
<td>size_type find(const char *s, size_type pos = 0)const</td>
<td>从pos开始，查找子串s，如果找到返回第一次出现位置的索引，如果找不到返回string::nops</td>
</tr>
<tr>
<td>size_type find(const char *s, size_type pos = 0, size_type n)const</td>
<td>从pos开始，查找s的前n个字符串组成的子串。如果找到返回第一次出现位置的索引，如果找不到返回string::nops</td>
</tr>
<tr>
<td>size_type find(char ch, size_type pos = 0)const</td>
<td>从pos开始，查找字符ch，如果找到返回第一次出现位置的索引，如果找不到返回string::nops</td>
</tr>
</tbody>
</table>
<p>其他方法：<code>rfind()</code>、<code>find_first_of()</code>、<code>find_last_of()</code>、<code>find_first_not_of()</code>、<code>find_last_not_of()</code>，这些方法的重载函数特征标都于<code>find()</code>相同。rfind查找的是最后一次出现的位置。find_first_of查找参数中任何一个字符首次出现的位置。find_last_of功能和前者类似，但查找的是最后一次的出现位置。find_first_not_of查找的是第一个不包含在参数内的字符。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">string s <span class="operator">=</span> <span class="string">&quot;cobra&quot;</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">int where<span class="comment">;</span></span><br><span class="line"><span class="attribute">where</span> <span class="operator">=</span> s.find_first_of(<span class="string">&quot;hark&quot;</span>)<span class="comment">; // 返回的是索引3，即stirng对象中的r是hark中任何一个字符首先出现的位置</span></span><br><span class="line"><span class="attribute">where</span> <span class="operator">=</span> s.find_last_of(<span class="string">&quot;hark&quot;</span>)<span class="comment">;  // 4</span></span><br><span class="line"><span class="attribute">where</span> <span class="operator">=</span> s.find_first_not_of(<span class="string">&quot;hark&quot;</span>)<span class="comment">; // 0</span></span><br><span class="line"><span class="attribute">where</span> <span class="operator">=</span> s.find_last_not_of(<span class="string">&quot;hark&quot;</span>)<span class="comment">; // 2</span></span><br></pre></td></tr></table></figure>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p>还有很多其他的工具，不在此一一详细描述，可以找string的文档看一下。还包括如下功能的函数：删除字符串部分或全部内容、用一个字符串的全部或部分内容替代另一个字符串的全部或部分内容、将数据插入到字符串中、用一个字符串的全部或部分内容与另一个字符串的全部或部分内容向比较、提取子串、交换两个字符串的内容。这些方法大都被重载，以便能同时处理C字符串和stirng对象。</p>
<p>再来看看自动调整大小的功能。需要调整string对象的大小时会发生什么？不能仅仅将已有的内存空间加大，因为相邻的内存可能被占用。因此可能需要分配一个新的内存块，并将原来的内容复制到新块中。如果要执行大量这样的操作，效率会非常低。因此实现中需要分配空间时，都会分配一个实际较大的内存块。如果字符串不断增大，超过内存块的大小，程序将分配一个大小为原来的<strong>两倍</strong>的内存块。方法capacity()<code>返回分配给当前字符串的内存块大小，</code>reverse()`方法让你可以请求内存块的最小长度。</p>
<p>如果你有string对象，但需要C风格字符串，该怎么办呢？<code>c_str()</code>方法返回一个指向C风格字符串的指针。其内容与调用这个方法的string对象相同。</p>
<p>多种字符串种类。前面提到string是基于模板的<code>basic_string</code> 的，这个模板有四个具体化，每个都有一个typedef名称：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basc_string&lt;<span class="type">char</span>&gt; string;</span><br><span class="line"><span class="keyword">typedef</span> basc_string&lt;<span class="type">wchar_t</span>&gt; wstring;</span><br><span class="line"><span class="keyword">typedef</span> basc_string&lt;<span class="type">char16_t</span>&gt; u16string;</span><br><span class="line"><span class="keyword">typedef</span> basc_string&lt;<span class="type">char32_t</span>&gt; u32string;</span><br></pre></td></tr></table></figure></p>
<p>这可以让我们使用基于各种不同char类型的字符串。<br>对string类的介绍就到这里。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 10 章：用户数据报协议</title>
    <url>/2018/03/19/tcpip-10-UDP/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>UDP 稍微扩展了IP协议，使得包可以在进程间传送，而不仅仅是在主机件。——《CSAPP》</p>
<p>IP 数据报是指 IP 层端到端的传输单元。分组（packet）是 IP 层和链路层的传输单元。一个分组可以是一个完整的数据报，也可以是一个分片。——《TCP／IP协议详解卷一 第一版》</p>
</blockquote>
<p>UDP 是一种保留消息边界的简单的面相数据报的传输层协议。它不提供差错纠正、队列管理、重复消除、流量控制、拥塞控制。它提供端到端差错检测，也就是传输层端到端校验和，也不保证报文一定能到达目的地。一般来说，每个被应用程序请求的 UDP 输出操作只产生一个 UDP 数据报，从而发送一个 IP 数据报，这一点不同于 TCP 面相数据流的特征。</p>
<p>UDP 本身是提供最小功能的传输层协议：它把应用程序传给 IP 层的数据发送出去。【RFC0768】是 UDP 30 多年来未改变的标准。虽然可靠性和保护性有所缺失，但 UDP 不是一无是处的。因为它的简单，因为它的无连接性，UDP 比其他的传输层协议的开销要小得多。另外，组播和广播操作更多使用 UDP 这样无连接的传输。 </p>
<h1 id="UDP-header"><a href="#UDP-header" class="headerlink" title="UDP header"></a>UDP header</h1><table>
<thead>
<tr>
<th>字段</th>
<th>长度(bytes)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>源端口号</td>
<td>2</td>
<td>见下文“端口号”</td>
</tr>
<tr>
<td>目的端口号</td>
<td>2</td>
<td>见下文“端口号”</td>
</tr>
<tr>
<td>长度</td>
<td>2</td>
<td>UDP头部和数据的总长度，以字节为单位</td>
</tr>
<tr>
<td>检验和</td>
<td>2</td>
<td>见下文“UDP检验和”</td>
</tr>
</tbody>
</table>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ul>
<li>端口号相当于电话号码之后的扩展码，帮助协议辨认<strong>进程</strong>。</li>
<li>它们是抽象的，即不与任何主机、任何物理实体相关。</li>
<li>在 UDP 中，端口号是 16 位的特殊数字（0～65535）。</li>
<li>源端口号是可选择的，如果发送者不要求回复的话，可以设置源端口号为 0.</li>
<li>IP 层根据协议字段或 IPv6头部中的下一个头部字段分离到特定的传输协议，这意味着端口号在不同的传输层协议之间是独立的。TCP 端口号只能被 TCP 使用，UDP 亦然。（尽管如此，但如果某个众所周知的服务同时由 TCP 和 UDP 提供，那么这两个端口号通常被分配成一样的）</li>
</ul>
<h2 id="UDP-检验和"><a href="#UDP-检验和" class="headerlink" title="UDP 检验和"></a>UDP 检验和</h2><ul>
<li>UDP 校验和是我们遇到的第一个<strong>传输层端到端检验和</strong>（ICMP 是网络层第一个端到端校验和）。UDP 校验和覆盖 UDP 头部、UDP 数据和 UDP 伪头部。端到端是指由发送方计算得到，由最终的接收方检验，途中不会被修改（除非是通过 NAT）。</li>
<li>对比只覆盖头部的 IPv4 检验和，经过每一跳路由器都要修改。传输层协议检验和覆盖传输层协议头部和数据。</li>
<li>“UDP 伪头部”是指UDP数据报长度可以是奇数长字节，而检验和算法只相加 16 位字（偶数字节），因此对于奇数字节长度的数据报，UDP 会在末尾添加一个都为 0 的填充。仅为了计算校验和，不会被传递出去。</li>
</ul>
<h1 id="UDP-和-IP-分片"><a href="#UDP-和-IP-分片" class="headerlink" title="UDP 和 IP 分片"></a>UDP 和 IP 分片</h1><p>在链路层中有介绍，链路层对可传输帧长度有一个最大上限。IP 引入分片和重组。IP 转发时，做出的判断，不仅根据路由表，也根据要求的 MTU 是多少。如果数据报太大则进行分片。</p>
<ul>
<li>分片可以在发送方到目的地上的端到端路径上<strong>任何中间路由器</strong>进行。</li>
<li>重组直到它到达最终目的地才会被重组。原因有二：一、网络中不进行重组减轻路由器的负担。二、不同分片可能经过不同路径到达目的地，这样的话路由器没有能力来重组。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>UDP 是一个简单的协议。它给 IP层之上的用户进程提供了端口号和检验和机制。没有流量控制、拥塞控制、差错纠正。有差错检测和消息边界保留。</p>
<p>我们看到了 UDP 用于IP 分片、路径 MTU 发现。当出现如下情况，最常用的就是 UDP 了：</p>
<ul>
<li>要避免建立连接的开销。</li>
<li>多端点传送（组播、广播）</li>
<li>不需要 TCP 相对笨重的可靠 </li>
</ul>
<p>UDP 的主要用途之一是 DNS（域名系统）。UDP 占据了观察到的互联网流量的 10% - 40%，随着点对点应用数量的增加，UDP 的使用仍在上升，虽然 TCP 在稳定性方面占据了统治地位。网络分片流量大多数 UDP 的，尽管总体流量中只有极少数是分片。分片中的流量类型主要有基于 UDP 的多媒体流量、VPN 隧道中封装的隧道流量。</p>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 11 章：名称解析和域名系统</title>
    <url>/2018/03/19/tcpip-11-DNS/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>到目前为止，我们使用 IP 地址来研究参与网络的主机。对于大众来说，这些地址太繁琐且难以记忆。为了使用如 TCP 和 IP 等协议，<strong>主机名称</strong>通过名为<strong>名称解析</strong>（name resolution）的过程转换成 IP 地址。在互联网中，存在着不同形式的名称解析，其中最普遍、最重要的是<strong>域名系统</strong>（Domain Name System，DNS）。</p>
<p>DNS 是一种分布式数据库系统，是一种典型的客户端／服务器模型的网络数据库。TCP／IP 应用程序使用它来完成主机名称和 IP 地址的映射。“分布式”是指在互联网中，没有一个站点可以保存所有的信息，而是有许许多多的站点（学校、公司、部门等等）都维护自己的信息数据库，运行一个服务器程序以供互联网上的其他系统查询。DNS 提供了客户端和服务器之间、服务器和服务器之间通信的协议。</p>
<p>DNS 作为互联网上的应用程序运行，是一个应用层设计。从别的应用程序的角度看，访问 DNS 是通过一个称为<strong>地址解析器</strong>（resolver）的程序来完成的。而TCP／IP 协议对 DNS 的存在一无所知，它们只对网络地址进行操作。</p>
<p>为了实现可扩展性，DNS 名称是分层的。我们将了解 DNS 名称空间，地址解析器、服务器如何使用 DNS 协议进行通信，以及 DNS 如何为普通用户所用。</p>
<h1 id="DNS-名称空间"><a href="#DNS-名称空间" class="headerlink" title="DNS 名称空间"></a>DNS 名称空间</h1><p>DNS 中所有使用的名称构成了 <strong>DNS 名称空间</strong>（name space）。名称空间和计算机系统的文件系统相似，都是划分为层次且大小写不敏感的。DNS 名称空间是一棵<strong>域名树</strong>。</p>
<ul>
<li>位于顶部的树根未命名。</li>
<li>树的最高层是所谓的顶级域名（Top-Level Domain Name，<code>TLD</code>）。包括通用顶级域名（generic，<code>gTLD</code>）、国家代码顶级域名（country code，<code>ccTLD</code>）、国际化国家代码顶级域名（internationalized，IDN ccTLD），基础设施顶级域名（infrastructure TLD）等等。</li>
<li>国际化域名 IDN 的历史是互联网国际化的一部分，漫长而复杂。</li>
<li>gTLD 分为几类：通用、通用限制、赞助。通用 gTLD 是开放的，其他两类受限于各种适用类型，以及什么实体可以从域名中分配名称。</li>
<li>ccTLD 包含 ISO 3166 标准中指定的两个字母的国家代码。</li>
<li>TLD 管理相关政策一般由 ICANN（互联网名称和号码分配机构）负责</li>
</ul>
<h2 id="命名语法"><a href="#命名语法" class="headerlink" title="命名语法"></a>命名语法</h2><p>域名树的 TLD 下面的名称进一步划分，称为<strong>子域名</strong>（subdomain）。</p>
<p>例如，英国大部分教育站点使用后缀<code>.ac.uk</code>，而大多数盈利机构以后缀<code>.co.uk</code>结尾。美国市政府的站点使用子域名<code>ci.city.state.us</code>，city 是城市的名称，state 是州名的两个字母缩写。例如<code>www.ci.manhatan-beach.ca.us</code>是加州曼哈顿海滩市的站点。</p>
<p>域名又分为完全限定域名（FQDN）和非限定域名（unqualified domain name）两种。前者书写为带有<strong>后随点</strong>的形式，例如<code>mit.edu.</code>，代表<strong>该名称是完整的</strong>，进行名称解析时，不会再添加额外的信息。</p>
<p>与此相对的就是非限定域名，域名解析时，会有字符串添加到尾部。例如，当配置系统时，使用 DHCP ，指定一个<strong>默认域名扩展和搜索列表</strong>。例如，默认域名为<code>can.berkeley.edu</code>在伯克利计算机系的系统中配置，这些机器上的用户输入名称<code>vangogh</code>，解析器就会将名称转换为<code>vangogh.cs.berkeley.edu</code>，解析器根据这个来找<code>vangogh</code>的地址。</p>
<p>一个域名包含一系列<strong>由点分开的标签</strong>（label）。每个标签代表域名树层级中的一个位置。点就是层次结构的分割，按照名称从右到左的顺序<strong>沿树下降</strong>。例如：www.net.in.tum.de.<code>表示包含在一个 4 级深度域名</code>net.in.tum.de<code>的主机名</code>www`。</p>
<ul>
<li>TLD 是 de，是德国的 ccTLD。</li>
<li>tum 是 Technische UNiversitat Munchen 的缩写</li>
<li>in 是 informatik （德语计算机科学）的缩写</li>
<li>net 是计算机学科中网络组缩写。</li>
</ul>
<p>标签是大小写不敏感的。</p>
<h1 id="名称服务器和区域"><a href="#名称服务器和区域" class="headerlink" title="名称服务器和区域"></a>名称服务器和区域</h1><p>DNS 命名空间的层次结构运行不同的管理机构管理名称空间的不同部分。例如，创建一个新的 DNS 名称<code>elevator.cs.berkeley.edu</code>只需与<code>cs.berkeley.edu</code>的子域拥有者协商即可。DNS 的这个特点是它<strong>可扩展性</strong>的保证，没有一个单一中心化实体必须管理整个 DNS 名称空间的所有变化。</p>
<p>部分（也通常是次级） DNS 名称空间的管理责任分配给了组织或个人。这些组织和个人至少安置两台<strong>名称服务器</strong>（name server）或者<strong>DNS 服务器</strong>（DNS server）来存储相关信息，提供给互联网用户查询名称。因为服务器的集合构成了 DNS 服务的核心本身，所以我们说<strong>DNS 是一个分布式系统</strong>。这个分布式系统的主要工作是提供名称到地址的映射，也可以提供额外的广泛信息。</p>
<p>在 DNS 的语境中，管理授权的单位是<strong>区域</strong>（zone）。</p>
<p>介绍并区分两个术语：</p>
<ul>
<li>所有域名的集合：<code>namespace</code></li>
<li>管理授权的单位：<code>zone</code></li>
</ul>
<p>可以理解为一个区域就是 DNS 命名空间中的一棵<strong>子树</strong>。即使是 TLD 也是在 roo<br>zone 中。每当一条新纪录添加到 zone 中，该 zone 管理员将新建一条新条目，保存名称和 IP 地址的映射，添加到服务器的数据库中。</p>
<p>一台 DNS 服务器可以提供多个区域的信息。在一个域名的任何层次变化点上，不同的区域和包含的服务器可能被访问，以提供该名称的地址。这称为<strong>授权</strong>（delegation）。例如在 <code>berkeley.edu</code>中可能存在主机<code>www.berkeley.edu</code>,也可能存在其他的域<code>cs.berkeley.edu</code>。每一个区域都有一个负责方或者管理者，拥有管理名称、地址、该区域下属区域的权利。不仅管理区域的内容，也管理区域数据库、各种服务器。</p>
<p>区域信息最少应存在两个地方，这样做是为了如果有一台服务器不能工作，至少有另一台可以使用。这叫做主服务器和辅助服务器之间的<strong>区域传输</strong>（zone transfer）进程。</p>
<h1 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h1><p>名称服务器包含名称到 IP 地址的映射信息。这些信息可以来自三个途径：</p>
<ul>
<li>直接来自于区域数据库。在这种情况下，服务器应该包含该区域的授权信息（authoritative information），服务器可以被称为该区域的授权服务器（authoritative server），这样的服务器能通过区域内的鉴别。</li>
<li>从一个从属服务器区域传输的结果。</li>
<li>来自处于解析过程中的另一台服务器。</li>
</ul>
<p>大部分名称服务器会<strong>缓存</strong>（cache）它们学习的区域信息，直到一个时间限制（TTL）为止。用缓存的信息来响应查询请求，可以大大减少 DNS 消息流量和响应时间。当应答查询时，服务器指明这条消息是来自缓存、还是区域的授权副本。</p>
<p>缓存同时适用成功的解析和不成功的解析。（否定缓存，negative caching）如果对一个特定域名的请求无法返回一个记录，则该事实也会被缓存。这样，再次请求同一不存在的域名时，就可以帮助降低互联网流量。</p>
<h1 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h1><p>DNS 协议由两个主要部分组成。</p>
<ul>
<li>DNS 特定名称的查询／响应报文协议。（最典型的用法）</li>
<li>名称服务器用于交换数据库的区域传输协议。分为 DNS 通知和动态更新。</li>
</ul>
<p>通过每个站点或是 ISP 本地部署服务器和一组特殊的<strong>根服务器</strong>（root server）构成 DNS <strong>分布式基础设施</strong>，通过该基础设施支持 DNS 查询／响应。</p>
<p>截止 2011 年，共有 13 台由字母 A 到 M 命名的根服务器。13 台 gTLD 服务器，也由 A 到 M 标示。通过联系根服务器和 gTLD 服务器，互联网中任何用 TLD 格式名称的主机、服务器，都可以被发现。</p>
<p>对于 UDP 和 TCP 来说，DNS 的知名端口号是 53。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="http://p6rl2gdnw.bkt.clouddn.com/02DNS%20query%20example.png" alt=""></p>
<p>下列序号是图中的箭头上的消息序号：</p>
<ol>
<li>当笔记本电脑 A.HOME 需要进行域名解析时，电脑上的解析器先朝最接近的本地名称服务器发送请求。也就是（消息1）。</li>
<li>如果本地的域名服务器不清楚此域名对应的 IP，它就会将查询转发至另一个服务器（也就是<strong>递归</strong>）。（消息2）前往 ISP 提供的 DNS 服务器。</li>
<li>ISP DNS 服务器也不清楚的话，就联系根服务器中的一台。</li>
<li><strong>根服务器不是递归的</strong>，它们不会再进一步朝别的服务器请求，而是<strong>返回需要联系的正确的服务器的信息。</strong></li>
<li>根据这些信息，ISP DNS 联系一个 gTLD 服务器。</li>
<li>这个 gTLD 服务器发现了对应的名称服务器的 IP 地址，通过消息6返回。</li>
<li>基于消息6，ISP DNS 联系适当的服务器。</li>
<li>该服务器回复请求的 IP地址</li>
<li>ISP DNS 返回给本地名称服务器。</li>
<li>本地名称服务器返回给笔记本电脑。</li>
</ol>
<h2 id="DNS-消息格式"><a href="#DNS-消息格式" class="headerlink" title="DNS 消息格式"></a>DNS 消息格式</h2><p><img src="http://p6rl2gdnw.bkt.clouddn.com/DNS%20message%20format.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bits)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>事务ID</td>
<td>16</td>
<td>由客户端设置，服务器来返回，用来匹配响应和查询</td>
</tr>
<tr>
<td>QR</td>
<td>1</td>
<td>QR = 0表示查询，QR = 1表示响应</td>
</tr>
<tr>
<td>OpCode</td>
<td>4</td>
<td>有三种值，0:标准查询，4:通知（NOTIFY），5:更新（UPDATE）</td>
</tr>
<tr>
<td>Flag</td>
<td>7</td>
<td>查看下文</td>
</tr>
<tr>
<td>RCODE</td>
<td>4</td>
<td>是一个响应码，常用的值有0:没有差错；3:不存在域名 等</td>
</tr>
<tr>
<td>查询数、区域数</td>
<td>16</td>
<td>这接下来4条的字段都是16bits，表示DNS消息中各个区段（问题、回答、授权、额外信息）的条目数量。</td>
</tr>
<tr>
<td>回答数、先决条件数</td>
<td>16</td>
<td>查看下文</td>
</tr>
<tr>
<td>授权记录数</td>
<td>16</td>
<td>查看下文</td>
</tr>
<tr>
<td>额外信息数</td>
<td>16</td>
<td>查看下文</td>
</tr>
<tr>
<td>区段</td>
<td>可变长度</td>
<td>DNS消息最后的部分。第一个区段指示类型，后续的区段都可以包含资源记录（resource record，RR）。RR可以被缓存，而问题则不可以。</td>
</tr>
</tbody>
</table>
<h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>一共7个标志，每一个 1bit。</p>
<table>
<thead>
<tr>
<th>标志名</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AA</td>
<td>Authoritative answer，指示希望的是授权信息，还是缓存里的信息也可以。</td>
</tr>
<tr>
<td>TC</td>
<td>Truncated，截断信息，表示当应答超过512字节时，只发送前512字节</td>
</tr>
<tr>
<td>RD</td>
<td>Recursion desired，告诉服务器希望执行递归查询</td>
</tr>
<tr>
<td>RA</td>
<td>Recursion availabe，服务器表明自己是可以递归查询的。根服务器就不是递归的</td>
</tr>
<tr>
<td>Z</td>
<td>0</td>
</tr>
<tr>
<td>AD</td>
<td>如果包含信息是授权信息，设置这一位</td>
</tr>
<tr>
<td>CD</td>
<td>禁止校验</td>
</tr>
</tbody>
</table>
<h2 id="区段"><a href="#区段" class="headerlink" title="区段"></a>区段</h2><p>接下来先讲标准查询。</p>
<p>区段是DNS消息最后的部分，有问题、回答、授权、额外信息四个种类。问题是 query 包里的，其余三个是 response 包的。在区段的前面四个16bits的字段就是对应这四个区段的条目数。对于 query 包来说，查询数就是1，其余三个的数量就是0。对于 response 包来说，回答数至少为 1，有可能包含其他信息。</p>
<h3 id="问题区段格式"><a href="#问题区段格式" class="headerlink" title="问题区段格式"></a>问题区段格式</h3><p>问题区段有名称、类型、类，见下图。</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/03%20question%20section.png" alt=""></p>
<p>字段|长度(bits)|含义<br>查询名称|可变，但需要填充字节|需要被查询的域名，使用一种<strong>标签编码</strong>，见下文<br>查询类型(Types)|16|查询哪种类型的资源记录，见下文“资源记录类型”<br>查询类(Class)|16|1:互联网类，254:没有类，255:所有类</p>
<p>下图是 DNS 系统中表示一个域名的编码——标签。一个标签就是一个完整的域名。对于一个标签来说，首先是用标签长度来指示后面跟了几个字符。0 表示一个标签的结束。每个标签的长度是 0 到 63。</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/04%20data%20labels.png" alt=""></p>
<p>如果使用普通的数据标签，如果在一次查询中出现了相同的名称，DNS 消息中的相同字符会重复。例如在一次查询中需要查询<code>usc.edu</code>和<code>ucla.edu</code>，如果使用上面的普通编码方式，<code>edu</code>这个字符会重复出现在消息内容中。下图是<strong>压缩标签</strong>，通过引用其他标签从而节省空间。普通的数据标签的开头是用一个字节的数字来表示后续的字符数量的。而压缩标签的用法是：开头用两个字节，共16bits，头两个bits置1，然后后续的14个bit形成一个偏移量指针，偏移量指示的是距离此消息开头的字节数。在查询<code>usc.edu</code>和<code>ucla.edu</code>时，后面的<code>edu</code>用偏移量 4 表示，就可以省下空间，见下图：</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/07%20compression%20label.png" alt=""></p>
<h3 id="回答、授权、额外信息区段格式"><a href="#回答、授权、额外信息区段格式" class="headerlink" title="回答、授权、额外信息区段格式"></a>回答、授权、额外信息区段格式</h3><p>除了问题区段，其他的区段包含零个或多个<strong>资源记录，RR</strong>。RR有固定的格式，见下图。</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/05%20DNS%20RR%20record.png" alt=""></p>
<p>字段|长度(bits)|含义<br>名称|可变，需要填充|就是域名<br>查询类型Type|16|见下文“资源记录类型”<br>查询类Class|16|同问题的区段。1:互联网类，254:没有类，255:所有类<br>TTL|16|缓存时间（秒）<br>RDLENGTH|16|资源数据长度（bytes）<br>RDATA|16|资源数据，根据查询类型的不同这里回放不同的东西</p>
<h2 id="资源记录类型"><a href="#资源记录类型" class="headerlink" title="资源记录类型"></a>资源记录类型</h2><p>虽然 DNS 常用来确定特定的名称对应的 IP 地址，但是它可以用于相反的目的（根据IP查域名），也经常用来查一些别的。这是由于 DNS 能够拥有很多类型的资源记录，DNS 甚至可以为非互联网数据提供分布式数据库功能。</p>
<p>资源记录分为三大类：</p>
<ul>
<li>数据类型。传达 DNS 中存储的信息。</li>
<li>查询类型。使用和数据类型相同的值，增加几个额外的值，在问题区段中使用。</li>
<li>元类型，特定单一 DNS 消息相关联的临时数据。 </li>
</ul>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/06%20RR%20types.png" alt=""></p>
<p>上图黄色标出了常用的资源记录类型。例如，一个 query 包里的问题区段的查询类型Type字段的值是 <code>A</code>，意味着需要查询一个对应域名的 IPv4 地址。</p>
<ul>
<li><code>A</code>：IPv4 地址</li>
<li><code>NS</code>：区域授权服务器的名称，以供查询使用</li>
<li><code>CNAME</code>：规范名称，也就是提供别名</li>
<li><code>AAAA</code>：IPv6 地址</li>
</ul>
<h2 id="区域传输-和-DNS-通知"><a href="#区域传输-和-DNS-通知" class="headerlink" title="区域传输 和 DNS 通知"></a>区域传输 和 DNS 通知</h2><p>区域传输是用于从一个服务器复制另一区域的一组 RR 的，通常是主服务器复制到从服务器。这个功能的目的是为了保持多台服务器的内容同步。如果一台服务器失效了，这个功能也能让其他服务器帮助它恢复。与这个功能有关的字段是<code>OpCode</code>中的<code>DNS NOTIFY</code>值。由于数据量很大，这会使用TCP协议。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DNS 是互联网的一个重要组成部分，也同时广泛地应用于私有网络中。DNS 名称空间是全世界范围的。应用程序使用解析器联系一个或多个 DNS 服务器，执行域名解析。解析器联系一个本地域名服务器，该服务器可能会递归地联系其他满足该请求的服务器。大多数 DNS 服务器会缓存知道的信息。DNS 协议被用于 DNS 查询、响应，区域交换。DNS 查询、响应由通用的消息格式，包括问题、回答、授权信息、额外信息等。资源记录用来保存大多数 DNS 信息。</p>
<p>DNS 一直受到众多攻击。例如伟光正的域名污染。</p>
<ul>
<li>DOS攻击，使重要的 DNS 过载，不能提供服务。</li>
<li>改变资源记录的内容，或者伪造成合法的 DNS 地址，但是回复假的资源记录，从而导致主机连接到错误的 IP 地址。也就是域名污染。</li>
<li>攻击者使用伪造的 IP 源地址产生对于 MX 记录的 DNS 请求。请求是较小的数据分组，但响应流量大（放大攻击，amplification）。响应会定向到请求的源 IP 地址。</li>
<li>域名污染的另一种形式——缓存中毒（cache poisoning），在这种攻击中，一台 DNS 服务器的缓存内容被错误的、伪造的数据替代。客户端被定向到伪服务器，若由别有用心的人将服务器故意配置成原来的模样，例如伪装成银行的 Web 洁面，用户可能会无意识泄露敏感信息。</li>
</ul>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 8 章：Internet 控制报文协议</title>
    <url>/2018/03/06/tcpip-8-ICMP/</url>
    <content><![CDATA[<h1 id="ICMP-报文"><a href="#ICMP-报文" class="headerlink" title="ICMP 报文"></a>ICMP 报文</h1><p>路由器是 Internet 的重要组成部分，严密监视 Internet 的操作。IP 协议未给发送失败的 IP 数据包提供一种错误处理，也没有给端系统提供直接的方法来发现错误。为了解决这一不足之处，<strong>ICMP（Internet Control Message Protocol，Internet 控制报文协议）</strong> 被设计出来，与 IP 结合使用。当路由器处理一个数据包的过程中发生了意外，就是通过 ICMP（向发送数据包的源端来报告相关事件的。ICMP 封装在 IP 数据包中，提供 IP 层配置和 IP 数据包相关的<strong>诊断、控制信息</strong>。</p>
<p>ICMP 报文通常是由 IP 层本身、上层传输协议、某些用户进程触发的。ICMP 负责传递的是可能需要被注意的<strong>差错和控制报文、查询、信息类报文</strong>。要注意的是，<strong>ICMP 没有为 IP 网络提供可靠性</strong>。最常见的丢包（路由器缓冲区溢出）并不会触发任何的 ICMP 信息。为网络提供可靠性的问题是由 TCP 来处理的。</p>
<p>ICMP 术语指一般的 ICMP，用 ICMPv4 和 ICMPv6 代表专门用于 IPv4 和 IPv6 的版本。</p>
<p>鉴于 ICMP 报文能够影响重要的系统功能操作和获取配置信息，黑客们在大量的攻击中专门利用了 ICMP 报文。因此网络管理员常常配置防火墙封阻 ICMP 报文，尤其是在边界路由器上。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>ICMP 报文被封装在 IP 数据报内。</p>
<ul>
<li>IPv4 中协议（Protocol）字段的值为 <code>1</code> 表示该报文携带 ICMPv4.</li>
<li>IPv6 的 ICMPv6 头部之前一个扩展头部的下一个头部（Next Header）字段的值为<code>58</code></li>
</ul>
<p>ICMP 报文格式、 ICMP 报文数据内容如下图所示：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/ICMP%20header.png" alt=""></p>
<p><img src="http://osax8w13y.bkt.clouddn.com/ICMP%20data.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bits)</th>
<th>内容</th>
<th>含义 or 注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型(Type)</td>
<td>8</td>
<td>ICMPv4 中保留了 42 个不同的值，约有 8 个常用</td>
<td>用于确定特定类型的报文</td>
</tr>
<tr>
<td>代码(Code)</td>
<td>8</td>
<td>略</td>
<td>进一步制定报文的含义</td>
</tr>
<tr>
<td>检验和(Checksum)</td>
<td>16</td>
<td>略</td>
<td>覆盖整个 ICMP 报文的校验和计算</td>
</tr>
<tr>
<td>有效内容(Content)</td>
<td>可变</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
<p>ICMP 校验和采用的算法和用在 IPv4 中的算法相同。与 IPv4 有区别的是，ICMP 是一个<strong>端到端检验和</strong>的例子，检验和从发送发发出的 ICMP 报文一直被携带到最终的接收方。而 IPv4 的头部校验和在经过每一跳路由器由于 TTL 值的改变，每一跳都要重新计算。ICMP 的校验和如果不正确，则会被接收方丢弃，因为报文内容不正确可能导致错误的系统行为。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>一般来说，ICMP 报文分为两大类：</p>
<ul>
<li><strong>差错报文（Error Message）</strong>，主要是有关 IP 数据包传递的。</li>
<li><strong>查询（query）、信息类报文（informational Message）</strong>，有关信息采集和配置。</li>
</ul>
<p>常用的 ICMP 报文消息类型：</p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的地不可达</td>
<td>数据包无法传递</td>
</tr>
<tr>
<td>超时</td>
<td>TTL 字段减到了 0</td>
</tr>
<tr>
<td>参数问题</td>
<td>无效 header</td>
</tr>
<tr>
<td>源抑制</td>
<td>抑制包，表示拥塞，弃用</td>
</tr>
<tr>
<td>重定向</td>
<td>告知路由器有关信息</td>
</tr>
<tr>
<td>回显及回显应答（ping）</td>
<td>检查一台机器是否存活</td>
</tr>
<tr>
<td>请求应答时间戳</td>
<td>与 ping 一样的功能，且要求加时间戳</td>
</tr>
<tr>
<td>路由器通告/请求</td>
<td>发现附近的路由器</td>
</tr>
</tbody>
</table>
<p>详细的类型号如下，更详细的代码不在此处贴出。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/Message%20type.png" alt=""></p>
<h1 id="处理-ICMP-报文"><a href="#处理-ICMP-报文" class="headerlink" title="处理 ICMP 报文"></a>处理 ICMP 报文</h1><p>对传入的 ICMP 报文的处理方式随着系统的不同而不同。一般而言：</p>
<ul>
<li>传入的信息类请求被操作系统处理。</li>
<li>传入的差错类报文传递给用户进程或者传输层协议。</li>
<li>也有例外情况，如重定向报文就是导致路由表的更新，等等。</li>
</ul>
<p>ICMPv6 的处理更为严格：</p>
<ul>
<li>未知的 ICMPv6 差错报文必须传递给上层产生差错报文的进程。</li>
<li>未知的 ICMPv6 信息类报文会被丢弃。</li>
<li>差错报文要求尽可能多的包含原始“出错” IPv6 报文。处理错误时，提取原始“违规”数据包中的上层协议类型，使用适当的上层进程。</li>
<li>IPv6 节点必须限制其发送 ICMPv6 报文的速率等。</li>
</ul>
<h1 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h1><p>上面提到的两大类 ICMP 报文，差错报文和信息类报文，它们之间的区别非常重要。先来讲差错报文。</p>
<p>ICMP 差错报文不会对以下报文进行响应；</p>
<ul>
<li>另一个 ICMP 差错报文。（如果没有这一条限制，处理某条差错报文时又可以产出另一个差错报文的话，将有可能导致死循环）</li>
<li>链路层广播数据报。</li>
<li>不是第一个分片的其他分片。</li>
<li>源地址不是单个主机地址的数据报。（零地址、环回地址、广播组播地址）</li>
</ul>
<p>ICMP 的 Content 中包含原来那个“违规”的“原始”数据报的头部副本，且包含一些有效载荷区的有效数据，但要确保总长度小于 MTU。在以前，ICMP 规范仅要求包含违规 IP 数据报的头 8 个字节（因为这样足以确定 TCP or UDP）的端口号，但随着现在协议越来越复杂，需要更多的信息来诊断问题。</p>
<h2 id="发送速率的限制"><a href="#发送速率的限制" class="headerlink" title="发送速率的限制"></a>发送速率的限制</h2><p>除了上述控制 ICMP 报文产生的条件，还要限制单一发送者发出的 ICMP 总体流量水平。[RFC4443] 推荐的方法是<strong>令牌桶</strong>。每个桶保存了最大数量为 B 的令牌，每个令牌允许一定数量的报文被发送。桶定期以速率 N 填充新的令牌，每发送一个报文 N 就自减 1。所以，令牌桶可以用参数（B, N) 刻画。</p>
<h1 id="查询-信息类报文"><a href="#查询-信息类报文" class="headerlink" title="查询/信息类报文"></a>查询/信息类报文</h1><p>很多 ICMP 定义的一些查询报文的功能都被其他的特殊协议取代。例如地址、掩码请求/应答（类型17/18）、时间戳请求/应答（类型13/14）等等，被一些例如 DHCP 等特殊协议取代了。现在保留下来唯一一个广泛使用的 ICMP 查询/信息类报文是<strong>回显请求/应答类报文</strong>，就是我们熟知的<strong>ping</strong>。</p>
<p>还有一个就是路由器发现报文，尽管 IPv4 中未广泛使用路由器发现机制，而在 IPv6 中非常基本的邻居发现中被普遍采用。</p>
<h1 id="几种常见的-ICMP-消息"><a href="#几种常见的-ICMP-消息" class="headerlink" title="几种常见的 ICMP 消息"></a>几种常见的 ICMP 消息</h1><h2 id="回显请求-应答类报文-ping"><a href="#回显请求-应答类报文-ping" class="headerlink" title="回显请求/应答类报文 ping"></a>回显请求/应答类报文 ping</h2><p>ICMPv4 类型 0/8（请求/应答），ICMPv6 类型 129/128（请求/应答）。</p>
<p>ping = packet Internet Groper，是<strong>直接使用网络层 ICMP 的重要例子</strong>，没有经过 TCP or UDP 这样的传输层协议。</p>
<p>接收到 ICMP 回显请求报文后，ICMP 的实现就是要求将任何收到的数据返回给发送者。这种报文是通过 <strong>ping 程序</strong>发送的，ping 的功能被用于确定 Internet 上一台主机是否可达的。一般来说，如果能“ping通”一台主机，那么几乎可以确定能够通过其他的方法（登录、其他服务等）访问到它。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/ping.png" alt=""></p>
<p>请求和应答是一一对应的，所以 ICPM ping 消息就包含了两个额外的字段：<strong>标识符</strong>（Identifier）和<strong>序列号</strong>（Sequence Number）</p>
<ul>
<li>标识符存放例如进程 ID 这样的内容，如果有多个 ping 程序在同一台主机运行，就能正确区分应答。</li>
<li>序列号就是从 0 开始，每多一次 ping 就加一。方便查看是否丢包、重排、遗失。</li>
</ul>
<h2 id="目的不可达-Destination-Unreachable-（主机-端口不可达、禁止通行、目的无路由等）"><a href="#目的不可达-Destination-Unreachable-（主机-端口不可达、禁止通行、目的无路由等）" class="headerlink" title="目的不可达 Destination Unreachable （主机/端口不可达、禁止通行、目的无路由等）"></a>目的不可达 Destination Unreachable （主机/端口不可达、禁止通行、目的无路由等）</h2><p>ICMPv4 类型 3，ICMPv6 类型 1。</p>
<p>目的不可达，是一种比较常见的 ICMP 报文类型，直观地表示数据报无法送达目的地。ICMPv4 还为此类型定义了 16 个代码，表示更详细的内容，但只有 4 个比较常用，分别是：</p>
<ul>
<li>主机不可达，code = 1</li>
<li>端口不可达，code = 3</li>
<li>需要分片，code = 4</li>
<li>管理禁止通信，code = 13</li>
</ul>
<p><strong>主机不可达</strong>是由路由器或主机产生的，出现情况是在使用<strong>直接交付</strong>发送一个 IP 数据报到一个主机时，由于某些原因无法到达目的地。例如试图发送 ARP 请求到不存在或关闭的主机。</p>
<p><strong>目的无路由</strong>就是数据报要路由时却没有任何一条合适的路由条目来指定下一跳。</p>
<p><strong>管理禁止通信</strong>通常是因为防火墙导致的故意丢弃流量。</p>
<p><strong>端口不可达</strong>就是目标应用程序还没准备好接受它时，就会产生一个端口不可达报文，在使用 UDP 时常见。还有就是一个报文发往了一个没有被任何服务器进程所使用的端口号时，UDP 也会回应一个 ICMP 端口不可达报文。</p>
<p>下图是一个 ICMPv4 目的不可达-端口不可达 消息的例子。红框里违规数据报头部的 IP 协议字段为 17 指 UDP。如前所述，ICMP 差错报文包含违规数据包的头部、有效载荷，有助于解析后面的字节，学习到源和目的端口号，将差错与特定进程相关联。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/destination%20unreachable.png" alt=""></p>
<p><strong>Packet Too Big（PTB）</strong>，ICMPv6 中，由一个<strong>Packet Too Big（PTB）</strong>替代了 ICMPv4 中 type = 3，code = 4 的消息。就是所谓的“数据报太大（需要分片）”。如果一个路由器收到一个打算转发的数据报，而数据报的大小大于传出网络接口的 MTU 则该数据报<strong>需要分片</strong>。若“Don’t Fragment”字段被设置，则会被丢弃。此时产生 ICMP 目的不可达 PTB 报文，而且携带 MUT 值在差错报文中，以便让原来的发送方路由器知道下一跳的 MTU。</p>
<p>此报文本来是设计用来诊断网络的，但被用于<strong>路径 MTU 发现</strong>：当进行通信时为了避免分片，PTB 消息用于确定合适的包大小，通常与 TCP 一起使用。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/PTB.png" alt=""></p>
<h2 id="超时-Time-Exceed"><a href="#超时-Time-Exceed" class="headerlink" title="超时 Time Exceed"></a>超时 Time Exceed</h2><p>ICMPv4 类型 11，ICMPv6 类型 3。</p>
<p>IPv4 头部有 TTL 字段来限制数据报在网络中存留的时间。当由于报文是因为 TTL 减至 0 被丢弃时，触发一个 ICMP 超时。这个错误信息被<strong>巧妙地运用在了 Traceroute 工具上</strong>。该工具由 Van Jacobson 在 1987 年开发，用于发现从主机到目的地址路径上的 IP 地址。方法其实很简单：给目的地址发送一系列 TTL 设置为 1,2,3 …… 的数据包，依次类推。根据这一系列带有特殊 TTL 值而导致路由器触发的 ICMP 超时消息，就可以确定沿途的路由器 IP 地址。</p>
<p>这不是 ICMP 超时消息设计的本意，却被设计成了最有用的网络调试工具。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/time%20exceeded.png" alt=""></p>
<h2 id="重定向-Redirect"><a href="#重定向-Redirect" class="headerlink" title="重定向 Redirect"></a>重定向 Redirect</h2><p>ICMPv4 类型 5，ICMPv6 类型 137。</p>
<p>一个路由器收到一个数据报，但<strong>确定自身并不是该数据报应该被投递到的合适下一跳</strong>。则该路由器发送一个重定向报文给原来的主机，并把该报文发送到正确的下一跳路由器（或主机）。即：如果路由器在接受到数据报时，确定存在一个比自己更好的下一跳，则会触发 ICMP 重定向消息，使原来的发送方更新其转发表。</p>
<p>不过，路由器主要还是通过动态路由协议来获得可达目的地的最佳下一跳节点。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/redirect.png" alt="">)</p>
<h1 id="Wireshark-抓包"><a href="#Wireshark-抓包" class="headerlink" title="Wireshark 抓包"></a>Wireshark 抓包</h1><ul>
<li>ping request</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/ping%20request.png" alt=""></p>
<ul>
<li>ping reply</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/ping%20reply.png" alt=""></p>
<ul>
<li>port unreachable</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/port%20unreachable.png" alt=""></p>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 9 章：广播和本地组播（IGMP 和 MLD）</title>
    <url>/2018/03/09/tcpip-9-IGMP/</url>
    <content><![CDATA[<p>广播和本地组播（IGMP 和 MLD）</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>有 4 种 IP 地址，<strong>单播</strong>（unicast）、<strong>任播</strong>（anycast）、<strong>组播</strong>（multicast）和<strong>广播</strong>（broadcast）。IPv4 可以使用所有地址，IPv6 可以使用除广播之外的地址。</p>
<p>本章讨论广播和组播的细节，例如：</p>
<ul>
<li>链路层如何有效地从一台计算机向其他计算机发送广播或组播流量。</li>
<li>互联网组管理协议（IGMP）和组播侦听协议（MLD）如何工作，通知组播路由器子网中哪些组播地址在使用。</li>
</ul>
<p>广播和组播都是为了<strong>将数据报交付至多个目的地的技术</strong>，也是客户端请求／发现服务器的手段。</p>
<ul>
<li>交付至多个目的地。有许多应用程序要将消息交付到多个收件方。若没有广播和组播，采取 TCP 与多个目的地分别建立连接，是非常低效的。</li>
<li>客户端请求／发现服务器。用了广播和组播，客户端／应用程序<strong>可以向一个服务器发送请求，而不需要知道特定的服务器 IP 地址</strong>。特别是在网络环境的配置信息不完善时，这种功能在配置方面非常有用。（例如 DHCP）</li>
</ul>
<p>虽然广播和组播都可以完成上述功能，但组播一般情况下<strong>比广播更可取</strong>，因为组播只涉及到那些支持特定服务或协议的系统（在特定的组播组里），而广播不是。广播请求会影响广播范围内所有能到达的主机，<strong>组播只影响那些对该请求感兴趣的主机。**</strong>广播更简单，但开销更大；组播改善了效率，但带来更多的复杂性。**</p>
<p><strong>一般来说，只用使用 UDP 传输协议的应用程序才利用广播和组播</strong>，在 UDP 下，发送单个报文到多个收件方才是有意义的。TCP 是面向连接的协议，使用 TCP 的话意味着两台主机（由IP地址指定）上面的进程（由端口号指定）之间建立了连接。TCP 可以使用单播和任播，但是不能使用广播和组播地址。</p>
<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p>广播是指将报文发送到网络中所有可能的接收者。原理上很清晰：路由器<strong>简单地把它接受到的任意报文，在除了报文到达接口之外的所有接口都发送一个副本。</strong></p>
<h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p>回忆一下，每个以太网帧包含源和目的 MAC 地址。使用单播地址时，MAC 地址由ARP 或 IPv6 邻居发现来确定。当一个帧以这种方式发送到单播 IP 地址时，任意两个主机之间的通信不会打扰这个网络上的其他主机。诸如以太网这种链路层支持<strong>链路层广播</strong>。</p>
<p>组播的 MAC 地址，高字节位是低位有效字节，也就是 CSAPP 里面讲的<a href="http://www.cnblogs.com/ZCplayground/p/6485364.html">小端法</a>。以太网的广播地址是<code>ff:ff:ff:ff:ff:ff</code>。</p>
<p>每个 IPv4 子网都有一个<strong>本子网广播地址，就是地址中的主机部分全置 1 形成的</strong>。特殊地址：<code>255.255.255.255</code> 被称为<strong>本地广播地址</strong>（也称为“有限广播”）。该地址我们在 DHCP 中见过。由于主机在未配置网络环境时，自身没有 IP 地址，也没有关于子网掩码等信息。适用本地广播地址，路由器是不会转发的，有限广播地址仅出现在本地网络。</p>
<h1 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h1><p>为了减少在广播中涉及的开销，可以只向那些<strong>对该流量感兴趣的接收方</strong>发送流量。这被称为组播（multicasting）。实现组播就要比广播更具复杂性，因为要实现组播就要维持一个组播<strong>状态信息</strong>（multicast state），主机和路由器维持状态信息来说明哪些接收方对哪类流量感兴趣。除此之外，该状态应该是软状态（soft state），应该定期更新或者是超时删除。</p>
<p>组播在企业和本地网络中的使用超过在广域网中的使用。在这种环境下广播的低效就体现的比较严重。</p>
<p>为了使组播工作，就要设计一种机制来使得主机发布其对某些流量的意愿（说白了就是加入某个组播组）的协议，路由器也要知道如何转发组播流量。</p>
<h2 id="将-IP-组播地址转换为-802-MAC／以太网地址"><a href="#将-IP-组播地址转换为-802-MAC／以太网地址" class="headerlink" title="将 IP 组播地址转换为 802 MAC／以太网地址"></a>将 IP 组播地址转换为 802 MAC／以太网地址</h2><p>下面研究 IP 组播流量是如何使用 MAC 层组播地址的。</p>
<p>当我们要发送组播流量时，链路层帧（我们专注考虑 IEEE 802，以太网和 Wi-Fi）中要存放什么样的目的 MAC 地址呢？（广播帧目的地址就是<code>ff:ff:ff:ff:ff:ff</code>）这里的技术就是简单的<strong>将一个IP组播地址直接映射到一些对应的MAC地址</strong>。</p>
<p>IANA 拥有 IEEE 组织唯一标识符（简称 OUI，以太网地址前缀）<code>00:00:5e</code>和<code>01:00:5e</code>，用前者来表示单播地址，用后者用于映射成组播地址。因为这个前缀占了 24 位，所以剩余的组播地址范围是：<code>01:00:5e:00:00:00</code> ~ <code>01:00:5e:ff:ff:ff</code>。IANA 只分配<strong>一半</strong>用于识别 IEEE 802 LAN 上的 IPv4 组播地址，范围是：<code>01:00:5e:00:00:00</code> ~ <code>01:00:5e:7f:ff:ff</code>。下图是一个 D 类地址<code>224.0.1.17</code> 映射成组播地址的例子：</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/D%20address.png" alt=""></p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/map%20of%20IPv4.png" alt=""></p>
<p>D 类地址的开头是固定的<code>1110</code>，所以有 28 位用来编码整个地址空间。即有 2^28 个组播地址。然而 INAN 只分配了 2^23 个链路层地址空间，因此，<strong>映射是非唯一的</strong>。则驱动和 IP 层需要进行过滤，因为有可能出现类似 hash 冲突的情况——主机不想接受的帧仍被发到了这个 MAC 地址。</p>
<h2 id="发送／接收组播数据报"><a href="#发送／接收组播数据报" class="headerlink" title="发送／接收组播数据报"></a>发送／接收组播数据报</h2><p>组播的基本概念是主机给定的接口上进程<strong>加入</strong>（joining）或<strong>离开</strong>（leaving）一个或多个组播组的概念。</p>
<p>能接受一个特定组播组数据的主机集合叫主机组。主机组可以跨越多个网络，成员资格是动态的，意思是主机成员可随时加入 or 离开主机组。一些组播地址被 IANA 确定为知名地址。</p>
<p>组成员资格是与接口相关的，一个进程可以在多个接口上加入同一组，也可以加入同一接口上的多个组。一个主机接收到一个组播数据报，向属于这个组播组的每个进程传递数据报的复制。</p>
<h2 id="主机地址过滤"><a href="#主机地址过滤" class="headerlink" title="主机地址过滤"></a>主机地址过滤</h2><p>为了了解操作系统进程如何为程序已加入的组播组接收组播数据报，我们需要了解<strong>过滤</strong>（filtering）操作。过滤在主机的网络接口卡（NIC）上发生。如图所示：</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/filter%20on%20group%20message.png" alt=""></p>
<p>在典型的交换式以太网环境中，广播和组播帧是沿着生成树在 VLAN 的所有段上被复制。简单来说，帧被交付至每台主机的 NIC 上，然后检查帧的完整性（CRC），决定是否接受该帧。若接收，就将其交付给设备驱动程序和网络协议栈。目的地址是接口的硬件地址的帧，以及广播帧，就按照上述过程处理了。但组播帧的情况更复杂一点。</p>
<p>NIC 处理组播帧一般有两类：</p>
<ul>
<li>基于<strong>组播硬件地址的散列值</strong>过滤。</li>
<li>基于<strong>侦听组播地址的一张有限表</strong>。</li>
</ul>
<ol>
<li>散列表的方法就意味着会出现<strong>冲突</strong>，意味着一些<strong>不需要的帧会误以为可以通过</strong>。这不是一个致命的问题，因为协议栈的较高层次依然会有检测。</li>
<li>侦听一张有限表上的组播地址的方法，如果长度超过限制，就会导致所有的组播流量将交给主机软件。尽管存在不完美的硬件过滤，组播仍然比广播更高效。</li>
</ol>
<p>一旦 NIC 确定一个帧可以接收（CRC 正确、VLAN 标签匹配、MAC 地址和 NIC 地址表的条目相匹配或散列值匹配），该帧被传递到设备<strong>驱动</strong>程序（driver），在此执行另外的过滤。</p>
<ul>
<li>首先，指定一种特定的<strong>协议</strong>（例如 IPv4、ARP 等等）</li>
<li>过滤以检查主机<strong>是否属于被寻址的组播组</strong>。</li>
</ul>
<p>然后，设备驱动程序将该帧传递到下一层。例如，帧类型是指定了一个 IP 数据报，则传递到 IP 层，IP 进行更多的过滤。如果一切依然没有问题，传递到下一层（如 UDP 和 TCP），再进行过滤。（如没有进程在使用目的端口，则数据报被丢弃，生产 ICMP 端口不可达报文；或者校验和错误，被默默丢弃）</p>
<p>为什么要研究组播过滤、寻址的特征？主要动机之一是为了<strong>避免广播的开销</strong>。考虑一个使用 UDP 广播的应用程序。一个网络（或者 VLAN）一共有 50 台主机，但只有 20 台参与了这个应用。当 UDP 广播被发送的时候，在 30 台没有参与的主机那里，UDP 广播数据报在上升到 UDP 层，因为发现了目的端口没有被使用，才被丢弃。使用组播的目的就是减少对该应用没有兴趣的主机的负担。使用组播，在 NIC 层次的过滤器就可以过滤不相关、不感兴趣的流量。这一机制使得在主机上处理数据报的开销减小，作为代价，就是在组播地址管理、组成员管理方面添加额外的协议。</p>
<h1 id="互联网组管理协议-和-组播侦听发现协议"><a href="#互联网组管理协议-和-组播侦听发现协议" class="headerlink" title="互联网组管理协议 和 组播侦听发现协议"></a>互联网组管理协议 和 组播侦听发现协议</h1><p>到目前为止，我们从主机角度讨论了组播数据报的传输、过滤、接收。当组播数据报在广域网，或是<strong>跨越多个子网</strong>中转发时，需要一个或多个<strong>组播路由器</strong>来启动<strong>组播路由</strong>（multicast routing）。组播路由器需要知道<strong>哪些主机对什么组播感兴趣</strong>。路由器需要知道这些信息，知道<strong>哪些组播数据报该转发到哪个接口</strong>。</p>
<p>两个主要协议用于组播路由器了解附近主机感兴趣的组：IPv4 使用的<strong>互联网组管理协议</strong>（Internet Group Management Protocol）和 IPv6 使用的<strong>组播侦听发现协议</strong>（Multicast Listening Discovery Protocol）</p>
<p>如下图所示，展示了具有组播功能的路由器如何使用 IGMP（MLD）。组播路由器沿着实线发送查询来了解各个主机的情况和兴趣，而虚线是主机向组播路由器发送报告。</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/IGMP%20query%20and%20report.png" alt=""></p>
<p>组播路由器定时向每个子网发送 IGMP（MLD）请求，以确定哪些组和源对连接的主机感兴趣。主机报告相应，说明感兴趣哪些组和源。如果成员资格发送变化，还能主动报告。</p>
<p>与 ICMP 的类似，IGMP 被认为是 IP 层的一部分，IGMP 报文也是封装在 IPv4 数据报中传输。非常不同的一点是，IGMP 数据报使用一个固定的 TTL = 1 值，所以数据报仅限于本地子网。下图是 IGMP 和 MLD 的封装。</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/IGMP%20IPv6%20header.png" alt=""></p>
<p>简单来说，IGMP 和 MLD 定义的是：</p>
<ul>
<li>成员主机（“组成员”）的工作是自发地报告对组播源的兴趣改变，响应定期地查询。可能是被动响应，也可以是主动报告。</li>
<li>组播路由器发送查询，确定链路上的主机对于任意组播组或者特定组播组是否有兴趣。</li>
</ul>
<h2 id="组成员的-IGMP-和-MLD-部分（“组成员部分”）"><a href="#组成员的-IGMP-和-MLD-部分（“组成员部分”）" class="headerlink" title="组成员的 IGMP 和 MLD 部分（“组成员部分”）"></a>组成员的 IGMP 和 MLD 部分（“组成员部分”）</h2><p>组成员的部分被设计为允许主机指定它们对什么样的组感兴趣（从某一特定源的流量是被接受还是过滤），这是<strong>向</strong>通过一个或多个连接到同一子网的<strong>组播路由器和参与主机</strong>发送报告完成的。</p>
<p>报告可以是响应查询后发送，也可以是在兴趣改变（加入或离开）之后自发、主动地发送。</p>
<p>报告分为成员资格记录（membership）组记录（group）。成员资格用于主机表达他们对什么组感兴趣。下图是成员资格记录的报文：</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/membership%20report.png" alt=""></p>
<p>成员资格报告的使用规则：</p>
<ol>
<li>第一个进程加入一个组，发送一个报告。若一个主机多个进程加入同一组，只发送一个报告。</li>
<li>离开一个组，不发送报告。主机只在知道没有成员属于某组后，在随即的IGMP 查询时不再发送报告报文。</li>
<li>发送报告来相应查询的话，对于至少包含一个进程的组均要报告。 </li>
</ol>
<p>组记录用于报告一个组播地址对来自于一个或多个源的流量是允许接受还是过滤掉。组记录用类型值来指定不同的模式，如下表。</p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/group%20record.png" alt=""></p>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/IGMP%20filtering%20mode.png" alt=""></p>
<h2 id="组播路由器的-IGMP-和-MLD-部分（“组播路由器部分”）"><a href="#组播路由器的-IGMP-和-MLD-部分（“组播路由器部分”）" class="headerlink" title="组播路由器的 IGMP 和 MLD 部分（“组播路由器部分”）"></a>组播路由器的 IGMP 和 MLD 部分（“组播路由器部分”）</h2><p>组播路由器的工作是为组播组、接口、源列表确定是否至少有一个成员目前感兴趣接收相应的流量。这是通过<strong>发送查询和成员主动发送的报告</strong>来确定的一个软状态（soft state）。软状态意味着如果没有刷新，经过一段时间后，要被删除。</p>
<p>发送查询：</p>
<ol>
<li>一般查询：学习邻居接口的完整组播接收状态（组地址和源地址为 0 ）</li>
<li>特定组查询：学习邻居对单一特定组播接收状态（源地址为0）</li>
<li>特定组特定源查询：学习邻居对一个特定源列表发送出的，目的地为某个组地址的接收状态。</li>
</ol>
<p><img src="http://p6rl2gdnw.bkt.clouddn.com/IGMP%20query.png" alt=""></p>
<h2 id="IGMP-和-MLD-健壮性"><a href="#IGMP-和-MLD-健壮性" class="headerlink" title="IGMP 和 MLD 健壮性"></a>IGMP 和 MLD 健壮性</h2><p>健壮性和可靠性体现在IGMP 或 MLD 本身失效时，有两个主要的问题：</p>
<ol>
<li>协议报文丢失</li>
<li>组播路由器的失效。</li>
</ol>
<p>可能导致不需要的组播流量分配，或者没有能力交付期望的组播流量。</p>
<ul>
<li>通过多个组播路由器在同一链路上运行，可以处理单一组播路由器失效故障。在这样的配置中，最小地址 IP 地址的路由器被选举为“查询器”，查询器负责发送查询。其他（非查询器）路由器监控协议报文，并且在查询器 down 时可以介入。查询器选举是一个类似生成树协议中根网桥选举的过程。</li>
<li>为了防止协议报文的丢失，有些报文会被重传多次，诸如主动报告间隔这种可配置参数可以合理配置。需要以生成额外的流量负担，增加健壮性。</li>
</ul>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 2 章：Internet 地址结构</title>
    <url>/2017/10/30/tcpip2-IP-address/</url>
    <content><![CDATA[<p>第二章介绍 Internet 使用的<strong>网络层地址</strong>，即熟知的 IP 地址。连接到 Internet 的设备，基于 TCP/IP 的专用网络中使用的设备都需要一个 IP 地址。</p>
<p>路由器（见 IP 协议 一章）转发是用 IP 地址来识别流量去向的。IP 在某些方面与电话号码相似。但大多数用户不需要记住一位位的数字，而是被 <strong>DNS</strong> 屏蔽在视线之外。当用户自建网络或 DNS 失效，就需要直接处理 IP 地址。</p>
<p>当一台设备被连接到全球性的 Internet 时，分配 IP 地址需要经过协调。这项工作由一个管理实体来帮助用户和服务提供商来分配地址。个人用户一般向 <strong>Internet 服务提供商（ISP）</strong>支付费用，由 ISP 分配地址，用户获得地址以及路由。</p>
<h1 id="IP-地址表示"><a href="#IP-地址表示" class="headerlink" title="IP 地址表示"></a>IP 地址表示</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><ul>
<li>点分四组（点分十进制）表示法。</li>
</ul>
<p>例如 <code>165.195.130.107</code> 。四个用点分隔的十进制。每个数字是范围 [0, 255] 的整数，代表 8 个 bit。即每个数字是 IP 地址的四分之一，使用简便的十进制表示。完整的 IP 地址是 32 位。</p>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>地址长度 128 位，是 IPv4 的 4 倍。写法是 8 个块，一个块是 4 个 16 进制数。例如：<code>5f05:2000:80ad:5800:0058:0800:2023:1d71</code></p>
<ol>
<li>一个块的前导零可以不写。<code>5f05:2000:80ad:5800:58:800:2023:1d71</code></li>
<li>全零块可以省略，用符号 <code>::</code>代替。但为了避免出现歧义，这个符号只能在一个地址中用一次。例如<code>2001:0db8:0:0:0:0:0:2</code> 可以写成：<code>2001:db8::2</code></li>
<li>IPv6 的低 32 位经常用 IPv4 的点分四组表示法，表示 IPv4 兼容的 IPv6 地址。</li>
</ol>
<p>以上规则带来的灵活性，但要规避不必要的混淆，有如下规则：</p>
<ol>
<li>前导零必须压缩。</li>
<li><code>::</code> 用于压缩最多的零，如果多个连续块包含等长度的零，则顺序靠前的用<code>::</code>替换。</li>
<li>十六进制 a - f 用小写。</li>
</ol>
<hr>
<h1 id="IP-地址结构"><a href="#IP-地址结构" class="headerlink" title="IP 地址结构"></a>IP 地址结构</h1><p>大多数 IPv4 最终被细分到一个地址，用于识别连接 Internet 或某些专用内联网的计算机网络接口。这种地址叫<strong>单播地址</strong>。其他类型包括<strong>广播、组播、任播地址</strong>，还有其他的特殊类型的地址。</p>
<h2 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h2><p>每个<strong>单播 IP 地址</strong>都有一个<strong>网络号</strong>（Network ID），标识该接口使用的地址在哪个网络中可以被发现。还有一个<strong>主机地址</strong>（host ID），标识由网络号给出的网络中的特定主机。</p>
<ul>
<li>最初的地址划分方法有五大类，主要是由地址中的头几位来定义：</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>开头</th>
<th>网络号</th>
<th>主机号</th>
</tr>
</thead>
<tbody>
<tr>
<td>A类</td>
<td>0</td>
<td>8位，除去开头一个1（下同），其余7位自由</td>
<td>24位</td>
</tr>
<tr>
<td>B类</td>
<td>10</td>
<td>16位，14位自由</td>
<td>16位</td>
</tr>
<tr>
<td>C类</td>
<td>110</td>
<td>24位，21位自由</td>
<td>8位</td>
</tr>
<tr>
<td>D类</td>
<td>1110</td>
<td>组播地址</td>
<td>32位，28位自由</td>
</tr>
<tr>
<td>E类</td>
<td>1111</td>
<td>保留</td>
<td>32位，28位自由</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>类</th>
<th>地址范围</th>
<th>用途</th>
<th>网络数</th>
<th>主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0.0.0.0 ~ 127.255.255.255</td>
<td>单播/特殊</td>
<td>128</td>
<td>16777216</td>
</tr>
<tr>
<td>B</td>
<td>128.0.0.0 ~ 191.255.255.255</td>
<td>单播/特殊</td>
<td>16384</td>
<td>65536</td>
</tr>
<tr>
<td>C</td>
<td>192.0.0.0 ~ 223.255.255.255</td>
<td>单播/特殊</td>
<td>2097152</td>
<td>256</td>
</tr>
<tr>
<td>D</td>
<td>224.0.0.0 ~ 239.255.255.255</td>
<td>组播</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>E</td>
<td>240.0.0.0 ~ 255.255.255.255</td>
<td>保留</td>
<td>N/A</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p>可以看出来 A 类的网络数比较少，但主机数非常多。C 类相反。从这里就可以看到，这种固定的网络地址分类，固定的网络数和主机数势必会让分配 IP 地址产生困难，协调很不方便。A 类容易浪费很多主机号，而 C 类不能提供足够的主机号。B 类地址比较折中，但很快就会耗尽。</p>
<p><strong>上述数字并不是准确的。</strong>例如，对于一个子网来说，第一个地址（主机号全为0）一般用来表示这个子网。最后一个地址（主机号全为 1）用来将数据报广播给该子网的所有主机。</p>
<h1 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h1><p>针对之前的分配新网段的网络号的棘手问题，人们很自然想到一种方式，在一个站点接入 Internet 之后，为其分配一个网络号，站点管理员再<strong>进一步划分本地子网数。</strong>很重要的一点是：Internet 的其余部分依然只看得到 A、B、C 类部分。而对于站点本身，<strong>进一步进行更加精细的分配。</strong>，这种方法叫做<strong>子网寻址</strong>（subneting）【RFC0950】。子网寻址为 IP 地址结构增加了额外的灵活性，没有增加地址的真实长度。借此，站点管理员可以在子网数和每个子网的预期主机数中寻找一个折中。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/subnetting.png" alt=""></p>
<p>图是一个 B 类地址被划分子网的例子。一个基础地址在站点内部进一步划分为一个<strong>子网号</strong>和一个<strong>主机号</strong>。这个 B 类地址使用 8 位作为子网 ID，这样，这个特殊配置的站点允许 256 个子网，每个子网最多包含 254 个主机。</p>
<p>站点之中的所有路由器和主机需要确定地址中的子网部分和主机部分。而 Internet 其他部分仍将其作为普通的 B 类地址看待。IP 协议中的 IP 转发操作，路由器需要区分网络中的不同子网，这需要额外的配置参数，具体例子看 CIDR 和聚合。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p><strong>子网掩码（mask）用于确定一台主机对应的 IP 地址中的网络和子网信息。</strong></p>
<ul>
<li>子网掩码中，设为 1 的部分，表示 IP 地址中对应的部分表示子网部分。设为 0 的部分，表示对应的是主机部分。</li>
</ul>
<p>长度与 IP 地址相同。配置方法可以是静态的（路由器中），也可以是动态的（DHCP）。写法可以是点分十进制。也可以用一种容易记忆的<strong>前缀长度</strong>写法：斜杠带上连续的 1 的个数。</p>
<p>例如 子网掩码：<code>255.255.255.192</code>  可以写成 <code>/27</code></p>
<h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p><strong>主机部分所有位置设置为 1。</strong></p>
<p>例如，对于子网 <code>128.32.1.0/24</code>，广播地址就是 <code>128.32.1.255</code>，这种广播作为一个单播包通过路由器到达子网后，再作为广播数据报发送给子网中的所有主机。从安全的角度来说，<strong>定向广播至今仍在 Internet 中被禁用</strong>。</p>
<p>特殊用途地址 <code>255.255.255.255</code> 称为<strong>本地网络广播</strong>，将被连接在同一网络中的计算机收到，除非终端主机明确禁用。这种本地广播不会经过路由器。广播地址经常出现在协议中，例如 UDP、ICMP。</p>
<p>IPv6 没有任何广播地址，仅使用组播地址。</p>
<hr>
<h1 id="CIDR-和聚合"><a href="#CIDR-和聚合" class="headerlink" title="CIDR 和聚合"></a>CIDR 和聚合</h1><p>使用子网掩码稍微缓解了连入 Internet 的设备增多的痛苦后（隔靴搔痒），Internet 立马又面临了更严重的两个问题：</p>
<ol>
<li><strong>IP 地址的耗尽</strong>。主要是 B 类地址。</li>
<li><strong>路由表条目的不断增长</strong>。由于每个网络号需要对应一条，随着规模不断增长，路由性能要受到严重影响。</li>
<li>A、B、C类的划分方法太固定，因此效率低下。</li>
</ol>
<p>下面介绍解决方案：CIDR 和聚合</p>
<h2 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h2><p>分类寻址方案由子网掩码采取了一个类似于可变长度子网掩码的概念（可将不同长度的子网掩码用于相同的网络号），叫做 <strong>CIDR</strong>（classless interdomain routing，<strong>无类别域间路由</strong>）</p>
<ul>
<li>提供一种方便的<strong>连续分配地址范围的方式</strong>。不只是单个 B 类或多个 C 类网络号可以分配给站点，使用 CIDR，任何未经过预定义的地址范围都可以作为一个类的一部分，只需要一个类似于子网掩码的掩码，称为 <strong>CIDR 掩码</strong>。</li>
<li>CIDR 掩码不像 subnetting mask 只对一个站点局限，而<strong>对全球路由系统都是可见</strong>的。</li>
<li>网络号和 CIDR 掩码的数字组合称为<strong>网络前缀</strong>（prefixes）</li>
<li>消除 IP 地址中网络和主机号的分隔定义，将更细粒度的 IP 地址分配范围成为可能。</li>
<li>前缀 n 的范围是 0~32 （IPv4），追加在 IP 地址后，跟着一个 / 字符。</li>
<li>例如 C 类网络号 192.125.3.0 写成前缀形式：<code>192.125.3.0/24</code>。A 类和 B 类网络号用前缀 <code>/8</code> 和 <code>/16</code> 表示。</li>
</ul>
<p>更精细地分配 IP 地址的例子：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">192.32.136.0</span>/<span class="number">21</span></span><br><span class="line"></span><br><span class="line">min address：<span class="number">11000000</span> <span class="number">00100000</span> <span class="number">10001000</span> <span class="number">00000001</span> </span><br><span class="line">mask：       <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111</span>--- -------- </span><br><span class="line">IP prefix：  <span class="number">11000000</span> <span class="number">00100000</span> <span class="number">10001</span>--- -------- </span><br><span class="line">max address：<span class="number">11000000</span> <span class="number">00100000</span> <span class="number">10001111</span> <span class="number">11111110</span> </span><br><span class="line"></span><br><span class="line"><span class="number">8</span> C networks: <span class="number">192.32.136.0</span>/<span class="number">24</span> to <span class="number">192.32.143.0</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line">通过使用前缀，分配 <span class="number">192.32.136.0</span>/<span class="number">21</span> 相当于分配了 <span class="number">8</span> 个 C 类地址</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到，CIDR 允许根据对地址空间的不同需求，将不同大小的地址块分配给某个组织。</li>
</ul>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>路由器要找出一个跨网段的数据报往哪发送，具体就是找到一条匹配的路由表条目，然后将其中的“下一跳”作为目的地，将包发送出去。</p>
<p>CIDR 能分配各种尺寸的地址块，<strong>但没解决路由表不断增长的问题</strong>。接下来这个<strong>聚合（Aggregation）</strong>方法解决了这个问题。</p>
<p>先举一个简单的例子 ：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">一家公司分配到以下后缀为 /<span class="number">24</span> 的四个连续网络号。</span><br><span class="line">在路由器上，四个网络中通常都使用相同的出口，</span><br><span class="line">可以进行 CIDR 聚合，以减少路由表的数量。</span><br><span class="line"></span><br><span class="line"><span class="number">128.56.24.0</span>/<span class="number">24</span>; <span class="number">10000000</span> <span class="number">00111000</span> <span class="number">00011000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">128.56.25.0</span>/<span class="number">24</span>; <span class="number">10000000</span> <span class="number">00111000</span> <span class="number">00011001</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">128.56.26.0</span>/<span class="number">24</span>; <span class="number">10000000</span> <span class="number">00111000</span> <span class="number">00011010</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">128.56.27.0</span>/<span class="number">24</span>. <span class="number">10000000</span> <span class="number">00111000</span> <span class="number">00011011</span> <span class="number">00000000</span></span><br><span class="line">                进行按位与 &amp;                  </span><br><span class="line"><span class="number">128.56.24.0</span>/<span class="number">22</span>  <span class="number">10000000</span> <span class="number">00111000</span> <span class="number">00011000</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line">用聚合的思想，最后一行代替路由表中的 <span class="number">4</span> 个条目</span><br><span class="line">以这个前缀开头的任何目的地都将显示这个下一跳，只需要一个条目就足够。</span><br></pre></td></tr></table></figure>
<ul>
<li>聚合的方法是对两个 IP 地址进行按位与。</li>
<li>分层路由思想：<ul>
<li>路由聚合思想。<strong>相邻的</strong>多个 IP 地址<strong>前缀合并成同一个短前缀</strong>，以覆盖更多地址空间。</li>
<li>这个行为是<strong>递归</strong>的。<strong>即使越来越多的路由器加入整个网络拓扑，这个良好的属性也会保持不变。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">例如某台路由器的路由表中有三个条目：</span><br><span class="line"></span><br><span class="line"><span class="number">190.154.27.0</span>/<span class="number">26</span>   <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">00000000</span> …… entry <span class="number">1</span></span><br><span class="line"><span class="number">190.154.27.64</span>/<span class="number">26</span>  <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">01000000</span> …… entry <span class="number">2</span></span><br><span class="line"><span class="number">190.154.27.192</span>/<span class="number">26</span> <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">11000000</span> …… entry <span class="number">3</span></span><br><span class="line"></span><br><span class="line">entry <span class="number">1</span> 与 entry <span class="number">2</span> 合并（按位与 &amp;）结果：   </span><br><span class="line"><span class="number">190.154.27.0</span>/<span class="number">25</span>   <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">00000000</span> …… entry <span class="number">4</span></span><br><span class="line"></span><br><span class="line">entry <span class="number">3</span> 目前不能合并，因为并不是相联的 IP 地址。</span><br><span class="line"></span><br><span class="line">此时路由表中新加入了一个条目：</span><br><span class="line"><span class="number">190.154.27.128</span>/<span class="number">26</span> <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">10000000</span> …… entry <span class="number">5</span></span><br><span class="line"></span><br><span class="line">entry <span class="number">5</span> 可与 entry <span class="number">3</span> 合并，因为是相邻的：</span><br><span class="line"><span class="number">190.154.27.192</span>/<span class="number">26</span> <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">11000000</span> …… entry <span class="number">3</span></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">190.154.27.128</span>/<span class="number">25</span> <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">10000000</span> …… entry <span class="number">6</span></span><br><span class="line"></span><br><span class="line">此时，entry <span class="number">6</span> 就可与 entry <span class="number">4</span> 合并了：</span><br><span class="line"><span class="number">190.154.27.0</span>/<span class="number">25</span>   <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">00000000</span> …… entry <span class="number">4</span></span><br><span class="line"><span class="number">190.154.27.128</span>/<span class="number">25</span> <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">10000000</span> …… entry <span class="number">6</span></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">190.154.27.0</span>/<span class="number">24</span>   <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011011</span> <span class="number">00000000</span> </span><br><span class="line"></span><br><span class="line">当在路由表条目中又遇到了相邻的 C类地址（递归）：</span><br><span class="line"><span class="number">190.154.26.0</span>/<span class="number">24</span>   <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011010</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line">又可以合并成：</span><br><span class="line"></span><br><span class="line"><span class="number">190.154.26.0</span>/<span class="number">23</span>   <span class="number">10111110</span> <span class="number">10011010</span> <span class="number">00011010</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line">…………</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>可以说 <strong>CIDR 开发和部署是 Internet 核心路由系统的一个根本性变化</strong>，CIDR 成功地为分配地址空间提供了更多灵活性，聚合提升路由的可扩展性</li>
<li>IPv6 在 20世纪 90年代受到重视，这是出于很快就需要更多地址的想法。<strong>当时没有预见的是，NAT 的广泛使用显著推迟了 IPv6 的使用</strong>。</li>
<li>但是，由于可用于路由的 IP 地址数量最终将减少到 0 ，因此未来将会出现一些变化。</li>
</ul>
<h1 id="IP转发行动："><a href="#IP转发行动：" class="headerlink" title="IP转发行动："></a>IP转发行动：</h1><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">简单的例题：</span><br><span class="line">路由器在其路由表中具有以下CIDR条目：</span><br><span class="line"></span><br><span class="line">地址 / 掩码         下一跳</span><br><span class="line"><span class="number">128.56.24.0</span>/<span class="number">22</span>     interface <span class="number">0</span></span><br><span class="line"><span class="number">128.56.60.0</span>/<span class="number">22</span>     interface <span class="number">1</span></span><br><span class="line">default             router <span class="number">2</span></span><br><span class="line"></span><br><span class="line">数据包的IP地址为 <span class="number">128.56.63.10</span>。 路由器的转发行为是什么？</span><br><span class="line"></span><br><span class="line"><span class="number">128.56.63.10</span> and mask <span class="number">22</span> bits</span><br><span class="line">IP address  =   <span class="number">10000000</span> <span class="number">00111000</span> <span class="number">01111111</span> <span class="number">00001010</span> </span><br><span class="line">Mask        =   <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111100</span> <span class="number">00000000</span></span><br><span class="line">                          By Per-bit &amp;</span><br><span class="line">Prefix      =   <span class="number">10000000</span> <span class="number">00111000</span> <span class="number">01111100</span> <span class="number">00000000</span> </span><br><span class="line">result：  <span class="number">128.56.60</span></span><br><span class="line"></span><br><span class="line">路由器表查找和匹配，应该去 interface <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最长前缀匹配-Longest-Prefix-Match"><a href="#最长前缀匹配-Longest-Prefix-Match" class="headerlink" title="最长前缀匹配 Longest Prefix Match"></a>最长前缀匹配 Longest Prefix Match</h2><p>当路由器的 IP 层需要向下一跳发送数据包时，检查目的 IP 地址，执行 <strong>最长前缀匹配 Longest Prefix Match</strong>。 IP 协议中的一个重要内容。</p>
<ul>
<li><p>因为使用了 CIDR ，对于一个给定的 IP 地址，可以有多个条目<strong>匹配</strong>。匹配是指：<strong>目的 IP 地址与掩码按位与之后，和转发条目中的目的地字段值相同。</strong></p>
</li>
<li><p>数据包必须使用<strong>最具体</strong>、<strong>最匹配</strong>的那条路由。最匹配就是在<strong>所有匹配的条目中，掩码中 1 最多的那个条目</strong>。</p>
</li>
</ul>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">考虑下面这个IPv4的路由表：</span><br><span class="line"></span><br><span class="line"><span class="number">192.168.0.0</span>/<span class="number">16</span></span><br><span class="line"><span class="number">192.168.20.16</span>/<span class="number">28</span></span><br><span class="line"></span><br><span class="line">在要查找地址<span class="number">192.168.20.19</span>的时候，这两个表项都“匹配”。</span><br><span class="line"></span><br><span class="line"><span class="number">192.168.20.19</span> = <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00010100</span> <span class="number">00010011</span></span><br><span class="line"></span><br><span class="line">匹配过程<span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">dst IP        = <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00010100</span> <span class="number">00010011</span></span><br><span class="line">mask <span class="number">16</span>bit    = <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">per-bit and   = <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00000000</span> <span class="number">00000000</span> </span><br><span class="line"><span class="number">192.168.0.0</span>   = <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00000000</span> <span class="number">00000000</span> match！！</span><br><span class="line"></span><br><span class="line">匹配过程<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">dst IP        = <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00010100</span> <span class="number">00010011</span></span><br><span class="line">mask <span class="number">28</span>bit    = <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11110000</span></span><br><span class="line">per-bit and   = <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00010100</span> <span class="number">00010000</span></span><br><span class="line"><span class="number">192.168.20.16</span> = <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00010100</span> <span class="number">00010000</span> match！！</span><br><span class="line"></span><br><span class="line">也就是说，两个表项都包含着要查找的地址。</span><br><span class="line"></span><br><span class="line">这种情况下，前缀最长的路由就是<span class="number">192.168.20.16</span>/<span class="number">28</span>，因为它的子网掩码（/<span class="number">28</span>）比其他表项的掩码（/<span class="number">16</span>）要长，使得它更加明确。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="特殊用途地址"><a href="#特殊用途地址" class="headerlink" title="特殊用途地址"></a>特殊用途地址</h1><p>不全部列举：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0.0.0/8</td>
<td>本地网络中的主机</td>
</tr>
<tr>
<td>10.0.0.0/8</td>
<td>专用网络、内联网的地址，不会出现在公共 Internet 中</td>
</tr>
<tr>
<td>192.168.0.0/16</td>
<td>同上</td>
</tr>
<tr>
<td>224.0.0.0/4</td>
<td>组播地址</td>
</tr>
<tr>
<td>255.255.255.255/32</td>
<td>本地网络受限广播地址</td>
</tr>
</tbody>
</table>
<p>专用地址空间管理由本地决定，在家庭网络、企业内部网络很常见，与此相关的话题是 <strong>NAT（网络地址转换）</strong>。</p>
<h1 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h1><p>IP 地址被分为大的块，这由一些权威机构完成。权威机构是为各种“所有者”分配地址空间的组织。所有者就是 ISP 或其他较小的权威机构。</p>
<p><strong>IANA：the Internet Assigned Number Authority 互联网数字分配机构</strong>，将分配权限分配给几个地区性 Internet 注册机构（RIR），它们为一些国家的<strong>小型机构、ISP</strong> 分配地址空间。ISP再给自己的客户提供地址空间。</p>
<ul>
<li><p>单播地址分配</p>
<ul>
<li>最简单的 Internet 服务：DSL 连接到 Internet，分配一个暂时的 IP 地址到 PPP 链路的一端。</li>
<li>家庭局域网、无线局域网，使用一台路由器或一台主机作为路由器连接 Internet，执行 NAT。从 ISP 的角度来看，只有一个 IP 地址被使用。大部分操作是自动的 (DHCP)</li>
<li>多个网络地址：需要固定的 IP，多个局域网、需要网络管理员确定需要多少地址、怎么划分子网、内外网（防火墙、NAT）</li>
</ul>
</li>
<li><p>组播</p>
<ul>
<li>用到在写 :)</li>
</ul>
</li>
</ul>
<h1 id="IP-地址相关攻击"><a href="#IP-地址相关攻击" class="headerlink" title="IP 地址相关攻击"></a>IP 地址相关攻击</h1><p>IP 地址基本上是数字，少数网络攻击会涉及到它们。</p>
<ul>
<li>IP 有助于查明涉嫌不良活动的个体。但很多情况下，IP 地址是暂时的，而且在不同时间分配给不同用户。在这种情况下，不知情人可能会由于 IP 地址成为嫌疑人，即使这个人不是攻击流量的发送者。</li>
<li>这类计算机、路由器（肉鸡）可通过基于 Internet 的黑市租赁，被用于执行攻击、非法内容服务等违法活动。</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://tool.520101.com/wangluo/ipjisuan/">IP 地址转换器</a></li>
<li><a href="http://www.cnblogs.com/dodng/p/4415110.html">CIDR详解和ip最长地址前缀匹配</a></li>
</ul>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 4 章：地址解析协议</title>
    <url>/2018/02/03/tcpip4-Address-Resolution-Protocol/</url>
    <content><![CDATA[<ul>
<li>链路层是经过单一链路通信的协议层。</li>
<li>IP 网络层协议的设计目标是为跨越不同物理类型的、多节点网络的 packet ，提供主机寻址、路由操作。</li>
</ul>
<p>在其中要注意的一点是：<strong>网络层使用的地址和底层网络硬件使用的地址是不同的概念</strong>。网络硬件的地址是由设备制造商定义的存储在设备硬件的永久型内存中，所以它不会改变。网络接口的 IP 地址是由用户或网络管理员分配，可以按需分配、选择，而且 IP 地址可能改变。</p>
<p><strong>网络接口的硬件</strong>通常有一个主要的<strong>硬件地址</strong>，例如以太网或 802.11 无线接口的 48 bits MAC 地址。由硬件交换的<strong>帧（frame）</strong>需要正确的地址定位到正确的<strong>硬件接口</strong>，否则无法传输数据。如果一个主机需要发送一个帧到另一个主机，仅知道这台主机的 IP 地址是不够的，还需要知道主机在网络中<strong>有效的硬件地址</strong>。这就需要；两个地址之间的互相转换。</p>
<p>对于 TCP/IP 网络，地址解析协议，<strong>ARP（Address Resolution Protocol）</strong>提供了一种在IPv4地址和各种网络技术中使用的硬件地址之间的映射。地址解析是发现两个地址之间映射关系的过程。</p>
<p><strong>ARP 仅用于 IPv4</strong>。IPv6 使用的是邻居发现协议，是 ICMPv6 的一部分。</p>
<p>ARP 是一个通用的协议。它被设计为支持多种地址之间的映射。不过实际上它最常被用于 IPv4地址和 MAC 地址之间的映射。ARP 提供<strong>动态映射</strong>，动态这个术语是因为它会自动执行以及随时间变化不需要系统管理员重新配置，ARP 的操作通常用户或系统人员无关</p>
<h1 id="直接交付"><a href="#直接交付" class="headerlink" title="直接交付"></a>直接交付</h1><p>当我们使用互联网服务时，例如在浏览器中打开一个网页，本地必须确定如何与相关的服务器联系。首先判断服务器是否位于本地（即是否在同一个子网）还是远程。如果是远程的需要一台可以到达目的地的路由器。只有位于与目的地同一 IP 子网的系统时，ARP 才能工作。</p>
<p><strong>直接交付</strong>（Direct delivery）发生在一个 IP 数据包被发送到一个具有与发送地址相同 IP 前缀的目的地址。即发送方跟接收方为同一子网。直接交付的示意图如下：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/direct%20delivery.png" alt=""></p>
<p>例如，用 Web 浏览器打开如下地址：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">10.0</span>.<span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<p>一个直接交付的操作：</p>
<ol>
<li>应用程序是一个外部浏览器调用一个函数来解析URL，看他是否包含主机名。这里不是这种情况，而是一个IPv4地址。</li>
<li>程序使用TCP协议建立一条连接。通过向目的地址发送一个IPv4数据包TCP尝试向远程主机发送一个连接请求（SYN）。</li>
<li>假设发送主机与目的IP地址，<strong>具有相同的网络前缀</strong>，这意味着数据报可以<strong>直接发送到这个地址而不经过任何路由器。</strong></li>
<li>假设链路层使用的是以太网地址。则发送主机必须将 32 位的IPv4目的地址转换为 48 位的以太网地址。这就是 <strong>ARP 功能</strong>。</li>
<li>在<strong>共享的链路层网段</strong>上 ARP 向所有主机发送一个称为 <strong>ARP 请求（ARP request）</strong>的以太网帧。这是被称为<strong>链路层广播</strong>。ARP 请求的内容是寻找以下问题的答案：“如果你的 IPv4 地址是 10.0.0.1，请向我回应您的 IP 地址。”</li>
<li>同一广播域的所有系统都可以接收到 ARP 请求。这其中可能包括根本不运行IPv4的系统，但不包括位于不同 vLAN 的系统。如果某个系统使用了这个请求内包含的 IPv4 地址，需要回应一个<strong>ARP 应答（ARP reply）</strong>，这个应答的内容就是其 MAC 地址。<strong>应答通常不是广播</strong>，而是直接发送给请求的发送方。收到应答的主机学习IPv4 到 Mac 地址的映射记录在内存之后，以供以后使用（缓存）。</li>
<li>发送方将数据报封装在以太网帧中，使用由 ARP 交换学习到的一台 MAC 地址作为目的地址。直接将数据交付到正确的主机。</li>
</ol>
<h1 id="ARP-缓存"><a href="#ARP-缓存" class="headerlink" title="ARP 缓存"></a>ARP 缓存</h1><p><strong>ARP 缓存（ARP cache）</strong>是 ARP 高效运行的关键。每个主机和路由器上有 ARP 缓存表。表存放了使用地址解析为每个接口维护从网络层地址到硬件地址的<strong>最新映射</strong>。当IP地址映射成硬件地址时，生成一个缓存表里的条目。默认到期时间是 20 分钟[RFC1122]</p>
<p>利用 <code>arp -a</code> 命令观察系统的 ARP cache。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/arp.png" alt=""></p>
<p>ARP 缓存存在<strong>超时</strong>。</p>
<p>命令允许管理员设置缓存条目永不超时，即设置为静态。大多数实现中，完整的条目超时时间为二十分钟，不完整的条目（例如一个到不存在的主机的请求）超时时间为三分钟。</p>
<p>这是一个关于<strong>软状态（soft state）</strong>的重要例子。软状态是指在超时前没有更新而被丢弃的信息。如果网络条件发生改变，软状态有助于启动自动重新配置。因此很多 Internet 协议使用软状态，软状态的成本就是必须刷新状态，以避免过期。在一些协议设计中经常包括软状态刷新，以保持软状态的活跃。</p>
<h1 id="ARP-帧格式"><a href="#ARP-帧格式" class="headerlink" title="ARP 帧格式"></a>ARP 帧格式</h1><p><img src="http://osax8w13y.bkt.clouddn.com/ARP%20frame.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(byte)</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DST</td>
<td>6</td>
<td>ff:ff:ff:ff:ff:ff</td>
<td>ARP 请求默认是广播地址，同一广播域所有以太网接口都可以接受到</td>
</tr>
<tr>
<td>SRC</td>
<td>6</td>
<td>略</td>
<td>发送方 MAC 地址会作为 ARP 应答的目的地址</td>
</tr>
<tr>
<td>Length or Type</td>
<td>2</td>
<td>0x0806</td>
<td>ARP 的以太网 type 是固定的 0x0806</td>
</tr>
<tr>
<td>硬件类型（Hard type）</td>
<td>2</td>
<td>以太网是 1</td>
<td>硬件地址类型（链路层可能有很多不同的）</td>
</tr>
<tr>
<td>协议类型（Prot type）</td>
<td>2</td>
<td>IPv4 是 0x0800</td>
<td>指出映射的网络层协议类型</td>
</tr>
<tr>
<td>硬件大小（Hard size）</td>
<td>1</td>
<td>以太网是 6</td>
<td>硬件地址的长度，以字节为单位，MAC 地址是 8 个字节</td>
</tr>
<tr>
<td>协议大小（Prot size）</td>
<td>1</td>
<td>IPv4 是 4</td>
<td>网络层协议地址的长度，以字节为单位，IPv4 地址是 4 个字节</td>
</tr>
<tr>
<td>操作类型（OP）</td>
<td>2</td>
<td>1~4</td>
<td>1：ARP 请求、2：ARP应答、3：RARP 请求、4：RARP 应答</td>
</tr>
<tr>
<td>发送方硬件地址</td>
<td>长度可变</td>
<td>顾名思义</td>
<td>顾名思义。紧跟在后面的四个字段是 ARP 的主要内容</td>
</tr>
<tr>
<td>发送方协议地址</td>
<td>长度可变</td>
<td>顾名思义</td>
<td>顾名思义</td>
</tr>
<tr>
<td>目的硬件地址</td>
<td>长度可变</td>
<td>顾名思义，且 ARP request 是 0</td>
<td>顾名思义</td>
</tr>
<tr>
<td>目的协议地址</td>
<td>长度可变</td>
<td>顾名思义</td>
<td>顾名思义</td>
</tr>
<tr>
<td>填充（Pad）</td>
<td>长度可变</td>
<td>顾名思义</td>
<td>顾名思义</td>
</tr>
<tr>
<td>FCS</td>
<td>4</td>
<td>4字节循环冗余校检码(CRC)</td>
<td>Frame Check Sequence</td>
</tr>
</tbody>
</table>
<p>目标主机生成应答的方式就是填充自己的硬件地址，然后将两个发送方地址和两个接收方地址交换，将<code>op</code>字段设置为 2，然后发送自己的应答。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ARP 是一个 TCP/IP 的基本协议，不过，它通常在应用程序或用户没有察觉的情况下使用和运行。ARP 用于确定本地可达的 IPv4 子网中，使用某个IPv4地址的主机对应的硬件地址。ARP 在数据报的目的地与发送方处于同一子网时发挥功效。不在同一子网，将会转发到一台路由器（详见 IP 协议）。ARP 缓存是其运行的基础，可以使用<code>arp</code>命令查看并处理缓存。缓存条目都有计时器。</p>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">wiki - ARP</a></li>
</ul>
<blockquote>
<p>The Address Resolution Protocol (ARP) is a communication protocol used for discovering the link layer address associated with a given IPv4 address, a critical function in the Internet protocol suite. ARP was defined in 1982 by RFC 826,[1] which is Internet Standard STD 37.</p>
<p>ARP is used for mapping a network address such as an IPv4 address, to a physical address, such as a MAC address. ARP has been implemented with many combinations of network and data link layer technologies, such as IPv4, Chaosnet, DECnet and Xerox PARC Universal Packet (PUP) using IEEE 802 standards, FDDI, X.25, Frame Relay and Asynchronous Transfer Mode (ATM). IPv4 over IEEE 802.3 and IEEE 802.11 is the most common usage.In Internet Protocol Version 6 (IPv6) networks, the functionality of ARP is provided by the Neighbor Discovery Protocol (NDP).</p>
</blockquote>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 3 章：链路层</title>
    <url>/2017/11/01/tcpip3-Link-Layer/</url>
    <content><![CDATA[<p>在体系结构中，我们知道：<strong>链路层（或数据链路层）</strong>包含为共享相同介质的<strong>邻居</strong>建立连接的协议和方法。该层是在广域网（WAN）中的<strong>相邻网络节点之间</strong>或<strong>同一局域网（LAN）网段上的节点</strong>之间传输数据的协议层，除此之外，提供检测物理层中可能发生的错误的手段，但不一定会去尝试纠正。同时，设计链路层的目的是<strong>为 IP 模块发送和接受 IP 数据报</strong>，链路层可用于携带支持 IP 的辅助性协议，例如 ARP。</p>
<blockquote>
<p> The link layer has the networking scope of the <strong>local network connection to which a host is attached</strong>. This regime is called the <strong>link</strong> in TCP/IP literature. It is the <strong>lowest component layer</strong> of the Internet protocols, </p>
<p>The data link layer provides the functional and procedural means to transfer data between network entities and might provide the means to detect and possibly correct errors that may occur in the physical layer.</p>
</blockquote>
<p><strong>TCP/IP 取得成功的的原因之一在于它能工作在几乎任意一种链路之上。</strong>不同的链路层依赖于其使用的网络硬件类型：有限局域网，例如以太网；城域网，例如有线电视、DSL 连接；有线语音网络，例如支持调制解调器的电话线；无线网络，如 WiFi（无线局域网）；基于蜂窝技术的无线数据服务。在本章中，主要讨论以太网，以及如何使用点到点协议 （PPP）。</p>
<blockquote>
<p>… as TCP/IP is designed to be <strong>hardware independent</strong>. As a result, TCP/IP may be implemented on top of virtually any hardware networking technology.</p>
</blockquote>
<p>大多数链路层技术都有一个相关的协议，描述由网络硬件传输的 <strong>PDU</strong>（Protocol Data Unit，协议数据单元） 格式。在描述链路层数据单元时，我们通常使用术语<strong>帧</strong>（frame），来和那些更高层的 PDU 格式区别开来，如网络层和传输层的 PDU <strong>分组</strong>（packet）和<strong>段</strong>（fragment）。帧通常支持<strong>可变帧长度</strong>，但有一个上限——最大传输单元（MTU，Maximum Transmission Unit），这是链路层的一个特点。</p>
<blockquote>
<p>Data-link <strong>frames</strong>, as these protocol data units are called, <strong>do not cross the boundaries of a local network</strong>. Inter-network routing and global addressing are higher-layer functions, allowing data-link protocols to focus on local delivery</p>
</blockquote>
<h1 id="以太网、IEEE-802-局域网标准"><a href="#以太网、IEEE-802-局域网标准" class="headerlink" title="以太网、IEEE 802 局域网标准"></a>以太网、IEEE 802 局域网标准</h1><p><strong>以太网</strong>（Ethernet）这个术语通常指<strong>一套标准</strong>，由 DEC、Intel、Xerox 公司于 1980 年首次发布，在 1982 年加以修订。第一个常见格式的以太网，目前被称为 “10 Mb/s 以太网” 或 “共享以太网”，它被 IEEE 采纳成为 <strong>802.3 标准</strong>。这种网络的结构通常如下所示：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/Ethernet1.png" alt=""></p>
<p>以太网包含如下概念和知识点：</p>
<h2 id="CSMA-CD-or-MAC"><a href="#CSMA-CD-or-MAC" class="headerlink" title="CSMA/CD or MAC"></a>CSMA/CD or MAC</h2><p>基本共享以太网包含一个或<strong>多个站（station）</strong>，它们都被连接到一个<strong>共享的电缆段上</strong>。标准需要每个以太网接口实现一种分布式算法。This common scheme is called <strong>carrier sense, multiple access with collision detection</strong> ，也就是<strong>CSMA/CD：带冲突检测的载波侦听多路访问</strong>。</p>
<ul>
<li><p>CSMA/CD 协调哪些计算机可以访问共享的介质（电缆），不需要其他特殊协议或同步。有助于降低成本、促进以太网技术的普及。</p>
</li>
<li><p>“载波侦听”：一个站在发送自己的数据之前，首先<strong>检测目前网络上发送的信号</strong>，在网络<strong>空闲</strong>时，才发送自己的帧。</p>
</li>
<li><p>“碰撞检测”：如果其他站碰巧在发送，重叠的电信号被视为<strong>碰撞（collision）</strong>。在这种情况下，站可以<strong>检测（detect）</strong>到。如果检测到碰撞，会导致发送方<strong>等待一个随机时间，然后重新发送数据。</strong></p>
</li>
<li><p>等待时间量的选择依据一个的概率分布。<strong>随后，如果再次检测到碰撞，每个碰撞会使等待时间长度加倍</strong>。最终<strong>每个站会得到机会转发</strong>，或者在尝试一定次数之后（传统以太网为 16）后<strong>超时</strong>。</p>
</li>
<li><p>只有当<strong>介质（medium）</strong>被确定为空闲状态时，链路层的 PDU 可以从一个站发送到其他一个或更多站。<strong>任何给定的时间内，网络中同一时刻只能有一个帧在传输</strong>。CSMA/CD 因此有另一个更正式的名字：<strong>介质访问控制协议，Medium Access Control。</strong></p>
</li>
<li><p><strong>以太网是一种广播网络。</strong></p>
</li>
</ul>
<h2 id="以太网帧格式-Frame-Format"><a href="#以太网帧格式-Frame-Format" class="headerlink" title="以太网帧格式 / Frame Format"></a>以太网帧格式 / Frame Format</h2><p>下面介绍交换机如何处理 PDU（Protocol Data Unit，协议数据单元）。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/frame%20format.png" alt=""></p>
<p>所有的以太网帧都基于一个共同的格式。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(byte)</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>前导（Preamble）</td>
<td>7</td>
<td>一般是一种公认的模式，典型值为 0xAA</td>
<td>接收接口电路使用，以确定帧的到达时间并确定编码位之间的时间量（称为时钟恢复）。<strong>简单来说，就是用于同步。</strong></td>
</tr>
<tr>
<td>帧起始分隔符（SFD）</td>
<td>1</td>
<td>固定值：0xAB</td>
<td>以太网帧<strong>开始的标志</strong></td>
</tr>
<tr>
<td>目的MAC地址（DST）</td>
<td>6</td>
<td>一个 MAC 地址</td>
<td>指明帧的接受者。目的地址也支持多个站点，例如广播（ARP协议）、组播（ICMPv6）</td>
</tr>
<tr>
<td>源MAC地址（SRC）</td>
<td>6</td>
<td>一个 MAC 地址</td>
<td>指明帧的发送者</td>
</tr>
<tr>
<td>长度或类型（Length/Type）</td>
<td>2</td>
<td>常见值有 IPv4（0x0800）、IPv6（0x86DD）、ARP（0x0806）</td>
<td>帧的数据字段的长度（长度或类型）</td>
</tr>
<tr>
<td>标签(tag)</td>
<td>最大482字节</td>
<td>如 QoS 指示符（服务质量）</td>
<td>包含由其他 IEEE 标准定义的各种协议字段</td>
</tr>
<tr>
<td><strong>有效载荷</strong>（payload）</td>
<td>46~1500</td>
<td>略</td>
<td>存放高层 PDU 的地方。对于TCP/IP 是 IP 数据包</td>
</tr>
<tr>
<td>填充（女仆长のpad）</td>
<td>可选</td>
<td>一定长度的连续 0</td>
<td>确保帧长度符合<strong>最小长度要求</strong></td>
</tr>
<tr>
<td><strong>循环冗余检验</strong>（FCS）</td>
<td>4</td>
<td>见下文</td>
<td>对接收网卡提供判断是否传输错误的一种方法</td>
</tr>
</tbody>
</table>
<h2 id="帧检验序列-循环冗余检验"><a href="#帧检验序列-循环冗余检验" class="headerlink" title="帧检验序列/循环冗余检验"></a>帧检验序列/循环冗余检验</h2><p>最后一个字段 FCS（Frame Check Sequence）提供了对<strong>帧完整性的检查</strong>。方法是：Cyclic Redundancy Check (CRC) <strong>循环冗余检验</strong>。<a href="http://blog.csdn.net/liyuanbhu/article/details/7882789">这篇文章</a>介绍的很好，在这里引用一下：</p>
<blockquote>
<p>CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的<strong>余数</strong>作为校验数据附加到原数据后面。（商是抛弃的）…… 为了进行CRC运算，也就是这种特殊的除法运算，<strong>必须要指定个被除数</strong>，在CRC算法中，这个被除数有一个专有名称叫做<strong>“生成多项式”</strong>。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。好在这个问题已经被专家们研究了很长一段时间了，对于我们这些使用者来说，只要把现成的成果拿来用就行了。</p>
<p>多项式的位宽（Width，简记为W），这个位宽不是多项式对应的二进制数的位数，而是位数减 1。按照 CRC 算法的要求，计算前要在原始数据后填上 W 个 0。</p>
</blockquote>
<p>值得注意的是，CRC 使用的是 <a href="https://baike.baidu.com/item/%E6%A8%A12%E8%BF%90%E7%AE%97/18556715?fr=aladdin">mod 2 二进制除法</a>计算余数。<strong>与四则运算不同的是模2运算不考虑进位和借位，即模2加法是不带进位的二进制加法运算，模2减法是不带借位的二进制减法运算。</strong>该计算结果的反码放置在帧的 CRC 或 FCS 字段中。在接受到数据之后，接收方执行相同的算法，得到结果，判断与存放在 FCS 字段的值是否匹配。如果两者不匹配，帧可能在传输过程中受损，通常被<strong>丢弃</strong>。</p>
<hr>
<h1 id="网桥和交换机"><a href="#网桥和交换机" class="headerlink" title="网桥和交换机"></a>网桥和交换机</h1><p>IEEE 802.1d 标准规定了网桥的操作。 <strong>交换机本质上是高性能的网桥。</strong></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>随着以太网技术的发展，更快的计算机和基础设施使得局域网速度不断提升。（速度从 10Mb/s 增加到 100Mb/s、10Gb/s 甚至更高）。</p>
<p>二十世纪九十年代初，共享电缆已经很大程度被双绞线（类似电话线）替代。随着<strong>快速以太网</strong>的发展（100Mb/s），最初<strong>基于竞争的 MAC 协议已经变得不流行</strong>。</p>
<ul>
<li>局域网中的每个站之间的线路变成<strong>不共享</strong>，而是由<strong>以太网交换机（Ethernet Switch）</strong>实现了一个专用的星形拓扑结构。</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/Ethernet%20Switch.png" alt=""></p>
<ul>
<li>交换机为以太网中的每个站提供<strong>同时</strong>发送和接受数据的能力。</li>
<li>每个站使用一条<strong>专用的线路</strong>连接到一个交换机<strong>端口（port）</strong>，在这种情况下，以太网以<strong>全双工</strong>方式运行，不需要使用 CSMA/CD 算法。</li>
<li>交换机可以通过<strong>交换机端口级联（interconnect）</strong>来形成更大的以太网。这种端口叫做<strong>“上行（uplink）端口”</strong></li>
</ul>
<h2 id="全双工、半双工"><a href="#全双工、半双工" class="headerlink" title="全双工、半双工"></a>全双工、半双工</h2><ul>
<li><p><strong>半双工（half duplex mode）</strong>：使用一条共享的电缆，CSMA/AD，以太网最初被开发出来的时候就工作在半双工模式。</p>
</li>
<li><p><strong>全双工（full duplex mode）</strong>：交换式以太网。网络不再是单一的共享线路，而代之以很多链路的组合。减少了冲突检测电路的使用，增加了以太网的物理长度。</p>
</li>
</ul>
<h2 id="互连、MAC-学习"><a href="#互连、MAC-学习" class="headerlink" title="互连、MAC 学习"></a>互连、MAC 学习</h2><p>图中的交换机 A 和 B 互连，形成一个<strong>扩展的局域网</strong>。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/switch.png" alt=""></p>
<p>下面介绍交换机的 <strong>MAC 学习（learn）</strong>过程：</p>
<ul>
<li>每个网络单元都有自己的 MAC 地址。</li>
<li>每个网桥经过一段时间的<strong>对域外 MAC 地址的学习</strong>后，最终每个交换机会知道<strong>每个站可以由哪个端口到达</strong>。</li>
<li>每个交换机基于每个端口的列表被存储在一张被称为<strong>过滤数据库（filtering database）</strong>的表中。</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/filteringdatabase.png" alt=""></p>
<ul>
<li>当交换机（桥）首次打开时，其数据库为空，因此不知道其他站点的位置。 无论何时收到<strong>目的地为自己以外的站的帧</strong>，它将为此帧目的端口<strong>之外的每个端口创建一个副本，并从每个端口发送帧的副本</strong>。（好像与广播有些许差别</li>
<li>why learn？如果交换机从未学习站的位置，<strong>每个帧都需要被交付到每个网段</strong>，这将导致显著的不必要开销。<strong>学习能力（learning capability）可以显著降低开销，这是交换机和网桥的一个基本功能。</strong></li>
<li>由于站可能出现异动、网卡更换、MAC 地址改变等各种情况，所以过滤数据库中的一个 MAC 地址可以通过某端口访问这条信息也<strong>不能假设是永远正确的。</strong><ul>
<li>为了解决这个问题，过滤数据库使用一个计时器（通常是五分钟）。如果在这个有效期内，没有再次看到某条目的地址，则将这个条目<strong>删除</strong>。</li>
</ul>
</li>
</ul>
<h1 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h1><p>我们知道了交换机的一个很重要的能力——MAC 地址学习能力。但由于可能存在端口交叉连接、交换机级联的可能性，可能会导致某些问题，看下图这个例子：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/STP%20%E6%8B%93%E6%89%91.png" alt=""></p>
<p>假设上图中的多个交换机刚刚被打开，它们的过滤数据库都为空。由于这个扩展以太网包括的 4 台交换机由冗余链路组成，会产生所谓<strong>广播风暴（broadcast storm）</strong></p>
<ul>
<li>当站点 S 发送一个帧时，交换机 B 在端口 7、8、9 复制该帧。</li>
<li>这些帧被交换机 A、D、C 接收，而交换机 A 依然会在 2、3 端口复制该帧，交换机 D、C 会在 20、22、13、14 生成更多副本。</li>
<li>这些副本在交换机之间<strong>来回双向传输</strong>，这导致了转发数据库的<strong>震荡（oscillate，体会与 collision 的区别）</strong>，将会导致多余的流量倍增。</li>
</ul>
<p>这时，需要一种协议来避免这种情况，就是<strong>生成树协议（Spanning Tree Protocol，STP）</strong>。</p>
<ul>
<li>顾名思义，一个网络拓扑就是一个图，生成树就是包含所有节点而边集合没有形成回路。</li>
<li>STP 是通过<strong>在每个网桥禁用某些端口</strong>来避免拓扑环路的。</li>
<li>一张图可能有多个生成树，而 STP 用于<strong>找出其中一个生成树</strong>。</li>
<li>生成树的形成和维护由多个网桥完成，所以是在每个网桥上运行一个<strong>分布式算法</strong>。</li>
</ul>
<p><img src="http://osax8w13y.bkt.clouddn.com/STP%20%E6%8B%93%E6%89%912.png" alt=""></p>
<p>上面这个例子中，通过 STP，端口6、7、1、2、13、14、20 处于转发状态，其余端口被阻塞，预防了广播风暴。当然，STP 也能处理拓扑变化，会重新计算一个新的生成树。</p>
<h2 id="STP-状态机"><a href="#STP-状态机" class="headerlink" title="STP 状态机"></a>STP 状态机</h2><p><img src="http://osax8w13y.bkt.clouddn.com/STP%20state%20machine.png" alt=""></p>
<p>STP 状态机中，端口可能有五个状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
<th>状态转移</th>
</tr>
</thead>
<tbody>
<tr>
<td>阻塞（blocking）</td>
<td>初始化后，端口会进入阻塞状态。不进行地址学习、数据转发、BPDU 发送。但会<strong>监控、接收BPDU</strong></td>
<td>监视接收到的BPDU，如果需要包含在根桥路径上，在这种情况下，端口转换到侦听状态。或者经过最大时间（MaxA），也会转变到侦听状态</td>
</tr>
<tr>
<td>侦听（listening）</td>
<td>在侦听状态下，该端口现在<strong>允许发送BPDU</strong>，但不学习地址或转发数据。</td>
<td>在15秒的典型<strong>转发延迟</strong>（delay）后，端口进入学习状态。</td>
</tr>
<tr>
<td>学习（learning）</td>
<td>这里允许执行除转发数据之外的所有过程。</td>
<td>等待一个转发延迟就可以进入转发状态。转发延迟内涵见 BPDU 的转发延迟字段。</td>
</tr>
<tr>
<td>转发（forwarding）</td>
<td>活跃的交换机端口承载数据流量的正常状态</td>
<td>上述三个状态都有可能因为拓扑改变，而被阻塞。</td>
</tr>
<tr>
<td>禁用（disabled）</td>
<td>顾名思义</td>
<td>由管理配置引起</td>
</tr>
</tbody>
</table>
<h2 id="端口角色"><a href="#端口角色" class="headerlink" title="端口角色"></a>端口角色</h2><p>每个端口都扮演一个<strong>角色</strong>。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>根端口（root bridge）</td>
<td>在生成树的<strong>边（edge）上</strong>，<strong>朝向根网桥</strong>的端口</td>
</tr>
<tr>
<td>指定端口（designated port）</td>
<td>处于转发状态，作为<strong>从附加网段</strong>（attached segment）<strong>到根的最小路径上的端口</strong></td>
</tr>
<tr>
<td>替代端口（Alternate port）</td>
<td>与指定端口定义类似，但是达到根成本更高的端口。该类端口为当前”根端口”到”根网桥”提供一条替代路径。平时处于阻塞状态，在根端口失效时可以替代它</td>
</tr>
<tr>
<td>备份端口（backup port）</td>
<td>该类端口为”指定端口”到达生成树叶提供一条备份路径，是指定端口的备份端口。仅当两个端口在一个由一个点对点链路组成的环路上连接时，或者当交换机有两个或多个到达共享LAN网段的连接时可以存在。在一个指定端口失效时用来接管。</td>
</tr>
</tbody>
</table>
<p>我们主要需要理解根端口和指定端口。贴出英文，好好揣摩：</p>
<ul>
<li><p>根端口：ports at the end of an edge on the spanning tree headed toward the root.</p>
</li>
<li><p>指定端口：ports in the forwarding state acting as the port on the least-cost path to the root from the attached segment.</p>
</li>
</ul>
<h2 id="BPDU"><a href="#BPDU" class="headerlink" title="BPDU"></a>BPDU</h2><p>下面介绍<strong>网桥协议数据单元（BPDU，Bridge Protocol Data Unit）</strong>，是 STP 形成、维护生成树过程中所使用的帧。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/BPDU.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度（bytes）</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>前导</td>
<td>7</td>
<td>略</td>
<td>略，见 Ethernet，下同</td>
</tr>
<tr>
<td>帧起始标志 SFD</td>
<td>1</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>DST</td>
<td>6</td>
<td><strong>总是被发送至 01:80:C2:00:00:00</strong></td>
<td>链路层组、因特网<strong>组播寻址</strong></td>
</tr>
<tr>
<td>SRC</td>
<td>6</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>长度/类型（L/T）</td>
<td>2</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>LLC/SNAP</td>
<td>3</td>
<td>此头部由 802.1 定义，针对 BPDU 设置为<strong>常数 0x424203</strong></td>
<td>STP <strong>用 LLC（逻辑链路控制）封装</strong>。并非所有 BPDU 都用 LLC/SNAP 封装，但这是很常见的选项</td>
</tr>
<tr>
<td>协议（Protocol identifier）</td>
<td>2</td>
<td>生成树协议设置为 <strong>0x0000</strong></td>
<td>协议 ID 号</td>
</tr>
<tr>
<td>版本（Protocol Version Identifier）</td>
<td>1</td>
<td>0/2/3</td>
<td>STP/RSTP/MSP 用于指出<strong>协议版本</strong></td>
</tr>
<tr>
<td>类型（BPDU Type）</td>
<td>1</td>
<td>与上一个字段，协议版本类似</td>
<td>略</td>
</tr>
<tr>
<td>标志（BPDU flags）</td>
<td>1</td>
<td>见下面详解</td>
<td>略</td>
</tr>
<tr>
<td><strong>根 ID</strong>（Root Identifier）</td>
<td>8</td>
<td>发送发使用的<strong>根网桥标识符</strong>，详情见网桥 ID 字段</td>
<td>生成树以某个特定网桥作为<strong>根</strong></td>
</tr>
<tr>
<td><strong>根路径成本</strong>（Root Path Cost）</td>
<td>4</td>
<td>到达根 ID 字段中指定的网桥的路径计算成本</td>
<td>用于计算生成树算法。 <strong>cost 是与链路传速速度成反比的</strong>。</td>
</tr>
<tr>
<td><strong>网桥 ID</strong>（Bridge Identifier）</td>
<td>8</td>
<td>交换机的 6 字节的 MAC 地址，以及前面一个 2 字节的<strong>优先级字段</strong></td>
<td>优先级的值可以通过管理软件来设置，强制要求生成树以某个特定网桥为根网桥</td>
</tr>
<tr>
<td><strong>端口 ID</strong>（Port identifier）</td>
<td>2</td>
<td>端口标识符，即由发送帧给出的端口号。也有一个可配置的 1 字节的<strong>优先级</strong>字段</td>
<td>作用类似网桥 ID 字段中优先级的作用。</td>
</tr>
<tr>
<td><strong>消息有效期</strong>（MsgA）</td>
<td>2</td>
<td>一开始设置为 0 。任何接收 BPDU 的桥将在其<strong>非根端口上发送帧</strong>，该字段<strong>增加 1</strong></td>
<td>此字段不像其他与时间相关的字段一样是一个固定值。<strong>实质上，该字段用作跳数</strong>，给出在接收BPDU之前已经处理的桥的数量。</td>
</tr>
<tr>
<td><strong>最大有效期</strong>（MaxA）</td>
<td>2</td>
<td>指出 BPDU 超时的期限，默认为 20 秒</td>
<td>在端口上接收到BPDU时，其包含的信息被保存在存储器中，并参与STP算法的执行中，直到被超时，<strong>超时是发生在(MaxA – MsgA)</strong>。如果在<strong>这个时间段内根端口没有接收到另一个 BPDU，根网桥被宣布“死亡”，重新开始根网桥选举过程</strong>。</td>
</tr>
<tr>
<td><strong>欢迎时间</strong>（Hello Time）</td>
<td>2</td>
<td>比如 2 秒</td>
<td>表示 BPDU 帧发送间隔</td>
</tr>
<tr>
<td><strong>转发延迟</strong>（Forward Delay）</td>
<td>2</td>
<td>典型为 15 秒</td>
<td>给出在学习和收听状态下等待所花费的时间。<strong>延迟是为了等待整个生成树的同步、MAC 表的刷新。</strong></td>
</tr>
<tr>
<td>FCS</td>
<td>4</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
<p>1 byte 的 flag 字段的位分别定义为：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bit)</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TC（topology change）</strong></td>
<td>1</td>
<td>拓扑变化</td>
</tr>
<tr>
<td>P</td>
<td>1</td>
<td>建议</td>
</tr>
<tr>
<td>端口角色</td>
<td>2</td>
<td>00 为未知，01 为替代or备份，10 为根端口，11 为指定端口</td>
</tr>
<tr>
<td>L</td>
<td>1</td>
<td>处于学习状态？</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>处于转发状态？</td>
</tr>
<tr>
<td>A</td>
<td>1</td>
<td>协议，agreement</td>
</tr>
<tr>
<td><strong>TCA（topology change acknowledgement）</strong></td>
<td>1</td>
<td>拓扑变化确认</td>
</tr>
</tbody>
</table>
<h2 id="建立生成树"><a href="#建立生成树" class="headerlink" title="建立生成树"></a>建立生成树</h2><p>第一个工作是<strong>选举根网桥</strong>。根网桥是在网络中<strong>网桥 ID 标识符最小</strong>（优先级和 MAC 地址结合）的网桥。具体步骤：</p>
<ul>
<li>当一个网桥初始化时，都假设自己是根网桥。用自己的网桥 ID 字段作为<strong>根 ID</strong>字段，发送 BPDU 消息。</li>
<li>如果某个网桥检测到一个 根 ID 更小的消息，则立即<strong>停止发送自己的帧</strong>，并<strong>基于接受到的那个更小的 ID 构造下一步要发送的 BPDU</strong>。</li>
</ul>
<p>我们可以这么理解：一群猴子要选出一个猴王出来，一开始，所有猴子都觉得自己能当猴王。假设有三只猴子 A、B、C：</p>
<ul>
<li>B 先向 A 发出挑战（交换机 B 用自己的 ID 发送 BPDU 给 A）</li>
<li>然而可惜的是， B 失败了（交换机 A 发送过来的 BPDU 中根 ID 字段比自己的要小），这样 B 就会承认 A 比较厉害，<strong>此后不再会挑战 A 的权威</strong>。（之后是基于 A 的更小的 ID 构造 BPDU，而不是发送自己的网桥 ID 了）</li>
<li>B 不仅向 A 俯首称臣了，还要向隔壁的 C 传达：<strong>A 是目前最厉害的猴子！</strong>（以后发送的 BPDU 中的根 ID 字段是 A 的 mac 地址）</li>
<li><strong>如果“A 是目前最厉害的猴子”这个消息传遍整个了猴群，那么 A 就当选了猴王。</strong></li>
</ul>
<p>下面来看一个例子，这个例子里包括四台交换机，各有两个端口互连，路径成本标在路径上：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/STP%20TOPO1.png" alt=""></p>
<ol>
<li><p>首先选择根网桥。假设这个例子中没有优先级，S1 的 MAC 地址最小，因此 S1 当选根桥（root bridge）。</p>
</li>
<li><p>选取<strong>每个网桥的</strong>根端口，考虑对象：网桥。选取方法：比较<strong>每一台交换机每个端口发出</strong>的 BPDU 的根路径成本，发出更小 BPDU 的那个端口就是根端口。</p>
</li>
</ol>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">S2: 端口<span class="number"> 1 </span>收到的 BPDU 的 cost 为 19; 端口<span class="number"> 2 </span>的为<span class="number"> 19 </span>+<span class="number"> 4 </span>+<span class="number"> 19 </span>= 42</span><br><span class="line">    端口<span class="number"> 1 </span>成为根端口</span><br><span class="line">S3: 端口 3:<span class="number"> 19 </span>+<span class="number"> 19 </span>= 38; 端口 4:19 +<span class="number"> 4 </span>= 23</span><br><span class="line">    端口<span class="number"> 4 </span>成为根端口</span><br><span class="line">S4: 端口 5:<span class="number"> 19 </span>+<span class="number"> 19 </span>+<span class="number"> 4 </span>= 42; 端口 6: 19</span><br><span class="line">    端口<span class="number"> 6 </span>成为根端口</span><br></pre></td></tr></table></figure>
<ol>
<li>选<strong>每个网段</strong>的指定端口，考虑对象：每条链路。选取方法：比较<strong>每条链路两端发出的</strong> BPDU 的 cost。</li>
</ol>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">S1-S2 网段: 端口<span class="number"> 8 </span>发出的 BPDU 的 cost 为 0; 端口<span class="number"> 1 </span>发出的 cost 为<span class="number"> 19 </span>+<span class="number"> 4 </span>+<span class="number"> 19 </span>= 42</span><br><span class="line">（这里，BPDU 不会逆着发，联想一下猴王的例子）</span><br><span class="line">            端口<span class="number"> 8 </span>成为指定端口</span><br><span class="line">S1-S3 网段: 端口 7: 0; 端口 6:<span class="number"> 19 </span>+<span class="number"> 19 </span>+<span class="number"> 4 </span>=<span class="number"> 42 </span></span><br><span class="line">            端口<span class="number"> 7 </span>成为指定端口</span><br><span class="line">S2-S3 网段: 端口 2: 19; 端口 3:<span class="number"> 19 </span>+<span class="number"> 4 </span>= 23</span><br><span class="line">            端口<span class="number"> 2 </span>成为指定端口</span><br><span class="line">S3-S4 网段: 端口 5: 19; 端口 4:<span class="number"> 19 </span>+<span class="number"> 19 </span>= 38</span><br><span class="line">            端口<span class="number"> 5 </span>成为指定端口</span><br></pre></td></tr></table></figure>
<p>下图是更新的状态：S1 当选根桥（root bridge）。端口 1、4、6 是根端口（蓝色圆圈）；端口 2、5、7、8 是指定端口（红色正方形）。<strong>既不是根端口，也不是指定端口的，就阻塞</strong>（图中的端口 3）。自然，形成了一棵生成树。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/STP%20TOPO2.png" alt=""></p>
<p>现在再来体会以下根端口和指定端口的定义。</p>
<ul>
<li><p>根端口是在生成树的<strong>边（edge）上</strong>，<strong>朝向根网桥</strong>的端口。我们可以联想 Prim 最小生成树算法，既然根端口是生成树边上朝向根网桥的端口，那么意味着<strong>根端口向整棵树的枝叶发</strong>消息的时候，<strong>往根端口发</strong>就可以了。</p>
</li>
<li><p>指定端口即作为<strong>从附加网段</strong>（attached segment）<strong>到根的最小路径上的端口</strong>。“附加的网段”可以想象成生成树扩张的状态。当<strong>叶节点需要向根网桥发送 BPDU</strong>（例如发送了拓扑改变），则<strong>往指定端口发</strong>就可以了。一句话总结，就是：</p>
</li>
<li><p><strong>根端口就像是树中的 child 指针，指定端口就像是 parent 指针。</strong></p>
</li>
</ul>
<p>此外，还可以得出以下一些性质：</p>
<ul>
<li>每个网络中只有一个根网桥；</li>
<li>每个非根网桥只有一个根端口；</li>
<li>每个网段只能有一个指定端口；</li>
<li>根网桥无根端口；</li>
<li>根网桥端口全为指定端口； </li>
</ul>
<h2 id="处理拓扑变化"><a href="#处理拓扑变化" class="headerlink" title="处理拓扑变化"></a>处理拓扑变化</h2><p>STP 另一项重要的工作就是要<strong>能处理拓扑变化</strong>。虽然前述中提到 filter database 有适应拓扑变化的机制，不过需要五分钟的时间没有接受到某条地址，才会删除这条条目。</p>
<ul>
<li>在 STP 中，当一个端口进入阻塞或转发状态时，意味着拓扑变化。</li>
<li><strong>当网桥检测到一个变化，向根端口之外的端口发送拓扑变化通知 TCN BPDU，并它通知自己在树中的父网桥，直到根为止</strong>。</li>
<li>在到根的路径上的网桥不断转发 TCN BPDU。直到当根网桥接收到拓扑变化通知后，根网桥在后续的周期性配置消息中<strong>设置 TC 位</strong>，这种消息被网络中的所有网桥转发。 </li>
<li>设置了 TC 位的 BPDU，允许网桥<strong>减小 filter database 中的计时器的有效期</strong>（用秒来代替推荐的五分钟）。这样，数据库里的有误条目被<strong>快速清除并重新学习</strong>（有一个术语描述这种操作，叫做<strong>老化</strong>），更新了拓扑视图。</li>
</ul>
<h2 id="快速生成树协议"><a href="#快速生成树协议" class="headerlink" title="快速生成树协议"></a>快速生成树协议</h2><p>传统 STP 的一个问题：</p>
<blockquote>
<p>生成树是一个具有<strong>缓慢收敛时间的旧协议</strong>。如果未正确实施，可能会导致主要的网络中断。 阻止链接的想法是客户现在不能接受的一个适当的高可用解决方案。 </p>
</blockquote>
<p>拓扑变化之后，只能通过一段时间未检测到 BPDU 来检测。<strong>收敛时间</strong>（沿着生成树重新建立数据流的时间）可能很长。</p>
<ul>
<li>为什么 STP 拓扑变化通知必须发回根端口？因为只有根端口能发 TC 置 1 的 BPDU。更新拓扑的机制是收到 TC BPUD 而老化数据库，更新拓扑。</li>
</ul>
<p>IEEE 802.1W 改进了传统 STP，定义了<strong>快速生成树协议（Rapid Spanning Tree Protocol，RSTP）</strong>。</p>
<ul>
<li>端口状态由五个减少到了三个：<strong>丢弃、学习、转发</strong>。</li>
<li>STP 中，BPDU 通常由一个通知网桥或根网桥发送。RSTP 中，为了“保持活跃”，<strong>BPDU由所有网桥来发送。</strong></li>
<li>主要改进是<strong>监视每个端口的状态</strong>。在 RSTP 中，检测到一次拓扑变化的交换机会<strong>发送一个表示拓扑变化的 BPDU</strong>。任何接收到它的交换机<strong>立即清除自己的过滤数据库</strong>。这个改变能<strong>显著影响协议的收敛时间</strong>。<strong>无需等待拓扑变化传递到根网桥再返回，而是立即清理相关条目。</strong></li>
</ul>
<p>说实话，第一次看到 RSTP 之后觉得这才是正常的思路啊？可能需要监控每个端口的状态需要更多的算法开销吧。</p>
<h1 id="点到点协议"><a href="#点到点协议" class="headerlink" title="点到点协议"></a>点到点协议</h1><ul>
<li>PPP，Point-to-Point Protocol，点到点协议【RFC1661】、【RFC1662】、【RFC2153】。</li>
<li>PPP是用于在<strong>两个节点</strong>之间<strong>建立直接连接</strong>的数据链路层通信协议。PPP 操作<strong>只关注一条链路的两端</strong>，不需要像 MAC 协议或者 Wi-Fi 那样处理共享资源访问的问题。</li>
<li><p>PPP用于多种类型的物理网络，包括串口线，电话线，中继线，移动电话，专用无线电链路以及SONET等光纤链路。</p>
</li>
<li><p>互联网服务提供商（ISP）经常使用 <strong>PPPoE（以太网上的点对点协议）</strong>建立<strong>数字用户线（DSL，Digital Subscriber Line）</strong>。可以说是实现互联网与客户的服务连接的“最后一公里”。</p>
</li>
<li><p>PPP 是一种协议集合，而不是一个单一的协议。</p>
<ul>
<li>首先，它有支持建立链接的基本方法：<strong>逻辑链路控制（Link Control Protocol，LCP）</strong>。</li>
<li>一系列的<strong>网络控制协议（Network Control Protocol）</strong>，NCP 用于建立了基本链路之后，为各种协议配置信息，建立链路层网络。</li>
<li>除此之外，它可以提供连接认证，传输加密和压缩。</li>
</ul>
</li>
</ul>
<h2 id="PPP-基本帧格式"><a href="#PPP-基本帧格式" class="headerlink" title="PPP 基本帧格式"></a>PPP 基本帧格式</h2><p>PPP 设计时，是基于<strong>高级数据链路控制（HDLC）</strong>建立的一种良好帧格式。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/PPP%20frame.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bytes)</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>标志（Flag）</td>
<td>1</td>
<td>0x7E</td>
<td>由两个<strong>固定的0x7E包围</strong>，指示帧的开始和结束</td>
</tr>
<tr>
<td>地址（Address）</td>
<td>1</td>
<td>0xFF</td>
<td>在HDLC中，地址字段将指定哪个站正在寻址。但是因为PPP只关心一个目的地，所以这个领域总是定义为值<strong>0xFF，广播地址</strong>。</td>
</tr>
<tr>
<td>控制（Control）</td>
<td>1</td>
<td>0x03</td>
<td>用于指示帧排序和重传行为。但这些<strong>链路层的可靠性功能通常不是通过PPP实现的</strong>，控制字段被设置到固定值0x03</td>
</tr>
<tr>
<td>协议（Protocol）</td>
<td>2</td>
<td>0x0000~0x00FF范围中的值包括大多数流行的<strong>网络层协议</strong>，0x8000~0xBFFF中的值指关联NCP的数据。0xC000~0XEFFF的协议值标识<strong>控制协议，如LCP</strong>。</td>
<td>PPP帧的协议字段指示正在传输的数据的类型</td>
</tr>
<tr>
<td>数据（Data）</td>
<td>不等</td>
<td>帧的有效载荷</td>
<td>PPP控制、网络层数据</td>
</tr>
<tr>
<td>填充（Pad）</td>
<td>不等</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>FCS</td>
<td>2或4</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>标志（Flag）</td>
<td>1</td>
<td>0x7E</td>
<td>由两个<strong>固定的0x7E包围</strong>，指示帧的开始和结束</td>
</tr>
</tbody>
</table>
<h2 id="PPP-状态机"><a href="#PPP-状态机" class="headerlink" title="PPP 状态机"></a>PPP 状态机</h2><p>下面是 PPP 状态机：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/LCP%20state%20machine.png" alt=""></p>
<ul>
<li><strong>链路不可用阶段</strong>。PPP链路都需从这个阶段开始和结束。</li>
<li><strong>链路建立阶段</strong>。是PPP协议最关键和最复杂的阶段。这是在数据链路层进行。该阶段主要是发送一些配置报文来配置数据链路，这些配置的参数不包括网络层协议所需的参数。在这个阶段<strong>主要是通过LCP协议进行链路参数的配置</strong>。</li>
<li><strong>验证阶段</strong>。多数情况下的链路两端设备是需要经过认证后才进入到网络层协议阶段，缺省情况下链路两端的设备是不进行认证的。在该阶段支持<strong>PAP 和 CHAP</strong>两种认证方式，验证方式的选择是依据在链路建立阶段双方进行协商的结果。</li>
<li><strong>网络层协议阶段</strong>。一旦PPP完成了前面几个阶段，每种网络层协议（IP、IPX和AppleTalk）会通过各自相应的网络控制协议进行配置，每个<strong>NCP 协议</strong>可在任何时间打开和关闭。</li>
<li><strong>网络终止阶段</strong>。PPP能在任何时候终止链路。当载波丢失、授权失败、链路质量检测失败和管理员人为关闭链路等情况均会导致链路终止。PPP 的除了不可用阶段，任何一种状态都可以立即进入网络终止阶段。</li>
</ul>
<h2 id="链路控制协议"><a href="#链路控制协议" class="headerlink" title="链路控制协议"></a>链路控制协议</h2><p><strong>链路控制协议（LCP）</strong>构成了互联网协议族中的点对点协议（PPP）的一部分。 在建立PPP通信时，发送和接收设备都<strong>发送LCP分组以确定随后的数据传输的标准。</strong></p>
<p>LCP Frame 是在 PPP Frame 上进行了简单的封装。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/LCP%20Frame.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bytes)</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>协议</td>
<td>2</td>
<td>0xC021</td>
<td>标识 LCP</td>
</tr>
<tr>
<td>代码（Code）</td>
<td>1</td>
<td>见下列</td>
<td>请求或响应的字段操作</td>
</tr>
<tr>
<td>标识（Ident）</td>
<td>1</td>
<td>见下列</td>
<td>见下列</td>
</tr>
</tbody>
</table>
<ul>
<li>代码字段配置的操作类型有：配置请求（按排序从 0x01 递增到 0X0D）、配置ACK、配置NACK 、配置REJECT 、终止请求 、终止ACK 、代码REJECT 、协议REJECT 、回送请求 、回送应答 、放弃请求 、标识 、剩余时间。</li>
<li><strong>ACK</strong> 标识接受一组选项，<strong>NACK</strong> 表明部分拒绝。</li>
<li><strong>REJECT</strong> 完全拒绝一个或多个选项。</li>
<li><strong>配置</strong>消息使得链路两端开始<strong>基本配置过程</strong>，建立商定的选项。</li>
<li><strong>终止</strong>消息可以<strong>清除一条链路</strong></li>
<li><strong>回送</strong>可由 LCP 在一条活跃的链路上随时交换，验证对方的操作。</li>
<li><strong>放弃请求</strong>，用于性能测试，指示对方丢弃没有相应的分组。</li>
<li><strong>标识</strong>、<strong>剩余时间</strong>用于管理目的：了解对方的系统类型，指出链路建立的时间。</li>
</ul>
<h2 id="LCP-状态"><a href="#LCP-状态" class="headerlink" title="LCP 状态"></a>LCP 状态</h2><p>LCP 用于建立 PPP 链路 ，商定各方选项。典型的过程包括：<strong>配置请求、配置确认、认证交换、数据交换、终止交换。</strong>因为 PPP 是一个<strong>包括很多部分的通用协议</strong>，所以一条链路的建立和终止之间可以发生很多其他种类的操作。</p>
<p>（下面引用自<a href="http://blog.csdn.net/xdsoft365/article/details/6335882">闲谈PPP协议</a>）</p>
<ul>
<li>配置请求：</li>
</ul>
<blockquote>
<p>一般而言在进入<strong>链路建立阶段</strong>时，通信双方无论哪一端都会连续发送几个配置请求报文<strong>（Config-Request报文）</strong>，而这几个请求报文的数据域可能是完全一样的，而仅仅是它们的标识域不同罢了。通常一个配置请求报文的ID是从0x01开始逐步加1的，当对端接收到该配置请求报文后，无论使用何种报文（回应报文可能是Config-Ack、Config-Nak和Config-Reject三种报文中的一种）来回应对方，但必须要求回应报文中的ID（标识域）要与接收报文中的ID一致，当通信设备收到回应后就可以将该回应与发送时的进行比较来决定下一步的操作。</p>
<p>当接收Config-Request报文的一端能识别发送过来的所有配置参数选项且认可所有配置参数选项数据域的内容时，接收端将会给对端回一个Config-Ack报文并将配置请求报文中的配置参数选项原封不动的放置在Config-Ack报文的数据域内（根据协议的规定是不可改变配置参数选项的顺序）。当配置请求报文的发送端收到Config-Ack报后，则会从当前阶段进入到下一个阶段。 </p>
</blockquote>
<ul>
<li>一旦底层协议表明一个关联变成活跃（例如调制解调器检测到载波），则认为这个链路已经被建立。然后，如果链接需要被<strong>认证</strong>（一般来说是要的），例如拨号到一个 ISP 时，需要一些额外的信息交换（用户名、密码），以验证链路上一方 or 双方的身份。</li>
</ul>
<blockquote>
<p>当接收Config-Request报文的一端能识别发送端所发送过来的所有配置参数选项，但<strong>对部分配置参数选项数据域中的内容不认可</strong>时，接收端将会给对端回应一个<strong>Config-Nak</strong>报文，（注意，是能够识别，只是对部分参数内容不认可，所以不是Config-Reject报文）。然而当接收端收到Config-Nak报文后，会重新发送Config-Request报文，而这个Config-Request报文与上一次所发送的Config-Request报文区别在于那些被对端不认可的配置参数选项的内容被填写到刚刚协商完后再次发送的Config-Request报文中。</p>
<p>当接收Config-Request报文的一端<strong>不能识别所有的发送端发送过来的配置参数选项</strong>时，此时接收端将会向对端回一个<strong>Config-Reject</strong>报文，该报文中的数据域只携带那些不能识别的配置参数选项（当配置参数选项的类型域不识别时）。当对端接收到Config-Reject报文后，同样会再次发送一个Config-Request报文，这个配置请求报文与上一次发送的区别在于将不可识别的那些配置参数选项给删除了。 </p>
<ul>
<li>链路终止</li>
</ul>
<p>分为Terminate-Request和Terminate-Reply两种报文。LCP报文中提供了一种机制来关闭一个点对点的连接，<strong>想要关断链路的一端会持续发送Terminate-Request报文，直到收到一个Terminate-Reply为止</strong>。接收端一旦收到了一个Terminate-Request报文后，必须回应一个Terminate-Reply报文，同时等待对端先将链路断开后，再完成本端的所有断开的操作。LCP的链路终止报文的数据域与链路配置报文的数据域不一样，链路终止报文中无需携带各配置参数选项。对于链路终止报文也同样需要ID一致，当接收到Terminate-Reply报文才会做链路终止操作。</p>
</blockquote>
<ul>
<li>当底层协议或硬件表明一个关联停止（例如载波消失），或发生了链路终止请求，并从对方接收到确认终止响应，则这个链路已被终止。</li>
</ul>
<h2 id="魔术数字"><a href="#魔术数字" class="headerlink" title="魔术数字"></a>魔术数字</h2><p>如果一个工作站处于<strong>环回模式</strong>，这时会使点到点链路出现一个常见问题。<strong>魔术字</strong>（发送方选择的任意数字）是在链路建立过程中比较重要的一个参数，这个参数是在Config-Request里面被协商的，主要的作用是防止环路。LCP 通过发送<strong>魔术数字</strong>，<strong>查看是否立即返回相同类型的信息</strong>。如果是的话，视为检测到环回，并可能需要进行维护。</p>
<p>（下面引用自<a href="http://blog.csdn.net/xdsoft365/article/details/6335882">闲谈PPP协议</a>）</p>
<blockquote>
<p>协议为了避免双方可能产生同样的魔术字，从而导致通信出现不必要的麻烦，因此要求由设备<strong>采用一些随机方法产生一个独一无二的魔术字</strong>。一般来说魔术字的选择会采用设备的系列号、网络硬件地址或时钟。双方产生相同魔术字的可能性不能说是没有的，但应尽量避免…… </p>
<p>我们知道魔术字产生的作用是用来帮助检测链路是否存在环路，当接收端收到一个Config-Request报文时，会将此报文与上一次所接收到的Config-Request进行比较，如果两个报文中所含的魔术字不一致的话，表明链路不存在环路。但如果一致的话，接收端认为链路<strong>可能</strong>存在环路，<strong>但不一定</strong>存在环路，还需进一步确认，方法是： <strong>此时接收端将发送一个Config-Nak报文，并在该报文中携带一个重新产生的魔术字，而且此时在未接收到任何Config-Request或Config-Nak报文之前，接收端也不会发送任何的Config-Request报文。</strong></p>
<ol>
<li><p>链路实际不存在环路，而是由于对方产生了一样的魔术字，但实际这种情况出现的概率是<strong>很小</strong>的。当Config-Nak被原来的发送端接收到后，应该立即重新发送一个Config-Request报文（此报文中的魔术字为之前Nak报文中的，也就是第一次接收端收到的魔术字），当接收端接收到后，与上次比较，由于接收端已经在Nak报文中<strong>产生了一个不同的魔术字</strong>，此时接收端收到的Config-Request报文中的魔术字与上次配置请求报文中不一样，所以接收端可断定链路不存在环路。</p>
</li>
<li><p>链路实际上确实存在环路。在这条链路上就会不断的出现Config-Request、Config-Nak报文，而且魔术字一直是相同的。这样周而复始下去，接收端就会认为PPP链路存在环路的可能性在不断增加，<strong>当达到一定数量级时，就可认为此链路存在环路。</strong>（注意，不是第一次受到相同的魔术字就判断有环路的）</p>
</li>
</ol>
<p>好了，基本上通过PPP闲谈，我们可以比较彻底的了解PPP协议的工作机制和特点，其实，会者不难，协议都是人制订的，只有简单易用的协议才会最终保留下来，就像TCP/IP打败OSI一样。所以，只要静下心来，没有什么高深的。</p>
</blockquote>
<h2 id="PPP-认证"><a href="#PPP-认证" class="headerlink" title="PPP 认证"></a>PPP 认证</h2><p>在一条 PPP 链路处于网络状态前，通常需要使用某种认证机制，识别建立链路的对方身份。</p>
<ul>
<li>最简单、安全性最低的认证方案就是<strong>密码认证协议（PAP）</strong>。非常简单，就是一方请求另一方发送一个明文密码。由于未加密，容易被轻易捕获。</li>
<li><strong>查询 - 握手认证协议（CHAP）</strong></li>
</ul>
<blockquote>
<p>其实CHAP的C代表Chanllenge的意思，即验证方会首先发起挑战：你把密码告诉我，这是第一次握手；然后被验证方才会将密码告知验证方，这是第二次握手；最后验证方反馈验证结果，这是第三次握手。而PAP则只有后两次握手，另外PAP的密码是明文，CHAP的是密文。</p>
</blockquote>
<ul>
<li><p>一个随机值从认证方发送到另一方。通过一种特殊的单向（不可逆）功能，将一个随机值和共享密钥（通常由密码生成）结合形成响应中的一个数字。在接受到这个响应之后，认证方能更可靠地验证对方密钥是否正确。不会以明文方式传输密钥或者密码。每次使用不同的随机值，窃听者即使可能捕捉到这个值，也无法通过重放来欺骗对方。</p>
</li>
<li><p><a href="http://network.51cto.com/art/201109/291563.htm">CHAP认证概述</a></p>
</li>
</ul>
<blockquote>
<p>CHAP认证第一步：主认证方发送挑战信息【01(此报文为认证请求）、id(此认证的序列号）、随机数据、主认证方认证用户名】，被认证方接收到挑战信息，根据接收到主认证方的认证用户名到自己本地的数据库中查找对应的密码（如果没有设密码就用默认的密码），查到密码再结合主认证方发来的id和随机数据根据MD5算法算出一个Hash值。</p>
<p>CHAP认证第二步：被认证方回复认证请求，认证请求里面包括【02（此报文为CHAP认证响应报文）、id(与认证请求中的id相同）、Hash值、被认证方的认证用户名】，主认证方处理挑战的响应信息，根据被认证方发来的认证用户名，主认证方在本地数据库中查找被认证方对应的密码（口令）结合id找到先前保存的随机数据和id根据MD5算法算出一个Hash值，与被认证方得到的Hash值做比较，如果一致，则认证通过，如果不一致，则认证不通过。</p>
<p>CHAP认证第三步：认证方告知被认证方认证是否通过。</p>
</blockquote>
<h2 id="网络控制协议"><a href="#网络控制协议" class="headerlink" title="网络控制协议"></a>网络控制协议</h2><p>在 LCP 完成链路建立和确认之后，该链路每端都进入网络状态。然后就可以开始使用<strong>一个或多个的 NCP</strong>（Network Control Protocol，NCP 网络控制协议）来<strong>进行网络层的相关协商。</strong></p>
<p>典型的例如 IPCP（针对 IPv4 的标准 NCP）用于在一条链路上建立 IPv4 链接。包括一系列选项：IP 压缩、移动 IPv4等等。</p>
<h2 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h2><p>对于大多数局域网和一些广域网连接，<a href="http://www.zcplayground.cc/2017/09/13/tcpip6-DHCP/">DHCP</a> 提供了最基本的客户机系统的自动配置方式。对于广域网连接（常见的 DSL，Digital Subscriber Line 数字用户线路），常用另一种基于 PPP 的方式替代 DHCP。这种方法涉及在以太网中携带 PPP，因此称为 <strong>PPPoE（Point-to-point protocol over Ethernet）</strong>。</p>
<ul>
<li>PPPoE 用于广域网连接设备作为一个交换机或者网桥（DSL Modem，也就是所谓的调制解调器，不支持路由）而不是路由器的情况下。</li>
<li>PPPoE 作为一些 ISP 建立连接的首选，也是建立用户连接到网络的“最后一公里”的首选。</li>
<li><a href="https://en.wikipedia.org/wiki/Point-to-point_protocol_over_Ethernet">wiki:</a> 2005年的一本网络书籍指出：“大多数DSL提供商使用PPPoE，它提供认证，加密和压缩。” PPPoE的典型应用包括利用 PPP 设施使用用户名和密码验证用户，主要通过PAP协议而较少通过CHAP。</li>
</ul>
<p>PPPoE是由UUNET，Redback Networks（现爱立信）和RouterWare（现在的风河系统）开发的。【RFC 2516】</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/PPPoE.png" alt=""></p>
<p>上图显示了一个典型的 ISP 使用 DSL 为客户提供服务。</p>
<ul>
<li>用户将一台家用 PC 连接到 DSL 调制解调器，使用一个点到点的以太网络（<strong>使用一根电缆的以太网</strong>）</li>
<li>DSL 提供一条点到点的数字链路。一般是与一条传统的模拟<strong>电话线同时工作</strong>。对物理电话线的同时使用是采取<strong>频分复用</strong>实现的。</li>
<li>DSL 调制解调器有效地向 ISP 的<strong>接入集中器</strong>（access concentrator）上的 <strong>PPP端口</strong>提供桥接服务。将接入集线器将客户的调制解调器线路和 ISP 的网络设备互连。</li>
<li>一旦 DSL 调制解调器已经成功建立了一个低层的链接 ISP，PC 可以开始 PPPoE 交换。【RFC2516】</li>
</ul>
<h1 id="环回"><a href="#环回" class="headerlink" title="环回"></a>环回</h1><p>在魔术数字提到的<strong>环回（loop）</strong>概念，可能一开始看起来很奇怪。不过在很多情况下，<strong>客户机可能希望用 Internet 协议来与同一计算机上的服务器通信</strong>。为了实现这个目标，大多是实现一种工作在网络层的环回能力。</p>
<ul>
<li>使用一个虚拟的还回网络接口来实现。它<strong>像一个真正的网络接口</strong>，但<strong>实际上是</strong>一个由<strong>操作系统提供的专门的软件</strong>。</li>
<li>以 127 开头的 IPv4 地址就是为了这个目的而保留。类 UNIX 系统为环回接口分配的地址是 <code>127.0.0.1</code>（IPv6 为 <code>::1</code>)，分配的名称是 <strong>localhost</strong>。Linux 中，环回接口被称为 <strong>lo</strong>。</li>
<li>发送到环回接口的 IP 数据报<strong>不会出现在任何网络中</strong>。</li>
<li>大多数的实现有经过传输层和网络层对数据的完整处理流程，仅在数据报离开网络层时将其送回给网络层协议栈。</li>
</ul>
<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>以太网帧有最小和最大尺寸。</p>
<ul>
<li><p>最小帧要求有 64 字节，有效载荷长度最小为 48 长度。当有效载荷较短，就需要填充一些字节（都是 0），确保达到最小长度。</p>
</li>
<li><p>最小长度对使用 CSMA/CD 的以太网来说很重要，如果帧太小意味着传输速度过快。当某个站检测到碰撞时，可能会发生这个帧已经传输完的情况，不知道是哪个帧发生了冲突。</p>
</li>
<li><p>传统以太网最大帧长度是 1518 字节。选择这个值也是有折衷的：如果一个帧发生了错误，那么只需要重传 1.5 KB 就好。</p>
</li>
</ul>
<p>因为以太网有最大长度限制，所以<strong>携带高层协议 PDU 的长度是有限制的</strong>。不仅是以太网，在很多链路层网络中都有这个特点。链路层的这种特征叫做<strong>最大传输单元（MTU）</strong>。</p>
<ul>
<li>本地链路的 MTU 对会话期间数据报的大小有直接影响。</li>
<li>当两台主机跨越多种网络通信时，<strong>每种不同的链路可能有不同大小的 MTU</strong>。因此，在包含所有链路的整个网络路径上，最小的 MTU 叫做 <strong>路径 MTU</strong>。</li>
<li>如果 IP 需要发送一个数据报，大小大于链路层 MTU，则 IP 通过<strong>分片（slice）</strong>将数据报分解成较小的部分，使每个分片都小于 MTU。分片会在 IP 协议中详细讨论。</li>
</ul>
<h1 id="隧道基础"><a href="#隧道基础" class="headerlink" title="隧道基础"></a>隧道基础</h1><p>简单来说：隧道就是在高层（或同等层）分组携带底层的数据。</p>
<h1 id="与链路层相关的攻击"><a href="#与链路层相关的攻击" class="headerlink" title="与链路层相关的攻击"></a>与链路层相关的攻击</h1><p>攻击 TCP/IP 以下的层次一直是常见的做法：</p>
<ul>
<li>早期，以太网是名副其实的<strong>共享电缆</strong>，使得任何一台连接到以太网的电脑可以“嗅探”别人的帧并检查其内容。在当时很多高层协议都包含明文密码等敏感信息，通过查看一个分组并解码就可以轻易获得密码。</li>
<li>一个目标是交换机的过滤数据库。如果 filtering database 被快速填充（例如被大量伪装的站快速填充），交换机就有可能被迫放弃合法条目，从而导致中断对合法站的服务。</li>
<li>使用 STP，一个站可以伪装成一个到根网桥最低路径上的站，从而吸引流量导向它。</li>
<li>Wi-Fi 网络的窃听和伪装问题。</li>
<li>如果攻击者可以访问两个端点之间的信道，就有很多方式来攻击 PPP 网络。对于简单的认证机制 PAP，简单的嗅探就可以捕获密码，用于后续的非法访问。</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">wiki - Internet_protocol_suite</a></li>
<li><p><a href="https://en.wikipedia.org/wiki/Data_link_layer">wiki - Data_link_layer</a></p>
</li>
<li><p><a href="https://baike.baidu.com/item/%E6%A8%A12%E8%BF%90%E7%AE%97/18556715?fr=aladdin">mod 2 运算</a></p>
</li>
<li><a href="http://blog.csdn.net/liyuanbhu/article/details/7882789">循环冗余校验（CRC）算法入门引导</a></li>
<li><p><a href="http://blog.csdn.net/huang_shiyang/article/details/50881305">CRC查找表法推导及代码实现比较</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Spanning_Tree_Protocol">wiki - Spanning Tree Protocol</a></p>
</li>
<li><a href="http://m.blog.csdn.net/hong0220/article/details/17448249">STP生成树协议之根端口 指定端口 阻塞端口</a></li>
<li><p><a href="http://blog.163.com/hlz_2599/blog/static/14237847420101124112234233/">生成树详解</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Link_Control_Protocol">wiki - Link Control Protocol</a></p>
</li>
<li><a href="http://blog.csdn.net/xdsoft365/article/details/6335882">闲谈PPP协议</a></li>
<li><a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol">wiki - Point-to-Point Protocol</a></li>
<li><p><a href="http://network.51cto.com/art/201109/291563.htm">CHAP认证概述</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Point-to-point_protocol_over_Ethernet">wiki - Point-to-point protocol over Ethernet</a></p>
</li>
</ul>
<hr>
<h1 id="Wireshark-抓包实例"><a href="#Wireshark-抓包实例" class="headerlink" title="Wireshark 抓包实例"></a>Wireshark 抓包实例</h1><p>附上一个 ARP 包的例子来看看以太网帧：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/Ethernetpacket1.png" alt=""></p>
<p>生成树协议：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/stppacket.png" alt=""></p>
<h1 id="Something-Else"><a href="#Something-Else" class="headerlink" title="Something Else"></a>Something Else</h1><hr>
<p>另：使用 Wireshark 抓以太网包没有前导、SFD、FCS 字段，搜索后得到如下原因：</p>
<ul>
<li>抓 preamble 没有意义。</li>
<li>Wireshark 抓到的数据包是网卡 driver 给上来的，有些网卡 driver 会把帧后面的 4 字节的 FCS 去掉，不上传给 tcp/ip 协议栈，Wireshark 自然就看不到了。</li>
</ul>
<hr>
<p>查看 MAC 地址的方法：在 cmd 中输入</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">ipconfig /<span class="keyword">all</span></span><br></pre></td></tr></table></figure>
<hr>
<p>附上组会上分享的生成树板书：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/stp%20presentation.JPG" alt=""></p>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 5 章：Internet 协议</title>
    <url>/2018/02/06/tcpip5-IP-Protocol/</url>
    <content><![CDATA[<p>IP 是 TCPIP 协议族中的<strong>核心协议</strong>。所有 TCP、UDP、ICMP、IGMP 数据都通过 IP 数据包（又称为 packet）来传输。IP 的英文名为 <strong>Internet Protocol</strong>，是互联网协议族中用于<strong>跨越网络边界中继数据报</strong>的主要通信协议，主要提供主机寻址、数据报路由操作。它的路由功能可以<strong>实现互联，从本质上建立互联网（网络的网络）</strong>。</p>
<ul>
<li><p>IP 是一种<strong>尽力而为（best-effort delivery service）</strong>的数据交付。尽力而为的含义是不保证IP数据包能够成功地到达目的地。有能力的时候，我会帮你转发。IP 不是简单的丢弃所有不必要流量，但是在某些错误发生时，例如一台路由器的缓冲区用尽，IP的简单错误处理方法就是丢弃一些数据。任何更高级的可靠性（重传，拥塞控制）都必须由高层的传输层来提供，例如 TCP</p>
</li>
<li><p>IP 是<strong>无连接（connection-less）</strong>的。无连接意味着IP不维护网原单元中数据包任何相关的链接状态信息每个数据包独立于其他数据包来处理。这意味着IP数据包可以不按顺序交付。如果一个主机向同一个目的地先后发送 A 和 B 两个数据包。那么每个数据包可以独立路由通过不同的路径，并且 B 可能在 A 之前到达。传输层协议，通常是 TCP ，需要处理这些潜在的问题，以便为应用提供无差错的交付。</p>
</li>
</ul>
<h1 id="IPv4-头部字段"><a href="#IPv4-头部字段" class="headerlink" title="IPv4 头部字段"></a>IPv4 头部字段</h1><p><img src="http://osax8w13y.bkt.clouddn.com/IPv4header.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bits)</th>
<th>内容</th>
<th>含义 or 注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本（version）</td>
<td>4</td>
<td>4</td>
<td>指明 IP 数据包的版本号</td>
</tr>
<tr>
<td>头部长度（IHL）</td>
<td>4</td>
<td>5</td>
<td>以 32 bits 为单位的字，IPv4 packet header 的长度。正常为 5（20个字节）</td>
</tr>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Differentiated_services">区分服务（DS）</a></td>
<td>6</td>
<td>见下文</td>
<td>为 IP 网络提供 QoS 服务，典型例子为 voIP（voice over IP）</td>
</tr>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Explicit_Congestion_Notification">显示拥塞控制（ECN）</a></td>
<td>2</td>
<td>见下文</td>
<td>IP 协议的扩展，使得内置 ECN 功能的端点间通讯时拥有拥塞控制机制</td>
</tr>
<tr>
<td>总长度（Total Length）</td>
<td>16</td>
<td>以字节为单位，整个 IP 数据报的长度</td>
<td>通过总长度字段和 IHL 字段，可以知道数据（又称有效载荷）从哪里开始</td>
</tr>
<tr>
<td>标识（Identification）</td>
<td>16</td>
<td>每个主机都有一个内部计数器，发送数据报时都将计数器自增 1 然后复制到标识字段</td>
<td>避免一个分片和其他分片混淆，对于实现分片很重要</td>
</tr>
<tr>
<td>标志（Flags）</td>
<td>3</td>
<td>见下文</td>
<td>见下文</td>
</tr>
<tr>
<td>分片偏移（Fragment Offset）</td>
<td>13</td>
<td>以 8 字节为单位，特定分片相对于原始未分片IP数据报开始的偏移量</td>
<td>用于组合分片</td>
</tr>
<tr>
<td>TTL（time-to-live）</td>
<td>8</td>
<td>发送方将其初始化为某个值（例如 64），每经过一次路由器的转发 TTL 自减 1，到达 0 时被丢弃</td>
<td>防止数据报因为意外路由环路而长久停留在网络中</td>
</tr>
<tr>
<td>协议（Protocol）</td>
<td>8</td>
<td>典型的例如 17（UDP）、6（TCP）</td>
<td>表示数据报有效载荷部分的协议类型</td>
</tr>
<tr>
<td>头部检验和（Header Checksum）</td>
<td>16</td>
<td>见下文</td>
<td>仅计算 IP header，意味着有效载荷数据部分的正确性需要其他协议来提供完整性验证机制</td>
</tr>
<tr>
<td>源IP地址（Source IP Address）</td>
<td>32</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>目的IP地址（Destination IP Address）</td>
<td>32</td>
<td>略</td>
<td>基本的 IPv4 header 到此为止，共 20 bytes</td>
</tr>
<tr>
<td>IP 选项（Option）</td>
<td>可变长度，最长 320 bits / 40 bytes</td>
<td>见下文</td>
<td>见下文</td>
</tr>
<tr>
<td>IP 数据（IP Data）</td>
<td>可变长度，最长为 65515 bytes</td>
<td>略</td>
<td>又叫有效载荷（payload） </td>
</tr>
</tbody>
</table>
<p>DS 和 ECN 是通过标记 IP 数据报，使它们的转发不同于其它数据报。（可能跟 ISP 收取不同的特殊费用有关）</p>
<ul>
<li>DS 中字段称为<strong>区分服务代码点（Differentiated Services Code Point (DSCP)）</strong>，是 IP 上用于支持 QoS 的服务。</li>
<li>ECN 是指<strong>显示拥塞控制 Explicit Congestion Notification</strong>。具有 ECN 功能的路由器在拥塞时，转发 packet 时会设置 ECN 位，被目的节点接受时，有些协议（例如 TCP）会发现这种标记，然后通知发送方降低发送速率来缓解拥塞。</li>
</ul>
<p>关于分片相关的 Flag，是一个 3 bits 字段，内容如下：</p>
<ul>
<li>bit 0: 不使用，填 0</li>
<li>bit 1: Don’t Fragment (DF)，不对此 datagram 分片。此位被设置时，当某个 datagram 经过路由器时若需要分片，则会被丢弃。将数据包发送给没有足够资源来处理碎片的主机时，可以使用此功能。还可以用于<strong>路径 MTU 发现</strong>。</li>
<li>bit 2: More Fragments (MF)，对于除了最后一片以外的分片，都设置了 MF 来表明“后面仍有其他分片”，方便拼接。最后一个分片 MF = 0 且 Fragmentation Offset 字段不为零，这样就将其与未分片的数据包区分开来。</li>
</ul>
<p>关于 IP checksum，参见 <a href="http://www.zcplayground.cc/2018/02/10/Internet-Checksum-and-Abel-Group/">here</a></p>
<h2 id="IP-选项"><a href="#IP-选项" class="headerlink" title="IP 选项"></a>IP 选项</h2><p><img src="http://osax8w13y.bkt.clouddn.com/IPOption.png" alt=""></p>
<p>IP 选项（Option）字段是一些可选参数通常用来配置一些行为，例如在路由期间使用的方法、一些探测、控制，早期对于 IP 进行的一些实验也是通过 IP 选项来完成的。在早期，处于 IPv4 设计阶段的 Internet 规模较小，来自恶意用户的威胁也比较少。随着时间的推移，所涉及相关的安全问题使得很多选项变得不再使用。许多路由器把某些 IP 选项认为是恶意或危险的，会被边界路由器或防火墙所拦截。多数标准化的选项在现如今的 Internet中很少使用。</p>
<h1 id="IPv6-头部字段"><a href="#IPv6-头部字段" class="headerlink" title="IPv6 头部字段"></a>IPv6 头部字段</h1><p><img src="http://osax8w13y.bkt.clouddn.com/IPv6header.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度(bits)</th>
<th>内容</th>
<th>含义 or 注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本（version）</td>
<td>4</td>
<td>6</td>
<td>指明 IP 数据包的版本号</td>
</tr>
<tr>
<td>区分服务（DS）</td>
<td>6</td>
<td>同 IPv4</td>
<td>略</td>
</tr>
<tr>
<td>显示拥塞控制（ECN）</td>
<td>2</td>
<td>同 IPv4</td>
<td>略</td>
</tr>
<tr>
<td>流标签（Flow Label）</td>
<td>20</td>
<td>未有详细定义</td>
<td>可用来标记特定流的报文，以便在网络层区分不同的报文。流标签在IPv6报文头中携带，转发路由器可以不必根据报文内容来识别不同的流，因此使用IPSec后仍然可以根据流标签进行QoS处理。</td>
</tr>
<tr>
<td>负载长度（Payload Length）</td>
<td>16</td>
<td>整个 IPv6 数据报减去头部后的字节数</td>
<td>略</td>
</tr>
<tr>
<td>下一个头部（Next Header)</td>
<td>8</td>
<td>见下文</td>
<td>见下文</td>
</tr>
<tr>
<td>跳数限制（Hop Limit）</td>
<td>8</td>
<td>同 IPv4 的 Time-to-live</td>
<td>略</td>
</tr>
<tr>
<td>源IP地址（Source IP Address）</td>
<td>128</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>目的IP地址（Destination IP Address）</td>
<td>128</td>
<td>略</td>
<td>基本的 IPv6 header 到此为止，共 40 bytes</td>
</tr>
</tbody>
</table>
<h2 id="IPv6-选项及扩展头部"><a href="#IPv6-选项及扩展头部" class="headerlink" title="IPv6 选项及扩展头部"></a>IPv6 选项及扩展头部</h2><p>可以发现，IPv6 的头部字段相对于 IPv4 较为简易。许多 IPv4 中利用特定字段来实现的功能，例如分片，很少在 IPv6 中使用，因此没有在 IPv6 中分配相应的位。基于这种情况，IPv6 有一个固定的 40 字节头部在开头，而仅在需要时使用<strong>扩展头部</strong>。相对于 IPv4，IPv6 提供了一种更灵活和可扩展的方式，将选项和<strong>扩展头部</strong>相结合。在 IPv6 头部之后增加<strong>下一个扩展头部</strong>实现。IPv6 的设计者简化了高性能路由器的设计，因为 IPv6 的路由器处理分组所需要的命令比 IPv4 简单。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/nextheader.png" alt=""></p>
<p><strong>下一个头部（Next Header）字段</strong>告诉接收方如何解释头部之后的数据。最后一个 Next Header 内容是携带有效载荷的上层协议信息，之后就是有效载荷。IPv6 使用许多下一个字段形成一个链。IPv6 头部（header）仅出现在数据报的开头。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/IPv6Nextheader.png" alt=""></p>
<h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p>相关知识点：<a href="http://www.zcplayground.cc/2017/11/01/tcpip3-Link-Layer/">MTU</a></p>
<blockquote>
<p> 如果 IP 需要发送一个数据报，大小大于链路层 MTU，则 IP 通过分片将数据报分解成较小的部分，使每个分片都小于 MTU。</p>
</blockquote>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p>下图是 IPv4 分片的示例图（来自 wiki）：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/IPV4fragmentation.png" alt=""></p>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><blockquote>
<p>IPv6 routers do not perform IP fragmentation. IPv6 hosts are required to either perform path MTU discovery, perform end-to-end fragmentation, or to send packets no larger than the default Maximum transmission unit (MTU), which is 1280 octets.</p>
</blockquote>
<p>IPv6 <strong>路由器</strong>不执行 IP 分片。 要求IPv6主机执行路径MTU发现，执行<strong>端到端分片</strong>，或发送不大于默认最大传输单元（MTU）的数据包。IPv6 的数据只在源端分片，目的端重组，中间路由器收到超过它 MTU 的数据会发送 ICMPv6 告诉源主机它的 MTU 大小，并把数据抛弃。</p>
<p>下图是 IPv6 分片的示例图：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/IPv6Fragmentation.png" alt=""></p>
<p>IPv6 中有用于指示分片功能的下一个头部。所包含的信息与 IPv4 header 中三个跟分片有关的字段（identification、flag、offset）功能相同，只不过位数略有不同。在下面这个例子中较大的数据包被分为三个小的分片。</p>
<ul>
<li>每个分片有一个 IPv6 头部。</li>
<li>负载长度字段被修改，反应新生成的分片的大小。</li>
<li>分片头部的标识符，用于指示是同一个数据报。确保网络中不同时原始数据报的生存期内不会被分配相同的标识符字段。</li>
<li>由于偏移量字段是以 8 bytes 为单位的，因此分片需要在满足条件的边界处进行。除了最后一个分片以外，所有的分片都是 8 bytes 的倍数。</li>
<li>接收方对分片进行重组（reassembly）。之前必须确保已接受所有数据包的原始分片。按照顺序重组成一个完整数据报，以便交给高层的其他协议处理。</li>
</ul>
<h1 id="IP-转发"><a href="#IP-转发" class="headerlink" title="IP 转发"></a>IP 转发</h1><p>数据报的<strong>路由</strong>（Routing）是IP层的一个主要功能。</p>
<p>从概念上来说IP转发是很简单的，如果目的地是直接相连的主机，例如点到点链接，或例如以太网这样的共享网络，IP 数据报将直接发送至目的地，而不需要使用路由器（直接交付）。否则主机将数据报发送到一台路由器，将由该路由器将数据报发送至目的地。这个简单方案，适用于大多数的主机配置。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>Router，重要的网络层设备。目前语境下的大多数主机可配置为主机，也可配置为路由器。</p>
<p>主机与路由器的最大区别在于处理 IP 数据报时，主机不转发那些不是由它生成的路由器数据包，但是路由器会这样做。</p>
<h2 id="转发表"><a href="#转发表" class="headerlink" title="转发表"></a>转发表</h2><p>当一个网络接口接收到一个数据包的时候，IP 模块首先检查<code>目的ip地址</code>是否为自己的 IP 地址。如果是的话数据将直接交付给 IPv4 头部的协议字段或 IPv6 头部的下一个头部指定的协议模块（即上交至对应协议栈）。如果数据包的目的地不是本地 IP 模块使用的 IP 地址，那么</p>
<ul>
<li>如果 IP 层配置为一台路由器，则根据<strong>路由表（routing table）</strong>来转发该数据报。</li>
<li>如果 IP 层配置是主机，那么数据包会被默默地丢弃。除了一些特殊情况，比如 ICMP 消息可能就会发送一些额外的信息回源节点。</li>
</ul>
<p>转发表中的内容没有被协议标准规定的很精确，这些工作留给 IP 协议的实现者。通常转发表需要包含下列关键信息</p>
<ul>
<li>目的地</li>
<li>掩码（用于进行最匹配前缀运算，见 <a href="http://www.zcplayground.cc/2017/10/30/tcpip2-IP-address/">IP地址</a>）</li>
<li>下一跳</li>
<li>下一跳网络接口（以太网、wifi、DSL 等）</li>
</ul>
<h2 id="IP-转发行动"><a href="#IP-转发行动" class="headerlink" title="IP 转发行动"></a>IP 转发行动</h2><p>简单来说 IP 转发的过程如下：</p>
<ul>
<li>主机在自己的转发表中查找“最匹配的前缀”。若找不到匹配前缀，则使用默认路由（default route），一般默认路由能够指出适合的下一跳网关地址。通过 ARP（IPv6 则是了邻居发现）向网关发送这个数据包。</li>
<li>网关接收到这个数据包之后检查自己的转发路由表，同样选择一个最合适的前缀，获得下一跳地址并将数据报发送出去。</li>
<li>若接收到数据报的是一个未在目的地子网的路由器，则路由器会仿照上诉步骤，进行相似的路由转发。</li>
<li>若数据报达到目标子网，则会进行<strong>直接交付</strong>（即下一跳内容是主机的网络接口，没有再涉及路由器）</li>
</ul>
<p>通常路由器不会直接将数据报发送至目的地，而是将其发送至一个<strong>更接近目的地的下一跳</strong>路由器。这是IP层的一个常见思路——<strong>“逐跳进行”</strong>。</p>
<ul>
<li>没有任何一个路由器或主机包含任何目的地的完整转发路径。转发机制只提供数据报发送的下一跳的地址。</li>
<li>假设每一个下一跳都能够“更接近目的地”。</li>
<li>TTL 字段用来限制数据包不会在网络中循环。</li>
<li><strong>路由协议（routing Protocol）</strong>用于保证路由表的正确，例如 RIP、OSPF、BGP 等。不在此讨论。</li>
</ul>
<p>下面给出直接交付和简介交付的例子：</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/IPforwarding.png" alt=""></p>
<p>关于掩码、最长前缀匹配的知识，参见 <a href="http://www.zcplayground.cc/2017/10/30/tcpip2-IP-address/">here</a></p>
<hr>
<h1 id="something-else"><a href="#something-else" class="headerlink" title="something else"></a>something else</h1><p>packet 是网络层的 PDU（协议数据单元），数据包</p>
<p>datagram 数据报，用于形容网络层的传输数据，一个 datagram 可以被分到一个或多个 packets，在数据链路层中传输。而且也有说法说 datagram 形容起始点和目的地都使用无连接网络服务的的网络层的信息单元，例如 UDP 协议中也称传输单元是 datagram。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://en.wikipedia.org/wiki/Internet_layer">wiki/Internet_layer</a></li>
<li><a href="https://en.wikipedia.org/wiki/IPv6">wiki/IPv6</a></li>
<li><a href="https://en.wikipedia.org/wiki/IPv4#Fragmentation_and_reassembly">wiki/IPv4</a></li>
</ul>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>《TCP/IP 详解 卷1：协议》第 6 章：DHCP 与自动配置</title>
    <url>/2017/09/13/tcpip6-DHCP/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>为了使用 TCP/IP 协议族，每台主机or路由器都需要一定的配置信息：</p>
<ul>
<li>IP地址</li>
<li>子网掩码</li>
<li>广播地址</li>
<li>路由或转发表</li>
<li>DNS</li>
</ul>
<p>协议配置方法：</p>
<ul>
<li>手动</li>
<li>通过使用网络服务来获得</li>
<li>使用一些算法来自动确定</li>
</ul>
<p>服务器、路由器通常采取手工配置。而客户端主机也要手动配置的话就太麻烦了！</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>动态主机配置协议[RFC2131] Dynamic Host Configuration Protocol</p>
<ul>
<li>Internet 客户端主机（有时也有路由器）中用于建立基本要素、指定配置信息的协议与程序。</li>
<li>流行的 client-server协议，应用层 协议</li>
<li>前身为 Internet 引导程序协议（Bootstrap Protocol，BOOTP）</li>
<li>分配方式：自动、动态、手动。</li>
<li>地址池和租用的概念</li>
</ul>
<h1 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h1><p><img src="http://osax8w13y.bkt.clouddn.com/DHCP%20packet%20.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>若是 client 送给 server 的封包，设为 1 ，反向为 2。</td>
</tr>
<tr>
<td>HTYPE</td>
<td>硬件类别，Ethernet 为 1。</td>
</tr>
<tr>
<td>HLEN</td>
<td>硬件地址长度， Ethernet 为 6。</td>
</tr>
<tr>
<td>HOPS</td>
<td>若封包需经过 router 传送，每站加 1 ，若在同一网内，为 0。</td>
</tr>
<tr>
<td>TRANSACTION ID</td>
<td>DHCP REQUEST 时产生的数值，以作 DHCPREPLY 时的依据。</td>
</tr>
<tr>
<td>SECONDS</td>
<td>Client 端启动时间（秒）。（时间戳）</td>
</tr>
<tr>
<td>FLAGS</td>
<td>从 0 到 15 共 16 bits ，最左一 bit 为 1 时表示 server 将以广播方式传送封包给 client ，其余尚未使用。</td>
</tr>
<tr>
<td>ciaddr</td>
<td>要是 client 端想继续使用之前取得之 IP 地址，则列于这里。</td>
</tr>
<tr>
<td>yiaddr</td>
<td>从 server 送回 client 之 DHCP OFFER 与 DHCPACK封包中，此栏填写分配给 client 的 IP 地址。</td>
</tr>
<tr>
<td>siaddr</td>
<td>若 client 需要透过网络开机，从 server 送出之 DHCP OFFER、DHCPACK、DHCPNACK封包中，此栏填写开机程序代码所在 server 之地址。</td>
</tr>
<tr>
<td>giaddr</td>
<td>若需跨网域进行 DHCP 发放，此栏为 relay agent 的地址，否则为 0。</td>
</tr>
<tr>
<td>chaddr</td>
<td>Client 之硬件地址。</td>
</tr>
<tr>
<td>sname</td>
<td>Server 之名称字符串，以 0x00 结尾。</td>
</tr>
<tr>
<td>file</td>
<td>若 client 需要透过网络开机，此栏将指出开机程序名称，稍后以 TFTP 传送。</td>
</tr>
<tr>
<td>options</td>
<td>允许厂商定议选项（Vendor-Specific Area)，以提供更多的设定信息（如：Netmask、Gateway、DNS、等等）。</td>
</tr>
</tbody>
</table>
<p>最后一项 options 长度可变，同时可携带多个选项，每一选项之第一个 byte 为信息代码，其后一个 byte 为该项数据长度，最后为项目内容。</p>
<p>项值类别:<br>1 DHCP DISCOVER<br>2 DHCP OFFER<br>3 DHCP REQUEST<br>4 DHCP DECLINE<br>5 DHCP ACK<br>6 DHCP NACK<br>7 DHCP RELEASE<br>DHCP 的选项非常多，这里不再叙述了。</p>
<h1 id="协议操作和状态机"><a href="#协议操作和状态机" class="headerlink" title="协议操作和状态机"></a>协议操作和状态机</h1><p><img src="http://osax8w13y.bkt.clouddn.com/DHCP%20exchange.png" alt=""></p>
<p>四步：</p>
<ul>
<li>Discover<ul>
<li>由于 DHCP Server 对于 client 来说是未知的，因此发现的操作的报文是广播的。</li>
</ul>
</li>
<li>Offer<ul>
<li>所有支持 TCP/IP 的主机都会接受到此报文，然而只有 DHCP Server 会回应。Offer也需要是广播，因为 client 此时可能还没有 IP 地址。</li>
</ul>
</li>
<li>Request<ul>
<li>Request也需要广播，通知其他 DHCP Server 自己做出的选择。</li>
</ul>
</li>
<li>ACK<ul>
<li>仍需要广播，其他 DHCP Server 将收回之前提供的 IP 地址。</li>
</ul>
</li>
</ul>
<p>状态机：状态机由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作，完成特定操作的控制中心。</p>
<p><img src="http://osax8w13y.bkt.clouddn.com/DHCP%20state%20machine.png" alt=""></p>
<h1 id="DHCP-relay"><a href="#DHCP-relay" class="headerlink" title="DHCP relay"></a>DHCP relay</h1><p><img src="http://osax8w13y.bkt.clouddn.com/DHCP%20relay.png" alt=""></p>
<p>用DHCP Relay代理可以去掉在每个物理的网段都要有DHCP服务器的必要。它可以传递消息到不在同一个物理子网的DHCP服务器，也可以将服务器的消息传回给不在同一个物理子网的DHCP客户机。</p>
<ol>
<li>当dhcp client 启动并进行dhcp 初始化时，它会在本地网络广播配置请求报文。</li>
<li>如果本地网络存在 dhcp server，则可以直接进行 dhcp 配置，不需要 dhcp relay。</li>
<li>如果本地网络没有 dhcp server，则与本地网络相连的具有 dhcprelay 功能的网络设备收到该广播报文后，将进行适当处理并转发给指定的其它网络上的 dhcp server。</li>
<li>dhcp server 根据 dhcp client 提供的信息进行相应的配置，并通过 dhcp relay 将配置信息发送给 dhcp client，完成对dhcp client 的动态配置。</li>
</ol>
<p>事实上，从开始到最终完成配置，需要多个这样的交互过程。</p>
<ol>
<li>dhcp relay 设备修改 dhcp 消息中的相应字段，把 dhcp 的广播包改成单播包，并负责在服务器与客户机之间转换。</li>
<li>netcore路由器（2x05）可以作为dhcp relay 代理。</li>
</ol>
<p>在 DHCP 客户端看来，DHCP 中继代理就像 DHCP 服务器；在 DHCP 服务器看来，DHCP 中继代理就像 DHCP 客户端。</p>
<h1 id="DHCP-与-DNS-交互"><a href="#DHCP-与-DNS-交互" class="headerlink" title="DHCP 与 DNS 交互"></a>DHCP 与 DNS 交互</h1><p>DNS 是一台机器使用互联网服务的一个很重要的部分，如果没有 DNS 服务器或者其他方式将域名映射为 IP 地址，大部分用户几乎难以访问互联网系统。由于 DNS 映射通常采取烦琐的手工配置，因此，将指定 DHCP 地址与相应地址的 DNS 映射更新方法结合起来会更加方便。这可以通过组合 DHCP/DNS 服务器或者动态 DNS 来解决。</p>
<h1 id="DHCP-安全问题：认证、与-DHCP-有关的攻击"><a href="#DHCP-安全问题：认证、与-DHCP-有关的攻击" class="headerlink" title="DHCP 安全问题：认证、与 DHCP 有关的攻击"></a>DHCP 安全问题：认证、与 DHCP 有关的攻击</h1><p>不幸的是，DHCP 并没有提供安全保障。为了缓解这些问题，[RFC3118]提出了DHCP认证（DHCP Authentication）</p>
<ul>
<li><p>DHCP 认证</p>
<ol>
<li>Authentication Information  保存一个类似于密码的字符串，用于 client 和 server 的匹配。</li>
<li>很明显这种流量可能被攻击者截获，很不安全，只能抵御偶然的DHCP问题</li>
</ol>
</li>
<li><p>DHCP 延期认证</p>
<ol>
<li>如此，则discover 、offer、ACK 消息中包含认证选项</li>
<li>用 MAC 确认身份。 </li>
<li>Client 和 Server 有一个共享的密钥，用于确保两者之间互换的 DHCP 消息没有被修改（Integrity）</li>
</ol>
</li>
<li><p>DHCP 认证没有被广泛使用的原因：</p>
<ol>
<li>所有 DHCP Server 和每个认证的 Client 都要分发共享密钥</li>
<li>认证的定义出现在 DHCP 已经广泛使用之后。</li>
</ol>
</li>
</ul>
<p>DHCP 很容易受到拒绝服务式攻击，大多数攻击可以通过为 DHCP 增加安全机制来缓解，但是目前仍然很少被使用。</p>
<hr>
<h1 id="links"><a href="#links" class="headerlink" title="links"></a>links</h1><ul>
<li><a href="https://wenku.baidu.com/view/8fdeb5ddcf84b9d529ea7a59.html">Wireshark对DHCP建立过程进行抓包分析</a></li>
<li><a href="https://baike.baidu.com/item/DHCP/218195?fr=aladdin">DHCP</a></li>
<li><a href="http://blog.csdn.net/u012359618/article/details/51872678">DHCP详解</a></li>
<li><a href="http://network.51cto.com/art/201406/441752.htm">DHCP的基本实现原理</a></li>
<li><a href="https://baike.baidu.com/item/DHCP%20Relay/3755455?fr=aladdin">DHCP Relay</a></li>
</ul>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2017/05/18/test1/</url>
    <content><![CDATA[<p>搭建博客：</p>
<p>Thanks to <a href="http://www.hellobenjamin.win/">WanderingBenjamin</a>！</p>
<ul>
<li><a href="https://hexo.io/zh-cn/">Hexo 框架</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html">Next 主题</a></li>
<li><a href="https://pages.github.com/">Githubpage</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a></li>
</ul>
]]></content>
  </entry>
</search>
